---
title: 10.4 业务逻辑层实现 10.4.1 设计业务逻辑组件
categories: 
  - 疯狂前端开发讲义JQuery AngularJS Bootstrap前端开发实战
  - 第10章 jQuery+Bootstrap整合开发 电子拍卖系统
  - 10.4 业务逻辑层实现
date: 2019-08-10 22:33:32
updated: 2019-11-02 01:39:01
abbrlink: 3c0fb3c9
---
- [10.4 业务逻辑层实现](/ReadingNotes/3c0fb3c9/#10-4-业务逻辑层实现)
- [10.4.1 设计业务逻辑组件](/ReadingNotes/3c0fb3c9/#10-4-1-设计业务逻辑组件)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 10.4 业务逻辑层实现 #
本系统的规模不大,只涉及5个`DAO`组件,分别用于对5个持久化对象进行增、删、改、查操作。本系统使用一个业务逻辑对象即可封装5个`DAO`组件。
# 10.4.1 设计业务逻辑组件 #
业务逻辑组件同样采用`面向接口编程`的原则,让系统中的控制器不是依赖于业务逻辑组件的实现类,而是依赖于业务逻辑组件的接口类,从而降低了系统重构的代价。
该业务逻辑组件接口的类图如图10.9所示。

`AuctionService` 接口里定义了大量业务方法,这些业务方法的实现依赖于`DAO` 组件。为了达到高层次的解耦,这里推荐**使用接口分离的规则,将业务逻辑组件分成接口和相应的实现类两个部分**。
`AuctionServiceImpl` 实现类实现了`AuctionService` 接口,并实现了该接口中的所有方法。此外,`AuctionServiceImpl`实现类中比接口中多了如下5个依赖注入的方法。

|方法|描述|
|:---|:---|
|`setUserDao(AuctionUserDao dao)`|为业务逻辑组件依赖注入`AuctionUserDao`的方法。|
|`setBidDao(BidDao dao)`|为业务逻辑组件依赖注入`BidDao`的方法。|
|`setItemDao(ItemDao dao)`|为业务逻辑组件依赖注入`ItemDao`的方法。|
|`setKindDao(KindDao dao)`|为业务逻辑组件依赖注入`KindDao`的方法。|
|`setStateDao(StateDao dao)`|为业务逻辑组件依赖注入`StateDao`的方法。|
该接口的作用同样是定义一种规范,规定该业务逻辑组件应该实现的方法。下面是该接口的代码:
```java
package org.crazyit.auction.service;

import java.util.List;

import org.crazyit.auction.business.BidBean;
import org.crazyit.auction.business.ItemBean;
import org.crazyit.auction.business.KindBean;
import org.crazyit.auction.domain.Bid;
import org.crazyit.auction.domain.Item;
import org.crazyit.auction.domain.Kind;
import org.crazyit.auction.exception.AuctionException;


public interface AuctionService
{
	/**
	 * 根据赢取者查询物品
	 * @param winerId 赢取者的ID
	 * @return 赢取者获得的全部物品
	 */
	List<ItemBean> getItemByWiner(Integer winerId)
		throws AuctionException;

	/**
	 * 查询流拍的全部物品
	 * @return 全部流拍物品
	 */
	List<ItemBean> getFailItems()throws AuctionException;

	/**
	 * 根据用户名，密码验证登录是否成功
	 * @param username 登录的用户名
 	 * @param pass 登录的密码
	 * @return 登录成功返回用户ID，否则返回-1
	 */
	int validLogin(String username , String pass)
		throws AuctionException;

	/**
	 * 查询用户的全部出价
	 * @param userId 竞价用户的ID
	 * @return 用户的全部出价
	 */
	List<BidBean> getBidByUser(Integer userId)
		throws AuctionException;

	/**
	 * 根据用户查找目前仍在拍卖中的全部物品
	 * @param userId 所属者的ID
	 * @return 属于当前用户的、处于拍卖中的全部物品。
	 */
	List<ItemBean> getItemsByOwner(Integer userId)
		throws AuctionException;

	/**
	 * 查询全部种类
	 * @return 系统中全部全部种类
	 */
	List<KindBean> getAllKind() throws AuctionException;

	/**
	 * 添加物品
	 * @param item 新增的物品
	 * @param avail 有效天数
	 * @param kindId 物品种类ID
	 * @param userId 添加者的ID
	 * @return 新增物品的主键
	 */
	int addItem(Item item, int avail , int kindId , Integer userId)
		throws AuctionException;

	/**
	 * 添加种类
	 * @param kind 新增的种类
	 * @return 新增种类的主键
	 */
	int addKind(Kind kind) throws AuctionException;

	/**
	 * 根据产品分类，获取处于拍卖中的全部物品
	 * @param kindId 种类id;
	 * @return 该类的全部产品
	 */
	List<ItemBean> getItemsByKind(int kindId) throws AuctionException;

	/**
	 * 根据种类id获取种类名
	 * @param kindId 种类id;
	 * @return 该种类的名称
	 */
	String getKind(int kindId) throws AuctionException;

	/**
	 * 根据物品id，获取物品
	 * @param itemId 物品id;
	 * @return 指定id对应的物品
	 */
	ItemBean getItem(int itemId) throws AuctionException;

	/**
	 * 增加新的竞价，并对竞价用户发邮件通知
	 * @param itemId 物品id;
	 * @param bid 竞价
	 * @param userId 竞价用户的ID
	 * @return 返回新增竞价记录的ID
	 */
	int addBid(int itemId , Bid bid ,Integer userId)
		throws AuctionException;

	/**
	 * 根据时间来修改物品的赢取者
	 */
	void updateWiner()throws AuctionException;
}
```
在该接口里定义了大量的业务逻辑方法,实际上,这些业务逻辑方法通常对应一次客户请求。这些业务逻辑方法当然不会被直接暴露出来,这些业务逻辑方法只是供前端`MVC` 控制器调用,而`MVC` 控制器并不直接与业务逻辑组件的实现类耦合,而仅仅只是依赖于系统的业务逻辑组件接口。当需要重构系统业务逻辑组件时,只要该组件的接口不变,则系统的功能不变,系统的控制器层也无须改变,从而把系统的业务逻辑层的改变阻止在该层以内,避免了向上扩散。

