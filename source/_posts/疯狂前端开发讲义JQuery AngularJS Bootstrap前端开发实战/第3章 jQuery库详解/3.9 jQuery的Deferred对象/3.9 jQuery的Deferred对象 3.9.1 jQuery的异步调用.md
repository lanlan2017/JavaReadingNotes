---
title: 3.9 jQuery的Deferred对象 3.9.1 jQuery的异步调用
categories: 
  - 疯狂前端开发讲义JQuery AngularJS Bootstrap前端开发实战
  - 第3章 jQuery库详解
  - 3.9 jQuery的Deferred对象
date: 2019-07-26 12:29:12
updated: 2019-11-02 01:39:02
abbrlink: 19f3a0c3
---
- [3.9 jQuery的Deferred对象](/ReadingNotes/19f3a0c3/#3-9-jQuery的Deferred对象)
- [3.9.1 jQuery的异步调用](/ReadingNotes/19f3a0c3/#3-9-1-jQuery的异步调用)
    - [Deferred详解](/ReadingNotes/19f3a0c3/#Deferred详解)
        - [如何创建Deferred对象](/ReadingNotes/19f3a0c3/#如何创建Deferred对象)
        - [Deferred提供的3个耗时状态](/ReadingNotes/19f3a0c3/#Deferred提供的3个耗时状态)
        - [修改Deferred状态的方法](/ReadingNotes/19f3a0c3/#修改Deferred状态的方法)
        - [Deferred对象的方法详解](/ReadingNotes/19f3a0c3/#Deferred对象的方法详解)
    - [程序示例](/ReadingNotes/19f3a0c3/#程序示例)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 3.9 jQuery的Deferred对象 #
在进行`JavaScript`开发的过程中,经常会遇到要执行耗时任务的情况,该任务可能是远程`Ajax` 调用,也可能是本地的耗时操作,总之不能立即有结果。遇到这种情况,通常就需要采用回调函数来监听该耗时操作的执行情况,当耗时操作执行完成后,自动激发相应的回调函数。`jQuery`为解决这类问题提供了`Deferred`对象。
# 3.9.1 jQuery的异步调用 #
在`jQuery`以前的版本中,当我们使用`$.ajax()`方法进行`Ajax`调用时,通常的代码格式如下:
```javascript
$.ajax({
    url:"pro",
    data:$("#userForm").serializeArray(),
    success:successFunction,
    error:errorFunction
});
```
在该`Ajax`调用中通过`success`和`error`分别指定了调用成功、调用失败时的回调函数,这是`jQuery`传统的管理回调函数的方式,这种方式虽然简单、直观,但编程一致性并不好,因为调用不同耗时操作时可能需要通过不同选项来指定回调函数。
`Deferred` 对象则改变了这种局面,`Deferred` 对象允许用"一致"的代码来管理回调函数。例如通过`done()`方法添加回调成功的回调函数,通过`fail()`方法添加调用失败的回调函数……从`jQuery 1.5`开始,`$.ajax()`方法返回的就是`Deferred`对象,因此`jQuery`允许我们采用如下形式来完成`Ajax`调用。
<!--SSTStop-->

下面的示例使用`Deferred`对象改写了前面的`Ajax`示例,程序如下。
```html
<!DOCTYPE html>
<html>

<head>
<meta name="author" content="Yeeku.H.Lee(CrazyIt.org)" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>使用jQuery的get方法</title>
</head>

<body>
	<h3>请输入你的信息：</h3>
	<form id="userForm">
		用户名: <input type="text" name="user" /> <br /> 喜欢的图书: <select
			multiple="multiple" name="books">
			<option value="java">疯狂Java讲义</option>
			<option value="javaee">轻量级Java EE企业应用实战</option>
			<option value="ajax">疯狂前端开发讲义</option>
			<option value="xml">疯狂XML讲义</option>
		</select> <br /> <input id="load" type="button" value="发送异步GET请求" />
	</form>
	<hr>
	<div id="show"></div>
	<script src="jquery-3.1.1.js" type="text/javascript">
		
	</script>
	<script type="text/javascript">
		// 为id为load的按钮绑定事件处理函数
		$("#load").click(function() {
			// `$.ajax()`方法返回的就是`Deferred`对象
			$.ajax({
				url : "pro",
				data : $("#userForm").serializeArray()
			})
			// 使用`Deferred`对象的done()方法添加“执行成功”的回调函数
			.done(function(data, statusText) {
				$("#show").empty();
				$("#show").append("服务器响应状态为：" + statusText + "<br />");
				$("#show").append(data);
			})
			// 使用`Deferred`对象的fail方法添加“执行失败”的回调函数
			.fail(function() {
				alert("服务器响应出错！");
			});
		});
	</script>
</body>
</html>
```
该程序调用了`$.ajax()`方法来发送异步请求,该方法将会返回一个`Deferred` 对象,接下来通过`Deferred`对象的`done()`方法和`fail()`方法分别添加调用成功、调用失败的回调函数。
提示:通过上面的示例不难看出`jQuery` 中`Deferred`的设计:
<!--SSTStart-->
`Deferred`其实就是`JavaScript`新增的`Promise`对象。它们都可对所有"耗时操作"的回调函数进行统一管理,就像`jQuery`最初提供的`jQuery`对象一样。**`jQuery`对象对所有`DOM`元素进行了统一管理,从而提供了一致的编程模型**。而**`Deferred`对象或`Promise`对象则可对所有耗时操作进行统一管理**。因此`jQuery`完全可能对原有的`Ajax`进行全新设计,从传统编程模型全面过渡到使用`Deferred`来管理回调函数。
<!--SSTStop-->
<!--SSTStart-->
## Deferred详解 ##
### 如何创建Deferred对象 ###
除了可以调用`$.ajax()`方法返回`Deferred`对象之外,`jQuery`专门提供了**`jQuery.Deferred()`方法来创建`Deferred`对象**。
### Deferred提供的3个耗时状态 ###
`Deferred`对象提供了以下三种状态来表示耗时操作的执行结果:
1. `pending`状态:`pending`表示任务执行中,未完成。此时将执行`Deferred`对象`progress()`方法添加的回调函数。
2. `fulfilled`状态`:fulfilled`表示任务完成了,该任务会执行`resolve`函数;进而执行`Deferred`对象`done()`方法添加的回调函数。
3. `rejected`状态`:rejected`表示任务失败了,该任务会执行`reject`函数;进而执行`fail()`方法添加的回调函数。

### 修改Deferred状态的方法 ###
为了让开发者手动改变`Deferred`对象的状态,`Deferred`还提供了`reject(args)`和`resolve(args)`两个方法,其中
- `reject(args)`方法用于将`Deferred`对象改为"`任务失败`"状态,
- `resolve(args)`方法用于将`Deferred`对象改为"`任务完成`"状态。

### Deferred对象的方法详解 ###
`Deferred`对象支持的方法如下。
#### 监听操作的方法 ####

|方法|描述|
|:---|:---|
|`progress(progressCallbacks)`|指定在`Deferred`对象包含的异步操作`执行过程中`激发的回调函数。|
|`done(doneCallbacks)`|指定`Deferred`对象包含的异步操作`执行成功后激发`的回调函数。|
|`fail(doneCallbacks)`|指定`Deferred`对象包含的异步操作`执行失败后激发`的回调函数。|
|`always(alwaysCallbacks [,alwaysCallbacks])`|该方法相当于`done()`、`fail()`两个方法的合体。也就是说,无论`Deferred`对象包含的异步操作执行成功还是执行失败,总会激发该方法指定的回调函数。|
|`then(doneCallbacks,failCallbacks [,progressCallbacks])`|`then()`方法相当于`done()`、`fail()`、和`progress()`三个方法的综合版本,该方法可以分别为`Deferred`对象包含的异步操作在`完成时`、`失败时`、`进行中`指定一个或多个回调函数。|

#### 调用监听操作方法的方法 ####

|方法|描述|
|:---|:---|
|`notify(args)`|调用在`Deferred`对象上通过`progress()`方法添加的函数,`args`作为参数传入`progress()`方法添加的函数。|
|`notifyWith(context [,args])`|类似于`notify(args)`方法的功能,只是激发`progress()`方法添加的函数时将传入`context`和`args`参数。|
|`reject(args)`|将`Deferred`对象状态改为"`rejected`(任务已失败)",在`Deferred` 对象上通过`fail()`方法添加的函数将会被激发,`args`作为参数传入`fail()`方法添加的函数。|
|`rejectWith(context [,args])`|类似于`reject(args)`方法的功能,只是激发`fail()`方法添加的函数时将传入`context`和`args`参数。|
|`resolve(args)`|将`Deferred`对象状态改为"`rejected`(任务已完成)",在`Deferred`对象上通过`done()`方法添加的函数将会被激发,`args`作为参数传入`done()`方法添加的函数。|
|`resolveWith(context [,args])`|类似于`resolve(args)`方法的功能,只是激发`done()`方法添加的函数时将传入`context`和`args`参数。|

#### 返回Promise对象的方法 ####

|方法|描述|
|:---|:---|
|`promise([target])`|返回`Deferred`对象对应的`Promise`对象(它相当于`Deferred`对象的副本,不允许开发者通过`Promise`对象修改`Deferred`对象的状态)。如果指定了`target`参数,则会在该参数指定的对象上增加`Deferred`接口。|
#### 查询一步操作所处的执行状态 ####

|方法|描述|
|:---|:---|
|`state()`|返回`Deferred`对象包含的异步操作所处的执行状态。|
该方法返回表示执行状态的字符串,可能返回如下三个字符串。
1. `pending`:任务执行中,未完成。
2. `resolved`:任务完成。
3. `rejected`:任务失败。
<!--SSTStop-->

## 程序示例 ##
下面的程序定义了一个耗时操作。程序需要统计出指定范围的所有`质数`,由于这个过程耗时较长,因此考虑使用`Deferred`对象来管理回调函数。`JavaScript`代码如下。
```html
<!DOCTYPE html>
<html>

<head>
	<meta name="author" content="Yeeku.H.Lee(CrazyIt.org)" />
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title> Deferred对象 </title>
</head>

<body>
	<script type="text/javascript" src="../jquery-3.1.1.js">
	</script>
	<script type="text/javascript">
		var calPrime = function (start, end) {
			// 定义一个Deferred对象
			var dfd = $.Deferred();      // ①
			try {
				var result = "";
				search:
				for (var n = start; n <= end; n++) {

					for (var i = 2; i <= Math.sqrt(n); i++) {
						// 如果除以n的余数为0，开始判断下一个数字。
						if (n % i == 0) {
							continue search;
						}
					}
					// 搜集找到的质数
					result += (n + ",");
				}
				// 当整个“耗时任务”执行完成时，将Deferred对象的状态改为resolved
				dfd.resolve(result);      // ②
			}
			catch (e) {
				// 如果程序出现异常，将Deferred对象的状态改为rejected
				dfd.reject("任务失败");   // ③
			}
			return dfd.promise();
		}
		// 调用calPrime()耗时函数
		calPrime(1, 1000000)
			// 通过done()方法添加回调函数
			.done(function (result) {
				$("body").append(result);
			})
			// 通过fail()方法添加回调函数
			.fail(function (result) {
				$("body").append("计算出错了！");
			});
	</script>
</body>

</html>
```
该程序中①号代码创建了一个`Deferred` 对象,该对象用于标识该耗时任务的完成进度:
- 当任务完成时,程序调用`Deferred`对象的`resolve()`方法将它的状态设为`resolved`;
- 当任务出错时,程序调用`Deferred`对象的`reject()`方法将它的状态设为`rejected`。

`calPrime()`方法返回`Deferred`对象的`Promise`对象,
<!--SSTStart-->
`Promise`对象相当于`Deferred`对象的副本,但**程序不能通过`Promise`对象来改变`Deferred`对象的状态**—通过这种方式,即可避免别人在方法外改变`Deferred`对象的状态。
<!--SSTStop-->

`Deferred`对象用于表示`calPrime()`耗时操作的完成状态,因此通常只应该在该方法内改变`Deferred`对象的状态。为了保证效果,建议将`Deferred`对象定义成该方法的局部变量,并让该方法返回`Deferred`对象的`Promise`对象。
在浏览器中执行该`JavaScript`代码,即可看到当`calPrime()`耗时操作执行完成后,会自动回调`done()`方法指定的回调函数。
