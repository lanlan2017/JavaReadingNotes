---
title: 9.5 示例3：下载计数Filter
categories: 
  - Serlet JSP和Spring MVC初学指南
  - 第一部分 Servlets和JSP
  - 第9章 Filters
date: 2019-04-17 23:19:20
updated: 2019-11-02 01:38:59
abbrlink: cdb49d4c
---
- [9.5 示例3：下载计数Filter](/ReadingNotes/cdb49d4c/#9-5-示例3：下载计数Filter)
    - [DownloadCounterFilter.java](/ReadingNotes/cdb49d4c/#DownloadCounterFilter-java)
    - [代码详解](/ReadingNotes/cdb49d4c/#代码详解)
        - [init方法](/ReadingNotes/cdb49d4c/#init方法)
        - [destroy方法](/ReadingNotes/cdb49d4c/#destroy方法)
        - [doFilter方法](/ReadingNotes/cdb49d4c/#doFilter方法)
    - [运行效果](/ReadingNotes/cdb49d4c/#运行效果)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 9.5 示例3：下载计数Filter #
本例子中，下载计数`Filter`将会示范如何**在`Filter`中计算资源下载的次数**。这个示例特别有用，它将会得到文档、音频文件的受欢迎程度。作为简单的示例，这里将数值保存在属性文件中，而不保存在数据库中。其中资源的`ULR`路径将作为属性名保存在属性文件中。
因为我们把值保存在属性文件中，并且**`Filter`可以被多线程访问，因此涉及线程安全问题**。用户访问一个资源时，`Filter`需要读取相应的属性值加`1`，然后保存该值。如果第二个用户在第一个线程完成前同时访问该资源，将会发生什么呢？计算值出错。在本例中，读写的同步锁并不是一个好的解决这个问题的方法，因为它会导致扩展性问题。
本示例中，解决这个线程安全问题是通过`Queue`以及`Executor`。如果不熟悉这两个`Java`类型的话，请看第18章"多线程及线程安全"
简而言之，**进来的`Request`请求将会保存在单线程`Executor`的队列中**。替换这个任务十分方便，因为这是一个异步的方法，因此你不需要等待该任务结束。`Executor`一次从队列中获取一个对象，然后做相应属性值的增加。由于`Executor`只在一个线程中使用，因此可以消除多个线程同时访问一个属性文件的影响。
## DownloadCounterFilter.java ##
```java
package filter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
@WebFilter(
	filterName = "DownloadCounterFilter",
	urlPatterns={"/*"}
)
public class DownloadCounterFilter
	implements
		Filter
{
	ExecutorService executorService = 
		Executors.newSingleThreadExecutor();
	Properties downloadLog;
	File logFile;
	@Override
	public void init(FilterConfig filterConfig) 
		throws ServletException
	{
		System.out.println("DownloadCounterFilter");
		//获取项目所在的根目录
		String appPath = 
			filterConfig
				.getServletContext()
					.getRealPath("/");
		//创建日志文件
		logFile = new File(appPath, "downloadLog.txt");
		if(!logFile.exists()) {
			try {
				//创建日志文件
				logFile.createNewFile();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		//创建配置文件
		downloadLog = new Properties();
		try {
			downloadLog
                        .load(new FileReader(logFile));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	@Override
	public void destroy()
	{
		if(logFile.exists())
		{
			//删除日志文件
			logFile.delete();
		}
		executorService.shutdown();
	}
	@Override
    public void doFilter(ServletRequest request,
            ServletResponse response, FilterChain filterChain)
            throws IOException, ServletException 
	{
        HttpServletRequest httpServletRequest =
        	(HttpServletRequest) request;
        //获取请求的uri
        final String uri = httpServletRequest.getRequestURI();
        executorService.execute(new Runnable() {
            @Override
            public void run() {
            	//读取配置文件该URL中对应的值
                String property = downloadLog.getProperty(uri);
                //如果没有读到值,这说明这是第一次访问
                if (property == null) {
                	//该url的值设置为1
                    downloadLog.setProperty(uri, "1");
                } else {
                    int count = 0;
                    try {
                        count = Integer.parseInt(property);
                    } catch (NumberFormatException e) {
                        // silent
                    }
                    //值加一
                    count++;
                    //更新配置文件中uri的值
                    downloadLog.setProperty(uri,
                            Integer.toString(count));
                }
                try {
                	//保存到本地配置文件中
                    downloadLog
                            .store(new FileWriter(logFile), "");
                } catch (IOException e) {
                }
            }
        });
        filterChain.doFilter(request, response);
    }
}
```
## 代码详解 ##
### init方法 ###
如果在当前应用的工作目录中不存在`downloadLog.txt`文件，这个`Filter`的`init`方法就会创建它：
```java
//获取项目所在的根目录
String appPath = 
	filterConfig
		.getServletContext()
			.getRealPath("/");
//创建日志文件
logFile = new File(appPath, "downloadLog.txt");
if(!logFile.exists()) {
	try {
		//创建日志文件
		logFile.createNewFile();
	} catch (IOException e) {
		e.printStackTrace();
	}
}
```
接着创建`Properties`对象，并读取该文件：
```java
//创建配置文件
downloadLog = new Properties();
try {
	downloadLog.load(new FileReader(logFile));
} catch (IOException e) {
	e.printStackTrace();
}
```
注意，`Filter`的实现类中引用到了`ExecutorService`（`Executor`的子类）：
```java
    ExecutorService executorService = 
            Executors.newSingleThreadExecutor();
```
### destroy方法 ###
且当`Filter`销毁时，会调用`ExecutorService`的`shutdown`方法：
```java
public void destroy() {
    executorService.shutdown();
}
```
### doFilter方法 ###
`Filter`的`doFilter`实现中大量地使用到这个`Job`。每次`URL`请求都会调用到`ExecutorService`的`execute`方法，然后才调用`FilterChaing.doFilter()`。该任务的`execute`实现非常好理解：它将`URL`作为一个属性名，从`Properties`实例中获取该属性的值，然后加1，并调用`flush`方法写回到指定的日志文件中：
```java
public void run() {
	//读取配置文件该URL中对应的值
    String property = downloadLog.getProperty(uri);
    //如果没有读到值,这说明这是第一次访问
    if (property == null) {
    	//该url的值设置为1
        downloadLog.setProperty(uri, "1");
    } else {
        int count = 0;
        try {
            count = Integer.parseInt(property);
        } catch (NumberFormatException e) {
            // silent
        }
        //值加一
        count++;
        //更新配置文件中uri的值
        downloadLog.setProperty(uri,
                Integer.toString(count));
    }
    try {
    	//保存到本地配置文件中
        downloadLog
                .store(new FileWriter(logFile), "");
    } catch (IOException e) {
    }
}
```
这个`Filter`的`urlPatterns`设置为`*`，即过滤所有`URL`,实际应用中可以修改为过滤某些特定的文件,如:只过滤`pdf`文件

## 运行效果 ##
访问项目中的多个`jsp`页面,然后多刷新几次,然后打开打开`downloadLog.txt`文件(在`Tomcat`中的路径`E:\apache-tomcat-8.5.35\webapps\app09a\downloadLog.txt`)可以看到效果,如下图所示:
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/ServlerJSPAndSpring%20MVCChuXueZhiNan/Chapter9/10.png)


