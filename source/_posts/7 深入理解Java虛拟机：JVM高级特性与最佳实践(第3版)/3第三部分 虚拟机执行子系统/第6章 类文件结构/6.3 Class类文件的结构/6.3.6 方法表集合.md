---
title: 6.3.6 方法表集合
categories: 
  - 7 深入理解Java虛拟机：JVM高级特性与最佳实践(第3版)
  - 3第三部分 虚拟机执行子系统
  - 第6章 类文件结构
  - 6.3 Class类文件的结构
abbrlink: 977f538b
date: 2021-11-20 21:02:21
<<<<<<< HEAD
updated: 2021-11-23 19:21:35
=======
updated: 2022-04-03 01:21:18
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0
---
# 6.3.6 方法表集合
如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依 次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表 集合（attributes）几项，如表6-11所示。这些数据项目的含义也与字段表中的非常类似，仅在访问标 志和属性表集合的可选项中有所区别。

<center>表6-11 方法表结构</center>

<<<<<<< HEAD
![image-20211118204129254](https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211118204129.png)
=======
![image-20211118204129254](https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20211118204129.png)
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0

因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对，synchronized、native、strictfp和abstract 关键字可以修饰方法，方法表的访问标志中也相应地增加了ACC_SYNCHRONIZED、 ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见表6-12。

<center>表6-12 方法访问标志</center>

<<<<<<< HEAD
![image-20211118204244209](https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211118204244.png)
=======
![image-20211118204244209](https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20211118204244.png)
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0

行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在下一节中详细讲解。

我们继续以代码清单6-1中的Class文件为例对方法表集合进行分析。如图6-9所示，方法表集合的入口地址为0x00000101，第一个u2类型的数据（即计数器容量）的值为0x0002，代表集合中有两个方法，这两个方法为编译器添加的实例构造器`<init>`和源码中定义的方法inc()。第一个方法的访问标志值为0x0001，也就是只有ACC_PUBLIC标志为真，名称索引值为0x0007，查代码清单6-2的常量池得方法名为“`<init>`”，描述符索引值为0x0008，对应常量为“()V”，属性表计数器attributes_count的值为0x0001，表示此方法的属性表集合有1项属性，属性名称的索引值为0x0009，对应常量为“Code”，说明此属性是方法的字节码描述。

<<<<<<< HEAD
![image-20211118204542279](https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211118204542.png)
=======
![image-20211118204542279](https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20211118204542.png)
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0

<center>图6-9 方法表结构实例</center>

与字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出 现来自父类的方法信息。但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造 器“`<clinit>()`”方法和实例构造器“`<init>()`”方法[^1]。

在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求 必须拥有一个与原方法不同的特征签名[^2]。特征签名是指一个方法中各个参数在常量池中的字段符号 引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值 的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围明显要更大一些， 只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签 名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。

[^1]: ＜init＞()和＜clinit＞()的详细内容见本书的下一部分“前端编译与优化”。 
[^2]: 在《Java虚拟机规范》第2版的4.4.4节及《Java语言规范》第3版的8.4.2节中分别都定义了字节码层 面的方法特征签名以及Java代码层面的方法特征签名，Java代码的方法特征签名只包括方法名称、参数 顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表，请读者根据上下文语境注 意区分。
