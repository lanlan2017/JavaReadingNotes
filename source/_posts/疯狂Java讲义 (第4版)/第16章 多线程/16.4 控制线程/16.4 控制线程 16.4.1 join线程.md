---
title: 16.4 控制线程 16.4.1 join线程
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.4 控制线程
date: 2019-07-16 10:28:44
updated: 2020-01-08 11:55:35
abbrlink: 6fdf5d88
---
<div id='my_toc'><a href="/JavaReadingNotes/6fdf5d88/#16-4-控制线程" class="header_1">16.4 控制线程</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#16-4-1-join线程" class="header_1">16.4.1 join线程</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#join方法的功能" class="header_2">join方法的功能</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#谁等待谁" class="header_2">谁等待谁</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#join方法的作用" class="header_2">join方法的作用</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#程序示例" class="header_2">程序示例</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#join方法的重载形式" class="header_2">join方法的重载形式</a>&nbsp;<br><a href="/JavaReadingNotes/6fdf5d88/#本文重点" class="header_2">本文重点</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
<!--SSTStart-->
# 16.4 控制线程
`Java`的线程(Thread类)支持提供了一些便捷的工具方法,通过这些便捷的工具方法可以很好地控制线程的执行.
# 16.4.1 join线程
## join方法
**`join`方法可以让一个线程`等待另一个线程完成`**。

`join()`方法有如下三种重载形式

|Thread类的join方法|描述|
|:--|:--|
|`void join()`|等待被`join`的线程执行完成。|
|`void join(long millis)`|等待被`join`的线程的时间最长为`millis`毫秒。如果在`millis`毫秒内被`join`的线程还没有执行结束,则不再等待。|
|`void join(long millis, int nanos)`|等待被`join`的线程的时间最长为`millis`毫秒加`nanos`毫微秒。很少使用这种形式,原因有两个:程序对时间的精度无须精确到毫微秒;计算机硬件、操作系统本身也无法精确到毫微秒。|

## 当前线程 等待 调用join方法的线程

例如,在**当前线程**中调用如下代码:
```java
B.join();
```
则**当前线程**要等待**B线程**运行结束.
这个当前线程要看调用join方法的代码位于哪个线程中
- 如果在主线程的代码中调用`B.join()`,则主线程必须等待B线程执行完毕
- 如果在A线程的代码中调用`B.join()`,则线程A必须等待线程B执行完毕

## join方法的作用
`join`方法通常由使用线程的程序调用,以将大问题划分成许多小问题,每个小问题分配一个线程。当所有的小问题都得到处理后,再调用主线程来进一步操作。

## 程序 join方法示例
```java
public class JoinThread extends Thread {
    // 提供一个有参数的构造器，用于设置该线程的名字
    public JoinThread(String name) {
        super(name);
    }

    // 重写run()方法，定义线程执行体
    public void run() {
        for (int i = 0; i <= 30; i++) {
            System.out.println(getName() + "  " + i);
            if(i==30){
                System.out.println("================== "+getName()+" 死亡");
            }
        }
    }

    public static void main(String[] args) throws Exception {
        // 启动子线程
        new JoinThread("线程A").start();
        for (int i = 0; i < 30; i++) {
            if (i == 10) {
                JoinThread jt = new JoinThread("线程B");
                jt.start();
                // main线程中调用了jt线程的join()方法
                // main线程必须等jt执行结束才会向下执行
                System.out.println("-----------------主线程 等待 线程B 开始---------------------");
                jt.join();
                System.out.println("-----------------主线程 等待 线程B 结束---------------------");
            }
            System.out.println("主线程  " + i);
        }
        System.out.println("================== 主线程 死亡");
    }
}
```
### 运行效果
```
主线程  0
线程A  0
主线程  1
......
主线程  8
线程A  7
主线程  9
线程A  8
-----------------主线程 等待 线程B 开始---------------------
线程B  0
线程A  9
线程B  1
线程A  10
......
线程A  28
线程B  22
线程A  29
线程B  23
线程A  30
线程B  24
================== 线程A 死亡
线程B  25
线程B  26
......
线程B  29
线程B  30
================== 线程B 死亡
-----------------主线程 等待 线程B 结束---------------------
主线程  10
主线程  11
......
主线程  28
主线程  29
================== 主线程 死亡
```
### 分析
上面程序中一共有3个线程：
- **主线程**开始时就启动**线程A**,然后,**线程A**将会和**主线程**并发执行。
- 当**主线程**的循环变量i等于10时,启动**线程B**,**线程B**不会和主线程并发执行,**<mark>主线程</mark>必须等<mark>线程B</mark>执行结束后才可以向下执行**。
- 在**线程B**的线程执行时,实际上只有**线程A**和**线程B**这2个子线程并发执行,而**主线程**处于等待状态。