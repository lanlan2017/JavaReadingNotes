---
title: 16.5.3 同步方法
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.5 线程同步
date: 2019-07-17 16:51:10
updated: 2019-11-02 01:39:01
abbrlink: '24208527'
---
- [16.5.3 同步方法](/ReadingNotes/24208527/#16-5-3-同步方法)
    - [什么是同步方法](/ReadingNotes/24208527/#什么是同步方法)
    - [同步方法的同步资源监视器是调用该同步方法的对象](/ReadingNotes/24208527/#同步方法的同步资源监视器是调用该同步方法的对象)
    - [什么样的类是线程安全的类](/ReadingNotes/24208527/#什么样的类是线程安全的类)
    - [程序示例](/ReadingNotes/24208527/#程序示例)
    - [如何减少线程安全的负面影响](/ReadingNotes/24208527/#如何减少线程安全的负面影响)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 16.5.3 同步方法 #
与同步代码块对应,`Java`的多线程安全支持还提供了同步方法,
## 什么是同步方法 ##
同步方法就是使用`synchronized`关键字来修饰某个方法,则该方法称为同步方法。
## 同步方法的同步资源监视器是调用该同步方法的对象 ##
对于`synchronized`修饰的实例方法(非`statIc`方法)而言,无须显式指定同步监视器,**同步方法的同步监视器是`this`,也就是调用该同步方法的对象**.
## 什么样的类是线程安全的类 ##
通过使用同步方法可以非常方便地实现线程安全的类,线程安全的类具有如下特征:
1. 该类的对象可以被多个线程安全地访问
2. 每个线程调用该对象的任意方法之后都将得到正确结果。
3. 每个线程调用该对象的任意方法之后,该对象状态依然保持合理状态。

前面介绍了可变类和不可变类,其中**不可变类总是线程安全的,因为它的对象状态不可改变**;
但可变对象需要额外的方法来保证其线程安全。例如上面的`Account`就是一个可变类,它的`accountNo`和`balance`两个成员变量都可以被改变,当两个线程同时修改`Account`对象的`balance`成员变量的值时,程序就出现了异常。
下面**将`Account`类对`balance`的访问设置成线程安全的,那么只要把修改`balance`的方法变成同步方法即可**。
<!--SSTStop-->
## 程序示例 ##
```java
public class Account
{
	// 封装账户编号、账户余额两个成员变量
	private String accountNo;
	private double balance;
	public Account(){}
	// 构造器
	public Account(String accountNo , double balance)
	{
		this.accountNo = accountNo;
		this.balance = balance;
	}

	// accountNo的setter和getter方法
	public void setAccountNo(String accountNo)
	{
		this.accountNo = accountNo;
	}
	public String getAccountNo()
	{
		return this.accountNo;
	}
	// 因此账户余额不允许随便修改，所以只为balance提供getter方法，
	public double getBalance()
	{
		return this.balance;
	}

	// 提供一个线程安全draw()方法来完成取钱操作
	public synchronized void draw(double drawAmount)
	{
		// 账户余额大于取钱数目
		if (balance >= drawAmount)
		{
			// 吐出钞票
			System.out.println(Thread.currentThread().getName()
				+ "取钱成功！吐出钞票:" + drawAmount);
			try
			{
				Thread.sleep(1);
			}
			catch (InterruptedException ex)
			{
				ex.printStackTrace();
			}
			// 修改余额
			balance -= drawAmount;
			System.out.println("\t余额为: " + balance);
		}
		else
		{
			System.out.println(Thread.currentThread().getName()
				+ "取钱失败！余额不足！");
		}
	}

	// 下面两个方法根据accountNo来重写hashCode()和equals()方法
	public int hashCode()
	{
		return accountNo.hashCode();
	}
	public boolean equals(Object obj)
	{
		if(this == obj)
			return true;
		if (obj !=null
			&& obj.getClass() == Account.class)
		{
			Account target = (Account)obj;
			return target.getAccountNo().equals(accountNo);
		}
		return false;
	}
}
```
上面程序中增加了一个代表取钱的`draw()`方法,并使用了`synchronized`关键字修饰该方法,把该方法变成同步方法,该同步方法的同步监视器是`this`,因此对于同一个`Account`账户而言,任意时刻只能有一个线程获得对`Account`对象的锁定,然后进入`draw()`方法执行取钱操作—这样也可以保证多个线程并发取钱的线程安全

因为`Account`类中已经提供了`draw()`方法,而且取消了`setBalance()`方法, `DrawThread`线程类需要改写,该线程类的`run()`方法只要调用`Account`对象的`draw()`方法即可执行取钱操作。`run()`方法代码片段如下。

上面的`DrawThread`类无须自己实现取钱操作,而是直接调用`account`的`draw()`方法来执行取钱操作。由于已经使用`synchronized`关键字修饰了`draw()`方法,同步方法的同步监视器是`this`,而`this`总代表调用该方法的对象—在上面示例中,调用`draw()`方法的对象是`account`,因此多个线程并发修改同一份`account`之前,必须先对`account`对象加锁。这也符合了"加锁→修改→释放锁"的逻辑。

在`Account`里定义`draw()`方法,而不是直接在`run()`方法中实现取钱逻辑,这种做法更符合面向对象规则。
在面向对象里有一种流行的设计方式: `Domain Driven Design`(领域驱动设计,`DDD)`,这种方式认为每个类都应该是完备的领域对象,例如`Account`代表用户账户,应该提供用户账户的相关方法;通过`draw()`方法来执行取钱操作(实际上还应该提供`transfer`等方法来完成转账等操作),而不是直接将`setBalance()`方法暴露出来任人操作,这样才可以更好地保证`Account`对象的完整性和一致性.

<!--SSTStart-->
## 如何减少线程安全的负面影响 ##
可变类的线程安全是以降低程序的运行效率作为代价的,为了减少线程安全所带来的负面影响,程序可以采用如下策略。
- **不要对线程安全类的所有方法都进行同步**,**只对那些会改变竞争资源的方法进行同步**(竞争资源也就是共享资源)。例如上面`Account`类中的`accountNo`实例变量就无须同步,所以程序只对`draw()`方法进行了同步控制。
- 如果可变类有两种运行环境:单线程环境和多线程环境,则应该为该可变类提供两种版本,即线程不安全版本和线程安全版本。在单线程环境中使用线程不安全版本以保证性能,在多线程环境中使用线程安全版本。

`JDK`所提供的`StringBuilder`、 `StringBuffer`就是为了照顾单线程环境和多线程环境所提供的类,
- 在单线程环境下应该使用`StringBuilder`来保证较好的性能;
- 当需要保证多线程安全时,就应该使用`String Buffer`.
<!--SSTStop-->

