---
title: 8.3.2 LinkedHashSet类
categories: 
  - 疯狂Java讲义 (第4版)
  - 第8章 Java集合
  - 8.3 Set集合
date: 2019-07-07 19:40:13
updated: 2019-12-22 08:26:36
abbrlink: e6cbfb40
---
<div id='my_toc'><a href="/JavaReadingNotes/e6cbfb40/#8-3-2-LinkedHashSet类" class="header_1">8.3.2 LinkedHashSet类</a><br><a href="/JavaReadingNotes/e6cbfb40/#LinkedHashSet是有序的集合" class="header_2">LinkedHashSet是有序的集合</a><br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
<!--SSTStart-->
# 8.3.2 LinkedHashSet类 #
`HashSet`还有一个子类`LinkedHashSet`, `LinkedHashSet`集合也是根据元素的`hashCode`值来决定元素的存储位置,但它同时使用链表维护元素的次序,这样使得元素看起来是以插入的顺序保存的。也就是说,**当遍历`LinkedHashSet`集合里的元素时, `LinkedHashSet`将会按元素的添加顺序来访问集合里的元素**。
`LinkedHashSet`需要维护元素的插入顺序,因此性能略低于`HashSet`的性能,但在迭代访问`Set`里的全部元素时将有很好的性能,因为它以链表来维护内部顺序。
```java
import java.util.*;

public class LinkedHashSetTest
{
    public static void main(String[] args)
    {
        LinkedHashSet books = new LinkedHashSet();
        books.add("疯狂Java讲义");
        books.add("轻量级Java EE企业应用实战");
        System.out.println(books);
        // 删除 疯狂Java讲义
        books.remove("疯狂Java讲义");
        // 重新添加 疯狂Java讲义
        books.add("疯狂Java讲义");
        System.out.println(books);
    }
}
```
编译、运行上面程序,看到如下输出:
```cmd
[疯狂Java讲义, 轻量级Java EE企业应用实战]
[轻量级Java EE企业应用实战, 疯狂Java讲义]
```
## LinkedHashSet是有序的集合 ##
**输出`LinkedHashSet`集合的元素时,元素的顺序总是与添加顺序一致**。
**注意**
虽然`LinkedHashSet`使用了链表记录集合元素的添加顺序,但`LinkedHashSet`依然是`HashSet`,因此它依然不允许集合元素重复
<!--SSTStop-->
