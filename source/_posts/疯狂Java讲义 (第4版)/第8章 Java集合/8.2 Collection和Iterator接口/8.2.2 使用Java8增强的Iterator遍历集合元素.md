---
title: 8.2.2 使用Java8增强的Iterator遍历集合元素
categories: 
  - 疯狂Java讲义 (第4版)
  - 第8章 Java集合
  - 8.2 Collection和Iterator接口
date: 2019-07-06 15:41:41
updated: 2019-11-02 01:39:01
abbrlink: 4fd1609
---
- [8.2.2 使用Java 8增强的Iterator遍历集合元素](/ReadingNotes/4fd1609/#8-2-2-使用Java-8增强的Iterator遍历集合元素)
    - [Iterator接口方法](/ReadingNotes/4fd1609/#Iterator接口方法)
    - [程序示例](/ReadingNotes/4fd1609/#程序示例)
    - [Iterator仅用于遍历集合](/ReadingNotes/4fd1609/#Iterator仅用于遍历集合)
    - [Iterator必须依附于Collection对象](/ReadingNotes/4fd1609/#Iterator必须依附于Collection对象)
    - [修改迭代变量的值对集合元素本身没有任何影响](/ReadingNotes/4fd1609/#修改迭代变量的值对集合元素本身没有任何影响)
    - [Iterator迭代时不可通过 其他方式 Collection集合里的元素](/ReadingNotes/4fd1609/#Iterator迭代时不可通过-其他方式-Collection集合里的元素)
    - [程序示例](/ReadingNotes/4fd1609/#程序示例)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 8.2.2 使用Java 8增强的Iterator遍历集合元素 #
`Iterator`接口也是`Java`集合框架的成员,但它与`Collection`系列、`Map`系列的集合不一样: 
- `Collection`系列集合、`Map`系列集合主要用于盛装其他对象,
- `Iterator`对象也被称为迭代器,**`Iterator`主要用于遍历(即迭代访问)`Collection`集合中的元素**。

`Iterator`接口隐藏了各种`Collection`实现类的底层细节,向应用程序提供了遍历`Collection`集合元素的统一编程接口。 
## Iterator接口方法 ##
`Iterator`接口里定义了如下4个方法

|方法|描述|
|:---|:---|
|`boolean hasNext()`|如果被迭代的集合元素还没有被遍历完,则返回`true`|
|`Object next()`|返回集合里的下一个元素|
|`void remove()`|删除集合里上一次`next`方法返回的元素|
|`void forEachRemaining(Consumer action)`|这是`Java 8`为`Iterator`新增的默认方法,该方法可使用`Lambda`表达式来遍历集合元素|
<!--SSTStop-->
## 程序示例 ##
下面程序示范了通过`Iterator`接口来遍历集合元素。
```java
import java.util.*;

public class IteratorTest
{
	public static void main(String[] args)
	{
		// 创建集合、添加元素的代码与前一个程序相同
		Collection books = new HashSet();
		books.add("轻量级Java EE企业应用实战");
		books.add("疯狂Java讲义");
		books.add("疯狂Android讲义");
		// 获取books集合对应的迭代器
		Iterator it = books.iterator();
		while(it.hasNext())
		{
			// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换
			String book = (String)it.next();
			System.out.println(book);
			if (book.equals("疯狂Java讲义"))
			{
				// 从集合中删除上一次next方法返回的元素
				it.remove();
			}
			// 对book变量赋值，不会改变集合元素本身
			book = "测试字符串";   //①
		}
		System.out.println("集合中的数据:"+books);
	}
}
```
运行效果:
```cmd
疯狂Android讲义
轻量级Java EE企业应用实战
疯狂Java讲义
集合中的数据:[疯狂Android讲义, 轻量级Java EE企业应用实战]
```
<!--SSTStart-->
## Iterator仅用于遍历集合 ##
从上面代码中可以看出, `Iterator`仅用于遍历集合, `Iterator`本身并不提供盛装对象的能力。如果需要创建`Iterator`对象,则必须有一个被迭代的集合。
## Iterator必须依附于Collection对象 ##
`Iterator`必须依附于`Collection`对象,若有一个`Iterator`对象,则必然有一个与之关联的`Collection`对象。 `Iterator`提供了两个方法来迭代访问`Collection`集合里的元素,并可通过`remove()`方法来删除集合中上一次`next()`方法返回的集合元素。
## 修改迭代变量的值对集合元素本身没有任何影响 ##
当使用`Iterator`对集合元素进行迭代时, `Iterator`并不是把集合元素本身传给了迭代变量,而是把集合元素的值传给了迭代变量,所以**修改迭代变量的值对集合元素本身没有任何影响**。
## Iterator迭代时不可通过 其他方式 Collection集合里的元素 ##
当使用`Iterator`迭代访问`Collection`集合元素时:
- 不可以通过`集合对象`修改`Collection`集合里的元素,例如:不能通过集合对象添加元素,也不能通过集合对象添加元素。
- 如果要删除元素,只有通过`Iterator`对象的的`remove`方法才可以删除`next()`方法返回的集合元素.
- 否则将会引发`java.util.ConcurrentModificationException`异常。

<!--SSTStop-->
## 程序示例 ##
下面程序示范了这一点。
```java
import java.util.*;

public class IteratorErrorTest {
	public static void main(String[] args) {
		// 创建集合、添加元素的代码与前一个程序相同
		Collection<String> collection = new HashSet<String>();
		collection.add("1");
		collection.add("2");
		collection.add("3");
		collection.add("4");
		// 获取books集合对应的迭代器
		Iterator<String> iterator = collection.iterator();
		while (iterator.hasNext()) {
			String book = iterator.next();
			System.out.println(book);
			if (book.equals("3")) {
				// 使用Iterator迭代过程中,不可以通过 集合对象 修改集合
				// collection.remove(book);
				collection.add("5");
				// 只有Iterator对象的remove方法才可以删除遍历的元素
				// iterator.remove();
			}
		}
	}
}
```
运行效果:
```
1
2
3
Exception in thread "main" java.util.ConcurrentModificationException
        at java.base/java.util.HashMap$HashIterator.nextNode(HashMap.java:1493)
        at java.base/java.util.HashMap$KeyIterator.next(HashMap.java:1516)
        at IteratorErrorTest.main(IteratorErrorTest.java:14)
```
上面程序中`collection.remove(book);`这行代码位于`Iterator`迭代块内,也就是在`Iterator`迭代`Collection`集合过程中修改了`Collection`集合,所以程序将在运行时引发异常。

<!--SSTStart-->
`Iterator`迭代器采用的是快速失败(`fail-fast`)机制,一旦在迭代过程中检测到该集合已经被修改(通常是程序中的其他线程修改),程序立即引发`ConcurrentModificationException`异常,而不是显示修改后的结果,这样可以避免共享资源而引发的潜在问题。
<!--SSTStop-->

