---
title: 8.5.1 PriorityQueue实现类
categories: 
  - 疯狂Java讲义 (第4版)
  - 第8章 Java集合
  - 8.5 Queue集合
date: 2019-07-08 22:10:50
updated: 2019-12-22 08:26:36
abbrlink: fa2c0452
---
<div id='my_toc'><a href="/JavaReadingNotes/fa2c0452/#8-5-1-PriorityQueue实现类" class="header_1">8.5.1 PriorityQueue实现类</a><br><a href="/JavaReadingNotes/fa2c0452/#程序实例" class="header_2">程序实例</a><br><a href="/JavaReadingNotes/fa2c0452/#PriorityQueue的toString-方法没有排序效果" class="header_2">PriorityQueue的toString()方法没有排序效果</a><br><a href="/JavaReadingNotes/fa2c0452/#poll-方法会-从小到大-将元素移出队列" class="header_2">poll()方法会`从小到大`将元素移出队列</a><br><a href="/JavaReadingNotes/fa2c0452/#PriorityQueue中不能加入null" class="header_2">PriorityQueue中不能加入null</a><br><a href="/JavaReadingNotes/fa2c0452/#自然排序-定制排序" class="header_2">自然排序 定制排序</a><br><a href="/JavaReadingNotes/fa2c0452/#参考资料" class="header_1">参考资料</a><br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
<!--SSTStart-->
# 8.5.1 PriorityQueue实现类 #
`PriorityQueue`是一个比较标准的队列实现类。之所以说它是比较标准的队列实现,而不是绝对标准的队列实现,是因为**`PriorityQueue`保存队列元素的顺序并不是按加入队列的顺序,而是按队列元素的大小进行`重新排序`**。

因此当调用**`peek()`方法或者`poll()`方法**取出队列中的元素时,并不是取出最先进入队列的元素,而是**取出队列中最小的元素**。从这个意义上来看, `PriorityQueue`已经违反了队列的最基本规则:先进先出(`FIFO`)。

## 程序实例 ##
下面程序示范了`PriorityQueue`队列的用法。
```java
import java.util.*;

public class PriorityQueueTest
{
    public static void main(String[] args)
    {
        PriorityQueue pq = new PriorityQueue();
        // 下面代码依次向pq中加入四个元素
        pq.offer(6);
        pq.offer(-3);
        pq.offer(20);
        pq.offer(18);
        // 输出pq队列，并不是按元素的加入顺序排列
        System.out.println(pq); // 输出[-3, 6, 20, 18]
        // 访问队列第一个元素，其实就是队列中最小的元素：-3
        System.out.println(pq.poll());
        System.out.println(pq.poll());
        System.out.println(pq.poll());
    }
}
```
运行效果:
```cmd
[-3, 6, 20, 18]
-3
6
18
```
## PriorityQueue的toString()方法没有排序效果 ##
运行上面程序**直接输出`PriorityQueue`集合时**,可能看到该队列里的元素并没有很好地按大小进行排序,但这只是受到`PriorityQueue`的`toString`方法的返回值的影响。
## poll()方法会`从小到大`将元素移出队列 ##
实际上,程序多次调用`PriorityQueue`集合对象的`poll()`方法时,可看到**元素按从小到大的顺序"移出队列".**
## PriorityQueue中不能加入null ##
`PriorityQueue`不允许插入`null`元素.
## 自然排序 定制排序 ##
`PriorityQueue`需要对队列元素进行排序, `PriorityQueue`的元素有两种排序方式:
1. **自然排序**:采用自然排序的`PriorityQueue`集合中的元素必须实现了`Comparable`接口,而且`PriorityQueue`中应该存放的是`同一个类`的多个实例,否则可能导致`ClassCastException`异常。
2. **定制排序**:创建`PriorityQueue`队列时,传入一个`Comparator`对象,该对象负责对队列中的所有元素进行排序。采用定制排序时不要求队列元素实现`Comparable`接口。

`PriorityQueue`队列对元素的要求与`TreeSet`对元素的要求基本一致,因此关于使用自然排序和定制排序的详细介绍请参考8.3.3节。
<!--SSTStop-->

# 参考资料 #
[https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/PriorityQueue.html)
