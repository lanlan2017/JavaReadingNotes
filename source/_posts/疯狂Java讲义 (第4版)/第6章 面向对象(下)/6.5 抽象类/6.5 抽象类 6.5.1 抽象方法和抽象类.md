---
title: 6.5 抽象类 6.5.1 抽象方法和抽象类
categories: 
  - 疯狂Java讲义 (第4版)
  - 第6章 面向对象(下)
  - 6.5 抽象类
date: 2019-09-25 17:22:36
updated: 2019-11-02 01:39:01
abbrlink: db78b302
---
- [6.5 抽象类](/ReadingNotes/db78b302/#6-5-抽象类)
    - [什么是抽象方法](/ReadingNotes/db78b302/#什么是抽象方法)
- [6.5.1 抽象方法和抽象类](/ReadingNotes/db78b302/#6-5-1-抽象方法和抽象类)
    - [抽象方法规则](/ReadingNotes/db78b302/#抽象方法规则)
    - [抽象类规则](/ReadingNotes/db78b302/#抽象类规则)
    - [抽象方法和空方法的区别](/ReadingNotes/db78b302/#抽象方法和空方法的区别)
        - [小结](/ReadingNotes/db78b302/#小结)
    - [普通类前面加上abstract就可以变成抽象类](/ReadingNotes/db78b302/#普通类前面加上abstract就可以变成抽象类)
        - [普通类](/ReadingNotes/db78b302/#普通类)
    - [不能abstract一起使用的修饰符](/ReadingNotes/db78b302/#不能abstract一起使用的修饰符)
        - [final和abstract永远不能同时使用](/ReadingNotes/db78b302/#final和abstract永远不能同时使用)
        - [没有抽象变量 没有抽象成员变量](/ReadingNotes/db78b302/#没有抽象变量-没有抽象成员变量)
        - [没有抽象构造器](/ReadingNotes/db78b302/#没有抽象构造器)
        - [没有静态抽象方法](/ReadingNotes/db78b302/#没有静态抽象方法)
        - [没有私有抽象方法](/ReadingNotes/db78b302/#没有私有抽象方法)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 6.5 抽象类 #
## 什么是抽象方法 ##
**抽象方法是只有方法签名,没有方法实现的方法**。
# 6.5.1 抽象方法和抽象类 #
抽象方法和抽象类必须使用`abstract`修饰符来定义,**有抽象方法的类只能被定义成抽象类**,**抽象类里可以没有抽象方法**。
## 抽象方法规则 ##
- 抽象方法也使用`abstract`修饰符来修饰,
- **抽象方法不能有方法体**

定义抽象方法只需在普通方法上增加`abstract`修饰符,并把普通方法的方法体全部去掉,并在方法后增加分号即可。
## 抽象类规则 ##
- 抽象类必须使用`abstract`修饰符来修饰。
- **抽象类不能被实例化**,无法使用`new`关键字来调用抽象类的构造器创建抽象类的实例。即使抽象类里不包含抽象方法,这个抽象类也不能创建实例。
- 抽象类可以包含`成员变量`、`方法`、`构造器`、`初始化块`、`内部类`5种成分。
    - 抽象类中的方法可以是普通方法也可以是抽象方法
    - 抽象类中的内部类包括`接口`和`枚举`
    - **抽象类的构造器不能用于创建实例**,主要**是用于给其子类调用**。
- **含有抽象方法的类只能被定义成抽象类**,这包括以下三种情况
    1. 该类直接定义了一个抽象方法;
    2. 该类继承了一个抽象父类,但没有完全实现父类包含的抽象方法;
    3. 该类实现了一个接口,但没有完全实现接口包含的抽象方法。

## 抽象方法和空方法的区别 ##
抽象方法和空方法体的方法不是同一个概念。例如, 
- `public abstract void test();`是一个抽象方法,它根本没有方法体,即**方法定义后面没有一对花括号**;
- `public void test(){}`方法是一个普通方法,它已经定义了方法体(花括号),只是方法体为空,即它的方法体什么也不做,因此这个方法不可使用`abstract`来修饰。

### 小结 ###
- 空方法有花括号,花括号为空,
- 抽象方法没有花括号

## 普通类前面加上abstract就可以变成抽象类 ##
### 普通类 ###
指的是没有包含抽象方法的类.
定义抽象类只需在普通类上增加`abstract`修饰符即可。甚至一个(没有包含抽象方法的)普通类增加`abstract`修饰符后也将变成抽象类

## 不能abstract一起使用的修饰符 ##
### final和abstract永远不能同时使用 ###
- 当使用`abstract`修饰类时,表明这个类只能被继承;
- 当使用`abstract`修饰方法时,表明这个方法必须由子类提供实现(即重写)。
- `final`修饰的类不能被继承, 
- `final`修饰的方法不能被重写。

因此**`final`和`abstract`永远不能同时使用**。

### 没有抽象变量 没有抽象成员变量 ###
`abstract`不能用于修饰成员变量,
`abstract`不能用于修饰局部变量,
即没有抽象变量、没有抽象成员变量等说法; 
### 没有抽象构造器 ###
`abstract`也不能用于修饰构造器,没有抽象构造器,抽象类里定义的构造器只能是普通构造器。
### 没有静态抽象方法 ###
当使用`static`修饰一个方法时,表明这个方法属于该类本身,即通过类就可调用该方法。
如果该方法被定义成抽象方法,**由于抽象方法没有方法体,所以通过该类来调用该方法时会出现错误**。因此`static`和`abstract`不能同时修饰某个方法,即没**有所谓的`类`抽象方法**。

`static`和`abstract`并不是绝对互斥的, `static`和`abstract`虽然不能同时修饰某个方法,但**`static`和`abstract`可以同时修饰`内部类`**
### 没有私有抽象方法 ###
`abstract`关键字修饰的方法必须被其子类重写才有意义,否则这个方法将永远不会有方法体,因此`abstract`方法不能定义为`private`访问权限,即**`private`和`abstract`不能同时修饰方法**
<!--SSTStop-->

