---
title: 18.1 类的加载 连接和初始化
categories: 
  - 疯狂Java讲义 (第4版)
  - 第18章 类加载机制与反射
  - 18.1 类的加载 连接和初始化
date: 2019-06-15 23:22:57
updated: 2020-01-16 06:57:20
abbrlink: 180ffbb8
---
<div id='my_toc'><a href="/JavaReadingNotes/180ffbb8/#18-1-类的加载-连接和初始化" class="header_1">18.1 类的加载 连接和初始化</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#18-1-1-JVM和类" class="header_1">18.1.1 JVM和类</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#JVM进程终止的情况" class="header_2">JVM进程终止的情况</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#程序示例" class="header_2">程序示例</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#18-1-2-类的加载" class="header_1">18.1.2 类的加载</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#类加载" class="header_2">类加载</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#什么是类加载" class="header_2">什么是类加载</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#类也是对象" class="header_2">类也是对象</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#类加载器" class="header_2">类加载器</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#类加载来源" class="header_2">类加载来源</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#18-1-3-类的连接" class="header_1">18.1.3 类的连接</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#18-1-4-类的初始化" class="header_1">18.1.4 类的初始化</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#对类变量指定初始值的两种方式" class="header_2">对类变量指定初始值的两种方式</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#JVM初始化类步骤" class="header_2">JVM初始化类步骤</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#JVM总是最先初始化Object类" class="header_2">JVM总是最先初始化Object类</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#18-1-5-类初始化的时机" class="header_1">18.1.5 类初始化的时机</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#访问编译时就可以确定的类变量不会初始化类" class="header_2">访问编译时就可以确定的类变量不会初始化类</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#访问编译时可确定值得final变量不会初始化类" class="header_3">访问编译时可确定值得final变量不会初始化类</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#final修饰的类常量" class="header_4">final修饰的类常量</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#-ClassLoader-类的-loadClass-方法-不会初始化类" class="header_3">`ClassLoader`类的`loadClass`方法 不会初始化类</a>&nbsp;<br><a href="/JavaReadingNotes/180ffbb8/#-Class-类的-forName-方法会强制初始化类" class="header_3">`Class`类的`forName`方法会强制初始化类</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
# 18.1 类的加载 连接和初始化
系统可能在第一次使用某个类时加载该类,也可能采用预加载机制来加载某个类。本节将会详细介绍类加载、连接和初始化过程中的每个细节。
# 18.1.1 JVM和类
当调用`java`命令运行某个`Java`程序时,该命令将会启动一个`Java`虚拟机进程,不管该`Java`程序有多么复杂,该程序启动了多少个线程,它们都处于该`Java`虚拟机进程里。正如前面介绍的,**同一个`JVM`的所有线程、所有变量都处于同一个进程里,它们都使用该`JVM`进程的内存区**。
## JVM进程终止的情况
- 当系统出现以下几种情况时,`JVM`进程将被终止。
- 程序运行到最后正常结束。
- 程序运行到使用`System.exit()`或`Runtime.getRuntime().exit()`代码处结束程序.
- 程序执行过程中遇到未捕获的异常或错误而结束
- 程序所在平台强制结束了`JVM`进程。

从上面的介绍可以看出,**当`Java`程序运行结束时,`JVM`进程结束,该进程在内存中的状态将会丢失**。下面以类的类变量来说明这个问题。
## 程序示例
下面程序先定义了一个包含类变量的类。
```java
public class A {
    // 定义该类的类变量
    public static int a = 6;
}
```
上面程序中定义了一个类变量a,接下来定义一个类创建A类的实例,并访问A对象的类变量a。
```java
public class ATest1 {
    public static void main(String[] args) {
        // 创建A类的实例
        A a = new A();
        // 让a实例的类变量a的值自加
        a.a++;
        System.out.println(a.a);
    }
}
```
下面程序也创建A对象,并访问其类变量a的值
```java
public class ATest2 {
    public static void main(String[] args) {
        // 创建A类的实例
        A b = new A();
        // 输出b实例的类变量a的值
        System.out.println(b.a);
    }
}
```
在`ATest1.Java`程序中创建了A类的实例,并让该实例的类变量a的值自加,程序输出该实例的类变量a的值将看到7,相信读者对这个答案没有疑问。关键是运行第二个程序`ATest2`时,程序再次创建了A对象,并输出A对象类变量的a的值,此时a的值是多少呢?**结果依然是6**,并不是7。这是因为**运行`ATest1`和`ATest2`是两次运行`JVM`进程,第一次运行`JVM`结束后,它对A类所做的修改将全部丢失**,第二次运行`JVM`时将再次初始化A类

**两次运行`Java`程序处于两个不同的`JVM`进程中,两个`JVM`之间并不会共享数据。**
# 18.1.2 类的加载
## 类加载
当程序主动使用某个类时,如果该类还未被加载到内存中,则系统会通过`加载`、`连接`、`初始化`三个步骤来对该类进行初始化。如果没有意外,`JVM`将会连续完成这三个步骤,所以有时也把这三个步骤统称为`类加载`或`类初始化`。
## 什么是类加载
**类加载指的是将类的`class`文件读入内存,并为之创建一个`java.lang.Class`对象**,也就是说,当程序中使用任何类时,系统都会为之建立一个`java.lang.Class`对象。
## 类也是对象
系统中所有的类实际上也是实例,它们都是`java.lang.Class`的实例。
## 类加载器
**类的加载由类加载器完成**,类加载器通常由`JVM`提供,这些类加载器也是前面所有程序运行的基础,
- `JVM`提供的这些类加载器通常被称为**系统类加载器**。
- 除此之外,开发者可以通过继承`ClassLoader`基类来创建自己的类加载器。

## 类加载来源
通过使用不同的类加载器,可以从不同来源加载**类的二进制数据**,通常有如下几种来源:
- **从本地文件系统加载`class`文件**,这是前面绝大部分示例程序的类加载方式.
- **从`JAR`包加载`class`文件**,这种方式也是很常见的,前面介绍`JDBC`编程时用到的数据库驱动类就放在`JAR`文件中,`JVM`可以从`JAR`文件中直接加载该`class`文件。
- 通过网络加载`class`文件。
- 把一个`Java`源文件动态编译,并执行加载。

类加载器通常无须等到"首次使用"该类时才加载该类,**`Java`虚拟机规范允许系统预先加载某些类**。
# 18.1.3 类的连接
当类被加载之后,系统为之生成一个对应的`Class`对象,接着将会进入连接阶段,连接阶段负责把类的二进制数据合并到`JRE`中。类连接又可分为如下三个阶段。
- `验证`:验证阶段用于检验被加载的类是否有正确的内部结构,并和其他类协调一致。
- `准备`:类准备阶段则负责`为类的类变量分配内存,并设置默认初始值`。
- `解析`:将类的二进制数据中的符号引用替换成直接引用。

# 18.1.4 类的初始化
在类的初始化阶段,虚拟机负责对类进行初始化,主要就是对`类变量`进行初始化。
## 对类变量指定初始值的两种方式
在`Java`类中**对类变量指定初始值**有两种方式:
1. **声明类变量时指定**初始值;
2. 使用**静态初始化块**为类变量指定初始值。

例如下面代码片段。
```java
public calss Test
{
    //声明变量a时指定初始值
    static int a=5;
    static int b;
    static int c;
    static{
        //使用静态初始化块为变量b指定初始值
        b=6;
    }
}
```
对于上面代码,程序为类变量a、b都显式指定了初始值,所以这两个类变量的值分别为5、6,但类变量c则没有指定初始值,它将采用**默认初始值**0。

**静态初始化块被当成`类的初始化语句`**,`JVM`会按这些语句在程序中的排列顺序依次执行它们.例如下面的类。
```java
public class Test {
    static {
        // 使用静态初始化块为变量b指定出初始值
        b = 6;
        System.out.println("----------");
    }
    // 声明变量a时指定初始值
    static int a = 5;
    static int b = 9; // ①
    static int c;

    public static void main(String[] args) {
        System.out.println(Test.b);
    }
}
```
上面代码先在静态初始化块中为b变量赋值,**此时类变量b的值为6**;
接着程序向下执行,执行到①号代码处,这行代码也属于该类的初始化语句,所以程序再次为类变量b赋值。也就是说,当`Test`类初始化结束后,该类的**类变量b的值为9**。

## JVM初始化类步骤
`JVM`初始化一个类包含如下几个步骤。
1. 假如这个类还没有被加载和连接,则程序**先加载并连接该类**
2. 假如该类的直接父类还没有被初始化,则**先初始化其直接父类**。
3. 假如该类中有初始化语句,则系统**依次执行这些初始化语句**。

当执行第2个步骤时,系统对直接父类的初始化步骤也遵循此步骤1到3;**如果该直接父类又有直接父类,则系统再次重复这三个步骤来先初始化这个父类**...依此类推。
## JVM总是最先初始化Object类
所以**`JVM`最先初始化的总是`java.lang.Object`类**。**当程序主动使用任何一个类时,系统会保证该类以及所有父类(包括直接父类和间接父类)都会被初始化**。

# 18.1.5 类初始化的时机
当`Java`程序首次通过下面6种方式来使用某个类或接口时,系统就会初始化该类或接口.
1. **创建类的实例**。为某个类创建实例的方式包括:
    - 使用`new`操作符来创建实例,
    - 通过反射来创建实例,
    - 通过反序列化的方式来创建实例。
2. **调用某个类的类方法**(静态方法)
3. 访问某个类或接口的`类变量`,或为该类变量赋值。
4. 使用反射方式来强制创建某个类或接口对应的`java.lang.Class`对象。例如代码:`Class.forName("Person");`如果系统还未初始化`Person`类,则这行代码将会导致该`Person`类被初始化,并返回`Person`类对应的`java.lang.Class`对象。
5. 初始化某个类的子类。当初始化某个类的子类时,该子类的所有父类都会被初始化。
6. 直接使用`java.exe`命令来运行某个主类。当运行某个主类时,程序会先初始化该主类。

## 访问编译时就可以确定的类变量不会初始化类
除此之外,下面的几种情形需要特别指出。
### 访问编译时可确定值得final变量不会初始化类
对于一个 `final`型的类变量,如果该类变量的值在编译时就可以确定下来,那么这个类变量相当于“宏变量”。`Java`编译器会在编译时直接把这个类变量出现的地方替换成它的值,因此即使程序使用该静态类变量,也不会导致该类的初始化。例如下面示例程序的结果：
```java
class MyTest
{
    static
    {
        System.out.println("静态初始化块...");
    }
    // 使用一个字符串直接量为static final的类变量赋值
    static final String compileConstant = "final static字符串";
}
public class CompileConstantTest
{
    public static void main(String[] args)
    {
        // 访问、输出MyTest中的compileConstant类变量
        System.out.println(MyTest.compileConstant);   // ①
    }
}
```
运行结果
```cmd
final static字符串
```
上面程序的`MyTest`类中有一个`compileConstant`的类变量,该类变量使用了`final`修饰,而且它的值可以在编译时确定下来,因此`compileConstant`会被当成"宏变量"处理。**程序中所有使用`compileConstant`的地方都会在编译时被直接替换成它的值**——也就是说,上面程序中①处的代码在编译时就会被替换成"`final static字符串`",所以**代码①**不会导致初始化`MyTest`类,静态代码块将不会执行。
#### final修饰的类常量
当某个类变量(也叫静态变量)使用了`final`修饰,而且它的值可以在编译时就确定下来,那么程序其他地方使用该类变量时,实际上并没有使用该类变量,而是相当于使用常量

反之,**如果`final`修饰的类变量的值不能在编译时确定下来**,则必须等到运行时才可以确定该类变量的值,如果通过该类来访问它的类变量,则**会导致该类被初始化**。例如将上面程序中定义`compileConstant`的代码改为如下:
```java
    // 采用系统当前时间为static final类变量赋值
    static final String compileConstant = System.currentTimeMillis()+"静态字符串嘻嘻嘻";//①
```
因为上面定义的`compileConstant`类变量的值必须在运行时才可以确定,所以①处的字代码必须保留为对`MyTest`类的类变量的引用,这行代码就变成了使用`MyTest`的类变量,这将导致`MyTest`类被初始化。
运行效果如下:
```
静态初始化块...
1560616123824静态字符串嘻嘻嘻
```
### `ClassLoader`类的`loadClass`方法 不会初始化类
当使用`ClassLoader`类的`loadClass()`方法来加载某个类时,这个`loadClass()`方法只是加载该类,并不会执行该类的初始化。
### `Class`类的`forName`方法会强制初始化类
使用`Class`的`forName()`静态方法才会导致强制初始化该类。例如如下代码：
```java
class Tester
{
    static
    {
        System.out.println("Tester类的静态初始化块...");
    }
}
public class ClassLoaderTest
{
    public static void main(String[] args)
        throws ClassNotFoundException
    {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        // 下面语句仅仅是加载Tester类
        cl.loadClass("Tester");//代码1
        System.out.println("---------------------------------------------");
        System.out.println("系统加载Tester类");
        // 下面语句才会初始化Tester类
        Class.forName("Tester");//代码2
    }
}
```
上面程序中的代码**代码1** **代码2**都用到了`Tester`类,**代码1**只是加载`Tester`类,并不会初始化`Tester`类。运行上面程序,会看到如下运行结果:
```cmd
系统加载Tester类
Tester类的静态初始化块...
```
从上面运行结果可以看出,必须等到执行`Class.forName("Tester")`时才完成对`Tester`类的初始化。
