---
title: 9.2.3 并不存在泛型类
categories: 
  - 疯狂Java讲义 (第4版)
  - 第9章 泛型
  - 9.2 深入泛型
date: 2019-11-16 19:10:21
updated: 2019-11-16 20:10:10
abbrlink: 8f3fe4f8
---
- [9.2.3 并不存在泛型类](/ReadingNotes/8f3fe4f8/#9-2-3-并不存在泛型类)
    - [静态方法 静态初始化块 静态变量的声明和初始化中不允许使用泛型形参](/ReadingNotes/8f3fe4f8/#静态方法-静态初始化块-静态变量的声明和初始化中不允许使用泛型形参)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 9.2.3 并不存在泛型类 #
前面提到可以把`ArrayList<String>`类当成`ArrayList`的子类,事实上, `ArrayList<String>`类也确实像种特殊的`Array List`类:该`Arraylists<String>`对象只能添加`String`对象作为集合元素。但实际上,系统并没有为`ArrayList<String>`生成新的`class`文件,而且也不会把`ArrayList<String>`当成新类来处理。
看下面代码的打印结果是什么?
```java
//分别创建List<String>对象和List<Integer>对象
List<string> list1=new ArrayList<>();
List<Integer> list2 =new ArrayList<>();
//调用getClass()方法来比较list1和list2的类是否相等
System.out.printin(list1.getClass()==list2.getClass());
```
运行上面的代码片段,可能有读者认为应该输出`false`,但实际输出`true`。因为不管泛型的实际类型参数是什么,它们在运行时总有同样的类(`class`).

## 静态方法 静态初始化块 静态变量的声明和初始化中不允许使用泛型形参 ##
不管为泛型形参传入哪一种类型实参,对于`Java`来说,它们依然被当成同一个类处理,在内存中也只占用一块内存空间,因此**在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用泛型形参**。下面程序演示了这种错误。
```java
public class R<T> {
	// 下面代码错误，不能在静态变量声明中使用泛型形参
	static T info;
	// T age;

	public void foo(T msg) {
	}
	// 下面代码错误，不能在静态方法声明中使用泛型形参
	// public static void bar(T msg){}
}
```
```
Cannot make a static reference to the non-static type TJava(536871434)
```
