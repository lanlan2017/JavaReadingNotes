---
title: 13.6.2 离线RowSet
categories: 
  - 疯狂Java讲义 (第4版)
  - 第13章 MySQL数据库与JDBC编程
  - 13.6 Java7的RowSet1.1
date: 2019-07-05 15:40:16
updated: 2019-11-02 01:39:01
abbrlink: e16aaec2
---
- [13.6.2 离线RowSet](/ReadingNotes/e16aaec2/#13-6-2-离线RowSet)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 13.6.2 离线RowSet #
在使用`ResultSet`的时代,程序查询得到`ResultSet`之后必须立即读取或处理它对应的记录,否则旦`Connection`关闭,再去通过`ResultSet`读取记录就会引发异常。在这种模式下,`JDBC`编程十分痛苦.
假设应用程序架构被分为两层:数据访问层和视图显示层,当应用程序在数据访问层查询得到`ResultSet`之后,对`ResultSet`的处理有如下两种常见方式。
- 1.使用迭代访问`ResultSet`里的记录,并将这些记录转换成`Java Bean`,再将多个`Java Bean`封装成个`List`集合,也就是完成"`ResultSet`到`Java Bean`集合"的转换。转换完成后可以关闭`Connection`等资源,然后将`Java bean`集合传到视图显示层,视图显示层可以显示查询得到的数据。
- 2.直接将`ResultSet`传到视图显示层——这要求当视图显示层显示数据时,底层`Connection`必须直处于打开状态,否则`ResultSet`无法读取记录。

- 第一种方式比较安全,但编程十分烦琐;
- 第二种方式则需要`Connection`一直处于打开状态,这不仅不安全,而且对程序性能也有较大的影响。

通过使用离线`RowSet`可以十分"优雅"地处理上面的问题,离线`RowSet`会直接将底层数据读入内存中,封装成`RowSet`对象,而`RowSet`对象则完全可以当成`Java Bean`来使用。因此不仅安全,而且编程十分简单。`CachedRowSet`是所有离线`RowSet`的父接口,因此下面以`CachedRowSet`为例进行介绍。看下面程序。
```java
import java.util.*;
import java.io.*;
import java.sql.*;
import javax.sql.*;
import javax.sql.rowset.*;

public class CachedRowSetTest
{
	private static String driver;
	private static String url;
	private static String user;
	private static String pass;
	public void initParam(String paramFile) throws Exception
	{
		// 使用Properties类来加载属性文件
		Properties props = new Properties();
		props.load(new FileInputStream(paramFile));
		driver = props.getProperty("driver");
		url = props.getProperty("url");
		user = props.getProperty("user");
		pass = props.getProperty("pass");
	}

	public CachedRowSet query(String sql) throws Exception
	{
		// 1.加载驱动
		Class.forName(driver);
		// 2.获取数据库连接
		Connection conn = DriverManager.getConnection(url, user, pass);
		Statement stmt = conn.createStatement();
		ResultSet rs = stmt.executeQuery(sql);
		// 3.使用RowSetProvider创建RowSetFactory
		RowSetFactory factory = RowSetProvider.newFactory();
		// 4.创建默认的CachedRowSet实例
		CachedRowSet cachedRs = factory.createCachedRowSet();
		// 5.使用ResultSet装填RowSet
		cachedRs.populate(rs); // ①
		// 关闭资源
		rs.close();
		stmt.close();
		conn.close();
		return cachedRs;
	}
	public static void main(String[] args) throws Exception
	{
		CachedRowSetTest ct = new CachedRowSetTest();
		ct.initParam("mysql.ini");
		CachedRowSet rs = ct.query("select * from student_table");
		rs.afterLast();
		// 向前滚动结果集
		while (rs.previous())
		{
			System.out.println(rs.getString(1) + "\t" + rs.getString(2) + "\t"
					+ rs.getString(3));
			if (rs.getInt("student_id") == 3)
			{
				// 修改指定记录行
				rs.updateString("student_name", "孙悟空");
				rs.updateRow();
			}
		}
		// 重新获取数据库连接
		Connection conn = DriverManager.getConnection(url, user, pass);
		conn.setAutoCommit(false);
		// 把对RowSet所做的修改同步到底层数据库
		rs.acceptChanges(conn);
	}
}
```
上面程序中的①号代码调用了`RowSet`的`populate(ResultSet rs)`方法来包装给定的`ResultSet`,接下来的粗体字代码关闭了`ResultSet`、 `Statement`、 `Connection`等数据库资源。如果程序直接返回`ResultSet`,那么这个`ResultSet`无法使用:这是因为底层的`Connection`已经关闭了;但程序返回的是`CachedRowSet`,它是一个离线`RowSet`,因此程序依然可以读取、修改`RowSet`中的记录。

运行该程序,可以看到在`Connection`关闭的情况下,程序依然可以读取、修改`RowSet`里的记录.
为了将程序对离线`RowSet`所做的修改同步到底层数据库,程序在调用`RowSet`的`acceptChanges()`方法时必须传入`Connection`.

