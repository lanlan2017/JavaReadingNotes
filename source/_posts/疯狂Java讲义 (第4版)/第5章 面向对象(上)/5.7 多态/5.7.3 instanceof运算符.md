---
title: 5.7.3 instanceof运算符
categories: 
  - 疯狂Java讲义 (第4版)
  - 第5章 面向对象(上)
  - 5.7 多态
date: 2019-09-24 09:57:38
updated: 2019-11-02 01:39:01
abbrlink: 8bbe0d02
---
- [5.7.3 **instanceof**运算符](/ReadingNotes/8bbe0d02/#5-7-3-instanceof运算符)
    - [**instanceof**前面的引用变量的**编译时类型**要与后面的类**相同**或者**有继承关系**](/ReadingNotes/8bbe0d02/#instanceof前面的引用变量的编译时类型要与后面的类相同或者有继承关系)
    - [**instanceof**的前面的引用变量的**运行时类型**决定返回**true**或**flase**](/ReadingNotes/8bbe0d02/#instanceof的前面的引用变量的运行时类型决定返回true或flase)
    - [**instanceof**运算符的作用](/ReadingNotes/8bbe0d02/#instanceof运算符的作用)
    - [先用**instanceof**判断再强制类型装换](/ReadingNotes/8bbe0d02/#先用instanceof判断再强制类型装换)
    - [实例](/ReadingNotes/8bbe0d02/#实例)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
<!--replace:instanceof=instance of-->
# 5.7.3 `instanceof`运算符 #
`instanceof`运算符的前一个操作数通常是一个`引用类型变量`,后一个操作数通常是一个类(也可以是接口,可以把接口理解成一种特殊的类),它用于**判断`前面的对象是否是后面的类`,或者其子类、实现类`的实例`**。如果是,则返回`true`,否则返回`false`.
## `instanceof`前面的引用变量的`编译时类型`要与后面的类`相同`或者`有继承关系` ##
在使用`instanceof`运算符时需要注意:
- **`instanceof`运算符前面操作数的`编译时类型`要么与后面的类相同**,
- **要么与后面的类`具有父子继承关系`**,
- 否则会引起`编译错误`。

## `instanceof`的前面的引用变量的`运行时类型`决定返回`true`或`flase` ##
如果`instanceof`前面的引用变量的运行时类型和后面的类一样,或者是后面类的子类,则返回`true`.

## `instanceof`运算符的作用 ##
`instanceof`运算符的作用是:在进行强制类型转换之前,首先判断前一个对象是否是后一个类的实例,是否可以成功转换,从而保证代码更加健壮.
## 先用`instanceof`判断再强制类型装换 ##
`instanceof`和`(type)`是`Java`提供的两个相关的运算符,通常**先用`instanceof`判断一个对象是否可以强制类型转换,然后再使用(`type)`运算符进行强制类型转换,从而保证程序不会出现错误**。
<!--SSTStop-->
## 实例 ##
```java
public class InstanceofTest {
	public static void main(String[] args) {
		Object hello = "Hello";
		// hello的编译时类型是Object,可以使用instanceof运算符比较,
		// hello的运算时类型是String,String类的对象是Object的实例,所以返回true
		System.out.println((hello instanceof Object));
		// hello的编译时类型时Object,Object和String具有继承关系,可以使用instanceof运算符比较
		// hello的运行时类型是String,String类的对象是String的实例,所以返回true
		System.out.println((hello instanceof String));
		System.out.println("-------------------------------------------------");
		// hello的编译时类型是Object,Object和Math具有继承关系,可以使用instanceof运算符比较
		// hello的运行时类型是String,String类的对象不是math类型的实例,返回false
		System.out.println((hello instanceof Math));
		// hello的编译时类型是Object,Object和 接口 可以使用instanceof比较
		// hello的运行时类型是String,String是Comparable接口的实现类,返回true
		System.out.println(hello instanceof Comparable);
		System.out.println("-------------------------------------------------");
		String a = "Hello";
		// a的编译时类型是String,String和Math没有继承关系,无法比较,编译不通过
		// System.out.println((a instanceof Math));
		// a的编译时类型是String,String和Object具有继承关系,可以使用instanceof运算比较.
		System.out.println(a instanceof Object);
		System.out.println("-----------------------------------------------");
		Father father = new Father();
		// father的编译时类型是Father,Father和Son有继承关系,可以使用instanceof比较.
		// father的运行时类型是Father,Father不是Son的子类,所以返回false
		System.out.println(father instanceof Son);
		father = new Son();
		// father的运行时类型是Son,Son和相等Son,返回true
		System.out.println(father instanceof Son);
	}
}

class Father {
}

class Son extends Father {

}
```
```
true
true
-------------------------------------------------
false
true
-------------------------------------------------
true
-----------------------------------------------
false
true
```

