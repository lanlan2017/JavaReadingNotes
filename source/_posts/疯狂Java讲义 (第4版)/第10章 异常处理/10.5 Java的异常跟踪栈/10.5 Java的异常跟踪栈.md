---
title: 10.5 Java的异常跟踪栈
categories: 
  - 疯狂Java讲义 (第4版)
  - 第10章 异常处理
  - 10.5 Java的异常跟踪栈
date: 2019-07-13 22:56:34
updated: 2019-11-02 01:39:01
abbrlink: cfdc28f0
---
- [10.5 Java的异常跟踪栈](/ReadingNotes/cfdc28f0/#10-5-Java的异常跟踪栈)
    - [异常跟踪栈信息](/ReadingNotes/cfdc28f0/#异常跟踪栈信息)
    - [多线程中发生异常的情形](/ReadingNotes/cfdc28f0/#多线程中发生异常的情形)
        - [结论](/ReadingNotes/cfdc28f0/#结论)
    - [本文重点](/ReadingNotes/cfdc28f0/#本文重点)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
# 10.5 Java的异常跟踪栈 #
异常对象的`printStackTrace`方法用于打印异常的跟踪栈信息,根据`printStackTrace`方法的输出结果,开发者可以找到异常的源头,并跟踪到异常一路触发的过程。看下面用于测试`printStackTrace`的例子程序。
```java
class SelfException extends RuntimeException
{
	SelfException(){}
	SelfException(String msg)
	{
		super(msg);
	}
}
public class PrintStackTraceTest
{
	public static void main(String[] args)
	{
		firstMethod();
	}
	public static void firstMethod()
	{
		secondMethod();
	}
	public static void secondMethod()
	{
		thirdMethod();
	}
	public static void thirdMethod()
	{
		throw new SelfException("自定义异常信息");
	}
}
```
上面程序中`main`方法调用`firstMethod`, `firstMethod`调用`secondMethod`, `secondMethod`调用`thirdMethod, thirdMethod`直接抛出一个`SelfException`异常。运行上面程序,会看到如下结果。
```cmd
Exception in thread "main" SelfException: 自定义异常信息
	at PrintStackTraceTest.thirdMethod(PrintStackTraceTest.java:25)
	at PrintStackTraceTest.secondMethod(PrintStackTraceTest.java:21)
	at PrintStackTraceTest.firstMethod(PrintStackTraceTest.java:17)
	at PrintStackTraceTest.main(PrintStackTraceTest.java:13)
```
从上面结果可以以看出,异常从`thirdMethod`方法开始触发,传到`secondMethod`方法,再传到`firstMethod`方法,最后传到`main`方法,在`main`方法终止,这个过程就是`Java`的异常跟踪栈。
只要异常没有被完全捕获(包括异常没有被捕获,或异常被处理后重新抛出了新异常),异常就会从发生异常的方法逐渐向外传播,首先传给该方法的调用者,该方法调用者再次传给其调用者…直至最后传到`main`方法,如果`main`方法依然没有处理该异常,`JVM`会中止该程序,并打印异常的跟踪栈信息。

## 异常跟踪栈信息 ##
异常跟踪栈信息它记录了应用程序中执行停止的各个点.
第一行的信息详细显示了异常的类型和异常的详细消息。
接下来跟踪栈记录程序中所有的异常发生点,各行显示被调用方法中执行的停止位置,并标明类类中的方法名、与故障点对应的文件的行编号。一行行地往下看,跟踪栈总是最内部的被调用方法逐渐上传,直到最外部业务操作的起点,通常就是程序的入口`main`方法或`Thread`类的`run`方法(多线程的情形)
## 多线程中发生异常的情形 ##
下面例子程序示范了多线程程序中发生异常的情形。
```java
public class ThreadExceptionTest implements Runnable
{
	public void run()
	{
		firstMethod();
		System.out.println("自定义线程正常结束");
	}
	public void firstMethod()
	{
		secondMethod();
	}
	public void secondMethod()
	{
		int a = 5;
		int b = 0;
		int c = a / b;
	}
	public static void main(String[] args)
	{
		new Thread(new ThreadExceptionTest()).start();
		try
		{
			Thread.sleep(5000);
			System.out.println("主线程睡眠结束");
		} catch (InterruptedException e)
		{
			// 打印异常跟踪栈
			e.printStackTrace();
		}
		System.out.println("main线程正常结束");
	}

}
```
运行结果如下:
```cmd
Exception in thread "Thread-0" java.lang.ArithmeticException: / by zero
	at ThreadExceptionTest.secondMethod(ThreadExceptionTest.java:16)
	at ThreadExceptionTest.firstMethod(ThreadExceptionTest.java:10)
	at ThreadExceptionTest.run(ThreadExceptionTest.java:5)
	at java.lang.Thread.run(Thread.java:745)
主线程睡眠结束
main线程正常结束
```
程序在`Thread`的`run`方法中出现了`ArithmeticException`异常,这个异常的源头是`ThreadExcetpionTest`的`secondMethod`方法,位于`ThreadExcetpionTest.java`文件的第`16`行代码。这个异常传播到`Thread`类的`run`方法就会结束.
### 结论 ###
对于多线程的情况,当异常传播到`Thread`类的`run`方法时,如果该异常没有得到处理,将会导致**该线程中止运行**。

虽然`printStackTrace`方法可以很方便地用于追踪异常的发生情况,可以用它来调试程序,但在最后发布的程序中,应该避免使用它;而应该对捕获的异常进行适当的处理,而不是简单地将异常的跟踪栈信息打印出来。
## 本文重点 ##
- `printStackTrace`方法可以打印异常跟踪栈信息.
- 线程中出现异常,如果不处理,则该线程会终止,
- 线程中发生的异常不会结束整个程序.
- 发生在一个线程中的异常不会影响其他线程。


