---
title: 7.10.3 获取方法返回值
categories: 
  - 轻量级Java EE企业应用实战(第5版)
  - 第7章 Spring的基本用法
  - 7.10 高级依赖关系配置
date: 2019-08-29 19:54:59
updated: 2019-11-02 01:39:03
abbrlink: d01356fa
---
- [7.10.3 获取方法返回值](/ReadingNotes/d01356fa/#7-10-3-获取方法返回值)
    - [调用静态方法](/ReadingNotes/d01356fa/#调用静态方法)
    - [调用实例方法](/ReadingNotes/d01356fa/#调用实例方法)
- [程序示例](/ReadingNotes/d01356fa/#程序示例)

<!--more-->
<script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.slim.min.js"></script>
<script>$(document).ready(function () {$(".post-body > ul:nth-child(1)").hide();});</script>

<!--end-->
<!--SSTStart-->
# 7.10.3 获取方法返回值 #
通过`MethodInvokingFactoryBean`这个工厂`Bean`,可调用任意类的类方法,也可调用任意对象的实例方法,**如果调用的方法有返回值,则既可将该指定方法的返回值定义成容器中的`Bean`,也可将指定方法的返回值注入给其他`Bean`**
使用`MethodInvokingFactoryBean`来调用任意方法时,可分为两种情形。
## 调用静态方法 ##
如果希望调用的方法是静态方法,则需要指定:
1. 调用哪个类。通过`MethodInvokingFactoryBean`的`setTargetClass(String targetClass)`方法指定。
2. 调用哪个方法。通过`MethodInvokingFactoryBean`的`setMethod(String targetMethod)`方法指定。
3. 调用方法的参数。通过`MethodInvokingFactoryBean`的`setArguments(Object[] arguments)`方法指定。如果希望调用的方法无须参数,则可以省略该配置。

## 调用实例方法 ##
如果希望调用的方法是实例方法,则需要指定:
1. 调用哪个对象。通过`MethodInvokingFactoryBean`的`setTargetobject(Object targetObject)`方法指定。
2. 调用哪个方法。通过`MethodInvokingFactoryBean`的`setTargetMethod(String targetMethod)`方法指定。
3. 调用方法的参数。通过`MethodInvokingFactoryBean`的`setArguments(Object[] arguments)`方法指定。如果希望调用的方法无须参数,则可以省略该配置。

假设有如下一段`Java`代码:
```java
JFrame win=new JFrame("我的窗口");
JTextArea jta=JTextArea(7,40);
win.add(new JScrollPane(jta));
JPanel jp=new JPanel();
win.add(jp,BorderLayout.SOUTH)
JButton jb1=new JButton("确定");
jp.add(jb1);
JButton jp2=new JButton("取消");
jp.add(jb2);
win.pack();
win.setVisible(true);
```
这段代码是一段很"随意"的`Java`代码(可以是任意一段`Java`代码),别人给你任何一段`Java`代码,你都应该能用`Spring`配置文件将它配置出来。
# 程序示例 #
```cmd
E:\workspace_QingLiangJiJavaEEQiYeYingYongShiZhang5\MethodInvokingFactoryBean
└─src\
  ├─beans.xml
  └─lee\
    └─SpringTest.java
```
下面使用`XML`配置文件将上面这段`Java`代码配置出来。
```xml
<?xml version="1.0" encoding="GBK"?>
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	http://www.springframework.org/schema/beans/spring-beans.xsd
	http://www.springframework.org/schema/util
	http://www.springframework.org/schema/util/spring-util-4.0.xsd">
	<!-- 下面配置相当于如下Java代码：
	JFrame win = new JFrame("我的窗口");
	win.setVisible(true); -->
	<bean id="win" class="javax.swing.JFrame">
		<constructor-arg value="我的窗口" type="java.lang.String"/>
		<property name="visible" value="true"/>
	</bean>
	
	<!-- 下面配置相当于如下Java代码：
	JTextArea jta = JTextArea(7, 40); -->
	<bean id="jta" class="javax.swing.JTextArea">
		<constructor-arg value="7" type="int"/>
		<constructor-arg value="40" type="int"/>
	</bean>	
	
	<!-- 使用MethodInvokingFactoryBean驱动Spring调用普通方法
	下面配置相当于如下Java代码：
	win.add(new JScrollPane(jta)); -->
	<bean class=
	"org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="win"/>
		<property name="targetMethod" value="add"/>
		<property name="arguments">
			<list>
				<bean class="javax.swing.JScrollPane">
					<constructor-arg ref="jta"/>
				</bean>
			</list>
		</property>
	</bean>
	
	<!-- 下面配置相当于如下Java代码：
	JPanel jp = new JPanel(); -->
	<bean id="jp" class="javax.swing.JPanel"/>

	<!-- 使用MethodInvokingFactoryBean驱动Spring调用普通方法
	下面配置相当于如下Java代码：
	win.add(jp , BorderLayout.SOUTH); -->
	<bean class=
		"org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="win"/>
		<property name="targetMethod" value="add"/>
		<property name="arguments">
			<list>
				<ref bean="jp"/>
				<util:constant static-field="java.awt.BorderLayout.SOUTH"/>
			</list>
		</property>
	</bean>
	
	<!-- 下面配置相当于如下Java代码：
	JButton jb1 = new JButton("确定"); -->
	<bean id="jb1" class="javax.swing.JButton">
		<constructor-arg value="确定" type="java.lang.String"/>
	</bean>
	
	<!-- 使用MethodInvokingFactoryBean驱动Spring调用普通方法
	下面配置相当于如下Java代码：
	jp.add(jb1); -->
	<bean class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="jp"/>
		<property name="targetMethod" value="add"/>
		<property name="arguments">
			<list>
				<ref bean="jb1"/>
			</list>
		</property>
	</bean>

	<!-- 下面配置相当于如下Java代码：
	JButton jb2 = new JButton("取消"); -->
	<bean id="jb2" class="javax.swing.JButton">
		<constructor-arg value="取消" type="java.lang.String"/>
	</bean>
	
	<!-- 使用MethodInvokingFactoryBean驱动Spring调用普通方法
	下面配置相当于如下Java代码：
	jp.add(jb2); -->
	<bean class=
		"org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="jp"/>
		<property name="targetMethod" value="add"/>
		<property name="arguments">
			<list>
				<ref bean="jb2"/>
			</list>
		</property>
	</bean>
	<!-- 使用MethodInvokingFactoryBean驱动Spring调用普通方法
	下面配置相当于如下Java代码：
	win.pack(); -->
	<bean class=
		"org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject" ref="win"/>
		<property name="targetMethod" value="pack"/>
	</bean>
</beans>
```
该示例的主程序非常简单,主程序只是简单的行:用于创建`Spring`容器。编译、运行该程序,可以看到如图7.4所示的界面。
通过上面示例证实了一点:几乎所有的`Java`代码都可以通过`Spring XML`配置文件配置出来连上面的`Swing`编程都可使用`Spring XML`配置文件来驱动。需要说明的是,此处只是向读者示范如何使用`Spring`配置文件来驱动执行任意一段`Java`代码,并非要大家使用`Spring XML`配置文件进行`Swing`界面编程.
经过上面的介绍不难发现`: Spring`框架的本质其实就是通过`XML`配置来执行`Java`代码,因此几乎可以把所有的`Java`代码放到`Spring`配置文件中管理。归纳一下:
1. 调用构造器创建对象(包括使用工厂方法创建对象),用`<bean>`元素。
2. 调用`setter`方法,用`<property>`元素。
3. 调用`getter`方法,用`PropertyPathFactoryBean`或`<util:property-path>`元素。
4. 获取`Field`的值,用`FieldRetrievingFactoryBean`或`<util:constant>`元素。
5. 调用普通方法,用`MethodInvokingFactoryBean`工厂`Bean`

那么是否有必要把所有的`Java`代码都放在`Sprin`配置文件中管理呢?答案是否定的。过度使用`XML`配置文件不仅使得配置文件更加臃肿,难以维护,而且导致程序的可读性严重降低。
一般来说,应该将如下两类信息放到`XML`配置文件中管理。
1. 项目升级、维护时经常需要改动的信息
2. 控制项目内各组件耦合关系的代码。

这样就体现了`Spring IoC`容器的作用:将原来使用`Java`代码管理的耦合关系,提取到`XML`中进行管理,从而降低了各组件之间的耦合,提高了软件系统的可维护性
<!--SSTStop-->


