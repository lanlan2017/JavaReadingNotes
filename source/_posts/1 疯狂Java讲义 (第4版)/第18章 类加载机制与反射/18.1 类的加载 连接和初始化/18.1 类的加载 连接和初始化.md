---
title: 18.1 类的加载 连接和初始化
categories: 
  - 1 疯狂Java讲义 (第4版)
  - 第18章 类加载机制与反射
  - 18.1 类的加载 连接和初始化
date: 2019-06-15 23:22:57
updated: 2020-02-28 10:04:49
abbrlink: 180ffbb8
---
# 18.1 类的加载 连接和初始化
系统可能在第一次使用某个类时加载该类，也可能采用预加载机制来加载某个类。本节将会详细介绍类加载、连接和初始化过程中的每个细节。
# 18.1.1 JVM和类
当调用`java`命令运行某个`Java`程序时，该命令将会启动一个`Java`虚拟机进程，不管该`Java`程序有多么复杂，该程序启动了多少个线程，它们都处于该`Java`虚拟机进程里。正如前面介绍的，**同一个`JVM`的所有线程、所有变量都处于同一个进程里，它们都使用该`JVM`进程的内存区**。
## JVM进程终止的情况
- 当系统出现以下几种情况时，`JVM`进程将被终止。
- 程序运行到最后正常结束。
- 程序运行到使用`System.exit()`或`Runtime.getRuntime().exit()`代码处结束程序.
- 程序执行过程中遇到未捕获的异常或错误而结束
- 程序所在平台强制结束了`JVM`进程。

从上面的介绍可以看出，**当`Java`程序运行结束时，`JVM`进程结束，该进程在内存中的状态将会丢失**。下面以类的类变量来说明这个问题。
## 程序示例
下面程序先定义了一个包含类变量的类。
```java
public class A {
    // 定义该类的类变量
    public static int a = 6;
}
```
上面程序中定义了一个类变量a，接下来定义一个类创建A类的实例，并访问A对象的类变量a。
```java
public class ATest1 {
    public static void main(String[] args) {
        // 创建A类的实例
        A a = new A();
        // 让a实例的类变量a的值自加
        a.a++;
        System.out.println(a.a);
    }
}
```
下面程序也创建A对象，并访问其类变量a的值
```java
public class ATest2 {
    public static void main(String[] args) {
        // 创建A类的实例
        A b = new A();
        // 输出b实例的类变量a的值
        System.out.println(b.a);
    }
}
```
在`ATest1.Java`程序中创建了A类的实例，并让该实例的类变量a的值自加，程序输出该实例的类变量a的值将看到7，相信读者对这个答案没有疑问。关键是运行第二个程序`ATest2`时，程序再次创建了A对象，并输出A对象类变量的a的值，此时a的值是多少呢?**结果依然是6**，并不是7。这是因为**运行`ATest1`和`ATest2`是两次运行`JVM`进程，第一次运行`JVM`结束后，它对A类所做的修改将全部丢失**，第二次运行`JVM`时将再次初始化A类

**两次运行`Java`程序处于两个不同的`JVM`进程中，两个`JVM`之间并不会共享数据。**
# 18.1.2 类的加载
## 类加载
当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过`加载`、`连接`、`初始化`三个步骤来对该类进行初始化。如果没有意外，`JVM`将会连续完成这三个步骤，所以有时也把这三个步骤统称为`类加载`或`类初始化`。
## 什么是类加载
**类加载指的是将类的`class`文件读入内存，并为之创建一个`java.lang.Class`对象**，也就是说，当程序中使用任何类时，系统都会为之建立一个`java.lang.Class`对象。
## 类也是对象
系统中所有的类实际上也是实例，它们都是`java.lang.Class`的实例。
## 类加载器
**类的加载由类加载器完成**，类加载器通常由`JVM`提供，这些类加载器也是前面所有程序运行的基础，
- `JVM`提供的这些类加载器通常被称为**系统类加载器**。
- 除此之外，开发者可以通过继承`ClassLoader`基类来创建自己的类加载器。

## 类加载来源
通过使用不同的类加载器，可以从不同来源加载**类的二进制数据**，通常有如下几种来源:
- **从本地文件系统加载`class`文件**，这是前面绝大部分示例程序的类加载方式.
- **从`JAR`包加载`class`文件**，这种方式也是很常见的，前面介绍`JDBC`编程时用到的数据库驱动类就放在`JAR`文件中，`JVM`可以从`JAR`文件中直接加载该`class`文件。
- 通过网络加载`class`文件。
- 把一个`Java`源文件动态编译，并执行加载。

类加载器通常无须等到"首次使用"该类时才加载该类，**`Java`虚拟机规范允许系统预先加载某些类**。
# 18.1.3 类的连接
当类被加载之后，系统为之生成一个对应的`Class`对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到`JRE`中。类连接又可分为如下三个阶段。
- `验证`:验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。
- `准备`:类准备阶段则负责`为类的类变量分配内存，并设置默认初始值`。
- `解析`:将类的二进制数据中的符号引用替换成直接引用。

# 18.1.4 类的初始化
在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对`类变量`进行初始化。
## 对类变量指定初始值的两种方式
在`Java`类中**对类变量指定初始值**有两种方式:
1. **声明类变量时指定**初始值;
2. 使用**静态初始化块**为类变量指定初始值。

例如下面代码片段。
```java
public calss Test
{
    //声明变量a时指定初始值
    static int a=5;
    static int b;
    static int c;
    static{
        //使用静态初始化块为变量b指定初始值
        b=6;
    }
}
```
对于上面代码，程序为类变量a、b都显式指定了初始值，所以这两个类变量的值分别为5、6，但类变量c则没有指定初始值，它将采用**默认初始值**0。

**静态初始化块被当成`类的初始化语句`**,`JVM`会按这些语句在程序中的排列顺序依次执行它们.例如下面的类。
```java
public class Test {
    static {
        // 使用静态初始化块为变量b指定出初始值
        b = 6;
        System.out.println("----------");
    }
    // 声明变量a时指定初始值
    static int a = 5;
    static int b = 9; // ①
    static int c;

    public static void main(String[] args) {
        System.out.println(Test.b);
    }
}
```
上面代码先在静态初始化块中为b变量赋值，**此时类变量b的值为6**;
接着程序向下执行，执行到①号代码处，这行代码也属于该类的初始化语句，所以程序再次为类变量b赋值。也就是说，当`Test`类初始化结束后，该类的**类变量b的值为9**。

## JVM初始化类步骤
`JVM`初始化一个类包含如下几个步骤。
1. 假如这个类还没有被加载和连接，则程序**先加载并连接该类**
2. 假如该类的直接父类还没有被初始化，则**先初始化其直接父类**。
3. 假如该类中有初始化语句，则系统**依次执行这些初始化语句**。

当执行第2个步骤时，系统对直接父类的初始化步骤也遵循此步骤1到3;**如果该直接父类又有直接父类，则系统再次重复这三个步骤来先初始化这个父类**...依此类推。
## JVM总是最先初始化Object类
所以**`JVM`最先初始化的总是`java.lang.Object`类**。**当程序主动使用任何一个类时，系统会保证该类以及所有父类(包括直接父类和间接父类)都会被初始化**。

# 18.1.5 类初始化的时机
当`Java`程序首次通过下面6种方式来使用某个类或接口时，系统就会初始化该类或接口.
1. **创建类的实例**。为某个类创建实例的方式包括:
    - 使用`new`操作符来创建实例，
    - 通过反射来创建实例，
    - 通过反序列化的方式来创建实例。
2. **调用某个类的类方法**(静态方法)
3. 访问某个类或接口的`类变量`，或为该类变量赋值。
4. 使用反射方式来强制创建某个类或接口对应的`java.lang.Class`对象。例如代码:`Class.forName("Person");`如果系统还未初始化`Person`类，则这行代码将会导致该`Person`类被初始化，并返回`Person`类对应的`java.lang.Class`对象。
5. 初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被初始化。
6. 直接使用`java.exe`命令来运行某个主类。当运行某个主类时，程序会先初始化该主类。

## 访问编译时就可以确定的类变量不会初始化类
除此之外，下面的几种情形需要特别指出。
### 访问编译时可确定值得final变量不会初始化类
对于一个 `final`型的类变量，如果该类变量的值在编译时就可以确定下来，那么这个类变量相当于“宏变量”。`Java`编译器会在编译时直接把这个类变量出现的地方替换成它的值，因此即使程序使用该静态类变量，也不会导致该类的初始化。例如下面示例程序的结果：
```java
class MyTest
{
    static
    {
        System.out.println("静态初始化块...");
    }
    // 使用一个字符串直接量为static final的类变量赋值
    static final String compileConstant = "final static字符串";
}
public class CompileConstantTest
{
    public static void main(String[] args)
    {
        // 访问、输出MyTest中的compileConstant类变量
        System.out.println(MyTest.compileConstant);   // ①
    }
}
```
运行结果
```cmd
final static字符串
```
上面程序的`MyTest`类中有一个`compileConstant`的类变量，该类变量使用了`final`修饰，而且它的值可以在编译时确定下来，因此`compileConstant`会被当成"宏变量"处理。**程序中所有使用`compileConstant`的地方都会在编译时被直接替换成它的值**——也就是说，上面程序中①处的代码在编译时就会被替换成"`final static字符串`"，所以**代码①**不会导致初始化`MyTest`类，静态代码块将不会执行。
#### final修饰的类常量
当某个类变量(也叫静态变量)使用了`final`修饰，而且它的值可以在编译时就确定下来，那么程序其他地方使用该类变量时，实际上并没有使用该类变量，而是相当于使用常量

反之，**如果`final`修饰的类变量的值不能在编译时确定下来**，则必须等到运行时才可以确定该类变量的值，如果通过该类来访问它的类变量，则**会导致该类被初始化**。例如将上面程序中定义`compileConstant`的代码改为如下:
```java
    // 采用系统当前时间为static final类变量赋值
    static final String compileConstant = System.currentTimeMillis()+"静态字符串嘻嘻嘻";//①
```
因为上面定义的`compileConstant`类变量的值必须在运行时才可以确定，所以①处的字代码必须保留为对`MyTest`类的类变量的引用，这行代码就变成了使用`MyTest`的类变量，这将导致`MyTest`类被初始化。
运行效果如下:
```
静态初始化块...
1560616123824静态字符串嘻嘻嘻
```
### `ClassLoader`类的`loadClass`方法 不会初始化类
当使用`ClassLoader`类的`loadClass()`方法来加载某个类时，这个`loadClass()`方法只是加载该类，并不会执行该类的初始化。
### `Class`类的`forName`方法会强制初始化类
使用`Class`的`forName()`静态方法才会导致强制初始化该类。例如如下代码：
```java
class Tester
{
    static
    {
        System.out.println("Tester类的静态初始化块...");
    }
}
public class ClassLoaderTest
{
    public static void main(String[] args)
        throws ClassNotFoundException
    {
        ClassLoader cl = ClassLoader.getSystemClassLoader();
        // 下面语句仅仅是加载Tester类
        cl.loadClass("Tester");//代码1
        System.out.println("---------------------------------------------");
        System.out.println("系统加载Tester类");
        // 下面语句才会初始化Tester类
        Class.forName("Tester");//代码2
    }
}
```
上面程序中的代码**代码1** **代码2**都用到了`Tester`类，**代码1**只是加载`Tester`类，并不会初始化`Tester`类。运行上面程序，会看到如下运行结果:
```cmd
系统加载Tester类
Tester类的静态初始化块...
```
从上面运行结果可以看出，必须等到执行`Class.forName("Tester")`时才完成对`Tester`类的初始化。
