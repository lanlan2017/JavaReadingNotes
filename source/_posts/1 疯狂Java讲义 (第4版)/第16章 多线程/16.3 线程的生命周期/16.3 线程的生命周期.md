---
title: 16.3 线程的生命周期
categories: 
  - 1 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.3 线程的生命周期
date: 2019-07-16 00:50:35
updated: 2020-03-20 09:17:27
abbrlink: 42f33da
---
# 16.3 线程的生命周期
当线程被创建并启动以后,它既不是一启动就进入了执行状态,也不是一直处于执行状态。
## 线程的5种状态
在线程的生命周期中,它要经过:
1. 新建(`New`)、
2. 就绪(`Runnable`)、
3. 运行(`Running`)、
4. 阻塞(`Blocked`)
5. 死亡(`Dead`)

这5种状态。

尤其是当线程启动以后,它不可能一直霸占着`CPU`独自运行,所以`CPU`需要在多条线程之间切换,于是线程状态也会多次在`运行`、`阻塞`之间切换。
# 16.3.1 新建状态和就绪状态
## 新建状态 new Thread创建线程后
**当程序使用`new`关键字创建了一个线程之后,该线程就处于`新建状态`**,此时它和其他的`Java`对象一样,仅仅由`Java`虚拟机为其分配内存,并初始化其成员变量的值。
此时的线程对象没有表现出任何线程的动态特征,程序也不会执行线程的线程执行体。

## 就绪状态 调用Thread对象start方法后
**当线程对象调用了`start`方法之后,该线程处于`就绪状态`**,`Java`虚拟机会为其创建**方法调用栈**和**程序计数器**,处于这个状态中的线程并没有开始运行,**只是表示该线程可以运行了**。至于该线程何时开始运行,取决于`JVM`里线程调度器的调度。

## 启动线程使用start方法
### 永远不要调用线程对象的run方法
**启动线程使用`start()`方法,而不是`run()`方法**!永远不要调用线程对象的`run()`方法!
- 调用`start()`方法来启动线程,系统会把该`run()`方法当成**线程执行体**来处理;
- 如果直接调用线程对象的`run()`方法,系统把线程对象当成一个普通对象,把`run()`方法当成一个普通方法,而不是线程执行体,`run()`方法将立即就会被执行,而且在`run()`方法返回之前其他线程无法并发执行

### 程序 调用run方法不会启动线程
```java
public class InvokeRun extends Thread
{
    private int i ;
    // 重写run方法，run方法的方法体就是线程执行体
    public void run()
    {
        for ( ; i < 100 ; i++ )
        {
            // 直接调用run方法时，Thread的this.getName返回的是该对象名字，
            // 而不是当前线程的名字。
            // 使用Thread.currentThread().getName()总是获取当前线程名字
            System.out.println(Thread.currentThread().getName()
                +  " " + i);   // ①
        }
    }
    public static void main(String[] args)
    {
        for (int i = 0; i < 100;  i++)
        {
            // 调用Thread的currentThread方法获取当前线程
            System.out.println(Thread.currentThread().getName()
                +  " " + i);
            if (i == 20)
            {
                // 直接调用线程对象的run方法，
                // 系统会把线程对象当成普通对象，run方法当成普通方法，
                // 所以下面两行代码并不会启动两条线程，而是依次执行两个run方法
                new InvokeRun().run();
                new InvokeRun().run();
            }
        }
    }
}
```
运行效果:
```cmd
main 0
main 1
main 2
main 3
......
main 18
main 19
main 20
main 0
main 1
main 2
......
main 44
main 45
main 46
main 47
main 48
main 49
main 0
main 1
main 2
main 3
......
main 47
main 48
main 49
```
上面程序创建线程对象后**直接调用了线程对象的`run()`方法,程序运行的结果是整个程序只有一个线程:`主线程`**。
还有一点需要指出,如果直接调用线程对象的`run()`方法,则`run()`方法里不能直接通过`getName()`方法来获得当前执行线程的名字,而是需要使用`Thread.currentThread()`方法先获得当前线程,再调用线程对象的`getName()`方法来获得线程的名字。
通过上面程序不难看出,**启动线程的正确方法是调用`Thread`对象的`start()`方法,而不是直接调用`run()`方法**,否则就变成单线程程序了

### 只能对处于新建状态的线程调用start方法
**只能对处于新建状态的线程调用`start`方法,否则将引发`IllegalThreadStateException`异常**。调用了线程的`run()`方法之后,该线程已经不再处于新建状态,不要再次调用线程对象的`start()`方法。
调用线程对象的`start`方法之后,该线程立即进入就绪状态,就绪状态相当于"等待执行",但该线程并未真正进入运行状态。

### 如何让子线程立即执行
如果希望调用子线程的`start`方法后子线程立即开始执行,程序可以使用`Thread.sleep(1)`来让`当前运行的线程(主线程)睡眠1毫秒`——1毫秒就够了,因为在这1毫秒内`CPU`不会空闲,它会去执行另一个处于就绪状态的线程,这样就可以让子线程立即开始执行。

## 小结
- **当程序使用`new`关键字创建了一个线程之后,该线程就处于`新建状态`**
- **当线程对象调用了`start`方法之后,该线程处于`就绪状态`**,就绪状态相当于"等待执行"状态,此时该线程并未真正进入运行状态。
- **只能对处于新建状态的线程调用`start`方法,否则将引发`IllegalThreadStateException`异常**
- **启动线程的正确方法是调用`Thread`对象的`start()`方法,而不是直接调用`run()`方法**,**直接调用了线程对象的`run()`方法,程序运行的结果是整个程序只有一个线程:`主线程`**
- 如果希望调用子线程的`start`方法后子线程立即开始执行,则可以让`当前运行的线程(主线程)睡眠1毫秒`,这种情况针只有一个子线程的情况,个人觉得用处不大.

# 16.3.2 运行状态和阻塞状态
## 运行状态 run方法得到执行
如果**处于就绪状态的线程获得了`CPU`,开始执行线程的执行体`run()`方法,则该线程处于`运行状态`**,如果计算机只有一个`CPU`,那么在任何时刻只有一个线程处于运行状态。当然,在一个多处理器的机器上,将会有多个线程**`并行`执行**;不过当线程数大于处理器数时,依然会存在多个线程在同一个`CPU`上轮换的现象。(注意多处理器的机器上是并行:`parallel`,单处理器上是`并发`)
当一个线程开始运行后,它不可能一直处于运行状态(除非它的线程执行体足够短,瞬间就执行结束了),**线程在运行过程中需要被中断,目的是使其他线程获得执行的机会**,线程调度的细节取决于底层平台所采用的策略。对于采用`抢占式策略`的系统而言,系统会给每个可执行的线程一个`小时间段`来处理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源,让其他线程获得执行的机会。在选择下一个线程时,系统会考虑线程的优先级。
所有现代的桌面和服务器操作系统都采用`抢占式调度策略`,但一些小型设备如`手机`则可能采用`协作式调度策略`,在这样的系统中,只有当一个线程调用了它的`sleep()`或`yield()`方法后才会放弃所占用的资源,也就是必须由该线程主动放弃所占用的资源。
## 阻塞状态 sleep IO阻塞 等待同步锁 等待通知 suspend
当发生如下情况时,线程将会进入阻塞状态。
1. 线程调用`sleep()`方法主动放弃所占用的处理器资源。
2. 线程调用了一个`阻塞式IO方法`,在`阻塞式IO方法`返回之前,该线程被阻塞。
3. 线程试图获得一个**同步监视器**,但该`同步监视器正被其他线程所持有的时候`。
4. 线程在等待某个通知(`notify`)。
5. 程序调用了线程的`suspend()`方法将该线程挂起。但这个方法容易导致死锁,所以应该尽量避免使用该方法。

## 阻塞结束进入就绪
当前正在执行的线程被阻塞之后,其他线程就可以获得执行的机会。**被阻塞的线程会在合适的时候重新进入`就绪状态`**,注意是`就绪状态`而不是**运行状态**。也就是说,**被阻塞线程的阻塞解除后,必须重新等待线程调度器再次调度它**。
### 阻塞进入就绪 sleep时间到 IO方法返回 获得同步锁 收到通知 resumed
针对上面几种情况,当发生如下特定的情况时可以解除上面的阻塞,让该线程重新进入就绪状态。
1. 调用`sleep`方法的线程经过了指定时间
2. 线程调用的`阻塞式IO方法`已经返回。
3. 线程成功地获得了试图取得的同步监视器。
4. 线程正在等待某个通知时,`其他线程发出了一个通知`。
5. 处于挂起状态的线程被调用了`resumed()`恢复方法。

## 线程状态转换图
图16.4显示了线程状态转换图。
![这里有一张图片](https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/fangkuangJavaJiangYi3/16/1.png)
从图16.4中可以看出：
- **线程从`阻塞状态`只能进入`就绪状态`,无法直接进入运行状态**。
- **`就绪状态`和`运行状态`之间的转换通常不受程序控制,而是由系统线程调度所决定**,
  - 当处于`就绪状态`的线程获得处理器资源时,该线程进入`运行状态`;
  - 当处于`运行状态`的线程失去处理器资源时,该线程进入`就绪状态`。
    - 但有个方法例外,**调用`yield()`方法可以让`运行状态`的线程转入`就绪状态`**。

# 16.3.3 线程死亡
## 线程死亡 run方法结束 异常 stop
线程会以如下三种方式结束,结束后就处于死亡状态。
- `run()`或`call()`方法执行完成,线程正常结束。
- 线程抛出一个未捕获的`Exception`或`Error`。
- 直接调用该线程的`stop()`方法来结束该线程,不过`stop()`方法容易导致死锁,通常不推荐使用。

## 一个线程结束不会影响其他线程
当主线程结束时,其他线程不受任何影响,并不会随之结束。一旦子线程启动起来后,它就拥有和主线程相同的地位,它不会受主线程的影响。
## isAlive方法
为了测试某个线程是否已经死亡,可以调用线程对象的`isAlive()`方法,
- 当线程处于`就绪`、`运行`、`阻塞`三种状态时,`isAlive()`方法将返回`true`;
- 当线程处于`新建`、`死亡`两种状态时,`isAlive()`方法将返回`false`

## 已经死亡的线程无法再次启动
不要试图对一个已经死亡的线程调用`start`方法使它重新启动,死亡就是死亡,该线程将不可再次作为线程执行。
### 程序 死亡的线程无法再次start
下面程序尝试对处于死亡状态的线程再次调用`start`方法。
```java
public class StartDead extends Thread
{
    // 重写run方法，run方法的方法体就是线程执行体
    private int i ;
    public void run()
    {
        for ( ; i < 100 ; i++ )
        {
            System.out.println(getName() +  " " + i);
        }
    }
    public static void main(String[] args)
    {
        // 创建线程对象
        StartDead sd = new StartDead();
        for (int i = 0; i < 300;  i++)
        {
            // 调用Thread的currentThread方法获取当前线程
            System.out.println(Thread.currentThread().getName()
                +  " " + i);
            if (i == 20)
            {
                // 启动线程
                // 判断启动后线程的isAlive()值，输出true
                sd.start();
                System.out.println(sd.isAlive());
            }
            // 只有当线程处于新建、死亡两种状态时isAlive()方法返回false。
            // 当i > 20，则该线程肯定已经启动过了，
            // 如果sd.isAlive()为假时，那只能是死亡状态了。
            if (i > 20 && !sd.isAlive())

            {
                // 试图再次启动该线程
                sd.start();
            }
        }
    }
}
```
上面程序中试图在线程已死亡的情况下再次调用`start`方法来启动该线程。
运行上面程序,将引发`IllegalThreadStateException`异常。这表明**处于死亡状态的线程无法再次运行了**。
### 只能对新建的线程start一次
不要对处于死亡状态的线程调用`start`方法,**只能对`新建状态`的线程调用`start`方法**,**对`新建状态`的线程两次调用`start`方法也是错误的**。这都会引发`IllegalThreadStateException`异常.
