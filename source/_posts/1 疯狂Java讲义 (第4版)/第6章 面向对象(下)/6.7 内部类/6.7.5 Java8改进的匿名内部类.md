---
title: 6.7.5 Java8改进的匿名内部类
categories: 
  - 1 疯狂Java讲义 (第4版)
  - 第6章 面向对象(下)
  - 6.7 内部类
abbrlink: ad008d9e
date: 2019-09-27 12:05:39
updated: 2022-04-03 01:21:15
---
# 6.7.5 Java8改进的匿名内部类 #
匿名内部类适合创建那种只需要一次使用的类,匿名内部类不能重复使用。
## 定义匿名内部类的格式 ##
### 创建接口的匿名内部类 ###
```java
new 实现接口（）
{
    //匿名内部类类体部分
}
```
### 实现接口方式接口名后面的括号里不能传入参数 ###
通过`实现接口`来创建匿名内部类时,由于接口中不能定义构造器,因此匿名内部类只有一个隐式的无参数构造器,故`new 接口名`后的括号里不能传入参数值
### 创建抽象类的匿名内部类 ###
```java
new 父类构造器（实参列表）
{
  //匿名内部类类体部分
}
```
### 抽象类的匿名内部类可以调用带参构造器 ###
由于抽象类可以定义构造器,并且抽象类的构造器是提供给子类调用的，所以,创建抽象类的匿名内部类时:
`new 抽象类名`后面的括号中`可以传入参数`,`也可以不传入参数`。
- 传入参数时,将调用对应的带参构造器。
- 不传入参数时,将调用无参构造器

## 匿名内部类规则 ##
关于匿名内部类还有如下两条规则。
- **匿名内部类不能是抽象类**,因为系统在创建匿名内部类时,会立即创建匿名内部类的对象。因此**不允许将匿名内部类定义成抽象类**。
- **匿名内部类不能定义构造器**。由于匿名内部类没有类名,所以无法定义构造器,但`匿名内部类可以定义初始化块`,可以**通过实例初始化块来完成构造器需要完成的事情**

## 匿名内部类必须实现所有抽象方法 ##
由于匿名内部类不能是抽象类,所以**匿名内部类必须实现它的抽象父类或者接口里包含的所有抽象方法**。如果有需要,也可以重写抽象父类中的普通方法

## 匿名内部类不可以修改局部变量的值 ##
## java8之前被匿名内部类访问的局部变量必须 手动 用final修饰 ##
在`Java8`之前,`Java`要求被`局部内部类`、`匿名内部类`访问的局部变量必须使用`final`修饰。

## java8后被匿名内部类访问的局部变量会 自动 加上final修饰 ##
从`Java8`开始，被`局部内部类`、`匿名内部类`访问的局部变量可以不显示用`final`修饰。如果**局部变量被匿名内部类访问,那么该局部变量相当于自动使用了`final`修饰**。
`Java8`将这个功能称为`"effectively final"`,它的意思是对于被匿名内部类访问的局部变量,可以用`final`修饰,也可以不用`final`修饰,但必须按照有`final`修饰的方式来用。
也就是**被匿名内部类访问的局部变量一旦被赋值一次后,以后不能再重新赋值**。

## 实例 ##
```java
interface A {
    void test();
}

public class ATest {
    public static void main(String[] args) {
        int age = 8; // ①
        // 下面代码将会导致编译错误
        // 由于age局部变量被匿名内部类访问了，因此age相当于被final修饰了
        // age = 2;
        A a = new A() {
            public void test() {
                // 在Java 8以前下面语句将提示错误：age必须使用final修饰
                // 从Java 8开始，匿名内部类、局部内部类允许访问非final的局部变量
                System.out.println(age);
            }
        };
        a.test();
    }
}
```

