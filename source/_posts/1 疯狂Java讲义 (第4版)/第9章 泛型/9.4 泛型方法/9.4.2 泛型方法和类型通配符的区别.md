---
title: 9.4.2 泛型方法和类型通配符的区别
categories: 
  - 1 疯狂Java讲义 (第4版)
  - 第9章 泛型
  - 9.4 泛型方法
abbrlink: 9bbab7e0
date: 2019-12-23 01:27:46
updated: 2022-04-03 01:21:15
---
# 9.4.2 泛型方法和类型通配符的区别
大多数时候都可以使用泛型方法来代替类型通配符。例如,对于`Java`的 `Collection`接口中两个方法定义:
```java
...
public interface Collection<E> extends Iterable<E> {
    ...
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    ...
}
```
上面集合中两个方法的形参都采用了类型通配符的形式,也可以采用泛型方法的形式,如下所示。
```java
...
public interface Collection<E> extends Iterable<E> {
    ...
    <T> boolean containsAll(Collection<T> c);
    <T extends E> boolean addAll(Collection<T> c);
    ...
}
```
上面方法使用了`<T extends E>`泛型形式,这时定义泛型形参时设定上限(其中`E`是 `Collection`接口里定义的泛型,在该接口里`E`可当成普通类型使用)。
上面两个方法中泛型形参T只使用了一次,泛型形参T产生的唯一效果是可以在不同的调用点传入不同的实际类型。对于这种情况,应该使用通配符:通配符就是被设计用来支持灵活的子类化的。
泛型方法允许泛型形参被用来表示方法的一个或多个参数之间的类型依赖关系,或者方法返回值与参数之间的类型依赖关系。如果没有这样的类型依赖关系,就不应该使用泛型方法.

如果某个方法中一个形参(`a`)的类型或返回值的类型依赖于另一个形参(`b`)的类型,则形参(`b`)的类型声眀不应该使用通配符——因为形参(`a`)或返回值的类型依赖于该形参(`b`)的类型,如果形参(`b`)的类型无法确定,程序就无法定义形参(`a`)的类型。在这种情况下,只能考虑使用在方法签名中声明泛型,也就是泛型方法.

如果有需要,也可以同时使用泛型方法和通配符,如`Java`的 `Collections.copy()`方法。
```java
...
public class Collections {
    ...
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        ...
    }
    ...
}
```
上面`copy`方法中的`dest`和`src`存在明显的依赖关系,从源`List`中复制出来的元素,必须可以“丢进”目标`List`中,所以**源`List`集合元素的类型只能是`目标集合`元素的类型的子类型或者它本身**。但`JDK`定义`src`形参类型时使用的是类型通配符,而不是泛型方法。这是因为:该方法无须向`src`集合中添加元素,也无须修改`src`集合里的元素,所以可以使用类型通配符,无须使用泛型方法。
提示:简而言之,指定上限的类型通配符支持协变,因此这种协变的集合可以安全地取出元素(协变只出不进),因此无须使用泛型方法。
当然,也可以将上面的方法签名改为使用泛型方法,不使用类型通配符,如下所示
```java
...
public class Collections {
    ...
    public static <T,S extends T> void copy(List<T> dest, List<S> src) {
        ...
    }
    ...
}
```
这个方法签名可以代替前面的方法签名。但注意上面的泛型形参S,它仅使用了一次,其他参数的类型、方法返回值的类型都不依赖于它,那泛型形参S就没有存在的必要,即可以用通配符来代替S。使用通配符比使用泛型方法(在方法签名中显式声明泛型形参)更加清晰和准确,因此`Java`设计该方法时采用了通配符,而不是泛型方法。
类型通配符与泛型方法(在方法签名中显式声明泛型形参)还有一个显著的区别:类型通配符既可以在方法签名中定义形参的类型,也可以用于定义变量的类型;但泛型方法中的泛型形参必须在对应方法中显式声明。
