---
title: 7.1 我是皇帝我独苗
categories: 
  - 8 设计模式之禅(第2版)
  - 2 第二部分 真刀实枪 23种设计模式完美演绎
  - 第7章 单例模式
abbrlink: a2282b7c
date: 2019-09-18 13:30:51
updated: 2021-10-03 15:25:21
---
# 7.1 我是皇帝我独苗 #
自从秦始皇确立了皇帝这个位置以后，同一时期基本上就只有一个人孤零零地坐在这个位置。这种情况下臣民们也好处理，大家叩拜、谈论的时候只要提及皇帝，每个人都知道指的是谁，而不用在皇帝前面加上特定的称呼，如张皇帝、李皇帝。这一个过程反应到设计领域就是，要求一个类只能生成一个对象（皇帝），所有对象对它的依赖都是相同的，因为只有一个对象，大家对它的脾气和习性都非常了解，建立健壮稳固的关系，我们把皇帝这种特殊职业通过程序来实现。

皇帝每天要上朝接待臣子、处理政务，臣子每天要叩拜皇帝，皇帝只能有一个，也就是一个类只能产生一个对象，该怎么实现呢？对象产生是通过new关键字完成的（当然也有其他方式，比如对象复制、反射等），这个怎么控制呀，但是大家别忘记了构造函数，使用new关键字创建对象时，都会根据输入的参数调用相应的构造函数，如果我们把构造函数设置为private私有访问权限不就可以禁止外部创建对象了吗？臣子叩拜唯一皇帝的过程类图如图7-1所示。

![image-20210927214335031](https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20210927214335.png)

<center>图7-1 臣子叩拜皇帝类图</center>
只有两个类，Emperor代表皇帝类，Minister代表臣子类，关联到皇帝类非常简单。Emperor如代码清单7-1所示。

代码清单7-1 皇帝类

```java
public class Emperor {
    private static final Emperor emperor =new Emperor();
    //初始化一个皇帝
    private Emperor(){
        //世俗和道德约束你，目的就是不希望产生第二个皇帝
    }
    public static Emperor getInstance(){
        return emperor;
    }
    //皇帝发话了
    public static void say(){
        System.out.println("我就是皇帝某某某....");
    }
}
```

通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象，而Emperor自己则可以new一个对象出来，其他类对该类的访问都可以通过getInstance获得同一个对象。

皇帝有了，臣子要出场，其类如代码清单7-2所示。

代码清单7-2 臣子类

```java
public class Minister {
    public static void main(String[] args) {
        for(int day=0;day<3;day++){
            Emperor emperor=Emperor.getInstance();
            emperor.say();
        }
        //三天见的皇帝都是同一个人，荣幸吧！
    }
}
```

臣子参拜皇帝的运行结果如下所示。

```
我就是皇帝某某某.... 
我就是皇帝某某某.... 
我就是皇帝某某某....
```

臣子天天要上朝参见皇帝，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，老熟人了，容易讲话，这就是单例模式。
