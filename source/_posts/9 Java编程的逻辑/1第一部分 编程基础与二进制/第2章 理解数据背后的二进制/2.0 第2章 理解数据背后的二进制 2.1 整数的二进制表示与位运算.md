---
title: 2.0 第2章 理解数据背后的二进制 2.1 整数的二进制表示与位运算
<<<<<<< HEAD
categories:
=======
categories: 
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0
  - 9 Java编程的逻辑
  - 1第一部分 编程基础与二进制
  - 第2章 理解数据背后的二进制
abbrlink: 9f845784
date: 2021-12-04 20:14:01
<<<<<<< HEAD
updated: 2021-12-08 12:34:05
=======
updated: 2022-04-03 01:21:19
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0
---
# 第2章 理解数据背后的二进制
在第1章，我们遗留了几个问题。
- 正整数相乘的结果居然出现了负数。
- 非常基本的小数运算结果居然不精确。
- 字符类型也可以进行算术运算和比较。

要理解这些行为，我们需要理解数值和文本字符在计算机内部的二进制表示，本章就来介绍各种数据背后的二进制，具体分为4节：2.1节介绍整数；2.2节介绍小数；2.3节介绍与语言无关的字符和文本的编码以及乱码；2.4节介绍Java中表示字符的基本类型char。

# 2.1 整数的二进制表示与位运算
要理解整数的二进制，我们先来看下熟悉的十进制。我们对十进制是如此熟悉，可能已忽略了它的含义。比如123，不假思索我们就知道它的值是多少。

但其实123表示1× (10^2)+2× (10^1)+3× (10^0)（10^2表示10的二次方），它表示的是各个位置数字含义之和，每个位置的数字含义与位置有关，从右向左，第一位乘以10的0次方，即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，以此类推。

换句话说，每个位置都有一个**位权**，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，以此类推。

## 2.1.1 正整数的二进制表示
正整数的二进制表示与此类似，只是在十进制中，每个位置可以有10个数字，为0～9，但在二进制中，每个位置只能是0或1。位权的概念是类似的，从右到左，第一位为1，然后依次乘以2，即第二位为2，第三位为4，以此类推。表2-1列出了一些数字的二进制与对应的十进制。

<center>表2-1 二进制与对应的十进制</center>

<<<<<<< HEAD
![epub_923038_19](https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211201223406.jpeg)
=======
![epub_923038_19](https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20211201223406.jpeg)
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0

### 2.1.2 负整数的二进制表示
十进制的负数表示就是在前面加一个负数符号-，例如-123。但二进制如何表示负数呢？其实概念是类似的，二进制使用最高位表示符号位，用1表示负数，用0表示正数。但哪个是最高位呢？整数有4种类型byte、short、int、long，分别占1、2、4、8个字节，即分别占8、16、32、64位，每种类型的符号位都是其最左边的一位。为方便举例，下面假定类型是byte，即从右到左的第8位表示符号位。

但负数表示不是简单地将最高位变为1，比如：
1）byte a=-1，如果只是将最高位变为1，二进制应该是10000001，但实际上，它应该是11111111。
2）byte a=-127，如果只是将最高位变为1，二进制应该是11111111，但实际上，它却应该是10000001。

和我们的直觉正好相反，这是什么表示法？这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加1。取反就是将0变为1,1变为0。负数的二进制表示就是对应的正数的补码表示，比如：
1）-1:1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。
2）-2:2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。
3）-127:127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。

给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样。

对于byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是-128～127。其他类型的整数也类似，负数能多表示一个数。

负整数为什么要采用这种奇怪的表示形式呢？原因是，只有这种形式，计算机才能实现正确的加减法。

计算机其实只能做加法，1-1其实是1+(-1)。如果用原码表示，计算结果是不对的，比如：

```
1   -> 00000001
-1 -> 10000001
+ ------------------
-2 -> 10000010
```

用符合直觉的原码表示，1-1的结果是-2，如果是补码表示：

```
1   -> 00000001
-1 -> 11111111
+ ------------------
0   -> 00000000
```

结果是正确的。再如，5-3：

```
5   -> 00000101
-3 -> 11111101
+ ------------------
2   -> 00000010
```

结果也是正确的。就是这样，看上去可能比较奇怪和难以理解，但这种表示其实是非常严谨和正确的，是不是很奇妙？

理解了二进制加减法，我们就能理解为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是1，然后就会被看作负数。比如，127+1：

```
127    -> 01111111
1      -> 00000001
+ ------------------
-128   -> 10000000
```

计算结果超出了byte的表示范围，会被看作-128。

## 2.1.3 十六进制
二进制写起来太长，为了简化写法，可以将4个二进制位简化为一个0～15的数，10～15用字符A～F表示，这种表示方法称为十六进制，如表2-2所示。

<center>表2-2 十六进制</center>


<<<<<<< HEAD
![epub_923038_20](https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211201223630.jpeg)
=======
![epub_923038_20](https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20211201223630.jpeg)
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0

可以用十六进制直接写常量数字，在数字前面加0x即可。比如十进制的123，用十六进制表示是0x7B，即123=7×16+11。给整数赋值或者进行运算的时候，都可以直接使用十六进制，比如：

```
int a = 0x7B;
```

Java 7之前不支持直接写二进制常量。比如，想写二进制形式的11001, Java 7之前不能直接写，可以在前面补0，补足8位，为00011001，然后用十六进制表示，即0x19。Java 7开始支持二进制常量，在前面加0b或0B即可，比如：

```
int a = 0b11001;
```

在Java中，可以方便地使用Integer和Long的方法查看整数的二进制和十六进制表示，例如：

```
int a = 25;
System.out.println(Integer.toBinaryString(a)); //二进制
System.out.println(Integer.toHexString(a));  //十六进制
System.out.println(Long.toBinaryString(a)); //二进制
System.out.println(Long.toHexString(a));  //十六进制
```

## 2.1.4 位运算
理解了二进制表示，我们来看二进制级别的操作：位运算。Java 7之前不能单独表示一个位，但可以用byte表示8位，用十六进制写二进制常量。比如，0010表示成十六进制是0x2,110110表示成十六进制是0x36。

位运算有移位运算和逻辑运算。移位有以下几种。
1）左移：操作符为<<，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看作整数，左移1位就相当于乘以2。
2）无符号右移：操作符为>>>，向右移动，右边的舍弃掉，左边补0。
3）有符号右移：操作符为>>，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看作整数，右移1位相当于除以2。

例如：

```
int a = 4; //100
a = a >> 2; //001，等于1
a = a << 3 //1000，变为8
```

逻辑运算有以下几种。

- 按位与&：两位都为1才为1。
- 按位或|：只要有一位为1，就为1。
- 按位取反~:1变为0,0变为1。
- 按位异或^：相异为真，相同为假。

大部分都比较简单，如下所示，具体就不赘述了。

```
int a = …;
a = a & 0x1 //返回0或1，就是a最右边一位的值
a   = a | 0x1 //不管a原来最右边一位是什么，都将设为1
```
