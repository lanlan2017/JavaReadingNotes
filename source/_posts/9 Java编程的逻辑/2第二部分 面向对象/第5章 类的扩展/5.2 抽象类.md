---
title: 5.2 抽象类
<<<<<<< HEAD
categories:
=======
categories: 
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0
  - 9 Java编程的逻辑
  - 2第二部分 面向对象
  - 第5章 类的扩展
abbrlink: 3eab5bb5
date: 2021-12-04 20:14:01
<<<<<<< HEAD
updated: 2021-12-07 12:07:08
=======
updated: 2022-04-03 01:21:19
>>>>>>> 4ed4de8f07c69857a05fa9fda8014b55c4291ca0
---
# 5.2 抽象类
顾名思义，**抽象类就是抽象的类。抽象是相对于具体而言的，一般而言，具体类有直接对应的对象，而抽象类没有，它表达的是抽象概念**，一般是具体类的比较上层的父类。比如，狗是具体对象，而动物则是抽象概念；樱桃是具体对象，而水果则是抽象概念；正方形是具体对象，而图形则是抽象概念。下面我们通过图形处理中的一些概念来说明Java中的抽象类。

## 5.2.1 抽象方法和抽象类
之前我们介绍过图形类Shape，它有一个方法draw()。Shape其实是一个抽象概念，它的draw()方法其实并不知道如何实现，只有子类才知道。这种只有子类才知道如何实现的方法，一般被定义为**抽象方法**。

抽象方法是相对于具体方法而言的，具体方法有实现代码，而抽象方法只有声明，没有实现。上节介绍的接口中的方法（非Java 8引入的静态和默认方法）就都是抽象方法。

抽象方法和抽象类都使用abstract这个关键字来声明，语法如下所示：

```java
public abstract class Shape {
    //其他代码
    public abstract void draw();
}
```

定义了抽象方法的类必须被声明为抽象类，不过，抽象类可以没有抽象方法。抽象类和具体类一样，可以定义具体方法、实例变量等，它和具体类的核心区别是，**抽象类不能创建对象(比如，不能使用new Shape())，而具体类可以**。

抽象类不能创建对象，要创建对象，必须使用它的具体子类。一个类在继承抽象类后，必须实现抽象类中定义的所有抽象方法，除非它自己也声明为抽象类。圆类的实现代码，如下所示：

```java
public class Circle extends Shape {
    //其他代码
    @Override
    public void draw() {
        //主体代码
    }
}
```

圆实现了draw()方法。与接口类似，抽象类虽然不能使用new，但可以声明抽象类的变量，引用抽象类具体子类的对象，如下所示：

```java
Shape shape = new Circle();
shape.draw();
```

shape是抽象类Shape类型的变量，引用了具体子类Circle的对象，调用draw()方法将调用Circle的draw代码。

## 5.2.2 为什么需要抽象类
抽象方法和抽象类看上去是多余的，对于抽象方法，不知道如何实现，定义一个空方法体不就行了吗？而抽象类不让创建对象，看上去只是增加了一个不必要的限制。

引入抽象方法和抽象类，是Java提供的一种语法工具，对于一些类和方法，引导使用者正确使用它们，减少误用。使用抽象方法而非空方法体，子类就知道它必须要实现该方法，而不可能忽略，若忽略Java编译器会提示错误。使用抽象类，类的使用者创建对象的时候，就知道必须要使用某个具体子类，而不可能误用不完整的父类。

无论是编写程序，还是平时做其他事情，**每个人都可能会犯错，减少错误不能只依赖人的优秀素质，还需要一些机制，使得一个普通人都容易把事情做对，而难以把事情做错。抽象类就是Java提供的这样一种机制**。

## 5.2.3 抽象类和接口
抽象类和接口有类似之处：都不能用于创建对象，接口中的方法其实都是抽象方法。如果抽象类中只定义了抽象方法，那抽象类和接口就更像了。但抽象类和接口根本上是不同的，**接口中不能定义实例变量**，而抽象类可以，一个类可以实现多个接口，但只能继承一个类。

**抽象类和接口是配合而非替代关系，它们经常一起使用，接口声明能力，抽象类提供默认实现，实现全部或部分方法，一个接口经常有一个对应的抽象类**。比如，在Java类库中，有：

- Collection接口和对应的AbstractCollection抽象类。
- List接口和对应的AbstractList抽象类。
- Map接口和对应的AbstractMap抽象类。

对于需要实现接口的具体类而言，有两个选择：一个是实现接口，自己实现全部方法；另一个则是继承抽象类，然后根据需要重写方法。

继承的好处是复用代码，只重写需要的部分即可，需要编写的代码比较少，容易实现。不过，如果这个具体类已经有父类了，那就只能选择实现接口了。

我们以一个例子来进一步说明这种配合关系。前面引入了IAdd接口，我们实现一个抽象类AbstractAdder，代码如下：

```java
public abstract class AbstractAdder implements IAdd {
    @Override
    public void addAll(int[] numbers) {
        for(int num : numbers){
            add(num);
        }
    }
}
```

这个抽象类提供了addAll方法的实现，它通过调用add方法来实现，而add方法是一个抽象方法。这样，对于需要实现IAdd接口的类来说，它可以选择直接实现IAdd接口，或者从AbstractAdder类继承，如果继承，只需要实现add方法就可以了。这里，我们让原有的Base类继承AbstractAdder，代码如下所示：

```java
public class Base extends AbstractAdder {
    private static final int MAX_NUM = 1000;
    private int[] arr = new int[MAX_NUM];
    private int count;
    @Override
    public void add(int number){
        if(count<MAX_NUM){
            arr[count++] = number;
        }
    }
}
```

## 5.2.4 小结
本节介绍了抽象类，相对于具体类，它用于表达抽象概念，虽然从语法上抽象类不是必需的，但它能使程序更为清晰，可以减少误用。抽象类和接口经常相互配合，接口定义能力，而抽象类提供默认实现，方便子类实现接口。

在目前关于类的描述中，每个类都是独立的，都对应一个Java源代码文件，但在Java中，一个类还可以放在另一个类的内部，称之为内部类。为什么要将一个类放到别的类内部呢？让我们下节探讨。
