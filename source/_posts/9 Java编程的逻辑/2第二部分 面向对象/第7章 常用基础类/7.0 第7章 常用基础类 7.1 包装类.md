---
title: 7.0 第7章 常用基础类 7.1 包装类
categories:
  - 9 Java编程的逻辑
  - 2第二部分 面向对象
  - 第7章 常用基础类
abbrlink: 31a72ecb
date: 2021-12-04 20:14:01
updated: 2021-12-08 12:34:05
---
# 第7章 常用基础类
本章介绍Java编程中一些常用的基础类，探讨它们的用法、应用和实现原理，这些类有：
- 各种包装类；
- 文本处理的类String和StringBuilder；
- 数组操作的类Arrays；
- 日期和时间处理；
- 随机。

# 7.1 包装类
Java有8种基本类型，每种基本类型都有一个对应的包装类。包装类是什么呢？它是一个类，内部有一个实例变量，保存对应的基本类型的值，这个类一般还有一些静态方法、静态变量和实例方法，以方便对数据进行操作。Java中，基本类型和对应的包装类如表7-1所示。

<center>表7-1 基本类型和对应的包装类</center>

[插图]

包装类也都很好记，除了Integer和Character外，其他类名称与基本类型基本一样，只是首字母大写。包装类有什么用呢？Java中很多代码（比如后续章节介绍的容器类）只能操作对象，为了能操作基本类型，需要使用其对应的包装类。另外，包装类提供了很多有用的方法，可以方便对数据的操作。下面先介绍各个包装类的基本用法及其共同点，然后重点介绍Integer和Character。

## 7.1.1 基本用法
各个包装类都可以与其对应的基本类型相互转换，方法也是类似的，部分类型如表7-2所示。

<center>表7-2 包装类与基本类型的转换</center>

[插图]

包装类与基本类型的转换代码结构是类似的，每种包装类都有一个静态方法valueOf()，接受基本类型，返回引用类型，也都有一个实例方法xxxValue()返回对应的基本类型。

将基本类型转换为包装类的过程，一般称为“装箱”，而将包装类型转换为基本类型的过程，则称为“拆箱”。装箱/拆箱写起来比较烦琐，Java 5以后引入了自动装箱和拆箱技术，可以直接将基本类型赋值给引用类型，反之亦可，比如：

[插图]

自动装箱/拆箱是Java编译器提供的能力，背后，它会替换为调用对应的valueOf/xxx-Value方法，比如，上面的代码会被Java编译器替换为：

[插图]

每种包装类也都有构造方法，可以通过new创建，比如：

[插图]

那到底应该用静态的valueOf方法，还是使用new呢？一般建议使用valueOf方法。new每次都会创建一个新对象，而除了Float和Double外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，提升性能。实际上，从Java 9开始，这些构造方法已经被标记为过时了，推荐使用静态的valueOf方法。

## 7.1.2 共同点
各个包装类有很多共同点，比如，都重写了Object中的一些方法，都实现了Comparable接口，都有一些与String有关的方法，大部分都定义了一些静态常量，都是不可变的。下面具体介绍。

### 1．重写Object方法
所有包装类都重写了Object类的如下方法：

[插图]

我们分别介绍。
#### （1）equals
equals用于判断当前对象和参数传入的对象是否相同，Object类的默认实现是比较地址，对于两个变量，只有这两个变量指向同一个对象时，equals才返回true，它和比较运算符（==）的结果是一样的。

equals应该反映的是对象间的逻辑相等关系，所以这个默认实现一般是不合适的，子类需要重写该实现。所有包装类都重写了该实现，实际比较用的是其包装的基本类型值，比如，对于Long类，其equals方法代码如下：

[插图]

对于Float，其实现代码如下：

[插图]

Float有一个静态方法floatToIntBits()，将float的二进制表示看作int。需要注意的是，只有两个float的二进制表示完全一样的时候，equals才会返回true。在2.2节的时候，我们提到小数计算是不精确的，数学概念上运算结果一样，但计算机运算结果可能不同，比如下面的代码：

[插图]

输出为：

[插图]

也就是，两个浮点数不一样，将二进制看作整数也不一样，相差为1。

Double的equals方法与Float类似，它有一个静态方法doubleToLongBits，将double的二进制表示看作long，然后再按long比较。

### （2）hashCode
hashCode返回一个对象的哈希值。哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。一个对象的哈希值不能改变，相同对象的哈希值必须一样。不同对象的哈希值一般应不同，但这不是必需的，可以有对象不同但哈希值相同的情况。

比如，对于一个班的学生对象，hashCode可以是学生的出生日期，出生日期是不变的，不同学生生日一般不同，分布比较均匀，个别生日相同的也没关系。

hashCode和equals方法联系密切，**对两个对象，如果equals方法返回true，则hashCode也必须一样**。反之不要求，equal方法返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。hashCode的默认实现一般是将对象的内存地址转换为整数，**子类如果重写了equals方法，也必须重写hashCode**。之所以有这个规定，是因为Java API中很多类依赖于这个行为，尤其是容器中的一些类。

包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte、Short、Integer、Character, hashCode就是其内部值，代码为：

[插图]

对于Boolean, hashCode代码为：

[插图]

根据基类类型值返回了两个不同的数，为什么选这两个值呢？它们是质数（即只能被1和自己整除的数），质数用于哈希时比较好，不容易冲突。

对于Long, hashCode代码为：

[插图]

是高32位与低32位进行位异或操作。

对于Double, hashCode代码为：

[插图]

与equals方法类似，将double的二进制表示看作long，然后再按long计算hashCode。

每个包装类也都重写了toString方法，返回对象的字符串表示，这个一般比较自然，不再赘述。

### 2. Comparable
每个包装类都实现了Java API中的Comparable接口。Comparable接口代码如下：

[插图]

`<T>`是泛型语法，我们在第8章介绍，T表示比较的类型，由实现接口的类传入。接口只有一个方法compareTo，当前对象与参数对象进行比较，在小于、等于、大于参数时，应分别返回-1、0、1。

各个包装类的实现基本都是根据基本类型值进行比较，不再赘述。对于Boolean,false小于true。对于Float和Double，存在和equals方法一样的问题，0.01和0.1*0.1相比的结果并不为0。

### 3．包装类和String
除了toString方法外，包装类还有一些其他与String相关的方法。除了Character外，每个包装类都有一个静态的valueOf(String)方法，根据字符串表示返回包装类对象，如：

[插图]

也都有一个静态的parseXXX(String)方法，根据字符串表示返回基本类型值，如：

[插图]

都有一个静态的toString方法，根据基本类型值返回字符串表示，如：

[插图]

输出：

[插图]

对于整数类型，字符串表示除了默认的十进制外，还可以表示为其他进制，如二进制、八进制和十六进制，包装类有静态方法进行相互转换，比如：

[插图]

输出：

[插图]

### 4．常用常量
包装类中除了定义静态方法和实例方法外，还定义了一些静态变量。对于Boolean类型，有：

[插图]

所有数值类型都定义了MAX_VALUE和MIN_VALUE，表示能表示的最大/最小值，比如，对Integer：

[插图]

Float和Double还定义了一些特殊数值，比如正无穷、负无穷、非数值，如Double类：

[插图]

### 5. Number
6种数值类型包装类有一个共同的父类Number。Number是一个抽象类，它定义了如下方法：

[插图]

通过这些方法，包装类实例可以返回任意的基本数值类型。
### 6．不可变性
包装类都是不可变类。所谓不可变是指实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：
- 所有包装类都声明为了final，不能被继承。
- 内部基本类型值是私有的，且声明为了final。
- 没有定义setter方法。

为什么要定义为不可变类呢？**不可变使得程序更为简单安全**，因为不用操心数据被意外改写的可能，可以安全地共享数据，尤其是在多线程的环境下。关于线程，我们在第15章介绍。

## 7.1.3 剖析Integer与二进制算法
本小节主要介绍Integer类， Long与Integer类似，就不再单独介绍了。一个简单的Integer还有什么要介绍的呢？它有一些二进制操作，包括位翻转和循环移位等，另外，我们也分析一下它的valueOf实现。为什么要关心实现代码呢？大部分情况下，确实不用关心，会用它就可以了，我们主要是学习其中的二进制操作。二进制是计算机的基础，但代码往往晦涩难懂，我们希望对其有一个更为清晰深刻的理解。

### 1．位翻转
Integer有两个静态方法，可以按位进行翻转：

[插图]

位翻转就是将int当作二进制，左边的位与右边的位进行互换，reverse是按位进行互换， reverseBytes是按byte进行互换，我们来看个例子：

[插图]

a是整数，用十六进制赋值，首先输出其二进制字符串，接着输出reverse后的二进制，最后输出reverseBytes后的十六进制，输出为：

[插图]

reverseBytes是按字节翻转，78是十六进制表示的一个字节，12也是，所以结果78563412是比较容易理解的。二进制翻转初看是不对的，这是因为输出不是32位，输出时忽略了前面的0，我们补齐32位再看：

[插图]

这次结果就对了。这两个方法是怎么实现的呢？

先来看reverseBytes的代码：

[插图]

代码比较晦涩，以参数i等于0x12345678为例，我们来分析执行过程：
1）i>>>24无符号右移，最高字节挪到最低位，结果是0x00000012；
2）(i>>8) & 0xFF00，左边第二个字节挪到右边第二个，i>>8结果是0x00123456，再进行& 0xFF00，保留的是右边第二个字节，结果是0x00003400；
3）(i << 8) & 0xFF0000，右边第二个字节挪到左边第二个，i<<8结果是0x34567800，再进行& 0xFF0000，保留的是右边第三个字节，结果是0x00560000；
4）i<<24，结果是0x78000000，最右字节挪到最左边。

这4个结果再进行或操作|，结果就是0x78563412，这样，通过左移、右移、与和或操作，就达到了字节翻转的目的。

我们再来看reverse的代码：

[插图]

这段代码虽然很短，但非常晦涩，到底是什么意思呢？代码第一行是一个注释，HD表示的是一本书，书名为Hacker's Delight，中文版为《算法心得：高效算法的奥秘》, HD是它的缩写，Figure 7-1是书中的图7-1, reverse的代码就是复制了这本书中图7-1的代码，书中也说明了代码的思路，我们简要说明。

高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着是4位一组交换、然后是8位、16位，16位之后就完成了。这个思路不仅适用于二进制，而且适用于十进制，为便于理解，我们看个十进制的例子。比如对数字12345678进行翻转。

第一轮，相邻单一数字进行互换，结果为：

[插图]

第二轮，以两个数字为一组交换相邻的，结果为：

[插图]

第三轮，以4个数字为一组交换相邻的，结果为：

[插图]

翻转完成。

对十进制而言，这个效率并不高，但对于二进制而言，却是高效的，因为二进制可以在一条指令中交换多个相邻位。下面代码就是对相邻单一位进行互换：

[插图]

5的二进制表示是0101,0x55555555的二进制表示是：

[插图]

x & 0x55555555就是取x的奇数位。

A的二进制表示是1010,0xAAAAAAAA的二进制表示是：

[插图]

x & 0xAAAAAAAA就是取x的偶数位。

[插图]

表示的就是x的奇数位向左移，偶数位向右移，然后通过|合并，达到相邻位互换的目的。这段代码可以有个小的优化，只使用一个常量0x55555555，后半部分先移位再进行与操作，变为：

[插图]

同理，如下代码就是以两位为一组，对相邻位进行互换：

[插图]

3的二进制表示是0011,0x33333333的二进制表示是：

[插图]

x & 0x33333333就是取x以两位为一组的低半部分。

C的二进制表示是1100,0xCCCCCCCC的二进制表示是：

[插图]

x & 0xCCCCCCCC就是取x以两位为一组的高半部分。

[插图]

表示的就是x以两位为一组，低半部分向高位移，高半部分向低位移，然后通过|合并，达到交换的目的。同样，可以去掉常量0xCCCCCCCC，代码可以优化为：

[插图]

同理，下面代码就是以4位为一组进行交换。

[插图]

到以8位为单位交换时，就是字节翻转了，可以写为如下更直接的形式，代码和reverse-Bytes基本完全一样。

[插图]

reverse代码为什么要写得这么晦涩呢？或者说不能用更容易理解的方式写吗？比如，实现翻转，一种常见的思路是：第一个和最后一个交换，第二个和倒数第二个交换，直到中间两个交换完成。如果数据不是二进制位，这个思路是好的，但对于二进制位，这个思路的效率比较低。

CPU指令并不能高效地操作单个位，它操作的最小数据单位一般是32位（32位机器），另外，CPU可以高效地实现移位和逻辑运算，但实现加、减、乘、除运算则比较慢。

reverse**是在充分利用CPU的这些特性，并行高效地进行相邻位的交换**，也可以通过其他更容易理解的方式实现相同功能，但很难比这个代码更高效。

### 2．循环移位
Integer有两个静态方法可以进行循环移位：

[插图]

rotateLeft方法是循环左移，rotateRight方法是循环右移，distance是移动的位数。所谓循环移位，是相对于普通的移位而言的，普通移位，比如左移2位，原来的最高两位就没有了，右边会补0，而如果是循环左移两位，则原来的最高两位会移到最右边，就像一个左右相接的环一样。看个例子：

[插图]

b是a循环左移8位的结果，c是a循环右移8位的结果，所以输出为：

[插图]

这两个函数的实现代码为：

[插图]

这两个函数中令人费解的是负数，如果distance是8，那i>>>-8是什么意思呢？其实，实际的移位个数不是后面的直接数字，而是直接数字的最低5位的值，或者说是直接数字&0x1f的结果。之所以这样，是因为5位最大表示31，移位超过31位对int整数是无效的。

理解了移动负数位的含义，就比较容易理解上面这段代码了，比如，-8的二进制表示是：

[插图]

其最低5位是11000，十进制表示就是24，所以i>>>-8就是i>>>24, i<<8 |i>>>24就是循环左移8位。上面代码中，i>>>-distance就是i>>>(32-distance),i<<-distance就是i<<(32-distance)。

Integer中还有一些其他的位操作，具体可参看API文档。关于其实现代码，都有注释指向Hacker's Delight这本书的相关章节，不再赘述。

### 3. valueOf的实现
在前面，我们提到，创建包装类对象时，可以使用静态的valueOf方法，也可以直接使用new，但建议使用valueOf方法，为什么呢？我们来看Integer的valueOf的代码（基于Java 
7）：

[插图]

它使用了IntegerCache，这是一个私有静态内部类，如代码清单7-1所示。

<center>代码清单7-1 IntegerCache</center>

[插图]

IntegerCache表示Integer缓存，其中的cache变量是一个静态Integer数组，在静态初始化代码块中被初始化，默认情况下，保存了-128～127共256个整数对应的Integer对象。

在valueOf代码中，如果数值位于被缓存的范围，即默认-128～127，则直接从Integer-Cache中获取已预先创建的Integer对象�
