<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="26.2 函数式数据处理：基本用法上一节介绍了Lambda表达式和函数式接口，本节探讨它们的应用：函数式数据处理，针对常见的集合数据处理，Java 8引入了一套新的类库，位于包java.util.stream下，称为Stream API。这套API操作数据的思路不同于我们之前介绍的容器类API，它们是函数式的，非常简洁、灵活、易读。具体有什么不同呢？本节先介绍一些基本的API，下节讨论一些高级功能">
<meta property="og:type" content="article">
<meta property="og:title" content="26.2 函数式数据处理：基本用法">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/b34b5819/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="26.2 函数式数据处理：基本用法上一节介绍了Lambda表达式和函数式接口，本节探讨它们的应用：函数式数据处理，针对常见的集合数据处理，Java 8引入了一套新的类库，位于包java.util.stream下，称为Stream API。这套API操作数据的思路不同于我们之前介绍的容器类API，它们是函数式的，非常简洁、灵活、易读。具体有什么不同呢？本节先介绍一些基本的API，下节讨论一些高级功能">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-08T04:34:35.000Z">
<meta property="article:modified_time" content="2021-12-08T04:34:35.000Z">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/b34b5819/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lanlan2017.github.io/JavaReadingNotes/b34b5819/","path":"/b34b5819/","title":"26.2 函数式数据处理：基本用法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>26.2 函数式数据处理：基本用法 | 蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">蓝蓝站点</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#26-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">26.2 函数式数据处理：基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-1-%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B"><span class="nav-text">26.2.1 基本示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%8E%E5%9F%BA%E6%9C%AC%E8%BF%87%E6%BB%A4"><span class="nav-text">1．基本过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8E%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2"><span class="nav-text">2．基本转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%8E%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BF%87%E6%BB%A4%E5%92%8C%E8%BD%AC%E6%8D%A2%E7%BB%84%E5%90%88"><span class="nav-text">3．基本的过滤和转换组合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-2-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-text">26.2.2 中间操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-distinct"><span class="nav-text">1. distinct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-sorted"><span class="nav-text">2. sorted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-skip-limit"><span class="nav-text">3. skip&#x2F;limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-peek"><span class="nav-text">4. peek</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-mapToLong-mapToInt-mapToDouble"><span class="nav-text">5. mapToLong&#x2F;mapToInt&#x2F;mapToDouble</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-flatMap"><span class="nav-text">6. flatMap</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-3-%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="nav-text">26.2.3 终端操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-max-min"><span class="nav-text">1. max&#x2F;min</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-count"><span class="nav-text">2. count</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-allMatch-anyMatch-noneMatch"><span class="nav-text">3. allMatch&#x2F;anyMatch&#x2F;noneMatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-findFirst-findAny"><span class="nav-text">4. findFirst&#x2F;findAny</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-forEach"><span class="nav-text">5. forEach</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-toArray"><span class="nav-text">6. toArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-reduce"><span class="nav-text">7. reduce</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-4-%E6%9E%84%E5%BB%BA%E6%B5%81"><span class="nav-text">26.2.4 构建流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-2-5-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%80%9D%E7%BB%B4"><span class="nav-text">26.2.5 函数式数据处理思维</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/b34b5819/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          26.2 函数式数据处理：基本用法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-08 12:34:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:34:35+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC26%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第26章 函数式编程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/b34b5819/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/b34b5819/" data-xid="/JavaReadingNotes/b34b5819/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="26-2-函数式数据处理：基本用法"><a href="#26-2-函数式数据处理：基本用法" class="headerlink" title="26.2 函数式数据处理：基本用法"></a>26.2 函数式数据处理：基本用法</h1><p>上一节介绍了Lambda表达式和函数式接口，本节探讨它们的应用：函数式数据处理，针对常见的集合数据处理，Java 8引入了一套新的类库，位于包java.util.stream下，称为Stream API。这套API操作数据的思路不同于我们之前介绍的容器类API，它们是函数式的，非常简洁、灵活、易读。具体有什么不同呢？本节先介绍一些基本的API，下节讨论一些高级功能。</p>
<p>接口Stream类似于一个迭代器，但提供了更为丰富的操作，Stream API的主要操作就定义在该接口中。Java 8给Collection接口增加了两个默认方法，它们可以返回一个Stream，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stream()返回的是一个<strong>顺序流</strong>，parallelStream()返回的是一个<strong>并行流</strong>。顺序流就是由一个线程执行操作。而并行流背后可能有多个线程并行执行，与之前介绍的并发技术不同，使用并行流不需要显式管理线程，使用方法与顺序流是一样的。</p>
<p>下面我们主要针对顺序流学习Stream接口，包括其用法和基本原理，随后我们再介绍并行流，先来看一些简单的示例。</p>
<h2 id="26-2-1-基本示例"><a href="#26-2-1-基本示例" class="headerlink" title="26.2.1 基本示例"></a>26.2.1 基本示例</h2><p>上一节演示时使用了学生类Student和学生列表<code>List&lt;Student&gt; lists</code>，本节继续使用它们，看一些基本的过滤、转换以及过滤和转换组合的例子。</p>
<h3 id="1．基本过滤"><a href="#1．基本过滤" class="headerlink" title="1．基本过滤"></a>1．基本过滤</h3><p>返回学生列表中90分以上的，传统上的代码一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; above90List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.getScore() &gt; <span class="number">90</span>) &#123;</span><br><span class="line">        above90List.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Stream API，代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; above90List = students.stream()</span><br><span class="line">        .filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>先通过stream()得到一个Stream对象，然后调用Stream上的方法，filter()过滤得到90分以上的，它的返回值依然是一个Stream，为了转换为List，调用了collect方法并传递了一个Collectors.toList()，表示将结果收集到一个List中。</p>
<p>代码更为简洁易读了，这种数据处理方式称为<strong>函数式数据处理</strong>。与传统代码相比，其特点是：<br>1）没有显式的循环迭代，循环过程被Stream的方法隐藏了。<br>2）提供了声明式的处理函数，比如filter，它封装了数据过滤的功能，而传统代码是命令式的，需要一步步的操作指令。<br>3）流畅式接口，方法调用链接在一起，清晰易读。</p>
<h3 id="2．基本转换"><a href="#2．基本转换" class="headerlink" title="2．基本转换"></a>2．基本转换</h3><p>根据学生列表返回名称列表，传统上的代码一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;&gt;(students.size());</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    nameList.add(t.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Stream API，代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = students.stream()</span><br><span class="line">        .map(Student::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里使用了Stream的map函数，它的参数是一个Function函数式接口，这里传递了方法引用。</p>
<h3 id="3．基本的过滤和转换组合"><a href="#3．基本的过滤和转换组合" class="headerlink" title="3．基本的过滤和转换组合"></a>3．基本的过滤和转换组合</h3><p>返回90分以上的学生名称列表，传统上的代码一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.getScore() &gt; <span class="number">90</span>) &#123;</span><br><span class="line">        nameList.add(t.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数式数据处理的思路，可以将这个问题分解为由两个基本函数实现：<br>1）过滤：得到90分以上的学生列表。<br>2）转换：将学生列表转换为名称列表。</p>
<p>使用Stream API，可以将基本函数filter()和map()结合起来，代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; above90Names = students.stream()</span><br><span class="line">        .filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这种组合利用基本函数、声明式实现集合数据处理功能的编程风格，就是函数式数据处理。</p>
<p>代码更为直观易读了，但你可能会担心它的性能有问题。filter()和map()都需要对流中的每个元素操作一次，一起使用会不会就需要遍历两次呢？答案是否定的，只需要一次。<strong>实际上，调用filter()和map()都不会执行任何实际的操作，它们只是在构建操作的流水线，调用collect才会触发实际的遍历执行，在一次遍历中完成过滤、转换以及收集结果的任务</strong>。</p>
<p>像filter和map这种不实际触发执行、用于构建流水线、返回Stream的操作称为<strong>中间操作</strong>（intermediate operation），而像collect这种触发实际执行、返回具体结果的操作称为<strong>终端操作</strong>（terminal operation）。Stream API中还有更多的中间和终端操作，下面我们具体介绍。</p>
<h2 id="26-2-2-中间操作"><a href="#26-2-2-中间操作" class="headerlink" title="26.2.2 中间操作"></a>26.2.2 中间操作</h2><p>除了filter和map, Stream API的中间操作还有distinct、sorted、skip、limit、peek、mapToLong、mapToInt、mapToDouble、flatMap等，我们逐个介绍。</p>
<h3 id="1-distinct"><a href="#1-distinct" class="headerlink" title="1. distinct"></a>1. distinct</h3><p>distinct返回一个新的Stream，过滤重复的元素，只留下唯一的元素，是否重复是根据equals方法来比较的，distinct可以与其他函数（如filter、map）结合使用。比如，返回字符串列表中长度小于3的字符串、转换为小写、只保留唯一的，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Abc&quot;</span>&#125;);</span><br><span class="line">List&lt;String&gt; retList = list.stream()</span><br><span class="line">        .filter(s-&gt;s.length()&lt;=<span class="number">3</span>).map(String::toLowerCase).distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>虽然都是中间操作，但distinct与filter和map是不同的。filter和map都是无状态的，对于流中的每一个元素，处理都是独立的，处理后即交给流水线中的下一个操作；distinct不同，它是<strong>有状态的</strong>，在处理过程中，它需要在内部记录之前出现过的元素，如果已经出现过，即重复元素，它就会过滤掉，不传递给流水线中的下一个操作。对于顺序流，内部实现时，distinct操作会使用HashSet记录出现过的元素，如果流是有顺序的，需要保留顺序，会使用LinkedHashSet。</p>
<h3 id="2-sorted"><a href="#2-sorted" class="headerlink" title="2. sorted"></a>2. sorted</h3><p>有两个sorted方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>

<p>它们都对流中的元素排序，都返回一个排序后的Stream。第一个方法假定元素实现了Comparable接口，第二个方法接受一个自定义的Comparator。比如，过滤得到90分以上的学生，然后按分数从高到低排序，分数一样的按名称排序，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore)</span><br><span class="line">                .reversed().thenComparing(Student::getName))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，使用了Comparator的comparing、reversed和thenComparing构建了Comparator。</p>
<p>与distinct一样，sorted也是一个有状态的中间操作，在处理过程中，需要在内部记录出现过的元素。其不同是，每碰到流中的一个元素，distinct都能立即做出处理，要么过滤，要么马上传递给下一个操作；sorted需要先排序，为了排序，它需要先在内部数组中保存碰到的每一个元素，到流结尾时再对数组排序，然后再将排序后的元素逐个传递给流水线中的下一个操作。</p>
<h3 id="3-skip-limit"><a href="#3-skip-limit" class="headerlink" title="3. skip/limit"></a>3. skip/limit</h3><p>它们的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span></span><br></pre></td></tr></table></figure>

<p>skip跳过流中的n个元素，如果流中元素不足n个，返回一个空流，limit限制流的长度为maxSize。比如，将学生列表按照分数排序，返回第3名到第5名，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = students.stream()</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore).reversed())</span><br><span class="line">        .skip(<span class="number">2</span>).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>skip和limit都是有状态的中间操作。对前n个元素，skip的操作就是过滤，对后面的元素，skip就是传递给流水线中的下一个操作。limit的一个特点是：它不需要处理流中的所有元素，只要处理的元素个数达到maxSize，后面的元素就不需要处理了，这种可以提前结束的操作称为<strong>短路操作</strong>。</p>
<p>skip和limit只能根据元素数目进行操作，Java 9增加了两个新方法，相当于更为通用的skip和limit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的skip，在谓词返回为true的情况下一直进行skip操作，直到某次返回false</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">dropWhile</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"><span class="comment">//通用的limit，在谓词返回为true的情况下一直接受，直到某次返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">takeWhile</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-peek"><a href="#4-peek" class="headerlink" title="4. peek"></a>4. peek</h3><p>peek的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>它返回的流与之前的流是一样的，没有变化，但它提供了一个Consumer，会将流中的每一个元素传给该Consumer。这个方法的主要目的是支持调试，可以使用该方法观察在流水线中流转的元素，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; above90Names = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">        .peek(System.out::println).map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="5-mapToLong-mapToInt-mapToDouble"><a href="#5-mapToLong-mapToInt-mapToDouble" class="headerlink" title="5. mapToLong/mapToInt/mapToDouble"></a>5. mapToLong/mapToInt/mapToDouble</h3><p>map函数接受的参数是一个Function&lt;T, R&gt;，为避免装箱/拆箱，提高性能，Stream还有如下返回基本类型特定流的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<p>DoubleStream/IntStream/LongStream是基本类型特定的流，有一些专门的更为高效的方法。比如，求学生列表的分数总和，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sum = students.stream().mapToDouble(Student::getScore).sum();</span><br></pre></td></tr></table></figure>

<h3 id="6-flatMap"><a href="#6-flatMap" class="headerlink" title="6. flatMap"></a>6. flatMap</h3><p>flatMap的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<p>它接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换为一个流Stream，然后把新生成流的每一个元素传递给下一个操作。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lines = Arrays.asList(<span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">&quot;hello abc&quot;</span>, <span class="string">&quot;老马  编程&quot;</span>&#125;);</span><br><span class="line">List&lt;String&gt; words = lines.stream()</span><br><span class="line">        .flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot;\\s+&quot;</span>)))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>

<p>这里的mapper将一行字符串按空白符分隔为了一个单词流，Arrays.stream可以将一个数组转换为一个流，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hello, abc, 老马， 编程]</span><br></pre></td></tr></table></figure>

<p>可以看出，实际上，flatMap完成了一个1到n的映射。</p>
<h2 id="26-2-3-终端操作"><a href="#26-2-3-终端操作" class="headerlink" title="26.2.3 终端操作"></a>26.2.3 终端操作</h2><p>中间操作不触发实际的执行，返回值是Stream，而终端操作触发执行，返回一个具体的值，除了collect, Stream API的终端操作还有max、min、count、allMatch、anyMatch、noneMatch、findFirst、findAny、forEach、toArray、reduce等，我们逐个介绍。</p>
<h3 id="1-max-min"><a href="#1-max-min" class="headerlink" title="1. max/min"></a>1. max/min</h3><p>max/min的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>

<p>它们返回流中的最大值/最小值，它们的返回值类型是<code>Optional&lt;T&gt;</code>，而不是T。</p>
<p>java.util.Optional是Java 8引入的一个新类，它是一个泛型容器类，内部只有一个类型为T的单一变量value，可能为null，也可能不为null。Optional有什么用呢？<strong>它用于准确地传递程序的语义，它清楚地表明，其代表的值可能为null，程序员应该进行适当的处理</strong>。</p>
<p>Optional定义了一些方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value不为null时返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际的值，如果为null，抛出异常NoSuchElementException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果value不为null，返回value，否则返回other</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span></span></span><br><span class="line"><span class="function"><span class="comment">//构建一个空的Optional, value为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//构建一个非空的Optional, 参数value不能为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//构建一个Optional，参数value可以为null，也可以不为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span></span></span><br></pre></td></tr></table></figure>

<p>在max/min的例子中，通过声明返回值为Optional，我们可以知道具体的返回值不一定存在，这发生在流中不含任何元素的情况下。</p>
<p>看个简单的例子，返回分数最高的学生，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = students.stream()</span><br><span class="line">        .max(Comparator.comparing(Student::getScore).reversed()).get();</span><br></pre></td></tr></table></figure>
<p>这里，假定students不为空。</p>
<h3 id="2-count"><a href="#2-count" class="headerlink" title="2. count"></a>2. count</h3><p>count很简单，就是返回流中元素的个数。比如，统计大于90分的学生个数，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> above90Count = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).count();</span><br></pre></td></tr></table></figure>

<h3 id="3-allMatch-anyMatch-noneMatch"><a href="#3-allMatch-anyMatch-noneMatch" class="headerlink" title="3. allMatch/anyMatch/noneMatch"></a>3. allMatch/anyMatch/noneMatch</h3><p>这几个函数都接受一个谓词Predicate，返回一个boolean值，用于判定流中的元素是否满足一定的条件。它们的区别是：</p>
<ul>
<li>allMatch：只有在流中所有元素都满足条件的情况下才返回true。</li>
<li>anyMatch：只要流中有一个元素满足条件就返回true。</li>
<li>noneMatch：只有流中所有元素都不满足条件才返回true。</li>
</ul>
<p>如果流为空，那么这几个函数的返回值都是true。</p>
<p>比如，判断是不是所有学生都及格了（不小于60分），代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> allPass = students.stream().allMatch(t-&gt;t.getScore()&gt;=<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p>这几个操作都是短路操作，不一定需要处理所有元素就能得出结果，比如，对于all-Match，只要有一个元素不满足条件，就能返回false。</p>
<h3 id="4-findFirst-findAny"><a href="#4-findFirst-findAny" class="headerlink" title="4. findFirst/findAny"></a>4. findFirst/findAny</h3><p>它们的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>它们的返回类型都是Optional，如果流为空，返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素，它们都是短路操作。随便找一个不及格的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; student = students.stream().filter(t-&gt;t.getScore()&lt;<span class="number">60</span>)</span><br><span class="line">        .findAny();</span><br><span class="line"><span class="keyword">if</span>(student.isPresent())&#123;</span><br><span class="line">    <span class="comment">//处理不及格的学生</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-forEach"><a href="#5-forEach" class="headerlink" title="5. forEach"></a>5. forEach</h3><p>有两个forEach方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>它们都接受一个Consumer，对流中的每一个元素，传递元素给Consumer。区别在于：在并行流中，forEach不保证处理的顺序，而forEachOrdered会保证按照流中元素的出现顺序进行处理。</p>
<p>比如，逐行打印大于90分的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="6-toArray"><a href="#6-toArray" class="headerlink" title="6. toArray"></a>6. toArray</h3><p>toArray将流转换为数组，有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray()</span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</span><br></pre></td></tr></table></figure>

<p>不带参数的toArray返回的数组类型为Object[]，这通常不是期望的结果，如果希望得到正确类型的数组，需要传递一个类型为IntFunction的generator。IntFunction的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generator接受的参数是流的元素个数，它应该返回对应大小的正确类型的数组。</p>
<p>比如，获取90分以上的学生数组，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student[] above90Arr = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">                          .toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p><code>Student[]::new</code>就是一个类型为<code>IntFunction&lt;Student[]&gt;</code>的generator。</p>
<h3 id="7-reduce"><a href="#7-reduce" class="headerlink" title="7. reduce"></a>7. reduce</h3><p>reduce代表<strong>归约</strong>或者叫<strong>折叠</strong>，它是max/min/count的更为通用的函数，将流中的元素归约为一个值。有三个reduce函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">    BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个reduce函数基本等同于调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">T result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">    <span class="keyword">if</span>(! foundAny) &#123;</span><br><span class="line">        foundAny = <span class="keyword">true</span>;</span><br><span class="line">        result = element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = accumulator.apply(result, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure>

<p>比如，使用reduce函数求分数最高的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student topStudent = students.stream().reduce((accu, t) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(accu.getScore() &gt;= t.getScore()) &#123;</span><br><span class="line">        <span class="keyword">return</span> accu;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure>

<p>第二个reduce函数多了一个identity参数，表示初始值，它基本等同于调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>第一个和第二个reduce函数的返回类型只能是流中元素的类型，而第三个reduce函数更为通用，它的归约类型可以自定义，另外，它多了一个combiner参数。combiner用在并行流中，用于合并子线程的结果。对于顺序流，它基本等同于调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">U result = identity;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>注意与第二个reduce函数相区分，它的结果类型不是T，而是U。比如，使用reduce函数计算学生分数的和，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sumScore = students.stream().reduce(<span class="number">0d</span>,</span><br><span class="line">    (sum, t) -&gt; sum += t.getScore(),</span><br><span class="line">    (sum1, sum2) -&gt; sum1 += sum2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从以上可以看出，reduce函数虽然更为通用，但比较费解，难以使用，一般情况下应该优先使用其他函数。collect函数比reduce函数更为通用、强大和易用，关于它，我们稍后再详细介绍。</p>
<h2 id="26-2-4-构建流"><a href="#26-2-4-构建流" class="headerlink" title="26.2.4 构建流"></a>26.2.4 构建流</h2><p>前面我们主要使用的是Collection的stream方法，换做parallelStream方法，就会使用并行流，接口方法都是通用的。但并行流内部会使用多线程，线程个数一般与系统的CPU核数一样，以充分利用CPU的计算能力。</p>
<p>进一步来说，并行流内部会使用Java 7引入的fork/join框架，即处理由fork和join两个阶段组成，fork就是将要处理的数据拆分为小块，多线程按小块进行并行计算，join就是将小块的计算结果进行合并，具体我们就不探讨了。使用并行流，不需要任何线程管理的代码，就能实现并行。</p>
<p>除了通过Collection接口的stream/parallelStream获取流，还有一些其他方式可以获取流。Arrays有一些stream方法，可以将数组或子数组转换为流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array, <span class="keyword">int</span> startInclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> endExclusive)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure>

<p>输出当前目录下所有普通文件的名字，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File[] files = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>).listFiles();</span><br><span class="line">Arrays.stream(files).filter(File::isFile).map(File::getName)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>Stream也有一些静态方法，可以构建流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个空流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回只包含一个元素t的流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含多个元素values的流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br><span class="line"><span class="function"><span class="comment">//通过Supplier生成流，流的元素个数是无限的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同样生成无限流，第一个元素为seed，第二个为f(seed)，第三个为f(f(seed))，以此类推</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br></pre></td></tr></table></figure>

<p>输出10个随机数，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(()-&gt;Math.random()).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出100个递增的奇数，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">1</span>, t-&gt;t+<span class="number">2</span>).limit(<span class="number">100</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="26-2-5-函数式数据处理思维"><a href="#26-2-5-函数式数据处理思维" class="headerlink" title="26.2.5 函数式数据处理思维"></a>26.2.5 函数式数据处理思维</h2><p>可以看出，使用Stream API处理数据集合，与直接使用容器类API处理数据的思路是完全不一样的。<strong>流定义了很多数据处理的基本函数，对于一个具体的数据处理问题，解决的主要思路就是组合利用这些基本函数，以声明式的方式简洁地实现期望的功能，这种思路就是函数式数据处理思维，相比直接利用容器类API的命令式思维，思考的层次更高</strong>。</p>
<p>Stream API的这种思路也不是新发明，它与数据库查询语言SQL是很像的，都是声明式地操作集合数据，很多函数都能在SQL中找到对应，比如filter对应SQL的where, sorted对应order by等。SQL一般都支持分组（group by）功能，StreamAPI也支持，但关于分组，我们下节再介绍。</p>
<p><strong>Stream API也与各种基于Unix系统的管道命令类似</strong>。熟悉Unix系统的都知道，Unix有很多命令，大部分命令只是专注于完成一件事情，但可以通过管道的方式将多个命令链接起来，完成一些复杂的功能，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nginx_access.log | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -rnk 1 | head -n 20</span><br></pre></td></tr></table></figure>

<p>以上命令可以分析nginx访问日志，统计出访问次数最多的前20个IP地址及其访问次数。具体来说，cat命令输出nginx访问日志到流，一行为一个元素，awk输出行的第一列，这里为IP地址，sort按IP进行排序，”uniq -c”按IP统计计数，”sort -rnk 1”按计数从高到低排序，”head -n 20”输出前20行。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/JavaReadingNotes/images/wechatpay.png" alt="蓝蓝 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>蓝蓝
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lanlan2017.github.io/JavaReadingNotes/b34b5819/" title="26.2 函数式数据处理：基本用法">https://lanlan2017.github.io/JavaReadingNotes/b34b5819/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/JavaReadingNotes/5dff3f09/" rel="prev" title="26.3 函数式数据处理：强大方便的收集器">
                  <i class="fa fa-chevron-left"></i> 26.3 函数式数据处理：强大方便的收集器
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/JavaReadingNotes/7c273c02/" rel="next" title="26.0 第26章 函数式编程 26.1 Lambda表达式">
                  26.0 第26章 函数式编程 26.1 Lambda表达式 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/b34b5819/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/b34b5819/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
