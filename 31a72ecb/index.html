<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="第7章 常用基础类本章介绍Java编程中一些常用的基础类，探讨它们的用法、应用和实现原理，这些类有：  各种包装类； 文本处理的类String和StringBuilder； 数组操作的类Arrays； 日期和时间处理； 随机。  7.1 包装类Java有8种基本类型，每种基本类型都有一个对应的包装类。包装类是什么呢？它是一个类，内部有一个实例变量，保存对应的基本类型的值，这个类一般还有一些静态方法">
<meta property="og:type" content="article">
<meta property="og:title" content="7.0 第7章 常用基础类 7.1 包装类">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="第7章 常用基础类本章介绍Java编程中一些常用的基础类，探讨它们的用法、应用和实现原理，这些类有：  各种包装类； 文本处理的类String和StringBuilder； 数组操作的类Arrays； 日期和时间处理； 随机。  7.1 包装类Java有8种基本类型，每种基本类型都有一个对应的包装类。包装类是什么呢？它是一个类，内部有一个实例变量，保存对应的基本类型的值，这个类一般还有一些静态方法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213344.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213434.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209094654.jpeg">
<meta property="article:published_time" content="2021-12-04T12:14:01.000Z">
<meta property="article:modified_time" content="2021-12-08T14:05:54.000Z">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213344.jpeg">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/","path":"/31a72ecb/","title":"7.0 第7章 常用基础类 7.1 包装类"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>7.0 第7章 常用基础类 7.1 包装类 | 蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">蓝蓝站点</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB"><span class="nav-text">第7章 常用基础类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-1-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-text">7.1 包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">7.1.1 基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-2-%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-text">7.1.2 共同点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%8E%E9%87%8D%E5%86%99Object%E6%96%B9%E6%B3%95"><span class="nav-text">1．重写Object方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%881%EF%BC%89equals"><span class="nav-text">（1）equals</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%882%EF%BC%89hashCode"><span class="nav-text">（2）hashCode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Comparable"><span class="nav-text">2. Comparable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8CString"><span class="nav-text">3．包装类和String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%8E%E5%B8%B8%E7%94%A8%E5%B8%B8%E9%87%8F"><span class="nav-text">4．常用常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Number"><span class="nav-text">5. Number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-text">6．不可变性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-3-%E5%89%96%E6%9E%90Integer%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-text">7.1.3 剖析Integer与二进制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%EF%BC%8E%E4%BD%8D%E7%BF%BB%E8%BD%AC"><span class="nav-text">1．位翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8E%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D"><span class="nav-text">2．循环移位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-valueOf%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3. valueOf的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-4-%E5%89%96%E6%9E%90Character"><span class="nav-text">7.1.4 剖析Character</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Unicode%E5%9F%BA%E7%A1%80"><span class="nav-text">1. Unicode基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8E%E6%A3%80%E6%9F%A5code-point%E5%92%8Cchar"><span class="nav-text">2．检查code point和char</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-code-point%E4%B8%8Echar%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">3. code point与char的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%8E%E6%8C%89code-point%E5%A4%84%E7%90%86char%E6%95%B0%E7%BB%84%E6%88%96%E5%BA%8F%E5%88%97"><span class="nav-text">4．按code point处理char数组或序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%8E%E5%AD%97%E7%AC%A6%E5%B1%9E%E6%80%A7"><span class="nav-text">5．字符属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%8E%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%8D%A2"><span class="nav-text">6．字符转换</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="7.0 第7章 常用基础类 7.1 包装类 | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          7.0 第7章 常用基础类 7.1 包装类
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-08 22:05:54" itemprop="dateModified" datetime="2021-12-08T22:05:54+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31a72ecb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31a72ecb/" data-xid="/JavaReadingNotes/31a72ecb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第7章-常用基础类"><a href="#第7章-常用基础类" class="headerlink" title="第7章 常用基础类"></a>第7章 常用基础类</h1><p>本章介绍Java编程中一些常用的基础类，探讨它们的用法、应用和实现原理，这些类有：</p>
<ul>
<li>各种包装类；</li>
<li>文本处理的类String和StringBuilder；</li>
<li>数组操作的类Arrays；</li>
<li>日期和时间处理；</li>
<li>随机。</li>
</ul>
<h1 id="7-1-包装类"><a href="#7-1-包装类" class="headerlink" title="7.1 包装类"></a>7.1 包装类</h1><p>Java有8种基本类型，每种基本类型都有一个对应的包装类。包装类是什么呢？它是一个类，内部有一个实例变量，保存对应的基本类型的值，这个类一般还有一些静态方法、静态变量和实例方法，以方便对数据进行操作。Java中，基本类型和对应的包装类如表7-1所示。</p>
<center>表7-1 基本类型和对应的包装类</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213344.jpeg" alt="epub_923038_50"><br>包装类也都很好记，除了Integer和Character外，其他类名称与基本类型基本一样，只是首字母大写。包装类有什么用呢？Java中很多代码（比如后续章节介绍的容器类）只能操作对象，为了能操作基本类型，需要使用其对应的包装类。另外，包装类提供了很多有用的方法，可以方便对数据的操作。下面先介绍各个包装类的基本用法及其共同点，然后重点介绍Integer和Character。</p>
<h2 id="7-1-1-基本用法"><a href="#7-1-1-基本用法" class="headerlink" title="7.1.1 基本用法"></a>7.1.1 基本用法</h2><p>各个包装类都可以与其对应的基本类型相互转换，方法也是类似的，部分类型如表7-2所示。</p>
<center>表7-2 包装类与基本类型的转换</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213434.jpeg" alt="epub_923038_51"><br>包装类与基本类型的转换代码结构是类似的，每种包装类都有一个静态方法valueOf()，接受基本类型，返回引用类型，也都有一个实例方法xxxValue()返回对应的基本类型。</p>
<p>将基本类型转换为包装类的过程，一般称为“装箱”，而将包装类型转换为基本类型的过程，则称为“拆箱”。装箱&#x2F;拆箱写起来比较烦琐，Java 5以后引入了自动装箱和拆箱技术，可以直接将基本类型赋值给引用类型，反之亦可，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure>

<p>自动装箱&#x2F;拆箱是Java编译器提供的能力，背后，它会替换为调用对应的valueOf&#x2F;xxx-Value方法，比如，上面的代码会被Java编译器替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure>

<p>每种包装类也都有构造方法，可以通过new创建，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">12.345</span>);</span><br><span class="line"><span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;马&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>那到底应该用静态的valueOf方法，还是使用new呢？一般建议使用valueOf方法。new每次都会创建一个新对象，而除了Float和Double外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，提升性能。实际上，从Java 9开始，这些构造方法已经被标记为过时了，推荐使用静态的valueOf方法。</p>
<h2 id="7-1-2-共同点"><a href="#7-1-2-共同点" class="headerlink" title="7.1.2 共同点"></a>7.1.2 共同点</h2><p>各个包装类有很多共同点，比如，都重写了Object中的一些方法，都实现了Comparable接口，都有一些与String有关的方法，大部分都定义了一些静态常量，都是不可变的。下面具体介绍。</p>
<h3 id="1．重写Object方法"><a href="#1．重写Object方法" class="headerlink" title="1．重写Object方法"></a>1．重写Object方法</h3><p>所有包装类都重写了Object类的如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>我们分别介绍。</p>
<h4 id="（1）equals"><a href="#（1）equals" class="headerlink" title="（1）equals"></a>（1）equals</h4><p>equals用于判断当前对象和参数传入的对象是否相同，Object类的默认实现是比较地址，对于两个变量，只有这两个变量指向同一个对象时，equals才返回true，它和比较运算符（&#x3D;&#x3D;）的结果是一样的。</p>
<p>equals应该反映的是对象间的逻辑相等关系，所以这个默认实现一般是不合适的，子类需要重写该实现。所有包装类都重写了该实现，实际比较用的是其包装的基本类型值，比如，对于Long类，其equals方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Float，其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">        &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Float有一个静态方法floatToIntBits()，将float的二进制表示看作int。需要注意的是，只有两个float的二进制表示完全一样的时候，equals才会返回true。在2.2节的时候，我们提到小数计算是不精确的，数学概念上运算结果一样，但计算机运算结果可能不同，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0.01f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">0.1f</span>＊<span class="number">0.1f</span>;</span><br><span class="line">System.out.println(f1.equals(f2));</span><br><span class="line">System.out.println(Float.floatToIntBits(f1));</span><br><span class="line">System.out.println(Float.floatToIntBits(f2));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="number">1008981770</span></span><br><span class="line"><span class="number">1008981771</span></span><br></pre></td></tr></table></figure>

<p>也就是，两个浮点数不一样，将二进制看作整数也不一样，相差为1。</p>
<p>Double的equals方法与Float类似，它有一个静态方法doubleToLongBits，将double的二进制表示看作long，然后再按long比较。</p>
<h4 id="（2）hashCode"><a href="#（2）hashCode" class="headerlink" title="（2）hashCode"></a>（2）hashCode</h4><p>hashCode返回一个对象的哈希值。哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。一个对象的哈希值不能改变，相同对象的哈希值必须一样。不同对象的哈希值一般应不同，但这不是必需的，可以有对象不同但哈希值相同的情况。</p>
<p>比如，对于一个班的学生对象，hashCode可以是学生的出生日期，出生日期是不变的，不同学生生日一般不同，分布比较均匀，个别生日相同的也没关系。</p>
<p>hashCode和equals方法联系密切，<strong>对两个对象，如果equals方法返回true，则hashCode也必须一样</strong>。反之不要求，equal方法返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。hashCode的默认实现一般是将对象的内存地址转换为整数，<strong>子类如果重写了equals方法，也必须重写hashCode</strong>。之所以有这个规定，是因为Java API中很多类依赖于这个行为，尤其是容器中的一些类。</p>
<p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte、Short、Integer、Character, hashCode就是其内部值，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Boolean, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据基类类型值返回了两个不同的数，为什么选这两个值呢？它们是质数（即只能被1和自己整除的数），质数用于哈希时比较好，不容易冲突。</p>
<p>对于Long, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="type">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是高32位与低32位进行位异或操作。</p>
<p>对于Double, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与equals方法类似，将double的二进制表示看作long，然后再按long计算hashCode。</p>
<p>每个包装类也都重写了toString方法，返回对象的字符串表示，这个一般比较自然，不再赘述。</p>
<h3 id="2-Comparable"><a href="#2-Comparable" class="headerlink" title="2. Comparable"></a>2. Comparable</h3><p>每个包装类都实现了Java API中的Comparable接口。Comparable接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">bits</span> <span class="operator">=</span> doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span>(<span class="type">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;T&gt;</code>是泛型语法，我们在第8章介绍，T表示比较的类型，由实现接口的类传入。接口只有一个方法compareTo，当前对象与参数对象进行比较，在小于、等于、大于参数时，应分别返回-1、0、1。</p>
<p>各个包装类的实现基本都是根据基本类型值进行比较，不再赘述。对于Boolean,false小于true。对于Float和Double，存在和equals方法一样的问题，0.01和0.1*0.1相比的结果并不为0。</p>
<h3 id="3．包装类和String"><a href="#3．包装类和String" class="headerlink" title="3．包装类和String"></a>3．包装类和String</h3><p>除了toString方法外，包装类还有一些其他与String相关的方法。除了Character外，每个包装类都有一个静态的valueOf(String)方法，根据字符串表示返回包装类对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也都有一个静态的parseXXX(String)方法，根据字符串表示返回基本类型值，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;123.45f&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>都有一个静态的toString方法，根据基本类型值返回字符串表示，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;123.45&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boolean.toString(<span class="literal">true</span>));</span><br><span class="line">System.out.println(Double.toString(<span class="number">123.45</span>));</span><br></pre></td></tr></table></figure>

<p>对于整数类型，字符串表示除了默认的十进制外，还可以表示为其他进制，如二进制、八进制和十六进制，包装类有静态方法进行相互转换，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">123.45</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(<span class="number">12345</span>));       <span class="comment">//输出二进制</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">12345</span>));          <span class="comment">//输出十六进制</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;3039&quot;</span>, <span class="number">16</span>));        <span class="comment">//按十六进制解析</span></span><br></pre></td></tr></table></figure>

<h3 id="4．常用常量"><a href="#4．常用常量" class="headerlink" title="4．常用常量"></a>4．常用常量</h3><p>包装类中除了定义静态方法和实例方法外，还定义了一些静态变量。对于Boolean类型，有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11000000111001</span><br><span class="line">3039</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>所有数值类型都定义了MAX_VALUE和MIN_VALUE，表示能表示的最大&#x2F;最小值，比如，对Integer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>Float和Double还定义了一些特殊数值，比如正无穷、负无穷、非数值，如Double类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">POSITIVE_INFINITY</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0.0</span>; <span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NEGATIVE_INFINITY</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0.0</span>; <span class="comment">//负无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NaN</span> <span class="operator">=</span> <span class="number">0.0d</span> / <span class="number">0.0</span>; <span class="comment">//非数值</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Number"><a href="#5-Number" class="headerlink" title="5. Number"></a>5. Number</h3><p>6种数值类型包装类有一个共同的父类Number。Number是一个抽象类，它定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">byteValue</span><span class="params">()</span></span><br><span class="line"><span class="type">short</span> <span class="title function_">shortValue</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">floatValue</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>通过这些方法，包装类实例可以返回任意的基本数值类型。</p>
<h3 id="6．不可变性"><a href="#6．不可变性" class="headerlink" title="6．不可变性"></a>6．不可变性</h3><p>包装类都是不可变类。所谓不可变是指实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：</p>
<ul>
<li>所有包装类都声明为了final，不能被继承。</li>
<li>内部基本类型值是私有的，且声明为了final。</li>
<li>没有定义setter方法。</li>
</ul>
<p>为什么要定义为不可变类呢？<strong>不可变使得程序更为简单安全</strong>，因为不用操心数据被意外改写的可能，可以安全地共享数据，尤其是在多线程的环境下。关于线程，我们在第15章介绍。</p>
<h2 id="7-1-3-剖析Integer与二进制算法"><a href="#7-1-3-剖析Integer与二进制算法" class="headerlink" title="7.1.3 剖析Integer与二进制算法"></a>7.1.3 剖析Integer与二进制算法</h2><p>本小节主要介绍Integer类， Long与Integer类似，就不再单独介绍了。一个简单的Integer还有什么要介绍的呢？它有一些二进制操作，包括位翻转和循环移位等，另外，我们也分析一下它的valueOf实现。为什么要关心实现代码呢？大部分情况下，确实不用关心，会用它就可以了，我们主要是学习其中的二进制操作。二进制是计算机的基础，但代码往往晦涩难懂，我们希望对其有一个更为清晰深刻的理解。</p>
<h3 id="1．位翻转"><a href="#1．位翻转" class="headerlink" title="1．位翻转"></a>1．位翻转</h3><p>Integer有两个静态方法，可以按位进行翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span></span><br></pre></td></tr></table></figure>

<p>位翻转就是将int当作二进制，左边的位与右边的位进行互换，reverse是按位进行互换， reverseBytes是按byte进行互换，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.reverse(a);</span><br><span class="line">System.out.println(Integer.toBinaryString(r));</span><br><span class="line"><span class="type">int</span> <span class="variable">rb</span> <span class="operator">=</span> Integer.reverseBytes(a);</span><br><span class="line">System.out.println(Integer.toHexString(rb));</span><br></pre></td></tr></table></figure>

<p>a是整数，用十六进制赋值，首先输出其二进制字符串，接着输出reverse后的二进制，最后输出reverseBytes后的十六进制，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10010001101000101011001111000</span><br><span class="line">11110011010100010110001001000</span><br><span class="line">78563412</span><br></pre></td></tr></table></figure>

<p>reverseBytes是按字节翻转，78是十六进制表示的一个字节，12也是，所以结果78563412是比较容易理解的。二进制翻转初看是不对的，这是因为输出不是32位，输出时忽略了前面的0，我们补齐32位再看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00010010001101000101011001111000</span><br><span class="line">00011110011010100010110001001000</span><br></pre></td></tr></table></figure>

<p>这次结果就对了。这两个方法是怎么实现的呢？</p>
<p>先来看reverseBytes的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i &gt;&gt;&gt; <span class="number">24</span>)              ) |</span><br><span class="line">            ((i &gt;&gt;    <span class="number">8</span>) &amp;    <span class="number">0xFF00</span>) |</span><br><span class="line">            ((i &lt;&lt;    <span class="number">8</span>) &amp; <span class="number">0xFF0000</span>) |</span><br><span class="line">            ((i &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较晦涩，以参数i等于0x12345678为例，我们来分析执行过程：<br>1）<code>i&gt;&gt;&gt;24</code>无符号右移，最高字节挪到最低位，结果是0x00000012；<br>2）(<code>i&gt;&gt;8</code>) &amp; 0xFF00，左边第二个字节挪到右边第二个，i&gt;&gt;8结果是0x00123456，再进行&amp; 0xFF00，保留的是右边第二个字节，结果是0x00003400；<br>3）(<code>i &lt;&lt; 8</code>) &amp; 0xFF0000，右边第二个字节挪到左边第二个，i&lt;&lt;8结果是0x34567800，再进行&amp; 0xFF0000，保留的是右边第三个字节，结果是0x00560000；<br>4）<code>i&lt;&lt;24</code>，结果是0x78000000，最右字节挪到最左边。</p>
<p>这4个结果再进行或操作|，结果就是0x78563412，这样，通过左移、右移、与和或操作，就达到了字节翻转的目的。</p>
<p>我们再来看reverse的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然很短，但非常晦涩，到底是什么意思呢？代码第一行是一个注释，HD表示的是一本书，书名为Hacker’s Delight，中文版为《算法心得：高效算法的奥秘》, HD是它的缩写，Figure 7-1是书中的图7-1, reverse的代码就是复制了这本书中图7-1的代码，书中也说明了代码的思路，我们简要说明。</p>
<p>高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着是4位一组交换、然后是8位、16位，16位之后就完成了。这个思路不仅适用于二进制，而且适用于十进制，为便于理解，我们看个十进制的例子。比如对数字12345678进行翻转。</p>
<p>第一轮，相邻单一数字进行互换，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21 43 65 87</span><br></pre></td></tr></table></figure>

<p>第二轮，以两个数字为一组交换相邻的，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43 21 87 65</span><br></pre></td></tr></table></figure>

<p>第三轮，以4个数字为一组交换相邻的，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8765 4321</span><br></pre></td></tr></table></figure>

<p>翻转完成。</p>
<p>对十进制而言，这个效率并不高，但对于二进制而言，却是高效的，因为二进制可以在一条指令中交换多个相邻位。下面代码就是对相邻单一位进行互换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (x &amp; 0x55555555) &lt;&lt;   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;&gt;   1;</span><br></pre></td></tr></table></figure>

<p>5的二进制表示是0101,0x55555555的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01010101010101010101010101010101</span><br></pre></td></tr></table></figure>

<p>x &amp; 0x55555555就是取x的奇数位。</p>
<p>A的二进制表示是1010,0xAAAAAAAA的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10101010101010101010101010101010</span><br></pre></td></tr></table></figure>

<p>x &amp; 0xAAAAAAAA就是取x的偶数位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; 0x55555555) &lt;&lt;   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;&gt;   1;</span><br></pre></td></tr></table></figure>

<p>表示的就是x的奇数位向左移，偶数位向右移，然后通过|合并，达到相邻位互换的目的。这段代码可以有个小的优化，只使用一个常量0x55555555，后半部分先移位再进行与操作，变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555;</span><br></pre></td></tr></table></figure>

<p>同理，如下代码就是以两位为一组，对相邻位进行互换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x33333333) &lt;&lt; 2 | (i &amp; 0xCCCCCCCC)&gt;&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>3的二进制表示是0011,0x33333333的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00110011001100110011001100110011</span><br></pre></td></tr></table></figure>

<p>x &amp; 0x33333333就是取x以两位为一组的低半部分。</p>
<p>C的二进制表示是1100,0xCCCCCCCC的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11001100110011001100110011001100</span><br></pre></td></tr></table></figure>

<p>x &amp; 0xCCCCCCCC就是取x以两位为一组的高半部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x33333333) &lt;&lt; 2 | (i &amp; 0xCCCCCCCC)&gt;&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>表示的就是x以两位为一组，低半部分向高位移，高半部分向低位移，然后通过|合并，达到交换的目的。同样，可以去掉常量0xCCCCCCCC，代码可以优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x33333333) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x33333333;</span><br></pre></td></tr></table></figure>

<p>同理，下面代码就是以4位为一组进行交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x0f0f0f0f) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;</span><br></pre></td></tr></table></figure>

<p>到以8位为单位交换时，就是字节翻转了，可以写为如下更直接的形式，代码和reverse-Bytes基本完全一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &lt;&lt; 24) | ((i &amp; 0xff00) &lt;&lt; 8) |</span><br><span class="line">    ((i &gt;&gt;&gt; 8) &amp; 0xff00) | (i &gt;&gt;&gt; 24);</span><br></pre></td></tr></table></figure>

<p>reverse代码为什么要写得这么晦涩呢？或者说不能用更容易理解的方式写吗？比如，实现翻转，一种常见的思路是：第一个和最后一个交换，第二个和倒数第二个交换，直到中间两个交换完成。如果数据不是二进制位，这个思路是好的，但对于二进制位，这个思路的效率比较低。</p>
<p>CPU指令并不能高效地操作单个位，它操作的最小数据单位一般是32位（32位机器），另外，CPU可以高效地实现移位和逻辑运算，但实现加、减、乘、除运算则比较慢。</p>
<p>reverse<strong>是在充分利用CPU的这些特性，并行高效地进行相邻位的交换</strong>，也可以通过其他更容易理解的方式实现相同功能，但很难比这个代码更高效。</p>
<h3 id="2．循环移位"><a href="#2．循环移位" class="headerlink" title="2．循环移位"></a>2．循环移位</h3><p>Integer有两个静态方法可以进行循环移位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br></pre></td></tr></table></figure>

<p>rotateLeft方法是循环左移，rotateRight方法是循环右移，distance是移动的位数。所谓循环移位，是相对于普通的移位而言的，普通移位，比如左移2位，原来的最高两位就没有了，右边会补0，而如果是循环左移两位，则原来的最高两位会移到最右边，就像一个左右相接的环一样。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.rotateLeft(a, <span class="number">8</span>);</span><br><span class="line">System.out.println(Integer.toHexString(b));</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.rotateRight(a, <span class="number">8</span>);</span><br><span class="line">System.out.println(Integer.toHexString(c))</span><br></pre></td></tr></table></figure>

<p>b是a循环左移8位的结果，c是a循环右移8位的结果，所以输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">34567812</span><br><span class="line">78123456</span><br></pre></td></tr></table></figure>

<p>这两个函数的实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;&gt;&gt; distance) | (i &lt;&lt; -distance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数中令人费解的是负数，如果distance是8，那i&gt;&gt;&gt;-8是什么意思呢？其实，实际的移位个数不是后面的直接数字，而是直接数字的最低5位的值，或者说是直接数字&amp;0x1f的结果。之所以这样，是因为5位最大表示31，移位超过31位对int整数是无效的。</p>
<p>理解了移动负数位的含义，就比较容易理解上面这段代码了，比如，-8的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111000</span><br></pre></td></tr></table></figure>

<p>其最低5位是11000，十进制表示就是24，所以i&gt;&gt;&gt;-8就是i&gt;&gt;&gt;24, i&lt;&lt;8 |i&gt;&gt;&gt;24就是循环左移8位。上面代码中，i&gt;&gt;&gt;-distance就是i&gt;&gt;&gt;(32-distance),i&lt;&lt;-distance就是i&lt;&lt;(32-distance)。</p>
<p>Integer中还有一些其他的位操作，具体可参看API文档。关于其实现代码，都有注释指向Hacker’s Delight这本书的相关章节，不再赘述。</p>
<h3 id="3-valueOf的实现"><a href="#3-valueOf的实现" class="headerlink" title="3. valueOf的实现"></a>3. valueOf的实现</h3><p>在前面，我们提到，创建包装类对象时，可以使用静态的valueOf方法，也可以直接使用new，但建议使用valueOf方法，为什么呢？我们来看Integer的valueOf的代码（基于Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它使用了IntegerCache，这是一个私有静态内部类，如代码清单7-1所示。</p>
<center>代码清单7-1 IntegerCache</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span> sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(integerCacheHighPropValue ! = <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">//Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntegerCache表示Integer缓存，其中的cache变量是一个静态Integer数组，在静态初始化代码块中被初始化，默认情况下，保存了-128～127共256个整数对应的Integer对象。</p>
<p>在valueOf代码中，如果数值位于被缓存的范围，即默认-128～127，则直接从Integer-Cache中获取已预先创建的Integer对象，只有不在缓存范围时，才通过new创建对象。</p>
<p>通过共享常用对象，可以节省内存空间，由于Integer是不可变的，所以缓存的对象可以安全地被共享。Boolean、Byte、Short、Long、Character都有类似的实现。这种共享常用对象的思路，是一种常见的设计思路，它有一个名字，叫<strong>享元模式</strong>，英文叫Flyweight，即共享的轻量级元素。</p>
<h2 id="7-1-4-剖析Character"><a href="#7-1-4-剖析Character" class="headerlink" title="7.1.4 剖析Character"></a>7.1.4 剖析Character</h2><p>本节探讨Character类。Character类除了封装了一个char外，还有什么可介绍的呢？它有很多静态方法，封装了Unicode字符级别的各种操作，是Java文本处理的基础，注意不是char级别，Unicode字符并不等同于char，本节详细介绍这些方法。在此之前，先来回顾一下Unicode知识。</p>
<h3 id="1-Unicode基础"><a href="#1-Unicode基础" class="headerlink" title="1. Unicode基础"></a>1. Unicode基础</h3><p>Unicode给世界上每个字符分配了一个编号，编号范围为0x000000～0x10FFFF。编号范围在0x0000～0xFFFF的字符为常用字符集，称BMP（Basic MultilingualPlane）字符。编号范围在0x10000～0x10FFFF的字符叫做增补字符（supplementary character）。</p>
<p>Unicode主要规定了编号，但没有规定如何把编号映射为二进制。UTF-16是一种编码方式，或者叫映射方式，它将编号映射为两个或4个字节，对BMP字符，它直接用两个字节表示，对于增补字符，使用4个字节表示，前两个字节叫高代理项（high surrogate），范围为0xD800～0xDBFF，后两个字节叫低代理项（lowsurrogate），范围为0xDC00～0xDFFF。UTF-16定义了一个公式，可以将编号与4字节表示进行相互转换。</p>
<p>Java内部采用UTF-16编码，char表示一个字符，但只能表示BMP中的字符，对于增补字符，需要使用两个char表示，一个表示高代理项，一个表示低代理项。</p>
<p>使用int可以表示任意一个Unicode字符，低21位表示Unicode编号，高11位设为0。整数编号在Unicode中一般称为<strong>代码点</strong>（code point），表示一个Unicode字符，与之相对，还有一个词<strong>代码单元</strong>（code unit）表示一个char。</p>
<p>Character类中有很多相关静态方法，下面分别介绍。</p>
<h3 id="2．检查code-point和char"><a href="#2．检查code-point和char" class="headerlink" title="2．检查code point和char"></a>2．检查code point和char</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个int是不是一个有效的代码点，小于等于0x10FFFF的为有效，大于的为无效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidCodePoint</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//判断一个int是不是BMP字符，小于等于0xFFFF的为BMP字符，大于的不是</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBmpCodePoint</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//判断一个int是不是增补字符，0x010000～0X10FFFF为增补字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSupplementaryCodePoint</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//判断char是否是高代理项，0xD800～0xDBFF为高代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isHighSurrogate</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//判断char是否为低代理项，0xDC00～0xDFFF为低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLowSurrogate</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//判断char是否为代理项， char为低代理项或高代理项，则返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSurrogate</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//判断两个字符high和low是否分别为高代理项和低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSurrogatePair</span><span class="params">(<span class="type">char</span> high, <span class="type">char</span> low)</span></span><br><span class="line"><span class="comment">//判断一个代码点由几个char组成，增补字符返回2, BMP字符返回1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">charCount</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-code-point与char的转换"><a href="#3-code-point与char的转换" class="headerlink" title="3. code point与char的转换"></a>3. code point与char的转换</h3><p>除了简单的检查外，Character类中还有很多方法，进行code point与char的相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据高代理项high和低代理项low生成代码点，这个转换有个公式，这个方法封装了这个公式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toCodePoint</span><span class="params">(<span class="type">char</span> high, <span class="type">char</span> low)</span></span><br><span class="line"><span class="comment">//根据代码点生成char数组，即UTF-16表示，如果code point为BMP字符，则返回的char</span></span><br><span class="line"><span class="comment">//数组长度为1，如果为增补字符，长度为2, char[0]为高代理项，char[1]为低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] toChars(<span class="type">int</span> codePoint)</span><br><span class="line"><span class="comment">//将代码点转换为char数组，与上面方法类似，只是结果存入指定数组dst的指定位置index</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toChars</span><span class="params">(<span class="type">int</span> codePoint, <span class="type">char</span>[] dst, <span class="type">int</span> dstIndex)</span></span><br><span class="line"><span class="comment">//对增补字符code point，生成低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">lowSurrogate</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//对增补字符code point，生成高代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">highSurrogate</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<h3 id="4．按code-point处理char数组或序列"><a href="#4．按code-point处理char数组或序列" class="headerlink" title="4．按code point处理char数组或序列"></a>4．按code point处理char数组或序列</h3><p>Character包含若干方法，以方便按照code point处理char数组或序列。</p>
<p>返回char数组a中从offset开始count个char包含的code point个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointCount</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>

<p>比如，如下代码输出为2, char个数为3，但code point为2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">chs[<span class="number">0</span>] = <span class="string">&#x27;马&#x27;</span>;</span><br><span class="line">Character.toChars(<span class="number">0x1FFFF</span>, chs, <span class="number">1</span>);</span><br><span class="line">System.out.println(Character.codePointCount(chs, <span class="number">0</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>除了接受char数组，还有一个重载的方法接受字符序列CharSequence：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointCount</span><span class="params">(CharSequence seq, <span class="type">int</span> beginIndex,<span class="type">int</span> endIndex)</span></span><br></pre></td></tr></table></figure>

<p>CharSequence是一个接口，它的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CharSequence</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">    CharSequence <span class="title function_">subSequence</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它与一个char数组是类似的，有length方法，有charAt方法根据索引获取字符，String类就实现了该接口。</p>
<p>返回char数组或序列中指定索引位置的code point：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointAt</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointAt</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index, <span class="type">int</span> limit)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointAt</span><span class="params">(CharSequence seq, <span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<p>如果指定索引位置为高代理项，下一个位置为低代理项，则返回两项组成的codepoint，检查下一个位置时，下一个位置要小于limit，没传limit时，默认为a.length。</p>
<p>返回char数组或序列中指定索引位置之前的code point：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointBefore</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointBefore</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index, <span class="type">int</span> start)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointBefore</span><span class="params">(CharSequence seq, <span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<p>codePointAt是往后找，codePointBefore是往前找，如果指定位置为低代理项，且前一个位置为高代理项，则返回两项组成的code point，检查前一个位置时，前一个位置要大于等于start，没传start时，默认为0。</p>
<p>根据code point偏移数计算char索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">offsetByCodePoints</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> start, <span class="type">int</span> count,<span class="type">int</span> index, <span class="type">int</span> codePointOffset)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">offsetByCodePoints</span><span class="params">(CharSequence seq, <span class="type">int</span> index,<span class="type">int</span> codePointOffset)</span></span><br></pre></td></tr></table></figure>

<p>如果字符数组或序列中没有增补字符，返回值为index+codePointOffset，如果有增补字符，则会将codePointOffset看作code point偏移，转换为字符偏移，start和count取字符数组的子数组。</p>
<p>比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">Character.toChars(<span class="number">0x1FFFF</span>, chs, <span class="number">1</span>);</span><br><span class="line">System.out.println(Character.offsetByCodePoints(chs, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>));<span class="comment">//输出结果为3, index和codePointOffset都为1，但第二个字符为增补字符，一个code point偏移是两个char偏移，所以结果为3。</span></span><br></pre></td></tr></table></figure>

<h3 id="5．字符属性"><a href="#5．字符属性" class="headerlink" title="5．字符属性"></a>5．字符属性</h3><p>Unicode在给每个字符分配一个编号之外，还分配了一些属性，Character类封装了对Unicode字符属性的检查和操作，下面介绍一些主要的属性。</p>
<p>获取字符类型（general category）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">(<span class="type">char</span> ch)</span></span><br></pre></td></tr></table></figure>

<p>Unicode给每个字符分配了一个类型，这个类型是非常重要的，很多其他检查和操作都是基于这个类型的。getType方法的参数可以是int类型的code point，也可以是char类型。char类型只能处理BMP字符，而int类型可以处理所有字符。Character类中很多方法都是既可以接受int类型，也可以接受char类型，后续只列出int类型的方法。返回值是int，表示类型，Character类中定义了很多静态常量表示这些类型，表7-3列出了一些字符、type值，以及Character类中常量的名称。</p>
<center>表7-3 常见字符类型值</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209094654.jpeg" alt="epub_923038_52"><br>检查字符是否在Unicode中被定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDefined</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>每个被定义的字符，其getType()返回值都不为0，如果返回值为0，表示无定义。注意与isValidCodePoint的区别，后者只要数字不大于0x10FFFF都返回true。</p>
<p>检查字符是否为数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>getType()返回值为DECIMAL_DIGIT_NUMBER的字符为数字。需要注意的是，不光字符’0’、’1’、……、’9’是数字，中文全角字符的0～9也是数字。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>; <span class="comment">//中文全角数字</span></span><br><span class="line">System.out.println((<span class="type">int</span>)ch+<span class="string">&quot;, &quot;</span>+Character.isDigit(ch));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65305, true</span><br></pre></td></tr></table></figure>

<p>全角字符的9, Unicode编号为65305，它也是数字。</p>
<p>检查是否为字母（Letter）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLetter</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>如果getType()的返回值为下列之一，则为Letter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPPERCASE_LETTER</span><br><span class="line">LOWERCASE_LETTER</span><br><span class="line">TITLECASE_LETTER</span><br><span class="line">MODIFIER_LETTER</span><br><span class="line">OTHER_LETTER</span><br></pre></td></tr></table></figure>

<p>除了TITLECASE_LETTER和MODIFIER_LETTER，其他在表7-3中有示例，而这两个平时碰到的也比较少，就不介绍了。</p>
<p>检查是否为字母或数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLetterOrDigit</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>只要其中之一返回true就返回true。</p>
<p>检查是否为字母（Alphabetic）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAlphabetic</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>这也是检查是否为字母，与isLetter的区别是：isLetter返回true时，isAlphabetic也必然返回true；此外，getType()值为LETTER_NUMBER时，isAlphabetic也返回true，而isLetter返回false。LETTER_NUMBER中常见的字符有罗马数字字符，如’I’、’Ⅱ’、’Ⅲ’、’Ⅳ’。</p>
<p>检查是否为空格字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSpaceChar</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p><code>getType()</code>值为<code>SPACE_SEPARATOR</code>,<code>LINE_SEPARATOR</code>和<code>PARAGRAPH_SEPARATOR</code>时，返回true。这个方法其实并不常用，因为它只能严格匹配空格字符本身，不能匹配实际产生空格效果的字符，如Tab控制键’<code>\t</code>‘。</p>
<p>更常用的检查空格的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isWhitespace</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>‘<code>\t</code>‘、’<code>\n</code>‘、全角空格’ ‘和半角空格’ ‘的返回值都为true。</p>
<p>检查是否为小写字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLowerCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>常见的小写字符主要是小写英文字母a～z。</p>
<p>检查是否为大写字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isUpperCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>常见的大写字符主要是大写英文字母A～Z。</p>
<p>检查是否为表意象形文字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isIdeographic</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>大部分中文都返回为true</p>
<p>检查是否为ISO 8859-1编码中的控制字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isISOControl</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>我们在第2章介绍过，0～31、127～159表示控制字符。</p>
<p>检查是否可作为Java标识符的第一个字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isJavaIdentifierStart</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>Java标识符是Java中的变量名、函数名、类名等，字母（Alphabetic）、美元符号（$）、下画线（_）可作为Java标识符的第一个字符，但数字字符不可以。</p>
<p>检查是否可作为Java标识符的中间字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isJavaIdentifierPart</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>相比isJavaIdentifierStart，主要多了数字字符，Java标识符的中间字符可以包含数字。</p>
<p>检查是否为镜像（mirrowed）字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirrored</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>常见镜像字符有<code>( )</code>、<code>&#123; &#125;</code>、<code>&lt; &gt;</code>、<code>[ ]</code>，都有对应的镜像。</p>
<h3 id="6．字符转换"><a href="#6．字符转换" class="headerlink" title="6．字符转换"></a>6．字符转换</h3><p>Unicode除了规定字符属性外，对有大小写对应的字符，还规定了其对应的大小写，对有数值含义的字符，也规定了其数值。</p>
<p>我们先来看大小写，Character有两个静态方法，对字符进行大小写转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toLowerCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toUpperCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>这两个方法主要针对英文字符a～z和A～Z，例如：toLowerCase(‘A’)返回’a’,toUpper-Case(‘z’)返回’Z’。</p>
<p>返回一个字符表示的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumericValue</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>字符’0’～’9’返回数值0～9，对于字符a～z，无论是小写字符还是大写字符，无论是普通英文还是中文全角，数值结果都是10～35。例如，如下代码的输出结果是一样的，都是10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//全角大写A</span></span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//全角小写a</span></span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>返回按给定进制表示的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digit</span><span class="params">(<span class="type">int</span> codePoint, <span class="type">int</span> radix)</span></span><br></pre></td></tr></table></figure>

<p>radix表示进制，常见的有二进制、八进制、十进制、十六进制，计算方式与get-NumericValue类似，只是会检查有效性，数值需要小于radix，如果无效，返回-1。例如：digit(‘F’,16)返回15，是有效的；但digit(‘G’,16)就无效，返回-1。</p>
<p>返回给定数值的字符形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">forDigit</span><span class="params">(<span class="type">int</span> digit, <span class="type">int</span> radix)</span></span><br></pre></td></tr></table></figure>

<p>与<code>digit(int codePoint, int radix)</code>相比，进行相反转换，如果数字无效，返回’<code>\0</code>‘。例如， <code>Character.forDigit(15, 16)</code>返回’<code>F</code>‘。</p>
<p>与Integer类似，Character也有按字节翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">char</span> ch)</span></span><br></pre></td></tr></table></figure>

<p>例如，翻转字符0x1234：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toHexString(Character.reverseBytes((<span class="type">char</span>)<span class="number">0x1234</span>)));</span><br></pre></td></tr></table></figure>

<p>输出为3412。</p>
<p>至此，Characer类就介绍完了，它在Unicode字符级别（而非char级别）封装了字符的各种操作，通过将字符处理的细节交给Character类，其他类就可以在更高的层次上处理文本了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/JavaReadingNotes/images/wechatpay.png" alt="蓝蓝 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>蓝蓝
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/" title="7.0 第7章 常用基础类 7.1 包装类">https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/JavaReadingNotes/36e750aa/" rel="prev" title="1.7 函数调用的基本原理">
                  <i class="fa fa-chevron-left"></i> 1.7 函数调用的基本原理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/JavaReadingNotes/703d32a8/" rel="next" title="7.5 剖析日期和时间">
                  7.5 剖析日期和时间 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:07</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/31a72ecb/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
