<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="第10章 Map和Set上一章介绍了ArrayList、LinkedList和ArrayDeque，它们的一个共同特点是：查找元素的效率都比较低，都需要逐个进行比较，本章介绍各种Map和Set，它们的查找效率要高得多。Map和Set都是接口，Java中有多个实现类，主要包括HashMap、HashSet、TreeMap、TreeSet、LinkedHashMap、LinedHashSet、Enum">
<meta property="og:type" content="article">
<meta property="og:title" content="10.0 第10章 Map和Set 10.1 剖析HashMap">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="第10章 Map和Set上一章介绍了ArrayList、LinkedList和ArrayDeque，它们的一个共同特点是：查找元素的效率都比较低，都需要逐个进行比较，本章介绍各种Map和Set，它们的查找效率要高得多。Map和Set都是接口，Java中有多个实现类，主要包括HashMap、HashSet、TreeMap、TreeSet、LinkedHashMap、LinedHashSet、Enum">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209130953.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209131007.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209131020.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209131034.jpeg">
<meta property="article:published_time" content="2021-12-05T02:36:09.000Z">
<meta property="article:modified_time" content="2021-12-08T04:34:05.000Z">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209130953.jpeg">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/","path":"/19b66ad5/","title":"10.0 第10章 Map和Set 10.1 剖析HashMap"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>10.0 第10章 Map和Set 10.1 剖析HashMap | 蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">蓝蓝站点</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-Map%E5%92%8CSet"><span class="nav-text">第10章 Map和Set</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E5%89%96%E6%9E%90HashMap"><span class="nav-text">10.1 剖析HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-1-Map%E6%8E%A5%E5%8F%A3"><span class="nav-text">10.1.1 Map接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-2-HashMap"><span class="nav-text">10.1.2 HashMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-3-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">10.1.3 实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%BC%8E%E5%86%85%E9%83%A8%E7%BB%84%E6%88%90"><span class="nav-text">1．内部组成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%EF%BC%8E%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">2．默认构造方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%EF%BC%8E%E4%BF%9D%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-text">3．保存键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%EF%BC%8E%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95"><span class="nav-text">4．查找方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%EF%BC%8E%E6%A0%B9%E6%8D%AE%E9%94%AE%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="nav-text">5．根据键删除键值对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%EF%BC%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="nav-text">6．实现原理小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-4-%E5%B0%8F%E7%BB%93"><span class="nav-text">10.1.4 小结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="10.0 第10章 Map和Set 10.1 剖析HashMap | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          10.0 第10章 Map和Set 10.1 剖析HashMap
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 10:36:09" itemprop="dateCreated datePublished" datetime="2021-12-05T10:36:09+08:00">2021-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC10%E7%AB%A0-Map%E5%92%8CSet/" itemprop="url" rel="index"><span itemprop="name">第10章 Map和Set</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/19b66ad5/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/19b66ad5/" data-xid="/JavaReadingNotes/19b66ad5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第10章-Map和Set"><a href="#第10章-Map和Set" class="headerlink" title="第10章 Map和Set"></a>第10章 Map和Set</h1><p>上一章介绍了ArrayList、LinkedList和ArrayDeque，它们的一个共同特点是：查找元素的效率都比较低，都需要逐个进行比较，本章介绍各种Map和Set，它们的查找效率要高得多。Map和Set都是接口，Java中有多个实现类，主要包括HashMap、HashSet、TreeMap、TreeSet、LinkedHashMap、LinedHashSet、EnumMap、EnumSet等，它们都有什么用？有什么不同？是如何实现的？本章进行深入剖析，我们先从最常用的HashMap开始。</p>
<h2 id="10-1-剖析HashMap"><a href="#10-1-剖析HashMap" class="headerlink" title="10.1 剖析HashMap"></a>10.1 剖析HashMap</h2><p>字面上看，HashMap由Hash和Map两个单词组成，这里Map不是地图的意思，而是表示映射关系，是一个接口，实现Map接口有多种方式，HashMap实现的方式利用了哈希（Hash）。下面先来看Map接口，接着看HashMap的用法，然后看实现原理，最后总结分析HashMap的特点。</p>
<h3 id="10-1-1-Map接口"><a href="#10-1-1-Map接口" class="headerlink" title="10.1.1 Map接口"></a>10.1.1 Map接口</h3><p>Map有<strong>键</strong>和<strong>值</strong>的概念。一个键映射到一个值，Map按照键存储和访问值，键不能重复，即一个键只会存储一份，给同一个键重复设值会覆盖原来的值。使用Map可以方便地处理需要根据键访问对象的场景，比如：</p>
<ul>
<li>一个词典应用，键可以为单词，值可以为单词信息类，包括含义、发音、例句等；</li>
<li>统计和记录一本书中所有单词出现的次数，可以以单词为键，以出现次数为值；</li>
<li>管理配置文件中的配置项，配置项是典型的键值对；</li>
<li>根据身份证号查询人员信息，身份证号为键，人员信息为值。</li>
</ul>
<p>数组、ArrayList、LinkedList可以视为一种特殊的Map，键为索引，值为对象。</p>
<p>Java 7中Map接口的定义如代码清单10-1所示，用注释表示方法的含义。</p>
<center>代码清单10-1 Map接口</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123; <span class="comment">//K和V是类型参数，分别表示键(Key)和值(Value)的类型</span></span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>; <span class="comment">//保存键值对，如果原来有key，覆盖，返回原来的值</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(Object key)</span>; <span class="comment">//根据键获取值， 没找到，返回null</span></span><br><span class="line">    V <span class="title function_">remove</span><span class="params">(Object key)</span>; <span class="comment">//根据键删除键值对， 返回key原来的值，如果不存在，返回null</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">//查看Map中键值对的个数</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">//是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>; <span class="comment">//查看是否包含某个键</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>; <span class="comment">//查看是否包含某个值</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>; <span class="comment">//保存m中的所有键值对到当前Map</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">//清空Map中所有键值对</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>; <span class="comment">//获取Map中键的集合</span></span><br><span class="line">    Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>; <span class="comment">//获取Map中所有值的集合</span></span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); <span class="comment">//获取Map中的所有键值对</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Entry</span>&lt;K, V&gt; &#123; <span class="comment">//嵌套接口，表示一条键值对</span></span><br><span class="line">        K <span class="title function_">getKey</span><span class="params">()</span>; <span class="comment">//键值对的键</span></span><br><span class="line">        V <span class="title function_">getValue</span><span class="params">()</span>; <span class="comment">//键值对的值</span></span><br><span class="line">        V <span class="title function_">setValue</span><span class="params">(V value)</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;</span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>Java 8增加了一些默认方法，如getOrDefault、forEach、replaceAll、putIfAbsent、replace、computeIfAbsent、merge等，Java 9增加了多个重载的of方法，可以方便地根据一个或多个键值对构建不变的Map，具体可参见API文档，我们就不介绍了。</p>
<p>Set是一个接口，表示的是数学中的集合概念，即没有重复的元素集合。Java 7中的Set定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它扩展了Collection，但没有定义任何新的方法，不过，它要求所有实现者都必须确保Set的语义约束，即不能有重复元素。Java 9增加了多个重载的of方法，可以根据一个或多个元素生成不变的Set，具体可参见API文档。关于Set,10.2节我们再详细介绍。</p>
<p>Map中的键是没有重复的，所以ketSet()返回了一个Set。keySet()、values()、entrySet()有一个共同的特点，它们返回的都是视图，不是复制的值，基于返回值的修改会直接修改Map自身，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.keySet().clear();</span><br></pre></td></tr></table></figure>

<p>会删除所有键值对。</p>
<h3 id="10-1-2-HashMap"><a href="#10-1-2-HashMap" class="headerlink" title="10.1.2 HashMap"></a>10.1.2 HashMap</h3><p>HashMap实现了Map接口，我们通过一个简单的例子来看如何使用。在7.6节，我们介绍过如何产生随机数，现在，我们写一个程序，来看随机产生的数是否均匀。比如，随机产生1000个0～3的数，统计每个数的次数，如代码清单10-2所示。</p>
<center>代码清单10-2 使用HashMap统计随机数</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> rnd.nextInt(<span class="number">4</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> countMap.get(num);</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="literal">null</span>)&#123;</span><br><span class="line">        countMap.put(num, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        countMap.put(num, count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; kv : countMap.entrySet())&#123;</span><br><span class="line">    System.out.println(kv.getKey()+<span class="string">&quot;, &quot;</span>+kv.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一次运行的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0,269</span><br><span class="line">1,236</span><br><span class="line">2,261</span><br><span class="line">3,234</span><br></pre></td></tr></table></figure>

<p>次数分别是269、236、261、234，代码比较简单，就不解释了。除了默认构造方法， HashMap还有如下构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span><br></pre></td></tr></table></figure>

<p>最后一个以一个已有的Map构造，复制其中的所有键值对到当前Map。前两个涉及参数initialCapacity和loadFactor，它们是什么意思呢？我们需要看下HashMap的实现原理。</p>
<h3 id="10-1-3-实现原理"><a href="#10-1-3-实现原理" class="headerlink" title="10.1.3 实现原理"></a>10.1.3 实现原理</h3><p>我们先来看HashMap的内部组成，然后分析一些主要方法的实现，代码基于Java7。</p>
<h4 id="1．内部组成"><a href="#1．内部组成" class="headerlink" title="1．内部组成"></a>1．内部组成</h4><p>HashMap内部有如下几个主要的实例变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Entry&lt;K, V&gt;[] table = (Entry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<p>size表示实际键值对的个数。table是一个Entry类型的数组，称为哈希表或哈希桶，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对。Entry是一个内部类，它的实例变量和构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K, V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K, V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">    Entry(<span class="type">int</span> h, K k, V v, Entry&lt;K, V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，key和value分别表示键和值，next指向下一个Entry节点，hash是key的hash值，待会我们会介绍其计算方法。直接存储hash值是为了在比较的时候加快计算，待会我们看代码。</p>
<p>table的初始值为EMPTY_TABLE，是一个空表，具体定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Entry&lt;? , ? &gt;[] EMPTY_TABLE = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>当添加键值对后，table就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于ArrayList。添加第一个元素时，默认分配的大小为16，不过，并不是size大于16时再进行扩展，下次什么时候扩展与threshold有关。</p>
<p>threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展。threshold是怎么算出来的呢？一般而言，threshold等于table.length乘以loadFactor。比如，如果table. length为16, loadFactor为0.75，则threshold为12。loadFactor是负载因子，表示整体上table被占用的程度，是一个浮点数，默认为0.75，可以通过构造方法进行修改。</p>
<p>下面，我们通过一些主要方法的代码来介绍HashMap是如何利用这些内部数据实现Map接口的。先看默认构造方法。需要说明的是，为清晰和简单起见，我们可能会省略一些非主要代码。</p>
<h3 id="2．默认构造方法"><a href="#2．默认构造方法" class="headerlink" title="2．默认构造方法"></a>2．默认构造方法</h3><p>默认构造方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DEFAULT_INITIAL_CAPACITY为16, DEFAULT_LOAD_FACTOR为0.75，默认构造方法调用的构造方法主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是设置loadFactor和threshold的初始值。</p>
<h3 id="3．保存键值对"><a href="#3．保存键值对" class="headerlink" title="3．保存键值对"></a>3．保存键值对</h3><p>下面，我们来看HashMap是如何把一个键值对保存起来的，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[i]; e ! = <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是第一次保存，首先调用inflateTable()方法给table分配实际的空间，inflateTable的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inflateTable</span><span class="params">(<span class="type">int</span> toSize)</span> &#123;</span><br><span class="line">    <span class="comment">//Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> roundUpToPowerOf2(toSize);</span><br><span class="line">    threshold = (<span class="type">int</span>) Math.min(capacity ＊ loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，capacity的值为16, threshold会变为12, table会分配一个长度为16的Entry数组。接下来，检查key是否为null，如果是，调用putForNullKey单独处理，我们暂时忽略这种情况。在key不为null的情况下，下一步调用hash方法计算key的hash值。hash方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于key自身的hashCode方法的返回值又进行了一些位运算，目的是为了随机和均匀性。有了hash值之后，调用indexFor方法，计算应该将这个键值对放到table的哪个位置，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexFor</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap中，length为2的幂次方，h&amp;(length-1)等同于求模运算h%length。找到了保存位置i, table[i]指向一个单向链表。接下来，就是在这个链表中逐个查找是否已经有这个键了，遍历代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e ! = <span class="literal">null</span>; e = e.next)</span><br></pre></td></tr></table></figure>

<p>而比较的时候，是先比较hash值，hash相同的时候，再使用equals方法进行比较，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br></pre></td></tr></table></figure>

<p>为什么要先比较hash呢？因为hash是整数，比较的性能一般要比equals高很多，hash不同，就没有必要调用equals方法了，这样整体上可以提高比较性能。如果能找到，直接修改Entry中的value即可。modCount++的含义与ArrayList和LinkedList中介绍一样，为记录修改次数，方便在迭代中检测结构性变化。如果没找到，则调用addEntry方法在给定的位置添加一条，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> ! = table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> ＊ table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> ! = key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果空间是够的，不需要resize，则调用createEntry方法添加。createEntry的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> bucketIndex)</span> &#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较直接，新建一个Entry对象，插入单向链表的头部，并增加size。如果空间不够，即size已经要超过阈值threshold了，并且对应的table位置已经插入过对象了，具体检查代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> ! = table[bucketIndex]))</span><br></pre></td></tr></table></figure>

<p>则调用resize方法对table进行扩展，扩展策略是乘2, resize的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> <span class="title class_">Entry</span>[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity ＊ loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配一个容量为原来两倍的Entry数组，调用transfer方法将原来的键值对移植过来，然后更新内部的table变量，以及threshold的值。transfer方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Entry[] newTable, <span class="type">boolean</span> rehash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> ! = e) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span>(rehash) &#123;</span><br><span class="line">                e.hash = <span class="literal">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数rehash一般为false。这段代码遍历原来的每个键值对，计算新位置，并保存到新位置，具体代码比较直接，就不解释了。</p>
<p>以上就是保存键值对的主要代码，简单总结一下，基本步骤为：<br>1）计算键的哈希值；<br>2）根据哈希值得到保存位置（取模）；<br>3）插到对应位置的链表头部或更新已有值；<br>4）根据需要扩展table大小。</p>
<p>以上描述可能比较抽象，我们通过一个例子，用图示的方式进行说明，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">countMap.put(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>);</span><br><span class="line">countMap.put(<span class="string">&quot;world&quot;</span>, <span class="number">3</span>);</span><br><span class="line">countMap.put(<span class="string">&quot;position&quot;</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>在通过new HashMap()创建一个对象后，内存中的结构如图10-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209130953.jpeg" alt="epub_923038_70"></p>
<center>图10-1 HashMap：初始结构</center>

<p>接下来执行保存键值对的代码，”hello”的hash值为96207088，模16的结果为0，所以插入table[0]指向的链表头部，内存结构变为图10-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209131007.jpeg" alt="epub_923038_71"></p>
<center>图10-2 HashMap对象示例：保存一个键值对后</center>

<p>“world”的hash值为111207038，模16结果为14，所以保存完”world”后，内存结构如图10-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209131020.jpeg" alt="epub_923038_72"></p>
<center>图10-3 HashMap对象示例：保存两个键值对后</center>

<p>“position”的hash值为771782464，模16结果也为0, table[0]已经有节点了，新节点会插到链表头部，内存结构变为如图10-4所示。理解了键值对在内存是如何存放的，就比较容易理解其他方法了。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209131034.jpeg" alt="epub_923038_73"></p>
<center>图10-4 HashMap对象示例：保存三个键值对后</center>

<h3 id="4．查找方法"><a href="#4．查找方法" class="headerlink" title="4．查找方法"></a>4．查找方法</h3><p>根据键获取值的get方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getForNullKey();</span><br><span class="line">    Entry&lt;K, V&gt; entry = getEntry(key);</span><br><span class="line">    <span class="type">return</span> <span class="variable">null</span> <span class="operator">=</span>= entry ? <span class="literal">null</span> : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap支持key为null, key为null的时候，放在table[0]，调用getForNullKey()获取值；如果key不为null，则调用getEntry()获取键值对节点entry，然后调用节点的getValue()方法获取值。getEntry方法的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K, V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">          e ! = <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key ! = <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑也比较简单，具体如下。</p>
<p>1）计算键的hash值，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br></pre></td></tr></table></figure>

<p>2）根据hash找到table中的对应链表，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table[indexFor(hash, table.length)];</span><br></pre></td></tr></table></figure>

<p>3）在链表中遍历查找，遍历代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">    e ! = <span class="literal">null</span>; e = e.next)</span><br></pre></td></tr></table></figure>

<p>4）逐个比较，先通过hash快速比较，hash相同再通过equals比较，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.hash == hash &amp;&amp;</span><br><span class="line">    ((k = e.key) == key || (key ! = <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br></pre></td></tr></table></figure>

<p>containsKey方法的逻辑与get是类似的，节点不为null就表示存在，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getEntry(key) ! = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap可以方便高效地按照键进行操作，但如果要根据值进行操作，则需要遍历， containsValue方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> containsNullValue();</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i] ; e ! = <span class="literal">null</span> ; e = e.next)</span><br><span class="line">            <span class="keyword">if</span>(value.equals(e.value))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要查找的值为null，则调用containsNullValue单独处理；如果要查找的值不为null，遍历的逻辑也很简单，就是从table的第一个链表开始，从上到下，从左到右逐个节点进行访问，通过equals方法比较值，直到找到为止。</p>
<h3 id="5．根据键删除键值对"><a href="#5．根据键删除键值对" class="headerlink" title="5．根据键删除键值对"></a>5．根据键删除键值对</h3><p>根据键删除键值对的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Entry&lt;K, V&gt; e = removeEntryForKey(key);</span><br><span class="line">    <span class="keyword">return</span>(e == <span class="literal">null</span> ? <span class="literal">null</span> : e.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>removeEntryForKey的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Entry&lt;K, V&gt; <span class="title function_">removeEntryForKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br><span class="line">    Entry&lt;K, V&gt; prev = table[i];</span><br><span class="line">    Entry&lt;K, V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span>(e ! = <span class="literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || (key ! = <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            modCount++;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">if</span>(prev == e)</span><br><span class="line">                table[i] = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev.next = next;</span><br><span class="line">            e.recordRemoval(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e;</span><br><span class="line">        e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本逻辑分析如下。</p>
<p>1）计算hash，根据hash找到对应的table索引，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(hash, table.length);</span><br></pre></td></tr></table></figure>

<p>2）遍历<code>table[i]</code>，查找待删节点，使用变量prev指向前一个节点，next指向后一个节点，e指向当前节点，遍历结构代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Entry&lt;K, V&gt; prev = table[i];</span><br><span class="line">Entry&lt;K, V&gt; e = prev;</span><br><span class="line"><span class="keyword">while</span>(e ! = <span class="literal">null</span>) &#123;</span><br><span class="line">    Entry&lt;K, V&gt; next = e.next;</span><br><span class="line">    <span class="keyword">if</span>(找到了)&#123;</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prev = e;</span><br><span class="line">    e = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）判断是否找到，依然是先比较hash值，hash值相同时再用equals方法比较。<br>4）删除的逻辑就是让长度减小，然后让待删节点的前后节点链起来，如果待删节点是第一个节点，则让table[i]直接指向后一个节点，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size--;</span><br><span class="line"><span class="keyword">if</span>(prev == e)</span><br><span class="line">    table[i] = next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    prev.next = next;</span><br></pre></td></tr></table></figure>

<p>e.recordRemoval(this)；在HashMap中代码为空，主要是为了HashMap的子类扩展使用。</p>
<h3 id="6．实现原理小结"><a href="#6．实现原理小结" class="headerlink" title="6．实现原理小结"></a>6．实现原理小结</h3><p>以上就是HashMap的基本实现原理，内部有一个哈希表，即数组table，每个元素<code>table[i]</code>指向一个单向链表，根据键存取值，用键算出hash值，取模得到数组中的索引位置buketIndex，然后操作<code>table[buketIndex]</code>指向的单向链表。</p>
<p>存取的时候依据键的hash值，只在对应的链表中操作，不会访问别的链表，在对应链表操作时也是先比较hash值，如果相同再用equals方法比较。这就要求，相同的对象其hashCode返回值必须相同，如果键是自定义的类，就特别需要注意这一点。这也是hash-Code和equals方法的一个关键约束。</p>
<p>需要说明的是，Java 8对HashMap的实现进行了优化，在哈希冲突比较严重的情况下，即大量元素映射到同一个链表的情况下（具体是至少8个元素，且总的键值对个数至少是64）, Java 8会将该链表转换为一个平衡的排序二叉树，以提高查询的效率，关于排序二叉树我们在10.3节介绍，Java 8的具体代码就不介绍了。</p>
<h2 id="10-1-4-小结"><a href="#10-1-4-小结" class="headerlink" title="10.1.4 小结"></a>10.1.4 小结</h2><p>本节介绍了HashMap的用法和实现原理，它实现了Map接口，可以方便地按照键存取值，内部使用数组链表和哈希的方式进行实现，这决定了它有如下特点：<br>1）根据键保存和获取值的效率都很高，为O(1)，每个单向链表往往只有一个或少数几个节点，根据hash值就可以直接快速定位；<br>2）HashMap中的键值对没有顺序，因为hash值是随机的。</p>
<p>如果经常需要根据键存取值，而且不要求顺序，那么HashMap就是理想的选择。如果要保持添加的顺序，可以使用HashMap的一个子类LinkedHashMap，我们在10.6节介绍。Map还有一个重要的实现类TreeMap，它可以排序，我们在10.4节介绍。</p>
<p>需要说明的是，HashMap不是线程安全的，Java中还有一个类Hashtable，它是Java最早实现的容器类之一，实现了Map接口，实现原理与HashMap类似，但没有特别的优化，它内部通过synchronized实现了线程安全。在HashMap中，键和值都可以为null，而在Hashtable中不可以。在不需要并发安全的场景中，推荐使用HashMap。在高并发的场景中，推荐使用17.2节介绍的ConcurrentHashMap。</p>
<p><strong>根据哈希值存取对象、比较对象是计算机程序中一种重要的思维方式，它使得存取对象主要依赖于自身Hash值，而不是与其他对象进行比较，存取效率也与集合大小无关，高达O(1)，即使进行比较，也利用Hash值提高比较性能</strong>。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/JavaReadingNotes/images/wechatpay.png" alt="蓝蓝 微信">
        <span>微信</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>蓝蓝
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/" title="10.0 第10章 Map和Set 10.1 剖析HashMap">https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/JavaReadingNotes/bb604ded/" rel="prev" title="9.3 剖析ArrayDeque">
                  <i class="fa fa-chevron-left"></i> 9.3 剖析ArrayDeque
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/JavaReadingNotes/e143b926/" rel="next" title="10.2 剖析HashSet">
                  10.2 剖析HashSet <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:07</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/19b66ad5/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/19b66ad5/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
