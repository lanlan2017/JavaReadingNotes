<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/19f3346f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/19f3346f/" class="post-title-link" itemprop="url">26.5 Java 8的日期和时间API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:09 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:09+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC26%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第26章 函数式编程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/19f3346f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/19f3346f/" data-xid="/JavaReadingNotes/19f3346f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="26-5-Java-8的日期和时间API"><a href="#26-5-Java-8的日期和时间API" class="headerlink" title="26.5 Java 8的日期和时间API"></a>26.5 Java 8的日期和时间API</h1><p>本节介绍Java 8对日期和时间API的增强。我们在之前介绍了Java 8以前的日期和时间API，主要的类是Date和Calendar，由于它的设计有一些不足，Java 8引入了一套新的API，位于包java.time下。本节我们就来简要介绍这套新的API，先从日期和时间的表示开始。</p>
<h2 id="26-5-1-表示日期和时间"><a href="#26-5-1-表示日期和时间" class="headerlink" title="26.5.1 表示日期和时间"></a>26.5.1 表示日期和时间</h2><p>我们在第7章介绍过日期和时间的几个基本概念，包括时刻、时区和年历，这里就不赘述了。Java 8中表示日期和时间的类有多个，主要的有：</p>
<ul>
<li>Instant：表示时刻，不直接对应年月日信息，需要通过时区转换；</li>
<li>LocalDateTime：表示与时区无关的日期和时间，不直接对应时刻，需要通过时区转换；</li>
<li>ZoneId/ZoneOffset：表示时区；</li>
<li>LocalDate：表示与时区无关的日期，与LocalDateTime相比，只有日期，没有时间信息；</li>
<li>LocalTime：表示与时区无关的时间，与LocalDateTime相比，只有时间，没有日期信息；</li>
<li>ZonedDateTime：表示特定时区的日期和时间。</li>
</ul>
<p>类比较多，但概念更为清晰了，下面我们逐个介绍。</p>
<h3 id="1-Instant"><a href="#1-Instant" class="headerlink" title="1. Instant"></a>1. Instant</h3><p>Instant表示时刻，获取当前时刻，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.now();</span><br></pre></td></tr></table></figure>

<p>可以根据Epoch Time（纪元时）创建Instant。比如，另一种获取当前时刻的代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Instant now = Instant.ofEpochMilli(System.currentTimeMillis());</span><br></pre></td></tr></table></figure>

<p>我们知道，Date也表示时刻，Instant和Date可以通过纪元时相互转换，比如，转换Date为Instant，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">toInstant</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Instant.ofEpochMilli(date.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转换Instant为Date，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">toDate</span><span class="params">(Instant instant)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(instant.toEpochMilli());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Instant有很多基于时刻的比较和计算方法，大多比较直观，我们就不列举了。</p>
<h3 id="2-LocalDateTime"><a href="#2-LocalDateTime" class="headerlink" title="2. LocalDateTime"></a>2. LocalDateTime</h3><p>LocalDateTime表示与时区无关的日期和时间，获取系统默认时区的当前日期和时间，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br></pre></td></tr></table></figure>

<p>还可以直接用年月日等信息构建LocalDateTime。比如，表示2017年7月11日20点45分5秒，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">45</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime有很多方法，可以获取年月日时分秒等日历信息，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getYear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMonthValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDayOfMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinute</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSecond</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>还可以获取星期几等信息，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DayOfWeek <span class="title">getDayOfWeek</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>DayOfWeek是一个枚举，有7个取值，从DayOfWeek.MONDAY到DayOfWeek.SUN-DAY。</p>
<h3 id="3-ZoneId-ZoneOffset"><a href="#3-ZoneId-ZoneOffset" class="headerlink" title="3. ZoneId/ZoneOffset"></a>3. ZoneId/ZoneOffset</h3><p>LocalDateTime不能直接转为时刻Instant，转换需要一个参数ZoneOffset,ZoneOffset表示相对于格林尼治的时区差，北京是+08:00。比如，转换一个LocalDateTime为北京的时刻，方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instant <span class="title">toBeijingInstant</span><span class="params">(LocalDateTime ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ldt.toInstant(ZoneOffset.of(<span class="string">&quot;+08:00&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一个时刻，使用不同时区解读，日历信息是不同的，Instant有方法根据时区返回一个ZonedDateTime：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ZonedDateTime <span class="title">atZone</span><span class="params">(ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>

<p>默认时区是ZoneId.systemDefault()，可以这样构建ZoneId：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//北京时区</span></span><br><span class="line">ZoneId bjZone = ZoneId.of(<span class="string">&quot;GMT+08:00&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>ZoneOffset是ZoneId的子类，可以根据时区差构造。</p>
<h3 id="4-LocalDate-LocalTime"><a href="#4-LocalDate-LocalTime" class="headerlink" title="4. LocalDate/LocalTime"></a>4. LocalDate/LocalTime</h3><p>可以认为LocalDateTime由两部分组成，一部分是日期LocalDate，另一部分是时间LocalTime。它们的用法也很直观，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示2017年7月11日</span></span><br><span class="line">LocalDate ld = LocalDate.of(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">11</span>);</span><br><span class="line"><span class="comment">//当前时刻按系统默认时区解读的日期</span></span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line"><span class="comment">//表示21点10分34秒</span></span><br><span class="line">LocalTime lt = LocalTime.of(<span class="number">21</span>, <span class="number">10</span>, <span class="number">34</span>);</span><br><span class="line"><span class="comment">//当前时刻按系统默认时区解读的时间</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br></pre></td></tr></table></figure>

<p>LocalDateTime由LocalDate和LocalTime构成，LocalDate加上时间可以构成LocalDate-Time, LocalTime加上日期可以构成LocalDateTime，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">20</span>, <span class="number">45</span>, <span class="number">5</span>);</span><br><span class="line">LocalDate ld = ldt.toLocalDate(); <span class="comment">//2017-07-11</span></span><br><span class="line">LocalTime lt = ldt.toLocalTime(); <span class="comment">// 20:45:05</span></span><br><span class="line"><span class="comment">//LocalDate加上时间，结果为2017-07-11 21:18:39</span></span><br><span class="line">LocalDateTime ldt2 = ld.atTime(<span class="number">21</span>, <span class="number">18</span>, <span class="number">39</span>);</span><br><span class="line"><span class="comment">//LocalTime加上日期，结果为2016-03-24 20:45:05</span></span><br><span class="line">LocalDateTime ldt3 = lt.atDate(LocalDate.of(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">24</span>));</span><br></pre></td></tr></table></figure>

<h3 id="5-ZonedDateTime"><a href="#5-ZonedDateTime" class="headerlink" title="5. ZonedDateTime"></a>5. ZonedDateTime</h3><p>ZonedDateTime表示特定时区的日期和时间，获取系统默认时区的当前日期和时间，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime zdt = ZonedDateTime.now();</span><br></pre></td></tr></table></figure>

<p>LocalDateTime.now()也是获取默认时区的当前日期和时间，有什么区别呢？<strong>Local-DateTime内部不会记录时区信息，只会单纯记录年月日时分秒等信息，而ZonedDateTime除了记录日历信息，还会记录时区</strong>，它的其他大部分构建方法都需要显式传递时区，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据Instant和时区构建ZonedDateTime</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">ofInstant</span><span class="params">(Instant instant, ZoneId zone)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据LocalDate、LocalTime和ZoneId构造</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">of</span><span class="params">(LocalDate date, LocalTime time, ZoneId zone)</span></span></span><br></pre></td></tr></table></figure>

<p>ZonedDateTime可以直接转换为Instant，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZonedDateTime ldt = ZonedDateTime.now();</span><br><span class="line">Instant now = ldt.toInstant();</span><br></pre></td></tr></table></figure>

<h2 id="26-5-2-格式化"><a href="#26-5-2-格式化" class="headerlink" title="26.5.2 格式化"></a>26.5.2 格式化</h2><p>Java 8中，主要的格式化类是java.time.format.DateTimeFormatter，它是线程安全的，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(</span><br><span class="line">    <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">LocalDateTime ldt = LocalDateTime.of(<span class="number">2016</span>,<span class="number">8</span>,<span class="number">18</span>,<span class="number">14</span>,<span class="number">20</span>,<span class="number">45</span>);</span><br><span class="line">System.out.println(formatter.format(ldt));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-08-18 14:20:45</span><br></pre></td></tr></table></figure>

<p>将字符串转化为日期和时间对象，可以使用对应类的parse方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(</span><br><span class="line">    <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">String str = <span class="string">&quot;2016-08-18 14:20:45&quot;</span>;</span><br><span class="line">LocalDateTime ldt = LocalDateTime.parse(str, formatter);</span><br></pre></td></tr></table></figure>

<h2 id="26-5-3-设置和修改时间"><a href="#26-5-3-设置和修改时间" class="headerlink" title="26.5.3 设置和修改时间"></a>26.5.3 设置和修改时间</h2><p>修改时期和时间有两种方式，一种是直接设置绝对值，另一种是在现有值的基础上进行相对增减操作，Java 8的大部分类都支持这两种方式。另外，<strong>Java 8的大部分类都是不可变类，修改操作是通过创建并返回新对象来实现的，原对象本身不会变</strong>。我们来看一些例子。</p>
<p>调整时间为下午3点20分，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">ldt = ldt.withHour(<span class="number">15</span>).withMinute(<span class="number">20</span>).withSecond(<span class="number">0</span>).withNano(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>还可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">ldt = ldt.toLocalDate().atTime(<span class="number">15</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>3小时5分钟后，示例代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">ldt = ldt.plusHours(<span class="number">3</span>).plusMinutes(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>LocalDateTime有很多plusXXX和minusXXX方法，分别用于相对增加和减少时间。</p>
<p>今天0点，可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">ldt = ldt.with(ChronoField.MILLI_OF_DAY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>ChronoField是一个枚举，里面定义了很多表示日历的字段，MILLI_OF_DAY表示在一天中的毫秒数，值从0到(24 * 60 * 60 * 1000)-1。还可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(LocalDate.now(), LocalTime.MIN);</span><br></pre></td></tr></table></figure>

<p>LocalTime.MIN表示”00:00”。也可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDate.now().atTime(<span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>下周二上午10点整，可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">ldt = ldt.plusWeeks(<span class="number">1</span>).with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>)</span><br><span class="line">    .with(ChronoField.MILLI_OF_DAY, <span class="number">0</span>).withHour(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上面下周二指定是下周，如果是下一个周二呢？这与当前是周几有关，如果当前是周一，则下一个周二就是明天，而其他情况则是下周，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line"><span class="keyword">if</span>(! ld.getDayOfWeek().equals(DayOfWeek.MONDAY))&#123;</span><br><span class="line">    ld = ld.plusWeeks(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">LocalDateTime ldt = ld.with(ChronoField.DAY_OF_WEEK, <span class="number">2</span>).atTime(<span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>针对这种复杂一点的调整，Java 8有一个专门的接口TemporalAdjuster，这是一个函数式接口，定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Temporal是一个接口，表示日期或时间对象，Instant、LocalDateTime和LocalDate等都实现了它，这个接口就是对日期或时间进行调整，还有一个专门的类TemporalAdjusters，里面提供了很多TemporalAdjuster的实现。比如，针对下一个周几的调整，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">next</span><span class="params">(DayOfWeek dayOfWeek)</span></span></span><br></pre></td></tr></table></figure>

<p>针对上面的例子，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line">LocalDateTime ldt = ld.with(TemporalAdjusters.next(</span><br><span class="line">    DayOfWeek.TUESDAY)).atTime(<span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这个next方法是怎么实现的呢？看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">next</span><span class="params">(DayOfWeek dayOfWeek)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dowValue = dayOfWeek.getValue();</span><br><span class="line">    <span class="keyword">return</span> (temporal) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> calDow = temporal.get(DAY_OF_WEEK);</span><br><span class="line">        <span class="keyword">int</span> daysDiff = calDow - dowValue;</span><br><span class="line">        <span class="keyword">return</span> temporal.plus(daysDiff &gt;= <span class="number">0</span> ? <span class="number">7</span> - daysDiff : -daysDiff, DAYS);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它内部封装了一些条件判断和具体调整，提供了更为易用的接口。</p>
<p>TemporalAdjusters中还有很多方法，部分方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">firstDayOfMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">lastDayOfMonth</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">firstInMonth</span><span class="params">(DayOfWeek dayOfWeek)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">lastInMonth</span><span class="params">(DayOfWeek dayOfWeek)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">previous</span><span class="params">(DayOfWeek dayOfWeek)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">nextOrSame</span><span class="params">(DayOfWeek dayOfWeek)</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法的含义比较直观，就不解释了。它们主要是封装了日期和时间调整的一些基本操作，更为易用。<br>明天最后一刻，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.of(</span><br><span class="line">    LocalDate.now().plusDays(<span class="number">1</span>), LocalTime.MAX);</span><br></pre></td></tr></table></figure>

<p>或者为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalTime.MAX.atDate(LocalDate.now().plusDays(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>本月最后一天最后一刻，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt =   LocalDate.now()</span><br><span class="line">        .with(TemporalAdjusters.lastDayOfMonth()).atTime(LocalTime.MAX);</span><br></pre></td></tr></table></figure>

<p>lastDayOfMonth()是怎么实现的呢？看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TemporalAdjuster <span class="title">lastDayOfMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(temporal) -&gt; temporal.with(DAY_OF_MONTH,</span><br><span class="line">      temporal.range(DAY_OF_MONTH).getMaximum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了range方法，从它的返回值可以获取对应日历单位的最大最小值，展开，本月最后一天最后一刻的代码还可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> maxDayOfMonth = LocalDate.now().range(</span><br><span class="line">    ChronoField.DAY_OF_MONTH).getMaximum();</span><br><span class="line">LocalDateTime ldt =   LocalDate.now()</span><br><span class="line">        .withDayOfMonth((<span class="keyword">int</span>)maxDayOfMonth).atTime(LocalTime.MAX);</span><br></pre></td></tr></table></figure>

<p>下个月第一个周一的下午5点整，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDate.now().plusMonths(<span class="number">1</span>)</span><br><span class="line">    .with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)).atTime(<span class="number">17</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="26-5-4-时间段的计算"><a href="#26-5-4-时间段的计算" class="headerlink" title="26.5.4 时间段的计算"></a>26.5.4 时间段的计算</h2><p>Java 8中表示时间段的类主要有两个：Period和Duration。Period表示日期之间的差，用年月日表示，不能表示时间；Duration表示时间差，用时分秒等表示，也可以用天表示，一天严格等于24小时，不能用年月表示。下面看一些例子。<br>计算两个日期之间的差，看个Period的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate ld1 = LocalDate.of(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">24</span>);</span><br><span class="line">LocalDate ld2 = LocalDate.of(<span class="number">2017</span>, <span class="number">7</span>, <span class="number">12</span>);</span><br><span class="line">Period period = Period.between(ld1, ld2);</span><br><span class="line">System.out.println(period.getYears() + <span class="string">&quot;年&quot;</span></span><br><span class="line">          + period.getMonths() + <span class="string">&quot;月&quot;</span> + period.getDays() + <span class="string">&quot;天&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1年3月18天</span><br></pre></td></tr></table></figure>

<p>根据生日计算年龄，示例代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate born = LocalDate.of(<span class="number">1990</span>,<span class="number">06</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> year = Period.between(born, LocalDate.now()).getYears();</span><br></pre></td></tr></table></figure>

<p>计算迟到分钟数，假定早上9点是上班时间，过了9点算迟到，迟到要统计迟到的分钟数，怎么计算呢？看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lateMinutes = Duration.between(LocalTime.of(<span class="number">9</span>,<span class="number">0</span>),</span><br><span class="line">        LocalTime.now()).toMinutes();</span><br></pre></td></tr></table></figure>

<h2 id="26-5-5-与Date-Calendar对象的转换"><a href="#26-5-5-与Date-Calendar对象的转换" class="headerlink" title="26.5.5 与Date/Calendar对象的转换"></a>26.5.5 与Date/Calendar对象的转换</h2><p>Java 8的日期和时间API没有提供与老的Date/Calendar相互转换的方法，但在实际中，我们可能是需要的。前面介绍了Date可以与Instant通过毫秒数相互转换，对于其他类型，也可以通过毫秒数/Instant相互转换。比如，将LocalDateTime按默认时区转换为Date，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">toDate</span><span class="params">(LocalDateTime ldt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(ldt.atZone(ZoneId.systemDefault())</span><br><span class="line">            .toInstant().toEpochMilli());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将ZonedDateTime转换为Calendar，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">toCalendar</span><span class="params">(ZonedDateTime zdt)</span> </span>&#123;</span><br><span class="line">    TimeZone tz = TimeZone.getTimeZone(zdt.getZone());</span><br><span class="line">    Calendar calendar = Calendar.getInstance(tz);</span><br><span class="line">    calendar.setTimeInMillis(zdt.toInstant().toEpochMilli());</span><br><span class="line">    <span class="keyword">return</span> calendar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Calendar保持了ZonedDateTime的时区信息。</p>
<p>将Date按默认时区转换为LocalDateTime，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">toLocalDateTime</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> LocalDateTime.ofInstant(Instant.ofEpochMilli(date.getTime()),</span><br><span class="line">    ZoneId.systemDefault());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Calendar转换为ZonedDateTime，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ZonedDateTime <span class="title">toZonedDateTime</span><span class="params">(Calendar calendar)</span> </span>&#123;</span><br><span class="line">    ZonedDateTime zdt = ZonedDateTime.ofInstant(</span><br><span class="line">        Instant.ofEpochMilli(calendar.getTimeInMillis()),</span><br><span class="line">        calendar.getTimeZone().toZoneId());</span><br><span class="line">    <span class="keyword">return</span> zdt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，关于Java 8的日期和时间API就介绍完了。相比以前版本的Date和Calendar，它引入了更多的类，但概念更为清晰，更为强大和易用。</p>
<p>本章介绍了Java 8引入的Lambda表达式、函数式编程，以及日期和时间API，利用本章介绍的内容，我们可以在更高的抽象层次上思考和解决问题，包括处理集合数据、管理异步任务、操作日期和时间等。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8a357756/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8a357756/" class="post-title-link" itemprop="url">26.4 组合式异步编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:08 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:08+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC26%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第26章 函数式编程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8a357756/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8a357756/" data-xid="/JavaReadingNotes/8a357756/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="26-4-组合式异步编程"><a href="#26-4-组合式异步编程" class="headerlink" title="26.4 组合式异步编程"></a>26.4 组合式异步编程</h1><p>前面两节讨论了Java 8中的函数式数据处理，那是对容器类的增强，它可以将对集合数据的多个操作以流水线的方式组合在一起。本节继续讨论Java 8的新功能，主要是一个新的类CompletableFuture，它是对并发编程的增强，<strong>它可以方便地将多个有一定依赖关系的异步任务以流水线的方式组合在一起，大大简化多异步任务的开发</strong>。</p>
<p>之前介绍了那么多并发编程的内容，还有什么问题不能解决？CompletableFuture到底能解决什么问题？与之前介绍的内容有什么关系？具体如何使用？基本原理是什么？本节进行详细讨论，我们先来看它要解决的问题。</p>
<h2 id="26-4-1-异步任务管理"><a href="#26-4-1-异步任务管理" class="headerlink" title="26.4.1 异步任务管理"></a>26.4.1 异步任务管理</h2><p>在现代软件开发中，系统功能越来越复杂，管理复杂度的方法就是分而治之，系统的很多功能可能会被切分为小的服务，对外提供Web API，单独开发、部署和维护。比如，在一个电商系统中，可能有专门的产品服务、订单服务、用户服务、推荐服务、优惠服务、搜索服务等，在对外具体展示一个页面时，可能要调用多个服务，而多个调用之间可能还有一定的依赖。比如，显示一个产品页面，需要调用产品服务，也可能需要调用推荐服务获取与该产品有关的其他推荐，还可能需要调用优惠服务获取该产品相关的促销优惠，而为了调用优惠服务，可能需要先调用用户服务以获取用户的会员级别。</p>
<p>另外，现代软件经常依赖很多第三方服务，比如地图服务、短信服务、天气服务、汇率服务等，在实现一个具体功能时，可能要访问多个这样的服务，这些访问之间可能存在着一定的依赖关系。</p>
<p>为了提高性能，充分利用系统资源，这些对外部服务的调用一般都应该是异步的、尽量并发的。我们之前介绍过异步任务执行服务，使用ExecutorService可以方便地提交单个独立的异步任务，可以方便地在需要的时候通过Future接口获取异步任务的结果，但对于多个尤其是有一定依赖关系的异步任务，这种支持就不够了。</p>
<p>于是，就有了CompletableFuture，它是一个具体的类，实现了两个接口，一个是Future，另一个是CompletionStage。Future表示异步任务的结果，而CompletionStage的字面意思是完成阶段。<strong>多个CompletionStage可以以流水线的方式组合起来，对于其中一个CompletionStage，它有一个计算任务，但可能需要等待其他一个或多个阶段完成才能开始，它完成后，可能会触发其他阶段开始运行</strong>。CompletionStage提供了大量方法，使用它们，可以方便地响应任务事件，构建任务流水线，实现组合式异步编程。</p>
<p>具体怎么使用呢？下面我们会逐步说明，CompletableFuture也是一个Future，我们先来看与Future类似的地方。</p>
<h2 id="26-4-2-与Future-FutureTask对比"><a href="#26-4-2-与Future-FutureTask对比" class="headerlink" title="26.4.2 与Future/FutureTask对比"></a>26.4.2 与Future/FutureTask对比</h2><p>我们先通过示例来简要回顾下异步任务执行服务和Future。</p>
<h3 id="1．基本的任务执行服务"><a href="#1．基本的任务执行服务" class="headerlink" title="1．基本的任务执行服务"></a>1．基本的任务执行服务</h3><p>在异步任务执行服务中，用Callable或Runnable表示任务。以Callable为例，一个模拟的外部任务为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">delayRandom</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> milli = max &gt; min ? rnd.nextInt(max - min) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(min + milli);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> milli;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Callable&lt;Integer&gt; externalTask = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> time = delayRandom(<span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>externalTask表示外部任务，我们使用了Lambda表达式，delayRandom用于模拟延时。</p>
<p>假定有一个异步任务执行服务，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor =</span><br><span class="line">        Executors.newFixedThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>通过任务执行服务调用外部服务，一般返回Future，表示异步结果，示例代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> executor.submit(externalTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主程序中，结合异步任务和本地调用的示例代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">master</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行异步任务</span></span><br><span class="line">    Future&lt;Integer&gt; asyncRet = callExternalService();</span><br><span class="line">    <span class="comment">//执行其他任务……</span></span><br><span class="line">    <span class="comment">//获取异步任务的结果，处理可能的异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Integer ret = asyncRet.get();</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2．基本的CompletableFuture"><a href="#2．基本的CompletableFuture" class="headerlink" title="2．基本的CompletableFuture"></a>2．基本的CompletableFuture</h3><p>使用CompletableFuture可以实现类似功能，不过，它不支持使用Callable表示异步任务，而支持Runnable和Supplier。Supplier替代Callable表示有返回结果的异步任务，与Callable的区别是，它不能抛出受检异常，如果会发生异常，可以抛出运行时异常。</p>
<p>使用Supplier表示异步任务，代码与Callable类似，替换变量类型即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Supplier&lt;Integer&gt; externalTask = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> time = delayRandom(<span class="number">20</span>, <span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用CompletableFuture调用外部服务的代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(externalTask, executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>supplyAsync是一个静态方法，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<p>它接受两个参数supplier和executor，使用executor执行supplier表示的任务，返回一个CompletableFuture，调用后，任务被异步执行，这个方法立即返回。</p>
<p>supplyAsync还有一个不带executor参数的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br></pre></td></tr></table></figure>

<p>没有executor，任务被谁执行呢？与系统环境和配置有关，一般来说，如果可用的CPU核数大于2，会使用Java 7引入的Fork/Join任务执行服务，即ForkJoinPool.common-Pool()，该任务执行服务背后的工作线程数一般为CPU核数减1，即Runtime.getRuntime(). availableProcessors()-1，否则，会使用ThreadPerTaskExecutor，它会为每个任务创建一个线程。</p>
<p>对于CPU密集型的运算任务，使用Fork/Join任务执行服务是合适的，但对于一般的调用外部服务的异步任务，Fork/Join可能是不合适的，因为它的并行度比较低，可能会让本可以并发的多任务串行运行，这时，应该提供Executor参数。</p>
<p>后面我们还会看到很多以Async结尾命名的方法，一般都有两个版本，一个带Executor参数，另一个不带，其含义是相同的，就不再重复介绍了。</p>
<p>对于类型为Runnable的任务，构建CompletableFuture的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Runnable runnable, Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<p>它与supplyAsync是类似的，具体就不赘述了。</p>
<h3 id="3-CompletableFuture对Future的基本增强"><a href="#3-CompletableFuture对Future的基本增强" class="headerlink" title="3. CompletableFuture对Future的基本增强"></a>3. CompletableFuture对Future的基本增强</h3><p>Future有的接口，CompletableFuture都是支持的，不过，CompletableFuture还有一些额外的相关方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCompletedExceptionally</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getNow</span><span class="params">(T valueIfAbsent)</span></span></span><br></pre></td></tr></table></figure>

<p>join与get方法类似，也会等待任务结束，但它不会抛出受检异常。如果任务异常结束了，join会将异常包装为运行时异常CompletionException抛出。</p>
<p>Future有isDone方法检查任务是否结束了，但不知道任务是正常结束还是异常结束， isCompletedExceptionally方法可以判断任务是否是异常结束。</p>
<p>getNow与join类似，区别是，如果任务还没有结束，getNow不会等待，而是会返回传入的参数valueIfAbsent。</p>
<h3 id="4．进一步理解Future-CompletableFuture"><a href="#4．进一步理解Future-CompletableFuture" class="headerlink" title="4．进一步理解Future/CompletableFuture"></a>4．进一步理解Future/CompletableFuture</h3><p>前面例子都使用了任务执行服务，其实，任务执行服务与异步结果Future不是绑在一起的，可以自己创建线程返回异步结果。为进一步理解，我们看些示例。</p>
<p>使用FutureTask调用外部服务，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(externalTask);</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            future.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部自己创建了一个线程，线程调用FutureTask的run方法。我们之前分析过Future-Task的代码，run方法会调用externalTask的call方法，并保存结果或碰到的异常，唤醒等待结果的线程。</p>
<p>使用CompletableFuture，也可以直接创建线程，并返回异步结果，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Future&lt;Integer&gt; <span class="title">callExternalService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                future.complete(externalTask.get());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                future.completeExceptionally(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了CompletableFuture的两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">complete</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">completeExceptionally</span><span class="params">(Throwable ex)</span></span></span><br></pre></td></tr></table></figure>

<p>这两个方法显式设置任务的状态和结果，complete设置任务成功完成，结果为value, completeExceptionally设置任务异常结束，异常为ex。Future接口没有对应的方法，Future-Task有相关方法但不是public的（是protected的）。设置完后，它们都会触发其他依赖它们的CompletionStage。具体会触发什么呢？我们接下来再看。</p>
<h2 id="26-4-3-响应结果或异常"><a href="#26-4-3-响应结果或异常" class="headerlink" title="26.4.3 响应结果或异常"></a>26.4.3 响应结果或异常</h2><p>使用Future，我们只能通过get获取结果，而get可能会需要阻塞等待，而通过Com-pletionStage，可以注册回调函数，当任务完成或异常结束时自动触发执行。有两类注册方法：whenComplete和handle，我们分别介绍。</p>
<h3 id="1-whenComplete"><a href="#1-whenComplete" class="headerlink" title="1. whenComplete"></a>1. whenComplete</h3><p>whenComplete的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>参数action表示回调函数，不管前一个阶段是正常结束还是异常结束，它都会被调用，函数类型是BiConsumer，接受两个参数，第一个参数是正常结束时的结果值，第二个参数是异常结束时的异常，BiConsumer没有返回值。whenComplete的返回值还是CompletableFuture，它不会改变原阶段的结果，还可以在其上继续调用其他函数。看个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(externalTask).whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(result ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ex ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).join();</span><br></pre></td></tr></table></figure>

<p>result表示前一个阶段的结果，ex表示异常，只可能有一个不为null。</p>
<p>whenComplete注册的函数具体由谁执行呢？一般而言，这要看注册时任务的状态。如果注册时任务还没有结束，则注册的函数会由执行任务的线程执行，在该线程执行完任务后执行注册的函数；如果注册时任务已经结束了，则由当前线程（即调用注册函数的线程）执行。</p>
<p>如果不希望当前线程执行，避免可能的同步阻塞，可以使用其他两个异步注册方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<p>与前面介绍的以Async结尾的方法一样，对第一个方法，注册函数action会由默认的任务执行服务（即ForkJoinPool.commonPool()或ThreadPerTaskExecutor）执行；对第二个方法，会由参数中指定的executor执行。</p>
<h3 id="2-handle"><a href="#2-handle" class="headerlink" title="2. handle"></a>2. handle</h3><p>whenComplete只是注册回调函数，不改变结果，它返回了一个CompletableFuture，但这个CompletableFuture的结果与调用它的CompletableFuture是一样的，还有一个类似的注册方法handle，其声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">handle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>回调函数是一个BiFunction，也是接受两个参数，一个是正常结果，另一个是异常，但BiFunction有返回值，在handle返回的CompletableFuture中，结果会被BiFunction的返回值替代，即使原来有异常，也会被覆盖，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String ret =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;).handle((result, ex)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;).join();</span><br><span class="line">System.out.println(ret);</span><br></pre></td></tr></table></figure>

<p>输出为”hello”。异步任务抛出了异常，但通过handle方法，改变了结果。</p>
<p>与whenComplete类似，handle也有对应的异步注册方法handleAsync，具体我们就不探讨了。</p>
<h3 id="3-exceptionally"><a href="#3-exceptionally" class="headerlink" title="3. exceptionally"></a>3. exceptionally</h3><p>whenComplete和handle都是既响应正常完成也响应异常，如果只对异常感兴趣，可以使用exceptionally，其声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Function&lt;Throwable, ? extends T&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>它注册的回调函数是Function，接受的参数为异常，返回一个值，与handle类似，它也会改变结果，具体就不举例了。</p>
<p>除了响应结果和异常，使用CompletableFuture，可以方便地构建有多种依赖关系的任务流，我们先来看简单的依赖单一阶段的情况。</p>
<h2 id="26-4-4-构建依赖单一阶段的任务流"><a href="#26-4-4-构建依赖单一阶段的任务流" class="headerlink" title="26.4.4 构建依赖单一阶段的任务流"></a>26.4.4 构建依赖单一阶段的任务流</h2><p>我们来看几个相关的方法——thenRun、thenAccept/thenApply和thenCompose。</p>
<h3 id="1-thenRun"><a href="#1-thenRun" class="headerlink" title="1. thenRun"></a>1. thenRun</h3><p>在一个阶段正常完成后，执行下一个任务，看个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable taskA = () -&gt; System.out.println(<span class="string">&quot;task A&quot;</span>);</span><br><span class="line">Runnable taskB = () -&gt; System.out.println(<span class="string">&quot;task B&quot;</span>);</span><br><span class="line">Runnable taskC = () -&gt; System.out.println(<span class="string">&quot;task C&quot;</span>);</span><br><span class="line">CompletableFuture.runAsync(taskA).thenRun(taskB).thenRun(taskC).join();</span><br></pre></td></tr></table></figure>

<p>这里，有三个异步任务taskA、taskB和taskC，通过thenRun自然地描述了它们的依赖关系。thenRun是同步版本，有对应的异步版本thenRunAsync：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action,</span></span></span><br><span class="line"><span class="params"><span class="function">    Executor executor)</span></span></span><br></pre></td></tr></table></figure>

<p>在thenRun构建的任务流中，只有前一个阶段没有异常结束，下一个阶段的任务才会执行，如果前一个阶段发生了异常，所有后续阶段都不会运行，结果会被设为相同的异常，调用join会抛出运行时异常CompletionException。</p>
<h3 id="2-thenAccept-thenApply"><a href="#2-thenAccept-thenApply" class="headerlink" title="2. thenAccept/thenApply"></a>2. thenAccept/thenApply</h3><p>如果下一个任务需要前一个阶段的结果作为参数，可以使用thenAccept或thenApply方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>thenAccept的任务类型是Consumer，它接受前一个阶段的结果作为参数，没有返回值。thenApply的任务类型是Function，接受前一个阶段的结果作为参数，返回一个新的值，这个值会成为thenApply返回的CompletableFuture的结果值。看个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; taskA = () -&gt; <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Function&lt;String, String&gt; taskB = (t) -&gt; t.toUpperCase();</span><br><span class="line">Consumer&lt;String&gt; taskC = (t) -&gt; System.out.println(<span class="string">&quot;consume: &quot;</span> + t);</span><br><span class="line">CompletableFuture.supplyAsync(taskA)</span><br><span class="line">    .thenApply(taskB).thenAccept(taskC).join();</span><br></pre></td></tr></table></figure>

<p>taskA的结果是”hello”，传递给了taskB, taskB转换结果为”HELLO”，再把结果给taskC, taskC进行了输出，所以输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consume: HELLO</span><br></pre></td></tr></table></figure>

<p>CompletableFuture中有很多名称带有run、accept或apply的方法，它们一般与任务的类型相对应，run与Runnable对应，accept与Consumer对应，apply与Function对应，后续就不赘述了。</p>
<h3 id="3-thenCompose"><a href="#3-thenCompose" class="headerlink" title="3. thenCompose"></a>3. thenCompose</h3><p>与thenApply类似，还有一个方法thenCompose，声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span></span><br></pre></td></tr></table></figure>

<p>这个任务类型也是Function，也是接受前一个阶段的结果，返回一个新的结果。不过，这个转换函数fn的返回值类型是CompletionStage，也就是说，它的返回值也是一个阶段，如果使用thenApply，结果就会变为<code>CompletableFuture&lt;CompletableFuture&lt;U&gt;&gt;</code>，而使用thenCompose，会直接返回fn返回的CompletionStage。thenCompose与thenApply的区别就如同Stream API中flatMap与map的区别，看个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; taskA = () -&gt; <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">Function&lt;String, CompletableFuture&lt;String&gt;&gt; taskB = (t) -&gt;</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; t.toUpperCase());</span><br><span class="line">Consumer&lt;String&gt; taskC = (t) -&gt; System.out.println(<span class="string">&quot;consume: &quot;</span> + t);</span><br><span class="line">CompletableFuture.supplyAsync(taskA)</span><br><span class="line">        .thenCompose(taskB).thenAccept(taskC).join();</span><br></pre></td></tr></table></figure>

<p>以上代码中，taskB是一个转换函数，但它自己也执行了异步任务，返回类型也是CompletableFuture，所以使用了thenCompose。</p>
<h2 id="26-4-5-构建依赖两个阶段的任务流"><a href="#26-4-5-构建依赖两个阶段的任务流" class="headerlink" title="26.4.5 构建依赖两个阶段的任务流"></a>26.4.5 构建依赖两个阶段的任务流</h2><p>thenRun、thenAccept、thenApply和thenCompose用于在一个阶段完成后执行另一个任务，CompletableFuture还有一些方法用于在两个阶段都完成后执行另一个任务，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? &gt; other, Runnable action</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">public</span> &lt;U, V&gt; CompletableFuture&lt;V&gt; thenCombine(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="params"><span class="function">    BiFunction&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U, ? extends V&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends U&gt; other,</span></span></span><br><span class="line"><span class="params"><span class="function">    BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>runAfterBoth对应的任务类型是Runnable, thenCombine对应的任务类型是BiFunction，接受前两个阶段的结果作为参数，返回一个结果；thenAcceptBoth对应的任务类型是BiConsumer，接受前两个阶段的结果作为参数，但不返回结果。它们都有对应的异步和带Executor参数的版本，用于指定下一个任务由谁执行，具体就不赘述了。当前阶段和参数指定的另一个阶段other没有依赖关系，并发执行，当两个都执行结束后，开始执行指定的另一个任务。</p>
<p>看个简单的示例，任务A和B执行结束后，执行任务C合并结果，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; taskA = () -&gt; <span class="string">&quot;taskA&quot;</span>;</span><br><span class="line">CompletableFuture&lt;String&gt; taskB = CompletableFuture.supplyAsync(</span><br><span class="line">    () -&gt; <span class="string">&quot;taskB&quot;</span>);</span><br><span class="line">BiFunction&lt;String, String, String&gt; taskC = (a, b) -&gt; a + <span class="string">&quot;, &quot;</span> + b;</span><br><span class="line">String ret = CompletableFuture.supplyAsync(taskA)</span><br><span class="line">        .thenCombineAsync(taskB, taskC).join();</span><br><span class="line">System.out.println(ret);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskA, taskB</span><br></pre></td></tr></table></figure>

<p>前面的方法要求两个阶段都完成后才执行下一个任务，如果只需要其中任意一个阶段完成，可以使用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? &gt; other, Runnable action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">applyToEither</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends T&gt; other, Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    CompletionStage&lt;? extends T&gt; other, Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>它们都有对应的异步和带Executor参数的版本，用于指定下一个任务由谁执行，具体就不赘述了。当前阶段和参数指定的另一个阶段other没有依赖关系，并发执行，只要其中一个执行完了，就会启动参数指定的另一个任务，具体就不赘述了。</p>
<h2 id="26-4-6-构建依赖多个阶段的任务流"><a href="#26-4-6-构建依赖多个阶段的任务流" class="headerlink" title="26.4.6 构建依赖多个阶段的任务流"></a>26.4.6 构建依赖多个阶段的任务流</h2><p>如果依赖的阶段不止两个，可以使用如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">allOf</span><span class="params">(CompletableFuture&lt;? &gt;... cfs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Object&gt; <span class="title">anyOf</span><span class="params">(CompletableFuture&lt;? &gt;... cfs)</span></span></span><br></pre></td></tr></table></figure>

<p>它们是静态方法，基于多个CompletableFuture构建了一个新的CompletableFuture。</p>
<p>对于allOf，当所有子CompletableFuture都完成时，它才完成，如果有的Completable-Future异常结束了，则新的CompletableFuture的结果也是异常。不过，它并不会因为有异常就提前结束，而是会等待所有阶段结束，如果有多个阶段异常结束，新的Com-pletableFuture中保存的异常是最后一个的。新的CompletableFuture会持有异常结果，但不会保存正常结束的结果，如果需要，可以从每个阶段中获取。看个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; taskA = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    delayRandom(<span class="number">100</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloA&quot;</span>;</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;Void&gt; taskB = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    delayRandom(<span class="number">2000</span>, <span class="number">3000</span>);</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture&lt;Void&gt; taskC = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">    delayRandom(<span class="number">30</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;task C exception&quot;</span>);</span><br><span class="line">&#125;, executor);</span><br><span class="line">CompletableFuture.allOf(taskA, taskB, taskC).whenComplete((result, ex) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(ex ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(! taskA.isCompletedExceptionally()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task A &quot;</span> + taskA.join());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>taskC会首先异常结束，但新构建的CompletableFuture会等待其他两个阶段结束，都结束后，可以通过子阶段（如taskA）的方法检查子阶段的状态和结果。</p>
<p>对于anyOf返回的CompletableFuture，当第一个子CompletableFuture完成或异常结束时，它相应地完成或异常结束，结果与第一个结束的子CompletableFuture一样，具体就不举例了。</p>
<h2 id="26-4-7-小结"><a href="#26-4-7-小结" class="headerlink" title="26.4.7 小结"></a>26.4.7 小结</h2><p>本节介绍了Java 8中的组合式异步编程CompletableFuture：<br>1）它是对Future的增强，但可以响应结果或异常事件，有很多方法构建异步任务流。<br>2）根据任务由谁执行，一般有三类对应方法：名称不带Async的方法由当前线程或前一个阶段的线程执行，带Async但没有指定Executor的方法由默认Excecutor（Fork-JoinPool.commonPool()或ThreadPerTaskExecutor）执行，带Async且指定Executor参数的方法由指定的Executor执行。<br>3）根据任务类型，一般也有三类对应方法：名称带run的对应Runnable，带accept的对应Consumer，带apply的对应Function。</p>
<p><strong>使用CompletableFuture，可以简洁自然地表达多个异步任务之间的依赖关系和执行流程，大大简化代码，提高可读性</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/5dff3f09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/5dff3f09/" class="post-title-link" itemprop="url">26.3 函数式数据处理：强大方便的收集器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:07 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:07+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC26%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第26章 函数式编程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/5dff3f09/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/5dff3f09/" data-xid="/JavaReadingNotes/5dff3f09/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>16k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="26-3-函数式数据处理：强大方便的收集器"><a href="#26-3-函数式数据处理：强大方便的收集器" class="headerlink" title="26.3 函数式数据处理：强大方便的收集器"></a>26.3 函数式数据处理：强大方便的收集器</h1><p>对于collect方法，前面只是演示了其最基本的应用，它还有很多强大的功能，比如，可以分组统计汇总，实现类似数据库查询语言SQL中的group by功能。具体都有哪些功能？有什么用？如何使用？基本原理是什么？让我们逐步进行探讨，先来进一步理解collect方法。</p>
<h2 id="26-3-1-理解collect"><a href="#26-3-1-理解collect" class="headerlink" title="26.3.1 理解collect"></a>26.3.1 理解collect</h2><p>在上节中，过滤得到90分以上的学生列表，代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; above90List = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>最后的collect调用看上去很神奇，它到底是怎么把Stream转换为<code>List&lt;Student&gt;</code>的呢？先看下collect方法的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span></span><br></pre></td></tr></table></figure>

<p>它接受一个收集器collector作为参数，类型是Collector，这是一个接口，它的定义基本上是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在顺序流中，collect方法与这些接口方法的交互大概是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先调用工厂方法supplier创建一个存放处理状态的容器container，类型为A</span></span><br><span class="line">A container = collector.supplier().get();</span><br><span class="line"><span class="comment">//对流中的每一个元素t，调用累加器accumulator，参数为累计状态container和当前元素t</span></span><br><span class="line"><span class="keyword">for</span>(T t : data)</span><br><span class="line">    collector.accumulator().accept(container, t);</span><br><span class="line"><span class="comment">//最后调用finisher对累计状态container进行可能的调整，类型转换(A转换为R)，返回结果</span></span><br><span class="line"><span class="keyword">return</span> collector.finisher().apply(container);</span><br></pre></td></tr></table></figure>

<p>combiner只在并行流中有用，用于合并部分结果。characteristics用于标示收集器的特征，Collector接口的调用者可以利用这些特征进行一些优化。Characteristics是一个枚举，有三个值：CONCURRENT、UNORDERED和IDENTITY_FINISH，它们的含义我们后面通过例子简要说明，目前可以忽略。</p>
<p>Collectors.toList()具体是什么呢？看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ? , List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                              (left, right) -&gt;&#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                              CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现类是CollectorImpl，这是Collectors内部的一个私有类，实现很简单，主要就是定义了两个构造方法，接受函数式参数并赋值给内部变量。对toList来说：<br>1）supplier的实现是ArrayList::new，也就是创建一个ArrayList作为容器。<br>2）accumulator的实现是List::add，也就是将碰到的每一个元素加到列表中。<br>3）第三个参数是combiner，表示合并结果。<br>4）第四个参数CH_ID是一个静态变量，只有一个特征IDENTITY_FINISH，表示finisher没有什么事情可以做，就是把累计状态container直接返回。</p>
<p>也就是说，collect(Collectors.toList())背后的伪代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(T t : data)</span><br><span class="line">    container.add(t);</span><br><span class="line"><span class="keyword">return</span> container;</span><br></pre></td></tr></table></figure>

<h2 id="26-3-2-容器收集器"><a href="#26-3-2-容器收集器" class="headerlink" title="26.3.2 容器收集器"></a>26.3.2 容器收集器</h2><p>与toList类似的容器收集器还有toSet、toCollection、toMap等，我们来进行介绍。</p>
<h3 id="1-toSet"><a href="#1-toSet" class="headerlink" title="1. toSet"></a>1. toSet</h3><p>toSet的使用与toList类似，只是它可以排重，就不举例了。toList背后的容器是ArrayList, toSet背后的容器是HashSet，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ? , Set&lt;T&gt;&gt; toSet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;Set&lt;T&gt;&gt;) HashSet::<span class="keyword">new</span>, Set::add,</span><br><span class="line">                              (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                              CH_UNORDERED_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CH_UNORDERED_ID是一个静态变量，它的特征有两个：一个是IDENTITY_FINISH，表示返回结果即为Supplier创建的HashSet；另一个是UNORDERED，表示收集器不会保留顺序，这也容易理解，因为背后容器是HashSet。</p>
<h3 id="2-toCollection"><a href="#2-toCollection" class="headerlink" title="2. toCollection"></a>2. toCollection</h3><p>toCollection是一个通用的容器收集器，可以用于任何Collection接口的实现类，它接受一个工厂方法Supplier作为参数，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt;</span><br><span class="line">Collector&lt;T, ? , C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(collectionFactory, Collection&lt;T&gt;::add,</span><br><span class="line">                                (r1, r2) -&gt; &#123; r1.addAll(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">                                CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，如果希望排重但又希望保留出现的顺序，可以使用LinkedHashSet,Collector可以这么创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collectors.toCollection(LinkedHashSet::<span class="keyword">new</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-toMap"><a href="#3-toMap" class="headerlink" title="3. toMap"></a>3. toMap</h3><p>toMap将元素流转换为一个Map，我们知道，Map有键和值两部分，toMap至少需要两个函数参数，一个将元素转换为键，另一个将元素转换为值，其基本定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ? , Map&lt;K, U&gt;&gt; toMap(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper)</span><br></pre></td></tr></table></figure>

<p>返回结果为<code>Map&lt;K,U&gt;</code>, keyMapper将元素转换为键，valueMapper将元素转换为值。比如，将学生流转换为学生名称和分数的Map，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Double&gt; nameScoreMap = students.stream().collect(</span><br><span class="line">        Collectors.toMap(Student::getName, Student::getScore));</span><br></pre></td></tr></table></figure>

<p>这里，<code>Student::getName</code>是keyMapper, <code>Student::getScore</code>是valueMapper。</p>
<p>实践中，经常需要将一个对象列表按主键转换为一个Map，以便以后按照主键进行快速查找，比如，假定Student的主键是id，希望转换学生流为学生id和学生对象的Map，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Student&gt; byIdMap = students.stream().collect(</span><br><span class="line">        Collectors.toMap(Student::getId, t -&gt; t));</span><br></pre></td></tr></table></figure>

<p><code>t-&gt;t</code>是valueMapper，表示值就是元素本身。这个函数用得比较多，接口Function定义了一个静态函数identity表示它。也就是说，上面的代码可以替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Student&gt; byIdMap = students.stream().collect(</span><br><span class="line">        Collectors.toMap(Student::getId, Function.identity()));</span><br></pre></td></tr></table></figure>

<p>上面的toMap假定元素的键不能重复，如果有重复的，会抛出异常，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; strLenMap = Stream.of(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;abc&quot;</span>).collect(</span><br><span class="line">        Collectors.toMap(Function.identity(), t-&gt;t.length()));</span><br></pre></td></tr></table></figure>

<p>希望得到字符串与其长度的Map，但由于包含重复字符串”abc”，程序会抛出异常。这种情况下，我们希望的是程序忽略后面重复出现的元素，这时，可以使用另一个toMap函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U&gt; Collector&lt;T, ? , Map&lt;K, U&gt;&gt; toMap(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">    BinaryOperator&lt;U&gt; mergeFunction)</span><br></pre></td></tr></table></figure>

<p>相比前面的toMap，它接受一个额外的参数mergeFunction，它用于处理冲突，在收集一个新元素时，如果新元素的键已经存在了，系统会将新元素的值与键对应的旧值一起传递给mergeFunction得到一个值，然后用这个值给键赋值。</p>
<p>对于前面字符串长度的例子，新值与旧值其实是一样的，我们可以用任意一个值，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; strLenMap = Stream.of(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;abc&quot;</span>).collect(</span><br><span class="line">        Collectors.toMap(Function.identity(),</span><br><span class="line">                t-&gt;t.length(), (oldValue, value)-&gt;value));</span><br></pre></td></tr></table></figure>

<p>有时，我们可能希望合并新值与旧值，比如一个联系人列表，对于相同的联系人，我们希望合并电话号码，mergeFunction可以定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;String&gt; mergeFunction = (oldPhone, phone)-&gt;oldPhone+<span class="string">&quot;, &quot;</span>+phone;</span><br></pre></td></tr></table></figure>

<p>toMap还有一个更为通用的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, U, M extends Map&lt;K, U&gt;&gt; Collector&lt;T, ? , M&gt; toMap(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper,</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,</span><br><span class="line">    BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier)</span><br></pre></td></tr></table></figure>

<p>相比前面的toMap，多了一个mapSupplier，它是Map的工厂方法，对于前面的两个toMap，其mapSupplier其实是HashMap::new。我们知道，HashMap是没有任何顺序的，如果希望保持元素出现的顺序，可以替换为LinkedHashMap，如果希望收集的结果排序，可以使用TreeMap。</p>
<p>toMap主要用于顺序流，对于并发流，Collectors有专门的名为toConcurrentMap的收集器，它内部使用ConcurrentHashMap，用法类似，具体我们就不讨论了。</p>
<h2 id="26-3-3-字符串收集器"><a href="#26-3-3-字符串收集器" class="headerlink" title="26.3.3 字符串收集器"></a>26.3.3 字符串收集器</h2><p>除了将元素流收集到容器中，另一个常见的操作是收集为一个字符串。比如，获取所有的学生名称，用逗号连接起来，传统上代码看上去像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span>(Student t : students)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sb.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sb.append(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(t.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br></pre></td></tr></table></figure>

<p>针对这种常见的需求，Collectors提供了joining收集器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ? , String&gt; joining()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ? , String&gt; joining(</span><br><span class="line">    CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure>

<p>第一个就是简单地把元素连接起来，第二个支持一个分隔符，还可以给整个结果字符串加前缀和后缀，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String result = Stream.of(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;老马&quot;</span>, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;[&quot;</span>, <span class="string">&quot;]&quot;</span>));</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[abc，老马，hello]</span><br></pre></td></tr></table></figure>

<p>joining的内部也利用了StringBuilder。比如，第一个joining函数的代码为：</p>
<p>[插图]</p>
<p>supplier是<code>StringBuilder::new</code>, accumulator是<code>StringBuilder::append</code>, finisher是<code>StringBuilder::toString</code>, CH_NOID表示特征集为空。</p>
<h2 id="26-3-4-分组"><a href="#26-3-4-分组" class="headerlink" title="26.3.4 分组"></a>26.3.4 分组</h2><p>分组类似于数据库查询语言SQL中的group by语句，它将元素流中的每个元素分到一个组，可以针对分组再进行处理和收集。分组的功能比较强大，我们逐步来说明。</p>
<p>为便于举例，我们先修改下学生类Student，增加一个字段grade表示年级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ? , String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">            StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">            (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">            StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例学生列表students改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String grade, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    <span class="keyword">this</span>.score = score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1．基本用法"><a href="#1．基本用法" class="headerlink" title="1．基本用法"></a>1．基本用法</h3><p>最基本的分组收集器为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student[] &#123;</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">91d</span>), <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">89d</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">50d</span>), <span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="number">78d</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;sunqi&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="number">59d</span>)&#125;);</span><br></pre></td></tr></table></figure>

<p>参数是一个类型为Function的分组器classifier，它将类型为T的元素转换为类型为K的一个值，这个值表示分组值，所有分组值一样的元素会被归为同一个组，放到一个列表中，所以返回值类型是<code>Map&lt;K, List&lt;T&gt;&gt;</code>。比如，将学生流按照年级进行分组，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ? , Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">    groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br></pre></td></tr></table></figure>

<p>学生会分为两组：第一组键为”1”，分组学生包括”zhangsan””wangwu”和”sunqi”；第二组键为”2”，分组学生包括”lisi” “zhaoliu”。这段代码基本等同于如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; groups = students.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Student::getGrade));</span><br></pre></td></tr></table></figure>

<p>显然，使用groupingBy要简洁清晰得多，但它到底是怎么实现的呢？</p>
<h3 id="2．基本原理"><a href="#2．基本原理" class="headerlink" title="2．基本原理"></a>2．基本原理</h3><p>groupingBy的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; groups = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    String key = t.getGrade();</span><br><span class="line">    List&lt;Student&gt; container = groups.get(key);</span><br><span class="line">    <span class="keyword">if</span>(container == <span class="keyword">null</span>) &#123;</span><br><span class="line">        container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        groups.put(key, container);</span><br><span class="line">    &#125;</span><br><span class="line">    container.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了第二个groupingBy方法，传递了toList收集器，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ? , Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法接受一个下游收集器downstream作为参数，然后传递给下面更通用的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ? , Map&lt;K, D&gt;&gt; groupingBy(</span><br><span class="line">        Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</span><br><span class="line">        Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>classifier还是分组器，mapFactory是返回Map的工厂方法，默认是HashMap::new, downstream表示下游收集器，<strong>下游收集器负责收集同一个分组内元素的结果</strong>。</p>
<p>对最通用的groupingBy函数返回的收集器，其收集元素的基本过程和伪代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建一个存放结果的Map</span></span><br><span class="line">Map map = mapFactory.get();</span><br><span class="line"><span class="keyword">for</span>(T t : data) &#123;</span><br><span class="line">    <span class="comment">//对每一个元素，先分组</span></span><br><span class="line">    K key = classifier.apply(t);</span><br><span class="line">    <span class="comment">//找存放分组结果的容器，如果没有，让下游收集器创建，并放到Map中</span></span><br><span class="line">    A container = map.get(key);</span><br><span class="line">    <span class="keyword">if</span>(container == <span class="keyword">null</span>) &#123;</span><br><span class="line">        container = downstream.supplier().get();</span><br><span class="line">        map.put(key, container);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将元素交给下游收集器(即分组收集器)收集</span></span><br><span class="line">    downstream.accumulator().accept(container, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用分组收集器的finisher方法，转换结果</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">    entry.setValue(downstream.finisher().apply(entry.getValue()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> map;</span><br></pre></td></tr></table></figure>

<p>在最基本的groupingBy函数中，下游收集器是toList，但下游收集器还可以是其他收集器，甚至是groupingBy，以构成多级分组。下面我们来看更多的示例。</p>
<h3 id="3．分组计数、找最大-最小元素"><a href="#3．分组计数、找最大-最小元素" class="headerlink" title="3．分组计数、找最大/最小元素"></a>3．分组计数、找最大/最小元素</h3><p>将元素按一定标准分为多组，然后计算每组的个数，按一定标准找最大或最小元素，这是一个常见的需求。Collectors提供了一些对应的收集器，一般用作下游收集器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , Long&gt; counting()</span><br><span class="line"><span class="comment">//计算最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , Optional&lt;T&gt;&gt; maxBy(</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="comment">//计算最小值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , Optional&lt;T&gt;&gt; minBy(</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br></pre></td></tr></table></figure>

<p>还有更为通用的名为reducing的归约收集器，我们就不介绍了。下面看一些例子。</p>
<p>为了便于使用Collectors中的方法，我们将其中的方法静态导入，即加入如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.＊;</span><br></pre></td></tr></table></figure>

<p>统计每个年级的学生个数，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; gradeCountMap = students.stream().collect(</span><br><span class="line">        groupingBy(Student::getGrade, counting()));</span><br></pre></td></tr></table></figure>

<p>统计一个单词流中每个单词的个数，按出现顺序排序，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; wordCountMap =</span><br><span class="line">        Stream.of(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;hello&quot;</span>).collect(</span><br><span class="line">            groupingBy(Function.identity(), LinkedHashMap::<span class="keyword">new</span>, counting()));</span><br></pre></td></tr></table></figure>

<p>获取每个年级分数最高的一个学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Optional&lt;Student&gt;&gt; topStudentMap = students.stream().collect(</span><br><span class="line">        groupingBy(Student::getGrade,</span><br><span class="line">                maxBy(Comparator.comparing(Student::getScore))));</span><br></pre></td></tr></table></figure>

<p>需要说明的是，这个分组收集结果是<code>Optional&lt;Student&gt;</code>，而不是Student，这是因为maxBy处理的流可能是空流，但对我们的例子，这是不可能的。为了直接得到Student，可以使用Collectors的另一个收集器collectingAndThen，在得到<code>Optional&lt;Student&gt;</code>后调用Optional的get方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Student&gt; topStudentMap = students.stream().collect(</span><br><span class="line">        groupingBy(Student::getGrade, collectingAndThen(</span><br><span class="line">            maxBy(Comparator.comparing(Student::getScore)), Optional::get)));</span><br></pre></td></tr></table></figure>

<p>关于collectingAndThen，我们稍后再进一步讨论。</p>
<h3 id="4．分组数值统计"><a href="#4．分组数值统计" class="headerlink" title="4．分组数值统计"></a>4．分组数值统计</h3><p>除了基本的分组计数，还经常需要进行一些分组数值统计，比如求学生分数的和、平均分、最高分、最低分等、针对int、long和double类型，Collectors提供了专门的收集器，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求平均值，int和long也有类似方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , Double&gt;</span><br><span class="line">    averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="comment">//求和，long和double也有类似方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , Integer&gt;</span><br><span class="line">    summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="comment">//求多种汇总信息，int和double也有类似方法</span></span><br><span class="line"><span class="comment">//LongSummaryStatistics包括个数、最大值、最小值、和、平均值等多种信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , LongSummaryStatistics&gt;</span><br><span class="line">    summarizingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>

<p>比如，按年级统计学生分数信息，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, DoubleSummaryStatistics&gt; gradeScoreStat =</span><br><span class="line">    students.stream().collect(groupingBy(Student::getGrade,</span><br><span class="line">                    summarizingDouble(Student::getScore)));</span><br></pre></td></tr></table></figure>

<h3 id="5．分组内的map"><a href="#5．分组内的map" class="headerlink" title="5．分组内的map"></a>5．分组内的map</h3><p>对于每个分组内的元素，我们感兴趣的可能不是元素本身，而是它的某部分信息。在Stream API中，Stream有map方法，可以将元素进行转换，Collectors也为分组元素提供了函数mapping，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt;</span><br><span class="line">Collector&lt;T, ? , R&gt; mapping(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper,</span><br><span class="line">    Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream)</span><br></pre></td></tr></table></figure>

<p>交给下游收集器downstream的不再是元素本身，而是应用转换函数mapper之后的结果。比如，对学生按年级分组，得到学生名称列表，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; gradeNameMap =</span><br><span class="line">        students.stream().collect(groupingBy(Student::getGrade,</span><br><span class="line">                          mapping(Student::getName, toList())));</span><br><span class="line">System.out.println(gradeNameMap);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1=[zhangsan, wangwu, sunqi], 2=[lisi, zhaoliu]&#125;</span><br></pre></td></tr></table></figure>

<p>Stream有flatMap方法。Java 9为Collectors增加了分组内的flatMap方法flatMapping，它与mapping的关系如同Stream中flatMap和map的关系，这里就不举例了，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U, A, R&gt; Collector&lt;T, ? , R&gt; flatMapping(</span><br><span class="line">    Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends U&gt;&gt; mapper,</span><br><span class="line">    Collector&lt;? <span class="keyword">super</span> U, A, R&gt; downstream)</span><br></pre></td></tr></table></figure>

<h3 id="6．分组结果处理（filter-sort-skip-limit）"><a href="#6．分组结果处理（filter-sort-skip-limit）" class="headerlink" title="6．分组结果处理（filter/sort/skip/limit）"></a>6．分组结果处理（filter/sort/skip/limit）</h3><p>对分组后的元素，我们可以计数，找最大/最小元素，计算一些数值特征，还可以转换（map）后再收集，那可不可以像Stream API一样，排序（sort）、过滤（filter）、限制返回元素（skip/limit）呢？Collector没有专门的收集器，但有一个通用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T, A, R, RR&gt; Collector&lt;T, A, RR&gt; <span class="title">collectingAndThen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Collector&lt;T, A, R&gt; downstream, Function&lt;R, RR&gt; finisher)</span></span></span><br></pre></td></tr></table></figure>

<p>这个方法接受一个下游收集器downstream和一个finisher，返回一个收集器，它的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(downstream.supplier(),</span><br><span class="line">    downstream.accumulator(), downstream.combiner(),</span><br><span class="line">    downstream.finisher().andThen(finisher), characteristics);</span><br></pre></td></tr></table></figure>

<p>也就是说，它在下游收集器的结果上又调用了finisher。利用这个finisher，我们可以实现多种功能，下面看一些例子。收集完再排序，可以定义如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , List&lt;T&gt;&gt; collectingAndSort(</span><br><span class="line">      Collector&lt;T, ? , List&lt;T&gt;&gt; downstream, Comparator&lt;? <span class="keyword">super</span> T&gt; comparator) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collectors.collectingAndThen(downstream, (r) -&gt; &#123;</span><br><span class="line">        r.sort(comparator);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将学生按年级分组，分组内的学生按照分数由高到低进行排序，利用这个方法，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap = students.stream()</span><br><span class="line">    .collect(groupingBy(Student::getGrade, collectingAndSort(toList(),</span><br><span class="line">              Comparator.comparing(Student::getScore).reversed())));</span><br></pre></td></tr></table></figure>

<p>针对这个需求，也可以先对流进行排序，然后再分组。</p>
<p>收集完再过滤，可以定义如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , List&lt;T&gt;&gt; collectingAndFilter(</span><br><span class="line">        Collector&lt;T, ? , List&lt;T&gt;&gt; downstream, Predicate&lt;T&gt; predicate) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collectors.collectingAndThen(downstream, (r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> r.stream().filter(predicate).collect(Collectors.toList());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将学生按年级分组，分组后，每个分组只保留不及格的学生（低于60分），利用这个方法，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap = students.stream()</span><br><span class="line">    .collect(groupingBy(Student::getGrade,</span><br><span class="line">        collectingAndFilter(toList(), t-&gt;t.getScore()&lt;<span class="number">60</span>)));</span><br></pre></td></tr></table></figure>

<p>Java 9中，Collectors增加了一个新方法filtering，可以实现相同的功能，定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, A, R&gt; Collector&lt;T, ? , R&gt; filtering(</span><br><span class="line">    Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, R&gt; downstream)</span><br></pre></td></tr></table></figure>

<p>用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap = students.stream()</span><br><span class="line">    .collect(groupingBy(Student::getGrade,</span><br><span class="line">        filtering(t-&gt;t.getScore()&lt;<span class="number">60</span>, toList()));</span><br></pre></td></tr></table></figure>

<p>你可能会认为，实现这种效果也可以先对整个流进行过滤，然后再分组，比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap = students.stream()</span><br><span class="line">        .filter(t-&gt;t.getScore()&lt;<span class="number">60</span>)</span><br><span class="line">        .collect(groupingBy(Student::getGrade, toList()));</span><br></pre></td></tr></table></figure>

<p>需要说明的是，这两种方式的结果可能是不一样的，如果是先过滤，那些没有任何元素的分组就不会出现在结果中，而如果是先分组，即使该组内的元素都被过滤了，组也会出现在最终结果中，只是分组结果为一个空的集合。</p>
<p>收集完，只返回特定区间的结果，可以定义如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , List&lt;T&gt;&gt; collectingAndSkipLimit(</span><br><span class="line">        Collector&lt;T, ? , List&lt;T&gt;&gt; downstream, <span class="keyword">long</span> skip, <span class="keyword">long</span> limit) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collectors.collectingAndThen(downstream, (r) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> r.stream().skip(skip).limit(limit)</span><br><span class="line">                          .collect(Collectors.toList());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，将学生按年级分组，分组后，每个分组只保留前两名的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; gradeStudentMap = students.stream()</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore).reversed())</span><br><span class="line">        .collect(groupingBy(Student::getGrade,</span><br><span class="line">                    collectingAndSkipLimit(toList(), <span class="number">0</span>, <span class="number">2</span>)));</span><br></pre></td></tr></table></figure>

<p>这次，我们先对学生流进行了排序，然后再进行了分组。</p>
<p>mapping和collectingAndThen都接受一个下游收集器，mapping在把元素交给下游收集器之前先进行转换，而collectingAndThen对下游收集器的结果进行转换，组合利用它们，可以构造更为灵活强大的收集器。</p>
<h3 id="7．分区"><a href="#7．分区" class="headerlink" title="7．分区"></a>7．分区</h3><p>分组的一个特殊情况是分区，就是将流按true/false分为两个组，Collectors有专门的分区函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ? , Map&lt;Boolean, List&lt;T&gt;&gt;&gt;</span><br><span class="line">    partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ? , Map&lt;Boolean, D&gt;&gt;</span><br><span class="line">    partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate,</span><br><span class="line">    Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream)</span><br></pre></td></tr></table></figure>

<p>第一个函数的下游收集器为toList()，第二个函数可以指定一个下游收集器。比如，将学生按照是否及格（大于等于60分）分为两组，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; byPass = students.stream().collect(</span><br><span class="line">    partitioningBy(t-&gt;t.getScore()&gt;=<span class="number">60</span>));</span><br></pre></td></tr></table></figure>

<p>按是否及格分组后，计算每个分组的平均分，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Double&gt; avgScoreMap = students.stream().collect(</span><br><span class="line">    partitioningBy(t-&gt;t.getScore()&gt;=<span class="number">60</span>, averagingDouble(Student::getScore)));</span><br></pre></td></tr></table></figure>

<h3 id="8．多级分组"><a href="#8．多级分组" class="headerlink" title="8．多级分组"></a>8．多级分组</h3><p>groupingBy和partitioningBy都可以接受一个下游收集器，对同一个分组或分区内的元素进行进一步收集，而下游收集器又可以是分组或分区，以构建多级分组。比如，按年级对学生分组，分组后，再按照是否及格对学生进行分区，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; multiGroup = students.stream()</span><br><span class="line">    .collect(groupingBy(Student::getGrade,</span><br><span class="line">                        partitioningBy(t-&gt;t.getScore()&gt;=<span class="number">60</span>)));</span><br></pre></td></tr></table></figure>

<p>至此，关于函数式数据处理Stream API就介绍完了，<strong>Stream API提供了集合数据处理的常用函数，利用它们，可以简洁地实现大部分常见需求，大大减少代码，提高可读性</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/b34b5819/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/b34b5819/" class="post-title-link" itemprop="url">26.2 函数式数据处理：基本用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:06 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:06+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC26%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第26章 函数式编程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/b34b5819/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/b34b5819/" data-xid="/JavaReadingNotes/b34b5819/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="26-2-函数式数据处理：基本用法"><a href="#26-2-函数式数据处理：基本用法" class="headerlink" title="26.2 函数式数据处理：基本用法"></a>26.2 函数式数据处理：基本用法</h1><p>上一节介绍了Lambda表达式和函数式接口，本节探讨它们的应用：函数式数据处理，针对常见的集合数据处理，Java 8引入了一套新的类库，位于包java.util.stream下，称为Stream API。这套API操作数据的思路不同于我们之前介绍的容器类API，它们是函数式的，非常简洁、灵活、易读。具体有什么不同呢？本节先介绍一些基本的API，下节讨论一些高级功能。</p>
<p>接口Stream类似于一个迭代器，但提供了更为丰富的操作，Stream API的主要操作就定义在该接口中。Java 8给Collection接口增加了两个默认方法，它们可以返回一个Stream，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stream()返回的是一个<strong>顺序流</strong>，parallelStream()返回的是一个<strong>并行流</strong>。顺序流就是由一个线程执行操作。而并行流背后可能有多个线程并行执行，与之前介绍的并发技术不同，使用并行流不需要显式管理线程，使用方法与顺序流是一样的。</p>
<p>下面我们主要针对顺序流学习Stream接口，包括其用法和基本原理，随后我们再介绍并行流，先来看一些简单的示例。</p>
<h2 id="26-2-1-基本示例"><a href="#26-2-1-基本示例" class="headerlink" title="26.2.1 基本示例"></a>26.2.1 基本示例</h2><p>上一节演示时使用了学生类Student和学生列表<code>List&lt;Student&gt; lists</code>，本节继续使用它们，看一些基本的过滤、转换以及过滤和转换组合的例子。</p>
<h3 id="1．基本过滤"><a href="#1．基本过滤" class="headerlink" title="1．基本过滤"></a>1．基本过滤</h3><p>返回学生列表中90分以上的，传统上的代码一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; above90List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.getScore() &gt; <span class="number">90</span>) &#123;</span><br><span class="line">        above90List.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Stream API，代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; above90List = students.stream()</span><br><span class="line">        .filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>先通过stream()得到一个Stream对象，然后调用Stream上的方法，filter()过滤得到90分以上的，它的返回值依然是一个Stream，为了转换为List，调用了collect方法并传递了一个Collectors.toList()，表示将结果收集到一个List中。</p>
<p>代码更为简洁易读了，这种数据处理方式称为<strong>函数式数据处理</strong>。与传统代码相比，其特点是：<br>1）没有显式的循环迭代，循环过程被Stream的方法隐藏了。<br>2）提供了声明式的处理函数，比如filter，它封装了数据过滤的功能，而传统代码是命令式的，需要一步步的操作指令。<br>3）流畅式接口，方法调用链接在一起，清晰易读。</p>
<h3 id="2．基本转换"><a href="#2．基本转换" class="headerlink" title="2．基本转换"></a>2．基本转换</h3><p>根据学生列表返回名称列表，传统上的代码一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;&gt;(students.size());</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    nameList.add(t.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Stream API，代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = students.stream()</span><br><span class="line">        .map(Student::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里使用了Stream的map函数，它的参数是一个Function函数式接口，这里传递了方法引用。</p>
<h3 id="3．基本的过滤和转换组合"><a href="#3．基本的过滤和转换组合" class="headerlink" title="3．基本的过滤和转换组合"></a>3．基本的过滤和转换组合</h3><p>返回90分以上的学生名称列表，传统上的代码一般是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student t : students) &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.getScore() &gt; <span class="number">90</span>) &#123;</span><br><span class="line">        nameList.add(t.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数式数据处理的思路，可以将这个问题分解为由两个基本函数实现：<br>1）过滤：得到90分以上的学生列表。<br>2）转换：将学生列表转换为名称列表。</p>
<p>使用Stream API，可以将基本函数filter()和map()结合起来，代码可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; above90Names = students.stream()</span><br><span class="line">        .filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这种组合利用基本函数、声明式实现集合数据处理功能的编程风格，就是函数式数据处理。</p>
<p>代码更为直观易读了，但你可能会担心它的性能有问题。filter()和map()都需要对流中的每个元素操作一次，一起使用会不会就需要遍历两次呢？答案是否定的，只需要一次。<strong>实际上，调用filter()和map()都不会执行任何实际的操作，它们只是在构建操作的流水线，调用collect才会触发实际的遍历执行，在一次遍历中完成过滤、转换以及收集结果的任务</strong>。</p>
<p>像filter和map这种不实际触发执行、用于构建流水线、返回Stream的操作称为<strong>中间操作</strong>（intermediate operation），而像collect这种触发实际执行、返回具体结果的操作称为<strong>终端操作</strong>（terminal operation）。Stream API中还有更多的中间和终端操作，下面我们具体介绍。</p>
<h2 id="26-2-2-中间操作"><a href="#26-2-2-中间操作" class="headerlink" title="26.2.2 中间操作"></a>26.2.2 中间操作</h2><p>除了filter和map, Stream API的中间操作还有distinct、sorted、skip、limit、peek、mapToLong、mapToInt、mapToDouble、flatMap等，我们逐个介绍。</p>
<h3 id="1-distinct"><a href="#1-distinct" class="headerlink" title="1. distinct"></a>1. distinct</h3><p>distinct返回一个新的Stream，过滤重复的元素，只留下唯一的元素，是否重复是根据equals方法来比较的，distinct可以与其他函数（如filter、map）结合使用。比如，返回字符串列表中长度小于3的字符串、转换为小写、只保留唯一的，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;Abc&quot;</span>&#125;);</span><br><span class="line">List&lt;String&gt; retList = list.stream()</span><br><span class="line">        .filter(s-&gt;s.length()&lt;=<span class="number">3</span>).map(String::toLowerCase).distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>虽然都是中间操作，但distinct与filter和map是不同的。filter和map都是无状态的，对于流中的每一个元素，处理都是独立的，处理后即交给流水线中的下一个操作；distinct不同，它是<strong>有状态的</strong>，在处理过程中，它需要在内部记录之前出现过的元素，如果已经出现过，即重复元素，它就会过滤掉，不传递给流水线中的下一个操作。对于顺序流，内部实现时，distinct操作会使用HashSet记录出现过的元素，如果流是有顺序的，需要保留顺序，会使用LinkedHashSet。</p>
<h3 id="2-sorted"><a href="#2-sorted" class="headerlink" title="2. sorted"></a>2. sorted</h3><p>有两个sorted方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>

<p>它们都对流中的元素排序，都返回一个排序后的Stream。第一个方法假定元素实现了Comparable接口，第二个方法接受一个自定义的Comparator。比如，过滤得到90分以上的学生，然后按分数从高到低排序，分数一样的按名称排序，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore)</span><br><span class="line">                .reversed().thenComparing(Student::getName))</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这里，使用了Comparator的comparing、reversed和thenComparing构建了Comparator。</p>
<p>与distinct一样，sorted也是一个有状态的中间操作，在处理过程中，需要在内部记录出现过的元素。其不同是，每碰到流中的一个元素，distinct都能立即做出处理，要么过滤，要么马上传递给下一个操作；sorted需要先排序，为了排序，它需要先在内部数组中保存碰到的每一个元素，到流结尾时再对数组排序，然后再将排序后的元素逐个传递给流水线中的下一个操作。</p>
<h3 id="3-skip-limit"><a href="#3-skip-limit" class="headerlink" title="3. skip/limit"></a>3. skip/limit</h3><p>它们的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span></span><br></pre></td></tr></table></figure>

<p>skip跳过流中的n个元素，如果流中元素不足n个，返回一个空流，limit限制流的长度为maxSize。比如，将学生列表按照分数排序，返回第3名到第5名，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; list = students.stream()</span><br><span class="line">        .sorted(Comparator.comparing(Student::getScore).reversed())</span><br><span class="line">        .skip(<span class="number">2</span>).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>skip和limit都是有状态的中间操作。对前n个元素，skip的操作就是过滤，对后面的元素，skip就是传递给流水线中的下一个操作。limit的一个特点是：它不需要处理流中的所有元素，只要处理的元素个数达到maxSize，后面的元素就不需要处理了，这种可以提前结束的操作称为<strong>短路操作</strong>。</p>
<p>skip和limit只能根据元素数目进行操作，Java 9增加了两个新方法，相当于更为通用的skip和limit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的skip，在谓词返回为true的情况下一直进行skip操作，直到某次返回false</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">dropWhile</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"><span class="comment">//通用的limit，在谓词返回为true的情况下一直接受，直到某次返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;T&gt; <span class="title">takeWhile</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4-peek"><a href="#4-peek" class="headerlink" title="4. peek"></a>4. peek</h3><p>peek的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>它返回的流与之前的流是一样的，没有变化，但它提供了一个Consumer，会将流中的每一个元素传给该Consumer。这个方法的主要目的是支持调试，可以使用该方法观察在流水线中流转的元素，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; above90Names = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">        .peek(System.out::println).map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="5-mapToLong-mapToInt-mapToDouble"><a href="#5-mapToLong-mapToInt-mapToDouble" class="headerlink" title="5. mapToLong/mapToInt/mapToDouble"></a>5. mapToLong/mapToInt/mapToDouble</h3><p>map函数接受的参数是一个Function&lt;T, R&gt;，为避免装箱/拆箱，提高性能，Stream还有如下返回基本类型特定流的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br><span class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<p>DoubleStream/IntStream/LongStream是基本类型特定的流，有一些专门的更为高效的方法。比如，求学生列表的分数总和，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sum = students.stream().mapToDouble(Student::getScore).sum();</span><br></pre></td></tr></table></figure>

<h3 id="6-flatMap"><a href="#6-flatMap" class="headerlink" title="6. flatMap"></a>6. flatMap</h3><p>flatMap的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>

<p>它接受一个函数mapper，对流中的每一个元素，mapper会将该元素转换为一个流Stream，然后把新生成流的每一个元素传递给下一个操作。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lines = Arrays.asList(<span class="keyword">new</span> String[]&#123;</span><br><span class="line">        <span class="string">&quot;hello abc&quot;</span>, <span class="string">&quot;老马  编程&quot;</span>&#125;);</span><br><span class="line">List&lt;String&gt; words = lines.stream()</span><br><span class="line">        .flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot;\\s+&quot;</span>)))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(words);</span><br></pre></td></tr></table></figure>

<p>这里的mapper将一行字符串按空白符分隔为了一个单词流，Arrays.stream可以将一个数组转换为一个流，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hello, abc, 老马， 编程]</span><br></pre></td></tr></table></figure>

<p>可以看出，实际上，flatMap完成了一个1到n的映射。</p>
<h2 id="26-2-3-终端操作"><a href="#26-2-3-终端操作" class="headerlink" title="26.2.3 终端操作"></a>26.2.3 终端操作</h2><p>中间操作不触发实际的执行，返回值是Stream，而终端操作触发执行，返回一个具体的值，除了collect, Stream API的终端操作还有max、min、count、allMatch、anyMatch、noneMatch、findFirst、findAny、forEach、toArray、reduce等，我们逐个介绍。</p>
<h3 id="1-max-min"><a href="#1-max-min" class="headerlink" title="1. max/min"></a>1. max/min</h3><p>max/min的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span></span><br></pre></td></tr></table></figure>

<p>它们返回流中的最大值/最小值，它们的返回值类型是<code>Optional&lt;T&gt;</code>，而不是T。</p>
<p>java.util.Optional是Java 8引入的一个新类，它是一个泛型容器类，内部只有一个类型为T的单一变量value，可能为null，也可能不为null。Optional有什么用呢？<strong>它用于准确地传递程序的语义，它清楚地表明，其代表的值可能为null，程序员应该进行适当的处理</strong>。</p>
<p>Optional定义了一些方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value不为null时返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回实际的值，如果为null，抛出异常NoSuchElementException</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果value不为null，返回value，否则返回other</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span></span></span><br><span class="line"><span class="function"><span class="comment">//构建一个空的Optional, value为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//构建一个非空的Optional, 参数value不能为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"><span class="comment">//构建一个Optional，参数value可以为null，也可以不为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span></span></span><br></pre></td></tr></table></figure>

<p>在max/min的例子中，通过声明返回值为Optional，我们可以知道具体的返回值不一定存在，这发生在流中不含任何元素的情况下。</p>
<p>看个简单的例子，返回分数最高的学生，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student student = students.stream()</span><br><span class="line">        .max(Comparator.comparing(Student::getScore).reversed()).get();</span><br></pre></td></tr></table></figure>
<p>这里，假定students不为空。</p>
<h3 id="2-count"><a href="#2-count" class="headerlink" title="2. count"></a>2. count</h3><p>count很简单，就是返回流中元素的个数。比如，统计大于90分的学生个数，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> above90Count = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).count();</span><br></pre></td></tr></table></figure>

<h3 id="3-allMatch-anyMatch-noneMatch"><a href="#3-allMatch-anyMatch-noneMatch" class="headerlink" title="3. allMatch/anyMatch/noneMatch"></a>3. allMatch/anyMatch/noneMatch</h3><p>这几个函数都接受一个谓词Predicate，返回一个boolean值，用于判定流中的元素是否满足一定的条件。它们的区别是：</p>
<ul>
<li>allMatch：只有在流中所有元素都满足条件的情况下才返回true。</li>
<li>anyMatch：只要流中有一个元素满足条件就返回true。</li>
<li>noneMatch：只有流中所有元素都不满足条件才返回true。</li>
</ul>
<p>如果流为空，那么这几个函数的返回值都是true。</p>
<p>比如，判断是不是所有学生都及格了（不小于60分），代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> allPass = students.stream().allMatch(t-&gt;t.getScore()&gt;=<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p>这几个操作都是短路操作，不一定需要处理所有元素就能得出结果，比如，对于all-Match，只要有一个元素不满足条件，就能返回false。</p>
<h3 id="4-findFirst-findAny"><a href="#4-findFirst-findAny" class="headerlink" title="4. findFirst/findAny"></a>4. findFirst/findAny</h3><p>它们的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>它们的返回类型都是Optional，如果流为空，返回Optional.empty()。findFirst返回第一个元素，而findAny返回任一元素，它们都是短路操作。随便找一个不及格的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; student = students.stream().filter(t-&gt;t.getScore()&lt;<span class="number">60</span>)</span><br><span class="line">        .findAny();</span><br><span class="line"><span class="keyword">if</span>(student.isPresent())&#123;</span><br><span class="line">    <span class="comment">//处理不及格的学生</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-forEach"><a href="#5-forEach" class="headerlink" title="5. forEach"></a>5. forEach</h3><p>有两个forEach方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span></span><br></pre></td></tr></table></figure>

<p>它们都接受一个Consumer，对流中的每一个元素，传递元素给Consumer。区别在于：在并行流中，forEach不保证处理的顺序，而forEachOrdered会保证按照流中元素的出现顺序进行处理。</p>
<p>比如，逐行打印大于90分的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="6-toArray"><a href="#6-toArray" class="headerlink" title="6. toArray"></a>6. toArray</h3><p>toArray将流转换为数组，有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] toArray()</span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator)</span><br></pre></td></tr></table></figure>

<p>不带参数的toArray返回的数组类型为Object[]，这通常不是期望的结果，如果希望得到正确类型的数组，需要传递一个类型为IntFunction的generator。IntFunction的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntFunction</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>generator接受的参数是流的元素个数，它应该返回对应大小的正确类型的数组。</p>
<p>比如，获取90分以上的学生数组，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student[] above90Arr = students.stream().filter(t-&gt;t.getScore()&gt;<span class="number">90</span>)</span><br><span class="line">                          .toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<p><code>Student[]::new</code>就是一个类型为<code>IntFunction&lt;Student[]&gt;</code>的generator。</p>
<h3 id="7-reduce"><a href="#7-reduce" class="headerlink" title="7. reduce"></a>7. reduce</h3><p>reduce代表<strong>归约</strong>或者叫<strong>折叠</strong>，它是max/min/count的更为通用的函数，将流中的元素归约为一个值。有三个reduce函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">    BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个reduce函数基本等同于调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">T result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">    <span class="keyword">if</span>(! foundAny) &#123;</span><br><span class="line">        foundAny = <span class="keyword">true</span>;</span><br><span class="line">        result = element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = accumulator.apply(result, element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure>

<p>比如，使用reduce函数求分数最高的学生，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student topStudent = students.stream().reduce((accu, t) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(accu.getScore() &gt;= t.getScore()) &#123;</span><br><span class="line">        <span class="keyword">return</span> accu;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure>

<p>第二个reduce函数多了一个identity参数，表示初始值，它基本等同于调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>第一个和第二个reduce函数的返回类型只能是流中元素的类型，而第三个reduce函数更为通用，它的归约类型可以自定义，另外，它多了一个combiner参数。combiner用在并行流中，用于合并子线程的结果。对于顺序流，它基本等同于调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">U result = identity;</span><br><span class="line"><span class="keyword">for</span>(T element : <span class="keyword">this</span> stream)</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>注意与第二个reduce函数相区分，它的结果类型不是T，而是U。比如，使用reduce函数计算学生分数的和，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> sumScore = students.stream().reduce(<span class="number">0d</span>,</span><br><span class="line">    (sum, t) -&gt; sum += t.getScore(),</span><br><span class="line">    (sum1, sum2) -&gt; sum1 += sum2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从以上可以看出，reduce函数虽然更为通用，但比较费解，难以使用，一般情况下应该优先使用其他函数。collect函数比reduce函数更为通用、强大和易用，关于它，我们稍后再详细介绍。</p>
<h2 id="26-2-4-构建流"><a href="#26-2-4-构建流" class="headerlink" title="26.2.4 构建流"></a>26.2.4 构建流</h2><p>前面我们主要使用的是Collection的stream方法，换做parallelStream方法，就会使用并行流，接口方法都是通用的。但并行流内部会使用多线程，线程个数一般与系统的CPU核数一样，以充分利用CPU的计算能力。</p>
<p>进一步来说，并行流内部会使用Java 7引入的fork/join框架，即处理由fork和join两个阶段组成，fork就是将要处理的数据拆分为小块，多线程按小块进行并行计算，join就是将小块的计算结果进行合并，具体我们就不探讨了。使用并行流，不需要任何线程管理的代码，就能实现并行。</p>
<p>除了通过Collection接口的stream/parallelStream获取流，还有一些其他方式可以获取流。Arrays有一些stream方法，可以将数组或子数组转换为流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array, <span class="keyword">int</span> startInclusive,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> endExclusive)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure>

<p>输出当前目录下所有普通文件的名字，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File[] files = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>).listFiles();</span><br><span class="line">Arrays.stream(files).filter(File::isFile).map(File::getName)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>Stream也有一些静态方法，可以构建流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个空流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回只包含一个元素t的流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含多个元素values的流</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br><span class="line"><span class="function"><span class="comment">//通过Supplier生成流，流的元素个数是无限的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br><span class="line"><span class="function"><span class="comment">//同样生成无限流，第一个元素为seed，第二个为f(seed)，第三个为f(f(seed))，以此类推</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br></pre></td></tr></table></figure>

<p>输出10个随机数，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(()-&gt;Math.random()).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>输出100个递增的奇数，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">1</span>, t-&gt;t+<span class="number">2</span>).limit(<span class="number">100</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="26-2-5-函数式数据处理思维"><a href="#26-2-5-函数式数据处理思维" class="headerlink" title="26.2.5 函数式数据处理思维"></a>26.2.5 函数式数据处理思维</h2><p>可以看出，使用Stream API处理数据集合，与直接使用容器类API处理数据的思路是完全不一样的。<strong>流定义了很多数据处理的基本函数，对于一个具体的数据处理问题，解决的主要思路就是组合利用这些基本函数，以声明式的方式简洁地实现期望的功能，这种思路就是函数式数据处理思维，相比直接利用容器类API的命令式思维，思考的层次更高</strong>。</p>
<p>Stream API的这种思路也不是新发明，它与数据库查询语言SQL是很像的，都是声明式地操作集合数据，很多函数都能在SQL中找到对应，比如filter对应SQL的where, sorted对应order by等。SQL一般都支持分组（group by）功能，StreamAPI也支持，但关于分组，我们下节再介绍。</p>
<p><strong>Stream API也与各种基于Unix系统的管道命令类似</strong>。熟悉Unix系统的都知道，Unix有很多命令，大部分命令只是专注于完成一件事情，但可以通过管道的方式将多个命令链接起来，完成一些复杂的功能，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nginx_access.log | awk &#x27;&#123;print $1&#125;&#x27; | sort | uniq -c | sort -rnk 1 | head -n 20</span><br></pre></td></tr></table></figure>

<p>以上命令可以分析nginx访问日志，统计出访问次数最多的前20个IP地址及其访问次数。具体来说，cat命令输出nginx访问日志到流，一行为一个元素，awk输出行的第一列，这里为IP地址，sort按IP进行排序，”uniq -c”按IP统计计数，”sort -rnk 1”按计数从高到低排序，”head -n 20”输出前20行。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/7c273c02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/7c273c02/" class="post-title-link" itemprop="url">26.0 第26章 函数式编程 26.1 Lambda表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:05 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:05+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC26%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第26章 函数式编程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/7c273c02/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/7c273c02/" data-xid="/JavaReadingNotes/7c273c02/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第26章-函数式编程"><a href="#第26章-函数式编程" class="headerlink" title="第26章 函数式编程"></a>第26章 函数式编程</h1><p>Java 8引入了一个重要新语法——Lambda表达式，<strong>它是一种紧凑的传递代码的方式</strong>，利用它，可以实现简洁灵活的函数式编程。</p>
<p>基于Lambda表达式，针对常见的集合数据处理，Java 8引入了一套新的类库，位于包java.util.stream下，称为Stream API。这套API操作数据的思路不同于我们之前介绍的容器类API，它们是函数式的，非常简洁、灵活、易读。</p>
<p>Stream API是对容器类的增强，它可以将对集合数据的多个操作以流水线的方式组合在一起。Java 8还增加了一个新的类CompletableFuture，它是对并发编程的增强，<strong>可以方便地将多个有一定依赖关系的异步任务以流水线的方式组合在一起，大大简化多异步任务的开发</strong>。</p>
<p>利用Lambda表达式，Java 8还增强了日期和时间API。</p>
<p>本章就来介绍这些Java 8引入的函数式编程特性和API，具体分为5节：26.1节介绍Lambda表达式；26.2节介绍函数式数据处理的基本用法；26.3节重点讨论函数式数据处理中的收集器；26.4节介绍组合式异步编程CompletableFuture;26.5节介绍Java 8的日期和时间API。</p>
<h1 id="26-1-Lambda表达式"><a href="#26-1-Lambda表达式" class="headerlink" title="26.1 Lambda表达式"></a>26.1 Lambda表达式</h1><p>Lambda表达式到底是什么？有什么用？本节进行详细探讨。Lambda这个名字来源于学术界的λ演算，具体我们就不探讨了。理解Lambda表达式，我们需要先回顾一下接口、匿名内部类和代码传递。</p>
<h2 id="26-1-1-通过接口传递代码"><a href="#26-1-1-通过接口传递代码" class="headerlink" title="26.1.1 通过接口传递代码"></a>26.1.1 通过接口传递代码</h2><p>我们之前介绍过接口以及面向接口的编程，针对接口而非具体类型进行编程，可以降低程序的耦合性，提高灵活性，提高复用性。<strong>接口常被用于传递代码</strong>，比如，我们知道File有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles(FilenameFilter filter)</span><br></pre></td></tr></table></figure>

<p>listFiles需要的其实不是FilenameFilter对象，而是它包含的如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>;</span><br></pre></td></tr></table></figure>

<p>或者说，listFiles希望接受一段方法代码作为参数，但没有办法直接传递这个方法代码本身，只能传递一个接口。</p>
<p>再如，类Collections中的很多方法都接受一个参数Comparator，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>它们需要的也不是Comparator对象，而是它包含的如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>但是，没有办法直接传递方法，只能传递一个接口。</p>
<p>又如，异步任务执行服务ExecutorService，提交任务的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<p>Callable和Runnable接口也用于传递任务代码。</p>
<p>通过接口传递行为代码，就要传递一个实现了该接口的实例对象，在之前的章节中，最简洁的方式是使用匿名内部类，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出当前目录下的所有扩展名为．txt的文件</span></span><br><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">File[] files = f.listFiles(<span class="keyword">new</span> FilenameFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将files按照文件名排序，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(files, <span class="keyword">new</span> Comparator&lt;File&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(File f1, File f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.getName().compareTo(f2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>提交一个最简单的任务，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">executor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="26-1-2-Lambda语法"><a href="#26-1-2-Lambda语法" class="headerlink" title="26.1.2 Lambda语法"></a>26.1.2 Lambda语法</h2><p>Java 8提供了一种新的紧凑的传递代码的语法：Lambda表达式。对于前面列出文件的例子，代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">File[] files = f.listFiles((File dir, String name) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.endsWith(<span class="string">&quot;.txt&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看出，相比匿名内部类，传递代码变得更为直观，不再有实现接口的模板代码，不再声明方法，也没有名字，而是直接给出了方法的实现代码。Lambda表达式由-&gt;分隔为两部分，前面是方法的参数，后面{}内是方法的代码。上面的代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File[] files = f.listFiles((File dir, String name) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当主体代码只有一条语句的时候，括号和return语句也可以省略，上面的代码可以变为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File[] files = f.listFiles((File dir, String name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>注意：没有括号的时候，主体代码是一个表达式，这个表达式的值就是函数的返回值，结尾不能加分号，也不能加return语句。</p>
<p>方法的参数类型声明也可以省略，上面的代码还可以继续简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File[] files = f.listFiles((dir, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>之所以可以省略方法的参数类型，是因为Java可以自动推断出来，它知道listFiles接受的参数类型是FilenameFilter，这个接口只有一个方法accept，这个方法的两个参数类型分别是File和String。这样简化下来，代码是不是简洁多了？</p>
<p>排序的代码用Lambda表达式可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));</span><br></pre></td></tr></table></figure>

<p>提交任务的代码用Lambda表达式可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executor.submit(()-&gt;System.out.println(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>参数部分为空，写为()。</p>
<p>当参数只有一个的时候，参数部分的括号可以省略。比如，File还有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter)</span><br></pre></td></tr></table></figure>

<p>FileFilter的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用FileFilter重写上面的列举文件的例子，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File[] files = f.listFiles(path -&gt; path.getName().endsWith(<span class="string">&quot;.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>与匿名内部类类似，Lambda表达式也可以访问定义在主体代码外部的变量，但对于局部变量，它也只能访问final类型的变量，与匿名内部类的区别是，它不要求变量声明为final，但变量事实上不能被重新赋值。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">executor.submit(()-&gt;System.out.println(msg));</span><br></pre></td></tr></table></figure>

<p>可以访问局部变量msg，但msg不能被重新赋值，如果这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">msg = <span class="string">&quot;good morning&quot;</span>;</span><br><span class="line">executor.submit(()-&gt;System.out.println(msg));</span><br></pre></td></tr></table></figure>

<p>Java编译器会提示错误。</p>
<p>这个原因与匿名内部类是一样的，Java会将msg的值作为参数传递给Lambda表达式，为Lambda表达式建立一个副本，它的代码访问的是这个副本，而不是外部声明的msg变量。如果允许msg被修改，则程序员可能会误以为Lambda表达式读到修改后的值，引起更多的混淆。</p>
<p>为什么非要建立副本，直接访问外部的msg变量不行吗？不行，因为msg定义在栈中，当Lambda表达式被执行的时候，msg可能早已被释放了。如果希望能够修改值，可以将变量定义为实例变量，或者将变量定义为数组，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] msg = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line">msg[<span class="number">0</span>] = <span class="string">&quot;good morning&quot;</span>;</span><br><span class="line">executor.submit(()-&gt;System.out.println(msg[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>

<p>从以上内容可以看出，Lambda表达式与匿名内部类很像，主要就是简化了语法，那它是不是语法糖，内部实现其实就是内部类呢？答案是否定的，<strong>Java会为每个匿名内部类生成一个类，但Lambda表达式不会</strong>。Lambda表达式通常比较短，为每个表达式生成一个类会生成大量的类，性能会受到影响。</p>
<p>内部实现上，Java利用了Java 7引入的为支持动态类型语言引入的invokedynamic指令、方法句柄（method handle）等，具体实现比较复杂，我们就不探讨了，感兴趣的读者可以参看<a target="_blank" rel="noopener" href="http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html</a> ，我们需要知道的是，Java的实现是非常高效的，不用担心生成太多类的问题。</p>
<p>Lambda表达式不是匿名内部类，那它的类型到底是什么呢？是<strong>函数式接口</strong>。</p>
<h2 id="26-1-3-函数式接口"><a href="#26-1-3-函数式接口" class="headerlink" title="26.1.3 函数式接口"></a>26.1.3 函数式接口</h2><p>Java 8引入了函数式接口的概念，函数式接口也是接口，但只能有一个抽象方法，前面提及的接口都只有一个抽象方法，都是函数式接口。之所以强调是“抽象”方法，是因为Java 8中还允许定义静态方法和默认方法。Lambda表达式可以赋值给函数式接口，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileFilter filter = path -&gt; path.getName().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">FilenameFilter fileNameFilter = (dir, name) -&gt; name.endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">Comparator&lt;File&gt; comparator = (f1, f2) -&gt;</span><br><span class="line">                    f1.getName().compareTo(f2.getName());</span><br><span class="line">Runnable task = () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果看这些接口的定义，会发现它们都有一个注解<code>@FunctionalInterface</code>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code>用于清晰地告知使用者这是一个函数式接口，不过，这个注解不是必需的，不加，只要只有一个抽象方法，也是函数式接口。但如果加了，而又定义了超过一个抽象方法，Java编译器会报错，这类似于我们之前介绍的Override注解。</p>
<h2 id="26-1-4-预定义的函数式接口"><a href="#26-1-4-预定义的函数式接口" class="headerlink" title="26.1.4 预定义的函数式接口"></a>26.1.4 预定义的函数式接口</h2><p>Java 8定义了大量的预定义函数式接口，用于常见类型的代码传递，这些函数定义在包java.util.function下，主要接口如表26-1所示。</p>
<center>表26-1 主要的预定义函数式接口</center>


<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211212654.jpeg" alt="epub_923038_153"><br>对于基本类型boolean、int、long和double，为避免装箱/拆箱，Java 8提供了一些专门的函数，比如，int相关的部分函数如表26-2所示。</p>
<center>表26-2 int类型的函数式接口</center>


<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211212741.jpeg" alt="epub_923038_154"><br>这些函数有什么用呢？它们被大量用于Java 8的函数式数据处理Stream相关的类中，即使不使用Stream，也可以在自己的代码中直接使用这些预定义的函数。我们看一些简单的示例，包括Predicate、Function和Consumer。</p>
<h3 id="1-Predicate示例"><a href="#1-Predicate示例" class="headerlink" title="1. Predicate示例"></a>1. Predicate示例</h3><p>为便于举例，我们先定义一个简单的学生类Student，它有name和score两个属性，如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们省略了构造方法和getter/setter方法。</p>
<p>有一个学生列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student[] &#123;</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">89d</span>), <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">89d</span>),</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">98d</span>) &#125;);</span><br></pre></td></tr></table></figure>

<p>在日常开发中，列表处理的一个常见需求是过滤，列表的类型经常不一样，过滤的条件也经常变化，但主体逻辑都是类似的，可以借助Predicate写一个通用的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">filter</span><span class="params">(List&lt;E&gt; list, Predicate&lt;E&gt; pred)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; retList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(E e : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pred.test(e)) &#123;</span><br><span class="line">            retList.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//过滤90分以上的</span></span><br><span class="line">students = filter(students, t -&gt; t.getScore() &gt; <span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-Function示例"><a href="#2-Function示例" class="headerlink" title="2. Function示例"></a>2. Function示例</h3><p>列表处理的另一个常见需求是转换。比如，给定一个学生列表，需要返回名称列表，或者将名称转换为大写返回，可以借助Function写一个通用的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T, R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    List&lt;R&gt; retList = <span class="keyword">new</span> ArrayList&lt;&gt;(list.size());</span><br><span class="line">    <span class="keyword">for</span>(T e : list) &#123;</span><br><span class="line">        retList.add(mapper.apply(e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据学生列表返回名称列表的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(students, t -&gt; t.getName());</span><br></pre></td></tr></table></figure>

<p>将学生名称转换为大写的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">students = map(students, t -&gt; <span class="keyword">new</span> Student(</span><br><span class="line">    t.getName().toUpperCase(), t.getScore()));</span><br></pre></td></tr></table></figure>

<h3 id="3-Consumer示例"><a href="#3-Consumer示例" class="headerlink" title="3. Consumer示例"></a>3. Consumer示例</h3><p>在上面转换学生名称为大写的例子中，我们为每个学生创建了一个新的对象，另一种常见的情况是直接修改原对象，通过代码传递，这时，可以用Consumer写一个通用的方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">foreach</span><span class="params">(List&lt;E&gt; list, Consumer&lt;E&gt; consumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(E e : list) &#123;</span><br><span class="line">        consumer.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面转换为大写的例子可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreach(students, t -&gt; t.setName(t.getName().toUpperCase()));</span><br></pre></td></tr></table></figure>

<p>以上这些示例主要用于演示函数式接口的基本概念，实际中可以直接使用流API。</p>
<h2 id="26-1-5-方法引用"><a href="#26-1-5-方法引用" class="headerlink" title="26.1.5 方法引用"></a>26.1.5 方法引用</h2><p>Lambda表达式经常用于调用对象的某个方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(students, t -&gt; t.getName());</span><br></pre></td></tr></table></figure>

<p>这时，它可以进一步简化，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = map(students, Student::getName);</span><br></pre></td></tr></table></figure>

<p>Student::getName这种写法是Java 8引入的一种新语法，称为<strong>方法引用</strong>。它是Lambda表达式的一种简写方法，由：：分隔为两部分，前面是类名或变量名，后面是方法名。方法可以是实例方法，也可以是静态方法，但含义不同。</p>
<p>我们看一些例子，还是以Student为例，先增加一个静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCollegeName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Laoma School&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于静态方法，如下两条语句是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Supplier&lt;String&gt; s = Student::getCollegeName;</span><br><span class="line">2. Supplier&lt;String&gt; s = () -&gt; Student.getCollegeName();</span><br></pre></td></tr></table></figure>

<p>它们的参数都是空，返回类型为String。</p>
<p>而对于实例方法，它的第一个参数就是该类型的实例，比如，如下两条语句是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Function&lt;Student, String&gt; f = Student::getName;</span><br><span class="line">2. Function&lt;Student, String&gt; f = (Student t) -&gt; t.getName();</span><br></pre></td></tr></table></figure>

<p>对于Student::setName，它是一个BiConsumer，即如下两条语句是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. BiConsumer&lt;Student, String&gt; c = Student::setName;</span><br><span class="line">2. BiConsumer&lt;Student, String&gt; c = (t, name) -&gt; t.setName(name);</span><br></pre></td></tr></table></figure>

<p>如果方法引用的第一部分是变量名，则相当于调用那个对象的方法。比如，假定t是一个Student类型的变量，则如下两条语句是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Supplier&lt;String&gt; s = t::getName;</span><br><span class="line">2. Supplier&lt;String&gt; s = () -&gt; t.getName();</span><br></pre></td></tr></table></figure>

<p>下面两条语句也是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Consumer&lt;String&gt; consumer = t::setName;</span><br><span class="line">2. Consumer&lt;String&gt; consumer = (name) -&gt; t.setName(name);</span><br></pre></td></tr></table></figure>

<p>对于构造方法，方法引用的语法是&lt;类名&gt;::new，如Student::new，即下面两条语句等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. BiFunction&lt;String, Double, Student&gt; s = (name, score)</span><br><span class="line">                                -&gt; new Student(name, score);</span><br><span class="line">2. BiFunction&lt;String, Double, Student&gt; s = Student::new;</span><br></pre></td></tr></table></figure>

<h2 id="26-1-6-函数的复合"><a href="#26-1-6-函数的复合" class="headerlink" title="26.1.6 函数的复合"></a>26.1.6 函数的复合</h2><p>在前面的例子中，函数式接口都用作方法的参数，其他部分通过Lambda表达式传递具体代码给它。<strong>函数式接口和Lambda表达式还可用作方法的返回值，传递代码回调用者，将这两种用法结合起来，可以构造复合的函数，使程序简洁易读</strong>。</p>
<p>下面我们看一些例子，这些例子利用了Java 8对接口的增强，即静态方法和默认方法，并利用它们实现复合函数，包括Comparator接口和function包。</p>
<h3 id="1-Comparator中的复合方法"><a href="#1-Comparator中的复合方法" class="headerlink" title="1. Comparator中的复合方法"></a>1. Comparator中的复合方法</h3><p>Comparator接口定义了如下静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(keyExtractor);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">        (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是什么意思呢？它用于构建一个Comparator，比如，在前面的例子中，对文件按照文件名排序的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(files, (f1, f2) -&gt; f1.getName().compareTo(f2.getName()));</span><br></pre></td></tr></table></figure>

<p>使用comparing方法，代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(files, Comparator.comparing(File::getName));</span><br></pre></td></tr></table></figure>

<p>这样，代码的可读性是不是大大增强了？comparing方法为什么能达到这个效果呢？它构建并返回了一个符合Comparator接口的Lambda表达式，这个Comparator接受的参数类型是File，它使用了传递过来的函数代码keyExtractor将File转换为String进行比较。像comparing这样使用复合方式构建并传递代码并不容易阅读，但调用者很方便，也很容易理解。</p>
<p>Comparator还有很多默认方法，我们看两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">reversed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.reverseOrder(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Comparator&lt;T&gt; <span class="title">thenComparing</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable) (c1, c2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> res = compare(c1, c2);</span><br><span class="line">        <span class="keyword">return</span> (res ! = <span class="number">0</span>) ? res : other.compare(c1, c2);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reversed返回一个新的Comparator，按原排序逆序排。thenComparing也返回一个新的Comparator，在原排序认为两个元素排序相同的时候，使用传递的Comparator other进行比较。</p>
<p>看一个使用的例子，将学生列表按照分数倒序排（高分在前），分数一样的按照名字进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.sort(Comparator.comparing(Student::getScore)</span><br><span class="line">                          .reversed()</span><br><span class="line">                          .thenComparing(Student::getName));</span><br></pre></td></tr></table></figure>

<p>这样，代码是不是很容易读？</p>
<h3 id="2-function包中的复合方法"><a href="#2-function包中的复合方法" class="headerlink" title="2. function包中的复合方法"></a>2. function包中的复合方法</h3><p>在java.util.function包的很多函数式接口里，都定义了一些复合方法，我们看一些例子。</p>
<p>Function接口有如下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先将T类型的参数转化为类型R，再调用after将R转换为V，最后返回类型V。</p>
<p>还有如下定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对V类型的参数，先调用before将V转换为T类型，再调用当前的apply方法转换为R类型返回。</p>
<p>Consumer、Predicate等都有一些复合方法，它们大量用于函数式数据处理API中，具体我们就不探讨了。</p>
<h2 id="26-1-7-小结"><a href="#26-1-7-小结" class="headerlink" title="26.1.7 小结"></a>26.1.7 小结</h2><p>本节介绍了Java 8中的一些新概念，包括Lambda表达式、函数式接口和方法引用等。</p>
<p>最重要的变化是，传递代码变得简单了，函数变为了代码世界的“一等公民”，可以方便地被作为参数传递，被作为返回值，被复合利用以构建新的函数，看上去，这些只是语法上的一些小变化，但利用这些小变化，却能使得代码更为通用、更为灵活、更为简洁易读，这大概就是函数式编程的奇妙之处。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/938c6751/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/938c6751/" class="post-title-link" itemprop="url">25.4 剖析常见表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:04 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:04+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC25%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第25章 正则表达式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/938c6751/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/938c6751/" data-xid="/JavaReadingNotes/938c6751/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="25-4-剖析常见表达式"><a href="#25-4-剖析常见表达式" class="headerlink" title="25.4 剖析常见表达式"></a>25.4 剖析常见表达式</h1><p>本节来讨论和分析一些常用的正则表达式，具体包括：</p>
<ul>
<li>邮编。</li>
<li>电话号码，包括手机号码和固定电话号码。</li>
<li>日期和时间。</li>
<li>身份证号。</li>
<li>IP地址。</li>
<li>URL。</li>
<li>Email地址。</li>
<li>中文字符。</li>
</ul>
<p>对于同一个目的，正则表达式往往有多种写法，大多没有唯一正确的写法，本节的写法主要是示例。此外，写一个正则表达式，匹配希望匹配的内容往往比较容易，但让它不匹配不希望匹配的内容则往往比较困难，也就是说，保证精确性经常是很难的，不过，很多时候，也没有必要写完全精确的表达式，需要写到多精确与需要处理的文本和需求有关。另外，正则表达式难以表达的，可以通过写程序进一步处理。这么描述可能比较抽象，下面，我们会具体讨论分析。</p>
<h2 id="1．邮编"><a href="#1．邮编" class="headerlink" title="1．邮编"></a>1．邮编</h2><p>邮编比较简单，就是6位数字，所以表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;6&#125;</span><br></pre></td></tr></table></figure>

<p>这个表达式可以用于验证输入是否为邮编，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern ZIP_CODE_PATTERN = Pattern.compile(<span class="string">&quot;[0-9]&#123;6&#125;&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isZipCode</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ZIP_CODE_PATTERN.matcher(text).matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但如果用于查找，这个表达式是不够的，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findZipCode</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    Matcher matcher = ZIP_CODE_PATTERN.matcher(text);</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        System.out.println(matcher.group());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    findZipCode(<span class="string">&quot;邮编 100013，电话18612345678&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文本中只有一个邮编，但输出却为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100013</span><br><span class="line">186123</span><br></pre></td></tr></table></figure>

<p>这怎么办呢？可以使用环视边界匹配，对于左边界，它前面的字符不能是数字，环视表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;![0-9])</span><br></pre></td></tr></table></figure>

<p>对于右边界，它右边的字符不能是数字，环视表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?![0-9])</span><br></pre></td></tr></table></figure>

<p>所以，完整的表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;![0-9])[0-9]&#123;6&#125;(?![0-9])</span><br></pre></td></tr></table></figure>

<p>使用这个表达式，将ZIP_CODE_PATTERN改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern ZIP_CODE_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">//左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;[0-9]&#123;6&#125;&quot;</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">//右边不能有数字</span></span><br></pre></td></tr></table></figure>

<p>就可以输出期望的结果了。6位数字就一定是邮编吗？答案当然是否定的，所以，这个表达式也不是精确的，如果需要更精确的验证，可以写程序进一步检查。</p>
<h2 id="2．手机号码"><a href="#2．手机号码" class="headerlink" title="2．手机号码"></a>2．手机号码</h2><p>中国的手机号码都是11位数字，所以，最简单的表达式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;11&#125;</span><br></pre></td></tr></table></figure>

<p>不过，目前手机号第1位都是1，第2位取值为3、4、5、7、8之一，所以更精确的表达式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[34578][0-9]&#123;9&#125;</span><br></pre></td></tr></table></figure>

<p>为方便表达手机号，手机号中间经常有连字符（即减号’-‘），形如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">186-1234-5678</span><br></pre></td></tr></table></figure>

<p>为表达这种可选的连字符，表达式可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[34578][0-9]-? [0-9]&#123;4&#125;-? [0-9]&#123;4&#125;</span><br></pre></td></tr></table></figure>

<p>在手机号前面，可能还有0、+86或0086，和手机号码之间可能还有一个空格，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">018612345678</span><br><span class="line">+86 18612345678</span><br><span class="line">0086 18612345678</span><br></pre></td></tr></table></figure>

<p>为表达这种形式，可以在号码前加如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((0|\+86|0086)\s? )?</span><br></pre></td></tr></table></figure>

<p>和邮编类似，如果为了抽取，也要在左右加环视边界匹配，左右不能是数字。所以，完整的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(? &lt;! [0-9])((0|\+86|0086)\s? )?1[34578][0-9]-? [0-9]&#123;4&#125;-? [0-9]&#123;4&#125;(? ! [0-9])</span><br></pre></td></tr></table></figure>

<p>用Java表示的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern MOBILE_PHONE_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">//左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;((0|\\+86|0086)\\s? )? &quot;</span> <span class="comment">// 0 +86 0086</span></span><br><span class="line">        + <span class="string">&quot;1[34578][0-9]-? [0-9]&#123;4&#125;-? [0-9]&#123;4&#125;&quot;</span> <span class="comment">// 186-1234-5678</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">//右边不能有数字</span></span><br></pre></td></tr></table></figure>

<h2 id="3．固定电话号码"><a href="#3．固定电话号码" class="headerlink" title="3．固定电话号码"></a>3．固定电话号码</h2><p>不考虑分机，中国的固定电话一般由两部分组成：区号和市内号码，区号是3到4位，市内号码是7到8位。区号以0开头，表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0[0-9]&#123;2,3&#125;</span><br></pre></td></tr></table></figure>

<p>市内号码表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;7,8&#125;</span><br></pre></td></tr></table></figure>

<p>区号可能用括号包含，区号与市内号码之间可能有连字符，如以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">010-62265678</span><br><span class="line">(010)62265678</span><br></pre></td></tr></table></figure>

<p>整个区号是可选的，所以整个表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\(?0[0-9]&#123;2,3&#125;\)?-?)?[0-9]&#123;7,8&#125;</span><br></pre></td></tr></table></figure>

<p>再加上左右边界环视，完整的Java表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern FIXED_PHONE_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">//左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;(\\(?0[0-9]&#123;2,3&#125;\\)? -? )? &quot;</span> <span class="comment">//区号</span></span><br><span class="line">        + <span class="string">&quot;[0-9]&#123;7,8&#125;&quot;</span><span class="comment">//市内号码</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">//右边不能有数字</span></span><br></pre></td></tr></table></figure>

<h2 id="4．日期"><a href="#4．日期" class="headerlink" title="4．日期"></a>4．日期</h2><p>日期的表示方式有很多种，我们只看一种，形如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-06-21</span><br><span class="line">2016-11-1</span><br></pre></td></tr></table></figure>

<p>年月日之间用连字符分隔，月和日可能只有一位。最简单的正则表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;</span><br></pre></td></tr></table></figure>

<p>年一般没有限制，但月只能取值1～12，日只能取值1～31，怎么表达这种限制呢？</p>
<p>对于月，有两种情况，1月到9月，表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0?[1-9]</span><br></pre></td></tr></table></figure>

<p>10月到12月，表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[0-2]</span><br></pre></td></tr></table></figure>

<p>所以，月的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0?[1-9]|1[0-2])</span><br></pre></td></tr></table></figure>

<p>对于日，有三种情况：</p>
<ul>
<li>1到9号，表达式为：<code>0?[1-9]</code>。</li>
<li>10号到29号，表达式为：<code>[1-2][0-9]</code>。</li>
<li>30号和31号，表达式为：<code>3[01]</code>。</li>
</ul>
<p>所以，整个表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;4&#125;-(0?[1-9]|1[0-2])-(0?[1-9]|[1-2][0-9]|3[01])</span><br></pre></td></tr></table></figure>

<p>加上左右边界环视，完整的Java表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern DATE_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">//左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;\\d&#123;4&#125;-&quot;</span> <span class="comment">//年</span></span><br><span class="line">        + <span class="string">&quot;(0? [1-9]|1[0-2])-&quot;</span> <span class="comment">//月</span></span><br><span class="line">        + <span class="string">&quot;(0? [1-9]|[1-2][0-9]|3[01])&quot;</span><span class="comment">//日</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">//右边不能有数字</span></span><br></pre></td></tr></table></figure>

<h2 id="5．时间"><a href="#5．时间" class="headerlink" title="5．时间"></a>5．时间</h2><p>考虑24小时制，只考虑小时和分钟，小时和分钟都用固定两位表示，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10:57</span><br></pre></td></tr></table></figure>

<p>基本表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;2&#125;:\d&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>小时取值范围为0～23，更精确的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([0-1][0-9]|2[0-3])</span><br></pre></td></tr></table></figure>

<p>分钟取值范围为0～59，更精确的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-5][0-9]</span><br></pre></td></tr></table></figure>

<p>所以，整个表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([0-1][0-9]|2[0-3]):[0-5][0-9]</span><br></pre></td></tr></table></figure>

<p>加上左右边界环视，完整的Java表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern TIME_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">// 左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;([0-1][0-9]|2[0-3])&quot;</span> <span class="comment">// 小时</span></span><br><span class="line">        + <span class="string">&quot;:&quot;</span> + <span class="string">&quot;[0-5][0-9]&quot;</span><span class="comment">// 分钟</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">// 右边不能有数字</span></span><br></pre></td></tr></table></figure>

<h2 id="6．身份证号"><a href="#6．身份证号" class="headerlink" title="6．身份证号"></a>6．身份证号</h2><p>身份证有一代和二代之分，一代身份证号是15位数字，二代身份证号是18位数字，都不能以0开头。对于二代身份证号，最后一位可能为x或X，其他是数字。一代身份证号表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9][0-9]&#123;14&#125;</span><br></pre></td></tr></table></figure>

<p>二代身份证号表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9][0-9]&#123;16&#125;[0-9xX]</span><br></pre></td></tr></table></figure>

<p>这两个表达式的前面部分是相同的，二代身份证号表达式多了如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9]&#123;2&#125;[0-9xX]</span><br></pre></td></tr></table></figure>

<p>所以，它们可以合并为一个表达式，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1-9][0-9]&#123;14&#125;([0-9]&#123;2&#125;[0-9xX])?</span><br></pre></td></tr></table></figure>

<p>加上左右边界环视，完整的Java表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern ID_CARD_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">//左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;[1-9][0-9]&#123;14&#125;&quot;</span> <span class="comment">//一代身份证</span></span><br><span class="line">        + <span class="string">&quot;([0-9]&#123;2&#125;[0-9xX])? &quot;</span> <span class="comment">//二代身份证多出的部分</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">//右边不能有数字</span></span><br></pre></td></tr></table></figure>

<p>符合这个要求的就一定是身份证号吗？当然不是，身份证号还有一些更为具体的要求，本书就不探讨了。</p>
<h2 id="7-IP地址"><a href="#7-IP地址" class="headerlink" title="7. IP地址"></a>7. IP地址</h2><p>IP地址示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.3.5</span><br></pre></td></tr></table></figure>

<p>点号分隔，4段数字，每个数字范围是0～255。最简单的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1-3&#125;</span><br></pre></td></tr></table></figure>

<p><code>\d&#123;1,3&#125;</code>太简单，没有满足0～255之间的约束，要满足这个约束，需要分多种情况考虑。</p>
<p>值是1位数，前面可能有0～2个0，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&#123;0,2&#125;[0-9]</span><br></pre></td></tr></table></figure>

<p>值是两位数，前面可能有一个0，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0?[0-9]&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>值是三位数，又要分为多种情况。以1开头的，后两位没有限制，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1[0-9]&#123;2&#125;</span><br></pre></td></tr></table></figure>

<p>以2开头的，如果第二位是0到4，则第三位没有限制，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2[0-4][0-9]</span><br></pre></td></tr></table></figure>

<p>如果第二位是5，则第三位取值为0到5，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25[0-5]</span><br></pre></td></tr></table></figure>

<p>所以，\d{1,3}更为精确的表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(0&#123;0,2&#125;[0-9]|0? [0-9]&#123;2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])</span><br></pre></td></tr></table></figure>

<p>所以，加上左右边界环视，IP地址的完整Java表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern IP_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;(? &lt;! [0-9])&quot;</span> <span class="comment">//左边不能有数字</span></span><br><span class="line">        + <span class="string">&quot;((0&#123;0,2&#125;[0-9]|0? [0-9]&#123;2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\\.)&#123;3&#125;&quot;</span></span><br><span class="line">        + <span class="string">&quot;(0&#123;0,2&#125;[0-9]|0? [0-9]&#123;2&#125;|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])&quot;</span></span><br><span class="line">        + <span class="string">&quot;(? ! [0-9])&quot;</span>); <span class="comment">//右边不能有数字</span></span><br></pre></td></tr></table></figure>

<h2 id="8-URL"><a href="#8-URL" class="headerlink" title="8. URL"></a>8. URL</h2><p>URL的格式比较复杂，其规范定义在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1738%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E8%80%83%E8%99%91HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%85%B6%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F%E6%98%AF%EF%BC%9A">https://tools.ietf.org/html/rfc1738，我们只考虑HTTP协议，其通用格式是：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;? &lt;searchpart&gt;</span><br></pre></td></tr></table></figure>

<p>开始是<code>http://</code>，接着是主机名，主机名之后是可选的端口，再之后是可选的路径，路径后是可选的查询字符串，以？开头。看一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com</span><br><span class="line">http://www.example.com/ab/c/def.html</span><br><span class="line">http://www.example.com:8080/ab/c/def? q1=abc&amp;q2=def</span><br></pre></td></tr></table></figure>

<p>主机名中的字符可以是字母、数字、减号和点号，所以表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-0-9a-zA-Z.]+</span><br></pre></td></tr></table></figure>

<p>端口部分可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(:\d+)?</span><br></pre></td></tr></table></figure>

<p>路径由多个子路径组成，每个子路径以/开头，后跟零个或多个非/的字符，简单地说，表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(/[^/]＊)＊</span><br></pre></td></tr></table></figure>

<p>更精确地说，把所有允许的字符列出来，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(/[-\w$.+! ＊&#x27;(), %; :@&amp;=]＊)＊</span><br></pre></td></tr></table></figure>

<p>对于查询字符串，简单地说，由非空字符串组成，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\?[\S]＊</span><br></pre></td></tr></table></figure>

<p>更精确的，把所有允许的字符列出来，表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\?[-\w$.+!＊&#x27;(),%;:@&amp;=]＊</span><br></pre></td></tr></table></figure>

<p>路径和查询字符串是可选的，且查询字符串只有在至少存在一个路径的情况下才能出现，其模式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(/&lt;sub_path&gt;(/&lt;sub_path&gt;)＊(\?&lt;search&gt;)?)?</span><br></pre></td></tr></table></figure>

<p>所以，路径和查询部分的简单表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(/[^/]＊(/[^/]＊)＊(\? [\S]＊)?)?</span><br></pre></td></tr></table></figure>

<p>精确表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(/[-\w$.+!＊&#x27;(),%;:@&amp;=]＊(/[-\w$.+!＊&#x27;(),%;:@&amp;=]＊)＊(\?[-\w$.+!＊&#x27;(),%;:@&amp;=]＊)?)?</span><br></pre></td></tr></table></figure>

<p>HTTP的完整Java表达式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern HTTP_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;http://&quot;</span> + <span class="string">&quot;[-0-9a-zA-Z.]+&quot;</span> <span class="comment">//主机名</span></span><br><span class="line">        + <span class="string">&quot;(:\\d+)? &quot;</span> <span class="comment">//端口</span></span><br><span class="line">        + <span class="string">&quot;(&quot;</span> <span class="comment">//可选的路径和查询 - 开始</span></span><br><span class="line">            + <span class="string">&quot;/[-\\w$.+! ＊&#x27;(), %; :@&amp;=]＊&quot;</span> <span class="comment">//第一层路径</span></span><br><span class="line">            + <span class="string">&quot;(/[-\\w$.+! ＊&#x27;(), %; :@&amp;=]＊)＊&quot;</span> <span class="comment">//可选的其他层路径</span></span><br><span class="line">            + <span class="string">&quot;(\\? [-\\w$.+! ＊&#x27;(), %; :@&amp;=]＊)? &quot;</span> <span class="comment">//可选的查询字符串</span></span><br><span class="line">        + <span class="string">&quot;)? &quot;</span>); <span class="comment">//可选的路径和查询 - 结束</span></span><br></pre></td></tr></table></figure>

<h2 id="9-Email地址"><a href="#9-Email地址" class="headerlink" title="9. Email地址"></a>9. Email地址</h2><p>完整的Email规范比较复杂，定义在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc822%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%88%E7%9C%8B%E4%B8%80%E4%BA%9B%E5%AE%9E%E9%99%85%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E3%80%82%E6%AF%94%E5%A6%82%E6%96%B0%E6%B5%AA%E9%82%AE%E7%AE%B1%EF%BC%9A">https://tools.ietf.org/html/rfc822，我们先看一些实际中常用的。比如新浪邮箱：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc@sina.com</span><br></pre></td></tr></table></figure>

<p>对于用户名部分，它的要求是：4～16个字符，可使用英文小写、数字、下画线，但下画线不能在首尾。怎么验证用户名呢？可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-z0-9][a-z0-9_]&#123;2,14&#125;[a-z0-9]</span><br></pre></td></tr></table></figure>

<p>新浪邮箱的完整Java表达式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern SINA_EMAIL_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;[a-z0-9]&quot;</span></span><br><span class="line">        + <span class="string">&quot;[a-z0-9_]&#123;2,14&#125;&quot;</span></span><br><span class="line">        + <span class="string">&quot;[a-z0-9]@sina\\.com&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们再来看QQ邮箱，它对于用户名的要求为：</p>
<p>1）3～18个字符，可使用英文、数字、减号、点或下画线；<br>2）必须以英文字母开头，必须以英文字母或数字结尾；<br>3）点、减号、下画线不能连续出现两次或两次以上。</p>
<p>如果只有第1条，可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-0-9a-zA-Z._]&#123;3,18&#125;</span><br></pre></td></tr></table></figure>

<p>为满足第2条，可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z][-0-9a-zA-Z._]&#123;1,16&#125;[a-zA-Z0-9]</span><br></pre></td></tr></table></figure>

<p>怎么满足第3条呢？可以使用边界环视，左边加如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?![-0-9a-zA-Z._]＊(--|\.\.|__))</span><br></pre></td></tr></table></figure>

<p>完整表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?![-0-9a-zA-Z._]＊(--|\.\.|__))[a-zA-Z][-0-9a-zA-Z._]&#123;1,16&#125;[a-zA-Z0-9]</span><br></pre></td></tr></table></figure>

<p>QQ邮箱的完整Java表达式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern QQ_EMAIL_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="comment">//点、减号、下画线不能连续出现两次或两次以上</span></span><br><span class="line">        <span class="string">&quot;(? ! [-0-9a-zA-Z._]＊(--|\\.\\.|__))&quot;</span></span><br><span class="line">        + <span class="string">&quot;[a-zA-Z]&quot;</span> <span class="comment">//必须以英文字母开头</span></span><br><span class="line">        + <span class="string">&quot;[-0-9a-zA-Z._]&#123;1,16&#125;&quot;</span> <span class="comment">//3～18位 英文、数字、减号、点、下画线组成</span></span><br><span class="line">        + <span class="string">&quot;[a-zA-Z0-9]@qq\\.com&quot;</span>); <span class="comment">//由英文字母、数字结尾</span></span><br></pre></td></tr></table></figure>

<p>以上都是特定邮箱服务商的要求，一般的邮箱是什么规则呢？一般而言，以@作为分隔符，前面是用户名，后面是域名。用户名的一般规则是：</p>
<ul>
<li>由英文字母、数字、下画线、减号、点号组成；</li>
<li>至少1位，不超过64位；</li>
<li>开头不能是减号、点号和下画线。</li>
</ul>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h_llo-abc.good@example.com</span><br></pre></td></tr></table></figure>

<p>这个表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9a-zA-Z][-._0-9a-zA-Z]&#123;0,63&#125;</span><br></pre></td></tr></table></figure>

<p>域名部分以点号分隔为多个部分，至少有两个部分。最后一部分是顶级域名，由2～3个英文字母组成，表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z]&#123;2,3&#125;</span><br></pre></td></tr></table></figure>

<p>对于域名的其他点号分隔的部分，每个部分一般由字母、数字、减号组成，但减号不能在开头，长度不能超过63个字符，表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9a-zA-Z][-0-9a-zA-Z]&#123;0,62&#125;</span><br></pre></td></tr></table></figure>

<p>所以，域名部分的表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([0-9a-zA-Z][-0-9a-zA-Z]&#123;0,62&#125;\.)+[a-zA-Z]&#123;2,3&#125;</span><br></pre></td></tr></table></figure>

<p>完整的Java表示为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern GENERAL_EMAIL_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;[0-9a-zA-Z][-._0-9a-zA-Z]&#123;0,63&#125;&quot;</span> <span class="comment">//用户名</span></span><br><span class="line">        + <span class="string">&quot;@&quot;</span></span><br><span class="line">        + <span class="string">&quot;([0-9a-zA-Z][-0-9a-zA-Z]&#123;0,62&#125;\\.)+&quot;</span> <span class="comment">//域名部分</span></span><br><span class="line">        + <span class="string">&quot;[a-zA-Z]&#123;2,3&#125;&quot;</span>); <span class="comment">//顶级域名</span></span><br></pre></td></tr></table></figure>

<h2 id="10．中文字符"><a href="#10．中文字符" class="headerlink" title="10．中文字符"></a>10．中文字符</h2><p>中文字符的Unicode编号一般位于\u4e00～\u9fff之间，所以匹配任意一个中文字符的表达式可以为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\u4e00-\u9fff]</span><br></pre></td></tr></table></figure>

<p>Java表达式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Pattern CHINESE_PATTERN = Pattern.compile(</span><br><span class="line">        <span class="string">&quot;[\\u4e00-\\u9fff]&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="11．小结"><a href="#11．小结" class="headerlink" title="11．小结"></a>11．小结</h2><p>本节详细讨论和分析了一些常见的正则表达式。在实际开发中，有些可以直接使用，有些需要根据具体文本和需求进行调整。完整的代码在Github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.laoma.regex.c90下。</p>
<p>至此，关于正则表达式就介绍完了。下一章，我们探讨Java 8中的函数式编程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/cb2401c5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/cb2401c5/" class="post-title-link" itemprop="url">25.3 模板引擎</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:03 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:03+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC25%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第25章 正则表达式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/cb2401c5/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/cb2401c5/" data-xid="/JavaReadingNotes/cb2401c5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="25-3-模板引擎"><a href="#25-3-模板引擎" class="headerlink" title="25.3 模板引擎"></a>25.3 模板引擎</h1><p>利用Java API尤其是Matcher中的几个方法，我们可以实现一个简单的模板引擎。模板是一个字符串，中间有一些变量，以<code>&#123;name&#125;</code>表示，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String template = <span class="string">&quot;Hi &#123;name&#125;, your code is &#123;code&#125;.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里，模板字符串中有两个变量：一个是name，另一个是code。变量的实际值通过Map提供，变量名称对应Map中的键，模板引擎的任务就是接受模板和Map作为参数，返回替换变量后的字符串，示例实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Pattern templatePattern = Pattern.compile(<span class="string">&quot;\\&#123;(\\w+)\\&#125;&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">templateEngine</span><span class="params">(String template,</span></span></span><br><span class="line"><span class="params"><span class="function">        Map&lt;String, Object&gt; params)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    Matcher matcher = templatePattern.matcher(template);</span><br><span class="line">    <span class="keyword">while</span>(matcher.find()) &#123;</span><br><span class="line">        String key = matcher.group(<span class="number">1</span>);</span><br><span class="line">        Object value = params.get(key);</span><br><span class="line">        matcher.appendReplacement(sb, value ! = <span class="keyword">null</span></span><br><span class="line">                Matcher.quoteReplacement(value.toString()) : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    matcher.appendTail(sb);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码寻找所有的模板变量，正则表达式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&#123;(\w+)\&#125;</span><br></pre></td></tr></table></figure>

<p>‘<code>&#123;</code>‘是元字符，所以要转义。<code>\w+</code>表示变量名，为便于引用，加了括号，可以通过分组1引用变量名。</p>
<p>使用该模板引擎的示例代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">templateDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String template = <span class="string">&quot;Hi &#123;name&#125;, your code is &#123;code&#125;.&quot;</span>;</span><br><span class="line">    Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    params.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br><span class="line">    params.put(<span class="string">&quot;code&quot;</span>, <span class="number">6789</span>);</span><br><span class="line">    System.out.println(templateEngine(template, params));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi 老马， your code is 6789.</span><br></pre></td></tr></table></figure>

<p>完整代码在github上，地址为 <a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo. laoma.regex.c89下。下一节，我们讨论和分析一些常见的正则表达式。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/56a2ee79/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/56a2ee79/" class="post-title-link" itemprop="url">25.2 Java API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:01 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:01+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC25%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第25章 正则表达式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/56a2ee79/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/56a2ee79/" data-xid="/JavaReadingNotes/56a2ee79/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="25-2-Java-API"><a href="#25-2-Java-API" class="headerlink" title="25.2 Java API"></a>25.2 Java API</h1><p>正则表达式相关的类位于包java.util.regex下，有两个主要的类，一个是Pattern，另一个是Matcher。Pattern表示正则表达式对象，它与要处理的具体字符串无关。Matcher表示一个匹配，它将正则表达式应用于一个具体字符串，通过它对字符串进行处理。</p>
<p>字符串类String也是一个重要的类，我们之前专门介绍过String，其中提到，它有一些方法，接受的参数不是普通的字符串，而是正则表达式。此外，正则表达式在Java中是需要先以字符串形式表示的。</p>
<p>下面，我们先来介绍如何表示正则表达式，然后探讨如何利用它实现一些常见的文本处理任务，包括切分、验证、查找和替换。</p>
<h2 id="1．表示正则表达式"><a href="#1．表示正则表达式" class="headerlink" title="1．表示正则表达式"></a>1．表示正则表达式</h2><p>正则表达式由元字符和普通字符组成，字符’<code>\</code>‘是一个元字符，要在正则表达式中表示’<code>\</code>‘本身，需要使用它转义，即’<code>\\</code>‘。</p>
<p>在Java中，没有什么特殊的语法能直接表示正则表达式，需要用字符串表示，而在字符串中，’<code>\</code>‘也是一个元字符，为了在字符串中表示正则表达式的’<code>\</code>‘，就需要使用两个’<code>\</code>‘，即’<code>\\</code>‘，而要匹配’<code>\</code>‘本身，就需要4个’<code>\</code>‘，即’<code>\\\\</code>‘。比如，如下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(\w+)&gt;(.＊)&lt;/\1&gt;</span><br></pre></td></tr></table></figure>

<p>对应的字符串表示就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;(\\w+)&gt;(.＊)&lt;/\\1&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>一个简单规则是：**正则表达式中的任何一个’<code>\</code>‘，在字符串中，需要替换为两个’<code>\</code>‘**。</p>
<p>字符串表示的正则表达式可以被<strong>编译</strong>为一个Pattern对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;&lt;(\\w+)&gt;(.＊)&lt;/\\1&gt;&quot;</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br></pre></td></tr></table></figure>

<p>Pattern是正则表达式的面向对象表示，所谓编译，简单理解就是将字符串表示为了一个内部结构，这个结构是一个有穷自动机。关于<strong>有穷自动机</strong>的理论比较深入，我们就不探讨了。</p>
<p>编译有一定的成本，而且Pattern对象只与正则表达式有关，与要处理的具体文本无关，它可以安全地被多线程共享，所以，在使用同一个正则表达式处理多个文本时，应该尽量重用同一个Pattern对象，避免重复编译。</p>
<p>Pattern的compile方法接受一个额外参数，可以指定匹配模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pattern <span class="title">compile</span><span class="params">(String regex, <span class="keyword">int</span> flags)</span></span></span><br></pre></td></tr></table></figure>

<p>上节，我们介绍过三种匹配模式：单行模式（点号模式）、多行模式和大小写无关模式，它们对应的常量分别为：<code>Pattern.DOTALL</code>、<code>Pattern.MULTILINE</code>和<code>Pattern.CASE_INSENSI-TIVE</code>，多个模式可以一起使用，通过’|’连起来即可，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern.compile(regex, Pattern.CASE_INSENSITIVE | Pattern.DOTALL)</span><br></pre></td></tr></table></figure>

<p>还有一个模式<code>Pattern.LITERAL</code>，在此模式下，正则表达式字符串中的元字符将失去特殊含义，被看作普通字符。Pattern有一个静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">quote</span><span class="params">(String s)</span></span></span><br></pre></td></tr></table></figure>

<p>quote()的目的是类似的，它将s中的字符都看作普通字符。我们在上节介绍过<code>\Q</code>和<code>\E</code>, <code>\Q</code>和<code>\E</code>之间的字符会被视为普通字符。quote()基本上就是在字符串s的前后加了<code>\Q</code>和<code>\E</code>，比如，如果s为”<code>\\d&#123;6&#125;</code>“，则quote()的返回值就是”<code>\\Q\\d&#123;6&#125;\\E</code>“。</p>
<h2 id="2．切分"><a href="#2．切分" class="headerlink" title="2．切分"></a>2．切分</h2><p>文本处理的一个常见需求是根据分隔符切分字符串，比如在处理CSV文件时，按逗号分隔每个字段，这个需求听上去很容易满足，因为String类有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc, def, hello&quot;</span>;</span><br><span class="line">String[] fields = str.split(<span class="string">&quot;, &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过，有一些重要的细节，我们需要注意。</p>
<p>split将参数regex看作正则表达式，而不是普通的字符，如果分隔符是元字符，比如． <code>$|()[&#123;^?*+\</code>，就需要转义。比如按点号’<code>.</code>‘分隔，需要写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] fields = str.split(<span class="string">&quot;\\.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果分隔符是用户指定的，程序事先不知道，可以通过<code>Pattern.quote()</code>将其看作普通字符串。</p>
<p>既然是正则表达式，分隔符就不一定是一个字符，比如，可以将一个或多个空白字符或点号作为分隔符，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc   def        hello.\n    world&quot;</span>;</span><br><span class="line">String[] fields = str.split(<span class="string">&quot;[\\s.]+&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>fields内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[abc, def, hello, world]</span><br></pre></td></tr></table></figure>

<p>需要说明的是，尾部的空白字符串不会包含在返回的结果数组中，但头部和中间的空白字符串会被包含在内，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;, abc, , def, , &quot;</span>;</span><br><span class="line">String[] fields = str.split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;field num: &quot;</span>+fields.length);</span><br><span class="line">System.out.println(Arrays.toString(fields));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">field num: 4</span><br><span class="line">[, abc, , def]</span><br></pre></td></tr></table></figure>

<p>如果字符串中找不到匹配regex的分隔符，返回数组长度为1，元素为原字符串。</p>
<p>Pattern也有split方法，与String方法的定义类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(CharSequence input)</span><br></pre></td></tr></table></figure>

<p>与String方法的区别如下。<br>1）Pattern接受的参数是CharSequence，更为通用，我们知道String、StringBuilder、StringBuffer、CharBuffer等都实现了该接口。<br>2）如果regex长度大于1或包含元字符，String的split方法必须先将regex编译为Pattern对象，再调用Pattern的split方法，这时，为避免重复编译，应该优先采用Pattern的方法。<br>3）如果regex就是一个字符且不是元字符，String的split方法会采用更为简单高效的实现，所以，这时应该优先采用String的split方法。</p>
<h2 id="3．验证"><a href="#3．验证" class="headerlink" title="3．验证"></a>3．验证</h2><p>验证就是检验输入文本是否完整匹配预定义的正则表达式，经常用于检验用户的输入是否合法。String有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span></span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;\\d&#123;8&#125;&quot;</span>;</span><br><span class="line">String str = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">System.out.println(str.matches(regex));</span><br></pre></td></tr></table></figure>

<p>检查输入是否是8位数字，输出为true。</p>
<p>String的matches实际调用的是Pattern的如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex, CharSequence input)</span></span></span><br></pre></td></tr></table></figure>

<p>这是一个静态方法，它的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex, CharSequence input)</span> </span>&#123;</span><br><span class="line">    Pattern p = Pattern.compile(regex);</span><br><span class="line">    Matcher m = p.matcher(input);</span><br><span class="line">    <span class="keyword">return</span> m.matches();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是先调用compile编译regex为Pattern对象，再调用Pattern的matcher方法生成一个匹配对象Matcher, Matcher的matches方法返回是否完整匹配。</p>
<h2 id="4．查找"><a href="#4．查找" class="headerlink" title="4．查找"></a>4．查找</h2><p>查找就是在文本中寻找匹配正则表达式的子字符串，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String regex = <span class="string">&quot;\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;&quot;</span>;</span><br><span class="line">    Pattern pattern = Pattern.compile(regex);</span><br><span class="line">    String str = <span class="string">&quot;today is 2017-06-02, yesterday is 2017-06-01&quot;</span>;</span><br><span class="line">    Matcher matcher = pattern.matcher(str);</span><br><span class="line">    <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;find &quot;</span>+matcher.group()</span><br><span class="line">            +<span class="string">&quot; position: &quot;</span>+matcher.start()+<span class="string">&quot;-&quot;</span>+matcher.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码寻找所有类似”2017-06-02”这种格式的日期，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find 2017-06-02 position: 9-19</span><br><span class="line">find 2017-06-01 position: 34-44</span><br></pre></td></tr></table></figure>

<p>Matcher的内部记录有一个位置，起始为0, find方法从这个位置查找匹配正则表达式的子字符串，找到后，返回true，并更新这个内部位置，匹配到的子字符串信息可以通过如下方法获取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//匹配到的完整子字符串</span><br><span class="line">public String group()</span><br><span class="line">//子字符串在整个字符串中的起始位置</span><br><span class="line">public int start()</span><br><span class="line">//子字符串在整个字符串中的结束位置加1</span><br><span class="line">public int end()</span><br></pre></td></tr></table></figure>

<p>group()其实调用的是group(0)，表示获取匹配的第0个分组的内容。我们在上节介绍过捕获分组的概念，分组0是一个特殊分组，表示匹配的整个子字符串。除了分组0, Matcher还有如下方法，获取分组的更多信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分组个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">groupCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//分组编号为group的内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(<span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"><span class="comment">//分组命名为name的内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">group</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//分组编号为group的起始位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"><span class="comment">//分组编号为group的结束位置加1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span></span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String regex = <span class="string">&quot;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&quot;</span>;</span><br><span class="line">    Pattern pattern = Pattern.compile(regex);</span><br><span class="line">    String str = <span class="string">&quot;today is 2017-06-02, yesterday is 2017-06-01&quot;</span>;</span><br><span class="line">    Matcher matcher = pattern.matcher(str);</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;year:&quot;</span> + matcher.group(<span class="number">1</span>)</span><br><span class="line">            + <span class="string">&quot;, month:&quot;</span> + matcher.group(<span class="number">2</span>) + <span class="string">&quot;, day:&quot;</span> + matcher.group(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">year:2017, month:06, day:02</span><br><span class="line">year:2017, month:06, day:01</span><br></pre></td></tr></table></figure>

<h2 id="5．替换"><a href="#5．替换" class="headerlink" title="5．替换"></a>5．替换</h2><p>查找到子字符串后，一个常见的后续操作是替换。String有多个替换方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span></span></span><br></pre></td></tr></table></figure>

<p>第一个replace方法操作的是单个字符，第二个是CharSequence，它们都是将参数看作普通字符。而replaceAll和replaceFirst则将参数regex看作正则表达式，它们的区别是， replaceAll替换所有找到的子字符串，而replaceFirst则只替换第一个找到的。看个简单的例子，将字符串中的多个连续空白字符替换为一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;\\s+&quot;</span>;</span><br><span class="line">String str = <span class="string">&quot;hello     world         good&quot;</span>;</span><br><span class="line">System.out.println(str.replaceAll(regex, <span class="string">&quot; &quot;</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello world good</span><br></pre></td></tr></table></figure>

<p>在replaceAll和replaceFirst中，参数replacement也不是被看作普通的字符串，可以使用美元符号加数字的形式（比如$<br>1）引用捕获分组。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&quot;</span>;</span><br><span class="line">String str = <span class="string">&quot;today is 2017-06-02.&quot;</span>;</span><br><span class="line">System.out.println(str.replaceFirst(regex, <span class="string">&quot;$1/$2/$3&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">today is 2017/06/02.</span><br></pre></td></tr></table></figure>

<p>这个例子将找到的日期字符串的格式进行了转换。所以，字符’$’在replacement中是元字符，如果需要替换为字符’$’本身，需要使用转义。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">&quot;#&quot;</span>;</span><br><span class="line">String str = <span class="string">&quot;#this is a test&quot;</span>;</span><br><span class="line">System.out.println(str.replaceAll(regex, <span class="string">&quot;\\$&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果替换字符串是用户提供的，为避免元字符的干扰，可以使用Matcher的如下静态方法将其视为普通字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">quoteReplacement</span><span class="params">(String s)</span></span></span><br></pre></td></tr></table></figure>

<p>String的replaceAll和replaceFirst调用的其实是Pattern和Matcher中的方法。比如， replaceAll的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>replaceAll和replaceFirst都定义在Matcher中，除了一次性的替换操作外，Matcher还定义了边查找、边替换的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Matcher <span class="title">appendReplacement</span><span class="params">(StringBuffer sb, String replacement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">appendTail</span><span class="params">(StringBuffer sb)</span></span></span><br></pre></td></tr></table></figure>

<p>这两个方法用于和find()一起使用，我们先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Pattern p = Pattern.compile(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    Matcher m = p.matcher(<span class="string">&quot;one cat, two cat, three cat&quot;</span>);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">int</span> foundNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">        m.appendReplacement(sb, <span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        foundNum++;</span><br><span class="line">        <span class="keyword">if</span>(foundNum == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    m.appendTail(sb);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将前两个”cat”替换为了”dog”，其他”cat”不变，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one dog, two dog, three cat</span><br></pre></td></tr></table></figure>

<p>StringBuffer类型的变量sb存放最终的替换结果，Matcher内部除了有一个查找位置，还有一个append位置，初始为0，当找到一个匹配的子字符串后，appendReplacement()做了三件事情：<br>1）将append位置到当前匹配之前的子字符串append到sb中，在第一次操作中，为”one “，第二次为”, two “。<br>2）将替换字符串append到sb中。<br>3）更新append位置为当前匹配之后的位置。</p>
<p>appendTail将append位置之后所有的字符append到sb中。</p>
<p>至此，正则表达式相关的主要Java API就介绍完了。我们讨论了如何在Java中表示正则表达式，如何利用它实现文本的切分、验证、查找和替换，对于替换，下面我们演示一个简单的模板引擎。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/74dd3bfe/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/74dd3bfe/" class="post-title-link" itemprop="url">25.0 第25章 正则表达式 25.1 语法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:40:00 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:40:00+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC25%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第25章 正则表达式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/74dd3bfe/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/74dd3bfe/" data-xid="/JavaReadingNotes/74dd3bfe/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第25章-正则表达式"><a href="#第25章-正则表达式" class="headerlink" title="第25章 正则表达式"></a>第25章 正则表达式</h1><p>前面章节，我们提到了正则表达式，它提升了文本处理的表达能力，本章就来讨论正则表达式，它是什么？有什么用？各种特殊字符都是什么含义？如何用Java借助正则表达式处理文本？都有哪些常用正则表达式？我们分为4小节进行介绍：25.1节先简要介绍正则表达式的语法；25.2节介绍相关的Java API;25.3节利用Java API实现一个简单的模板引擎；25.4节讨论和分析一些常用的正则表达式。</p>
<h1 id="25-1-语法"><a href="#25-1-语法" class="headerlink" title="25.1 语法"></a>25.1 语法</h1><p>正则表达式是一串字符，它描述了一个文本模式，利用它可以方便地处理文本，包括文本的查找、替换、验证、切分等。正则表达式中的字符有两类：一类是普通字符，就是匹配字符本身；另一类是元字符，这些字符有特殊含义，这些元字符及其特殊含义构成了正则表达式的语法。</p>
<p>正则表达式有一个比较长的历史，各种与文本处理有关的工具、编辑器和系统都支持正则表达式，大部分编程语言也都支持正则表达式。虽然都叫正则表达式，但由于历史原因，不同语言、系统和工具的语法不太一样，本书主要针对Java语言，其他语言可能有所差别。</p>
<p>下面，我们就来简要介绍正则表达式的语法，我们先分为以下部分分别介绍：</p>
<ul>
<li>单个字符；</li>
<li>字符组；</li>
<li>量词；</li>
<li>分组；</li>
<li>特殊边界匹配；</li>
<li>环视边界匹配。</li>
</ul>
<p>最后针对转义、匹配模式和各种语法进行总结。</p>
<h2 id="1．单个字符"><a href="#1．单个字符" class="headerlink" title="1．单个字符"></a>1．单个字符</h2><p>大部分的单个字符就是用字符本身表示的，比如字符’0’、’3’、’a’、’马’等，但<strong>有一些单个字符使用多个字符表示</strong>，这些字符都以斜杠’<code>\</code>‘开头，比如：<br>1）<strong>特殊字符</strong>，比如tab字符’<code>\t</code>‘、换行符’<code>\n</code>‘、回车符’<code>\r</code>‘等。<br>2）<strong>八进制表示的字符</strong>，以<code>\0</code>开头，后跟1～3位数字，比如<code>\0141</code>，对应的是ASCII编码为97的字符，即字符’a’。<br>3）<strong>十六进制表示的字符</strong>，以<code>\x</code>开头，后跟两位字符，比如<code>\x6A</code>，对应的是ASCII编码为106的字符，即字符’j’。<br>4）<strong>Unicode编号表示的字符</strong>，以<code>\u</code>开头，后跟4位字符，比如<code>\u9A6C</code>，表示的是中文字符’马’，这只能表示编号在0xFFFF以下的字符，如果超出0XFFFF，使用<code>\x&#123;...&#125;</code>形式，比如<code>\x&#123;1f48e&#125;</code>。<br>5）<strong>斜杠\本身</strong>，斜杠<code>\</code>是一个元字符，如果要匹配它自身，使用两个斜杠表示，即’<code>\\</code>‘。<br>6）<strong>元字符本身</strong>，除了’<code>\</code>‘，正则表达式中还有很多元字符，比如<code>．</code>、<code>*</code>、<code>?</code> 、<code>+</code>等，要匹配这些元字符自身，需要在前面加转义字符’<code>\</code>‘，比如’<code>\.</code>‘。</p>
<h2 id="2．字符组"><a href="#2．字符组" class="headerlink" title="2．字符组"></a>2．字符组</h2><p>字符组有多种，包括任意字符、多个指定字符之一、字符区间、排除型字符组、预定义的字符组等，下面具体介绍。</p>
<p>点号字符’.’是一个元字符，默认模式下，它匹配<strong>除了换行符以外的任意字符</strong>，比如正则表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.f</span><br></pre></td></tr></table></figure>
<p>既匹配字符串”<code>abf</code>“，也匹配”<code>acf</code>“。可以指定另外一种匹配模式，一般称为<strong>单行匹配模式</strong>或者<strong>点号匹配模式</strong>，在此模式下，’<code>.</code>‘匹配任意字符，包括换行符。可以有两种方式指定匹配模式：一种是在正则表达式中，以<code>(?s)</code>开头，s表示<code>single line</code>，即<code>单行匹配模式</code>。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?s)a.f</span><br></pre></td></tr></table></figure>
<p>另外一种是在程序中指定，在Java中，对应的模式常量是<code>Pattern.DOTALL</code>，下节我们再介绍Java API。</p>
<p>在单个字符和任意字符之间，有一个字符组的概念，匹配组中的任意一个字符，用中括号<code>[]</code>表示，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[abcd]</span><br></pre></td></tr></table></figure>

<p>匹配a、b、c、d中的任意一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0123456789]</span><br></pre></td></tr></table></figure>

<p>匹配任意一个数字字符。</p>
<p>为方便表示连续的多个字符，字符组中可以使用连字符’-‘，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[0-9]</span><br><span class="line">[a-z]</span><br></pre></td></tr></table></figure>

<p>可以有多个连续空间，可以有其他普通字符，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0-9a-zA-Z_]</span><br></pre></td></tr></table></figure>

<p>在字符组中，’-‘是一个元字符，如果要匹配它自身，可以使用转义，即’-‘，或者把它放在字符组的最前面，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-0-9]</span><br></pre></td></tr></table></figure>

<p>字符组支持排除的概念，在[后紧跟一个字符^，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^abcd]</span><br></pre></td></tr></table></figure>

<p>表示匹配除了a, b, c, d以外的任意一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^0-9]</span><br></pre></td></tr></table></figure>

<p>表示匹配一个非数字字符。</p>
<p>排除不是不能匹配，而是匹配一个指定字符组以外的字符，要表达不能匹配的含义，需要使用后文介绍的环视语法。^只有在字符组的开头才是元字符，如果不在开头，就是普通字符，匹配它自身，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a^b]</span><br></pre></td></tr></table></figure>

<p>就是匹配字符a, <code>^</code>或b。</p>
<p>在字符组中，除了<code>^</code>、<code>-</code>、<code>[ ]</code>、<code>\</code>外，其他在字符组外的元字符不再具备特殊含义，变成了普通字符，比如字符’<code>.</code>‘和’<code>*</code>‘, <code>[.*]</code>就是匹配’<code>.</code>‘或者’<code>*</code>‘本身。</p>
<p>有一些特殊的以\开头的字符，表示一些预定义的字符组，比如：</p>
<ul>
<li><code>\d</code>:d表示digit，匹配一个数字字符，等同于<code>[0-9]</code>。</li>
<li><code>\w</code>:w表示word，匹配一个单词字符，等同于<code>[a-zA-Z_0-9]</code>。</li>
<li><code>\s</code>:s表示space，匹配一个空白字符，等同于<code>[ \t\n\x0B\f\r]</code>。</li>
</ul>
<p>它们都有对应的排除型字符组，用大写表示，即：</p>
<ul>
<li><code>\D</code>：匹配一个非数字字符，即<code>[^\d]</code>。</li>
<li><code>\W</code>：匹配一个非单词字符，即<code>[^\w]</code>。</li>
<li><code>\S</code>：匹配一个非空白字符，即<code>[^\s]</code>。</li>
</ul>
<p>还有一类字符组，称为POSIX字符组，它们是POSIX标准定义的一些字符组，在Java中，这些字符组的形式是<code>\p&#123;...&#125;</code>。POSIX字符组比较多，我们就不介绍了。</p>
<h2 id="3．量词"><a href="#3．量词" class="headerlink" title="3．量词"></a>3．量词</h2><p>量词指的是指定出现次数的元字符，有三个常见的元字符：<code>+</code>、<code>*</code>、<code>?</code> ：<br>1）<code>+</code>：表示前面字符的一次或多次出现，比如正则表达式ab+c，既能匹配abc，也能匹配abbc，或abbbc。<br>2）<code>*</code>：表示前面字符的零次或多次出现，比如正则表达式ab*c，既能匹配abc，也能匹配ac，或abbbc。<br>3）<code>?</code>：表示前面字符可能出现，也可能不出现，比如正则表达式ab? c，既能匹配abc，也能匹配ac，但不能匹配abbc。</p>
<p>更为通用的表示出现次数的语法是<code>&#123;m,n&#125;</code>，出现次数从m到n，包括m和n，如果n没有限制，可以省略，如果m和n一样，可以写为<code>&#123;m&#125;</code>，比如：</p>
<ul>
<li><code>ab&#123;1,10&#125;c</code>:b可以出现1次到10次。</li>
<li><code>ab&#123;3&#125;c</code>:b必须出现三次，即只能匹配<code>abbbc</code>。</li>
<li><code>ab&#123;1,&#125;c</code>：与<code>ab+c</code>一样。</li>
<li><code>ab&#123;0,&#125;c</code>：与<code>ab*c</code>一样。</li>
<li><code>ab&#123;0,1&#125;c</code>：与<code>ab?c</code>一样。</li>
</ul>
<p>需要注意的是，语法必须是严格的<code>&#123;m,n&#125;</code>形式，逗号左右不能有空格。</p>
<p><code>?</code>、<code>*</code>、<code>+</code>、<code>&#123;</code>是元字符，如果要匹配这些字符本身，需要使用’<code>\</code>‘转义，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a\＊b</span><br></pre></td></tr></table></figure>

<p>匹配字符串”<code>a*b</code>“。这些量词出现在字符组中时，不是元字符，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[? ＊+&#123;]</span><br></pre></td></tr></table></figure>

<p>就是匹配其中一个字符本身。</p>
<p>关于量词，它们的默认匹配是贪婪的，什么意思呢？看个例子，正则表达式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;.＊&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>如果要处理的字符串是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;first&lt;/a&gt;&lt;a&gt;second&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>目的是想得到两个匹配，一个匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;first&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>另一个匹配：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;second&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>但默认情况下，得到的结果却只有一个匹配，匹配所有内容。</p>
<p>这是因为<code>.*</code>可以匹配第一个<code>&lt;a&gt;</code>和最后一个<code>&lt;/a&gt;</code>之间的所有字符，只要能匹配，<code>.*</code>就尽量往后匹配，它是贪婪的。如果希望在碰到第一个匹配时就停止呢？应该使用懒惰量词，在量词的后面加一个符号’<code>?</code>‘，针对上例，将表达式改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;.＊? &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>就能得到期望的结果。所有量词都有对应的懒惰形式，比如：<code>x??</code> 、<code>x*?</code> 、<code>x+?</code> 、<code>x&#123;m,n&#125;?</code>等。</p>
<h2 id="4．分组"><a href="#4．分组" class="headerlink" title="4．分组"></a>4．分组</h2><p>表达式可以用括号()括起来，表示一个分组，比如a(bc)d, bc就是一个分组。分组可以嵌套，比如a(de(fg))。分组默认都有一个编号，按照括号的出现顺序，从1开始，从左到右依次递增，比如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(bc)((de)(fg))</span><br></pre></td></tr></table></figure>

<p>字符串abcdefg匹配这个表达式，第1个分组为bc，第2个为defg，第3个为de，第4个为fg。分组0是一个特殊分组，内容是整个匹配的字符串，这里是abcdefg。</p>
<p>分组匹配的子字符串可以在后续访问，好像被捕获了一样，所以默认分组称为<strong>捕获分组</strong>。关于如何在Java中访问和使用捕获分组，我们下节再介绍。</p>
<p>可以对分组使用量词，表示分组的出现次数，比如a(bc)+d，表示bc出现一次或多次。</p>
<p>中括号[]表示匹配其中的一个字符，括号()和元字符’|’一起，可以表示匹配其中的一个子表达式，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(http|ftp|file)</span><br></pre></td></tr></table></figure>

<p>匹配http或ftp或file。</p>
<p>需要注意区分|和[], |用于[]中不再有特殊含义，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a|b]</span><br></pre></td></tr></table></figure>

<p>它的含义不是匹配a或b，而是a或|或b。</p>
<p>在正则表达式中，可以使用斜杠\加分组编号引用之前匹配的分组，这称为<strong>回溯引用</strong>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(\w+)&gt;(.＊)&lt;/\1&gt;</span><br></pre></td></tr></table></figure>

<p><code>\1</code>匹配之前的第一个分组(<code>\w+</code>)，这个表达式可以匹配类似如下字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title&gt;bc&lt;/title&gt;</span><br></pre></td></tr></table></figure>

<p>这里，第一个分组是”title”。</p>
<p>使用数字引用分组，可能容易出现混乱，可以对分组进行命名，通过名字引用之前的分组，对分组命名的语法是(<code>? &lt;name&gt;X</code>)，引用分组的语法是<code>\k&lt;name&gt;</code>，比如，上面的例子可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;(?&lt;tag&gt;\w+)&gt;(.＊)&lt;/\k&lt;tag&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>默认分组都称为捕获分组，即分组匹配的内容被捕获了，可以在后续被引用。实现捕获分组有一定的成本，为了提高性能，如果分组后续不需要被引用，可以改为<strong>非捕获分组</strong>，语法是<code>(?:...)</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:abc|def)</span><br></pre></td></tr></table></figure>

<h2 id="5．特殊边界匹配"><a href="#5．特殊边界匹配" class="headerlink" title="5．特殊边界匹配"></a>5．特殊边界匹配</h2><p>在正则表达式中，除了可以指定字符需满足什么条件，还可以指定字符的边界需满足什么条件，或者说匹配特定的边界，常用的表示特殊边界的元字符有<code>^</code>、<code>$</code>、<code>\A</code>、<code>\Z</code>、<code>\z</code>和<code>\b</code>。</p>
<p>默认情况下，<code>^</code>匹配整个字符串的开始，<code>^abc</code>表示整个字符串必须以abc开始。</p>
<p>需要注意的是<code>^</code>的含义，在字符组中它表示排除，但在字符组外，它匹配开始，比如表达式<code>^[^abc]</code>，表示以一个不是a、b、c的字符开始。</p>
<p>默认情况下，<code>$</code>匹配整个字符串的结束，不过，如果整个字符串以换行符结束，$匹配的是换行符之前的边界，比如表达式<center>abc$</center>，表示整个表达式以abc结束，或者以<code>abc\r\n</code>或<code>abc\n</code>结束。</p>
<p>以上<code>^</code>和<code>$</code>的含义是默认模式下的，可以指定另外一种匹配模式：<strong>多行匹配模式</strong>，在此模式下，会以行为单位进行匹配，<code>^</code>匹配的是行开始，<code>$</code>匹配的是行结束，比如表达式是<code>^abc$</code>，字符串是”<code>abc\nabc\r\n</code>“，就会有两个匹配。</p>
<p>可以有两种方式指定匹配模式。一种是在正则表达式中，以<code>(?m)</code>开头，m表示multi-line，即<strong>多行匹配模式</strong>，上面的正则表达式可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(? m)^abc$</span><br></pre></td></tr></table></figure>

<p>另外一种是在程序中指定，在Java中，对应的模式常量是<code>Pattern.MULTILINE</code>，下节我们再介绍Java API。</p>
<p>需要说明的是，多行模式和之前介绍的单行模式容易混淆，其实，它们之间没有关系。<strong>单行模式影响的是字符’<code>.</code>‘的匹配规则，使得’<code>.</code>‘可以匹配换行符</strong>；<strong>多行模式影响的是<code>^</code>和<code>$</code>的匹配规则，使得它们可以匹配行的开始和结束，两个模式可以一起使用</strong>。</p>
<p><code>\A</code>与<code>^</code>类似，但不管什么模式，它匹配的总是<strong>整个字符串的开始边界</strong>。</p>
<p><code>\Z</code>和<code>\z</code>与<code>$</code>类似，但不管什么模式，它们匹配的总是整个字符串的结束边界。<code>\Z</code>与<code>\z</code>的区别是：如果字符串以换行符结束，<code>\Z</code>与<code>$</code>一样，匹配的是换行符之前的边界，而<code>\z</code>匹配的总是结束边界。在进行输入验证的时候，为了确保输入最后没有多余的换行符，可以使用<code>\z</code>进行匹配。</p>
<p><code>\b</code>匹配的是单词边界，比如<code>\bcat\b</code>，匹配的是完整的单词cat，它不能匹配category。**<code>\b</code>匹配的不是一个具体的字符，而是一种边界，这种边界满足一个要求，即一边是单词字符，另一边不是单词字符**。在Java中，<code>\b</code>识别的单词字符除了<code>\w</code>，还包括中文字符。</p>
<p>边界匹配可能难以理解，我们解释下。<strong>边界匹配不同于字符匹配，可以认为，在一个字符串中，每个字符的两边都是边界，而上面介绍的这些特殊字符，匹配的都不是字符，而是特定的边界</strong>，看个例子，如图25-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211135942.jpeg" alt="epub_923038_145"></p>
<center>图25-1 边界匹配示例</center>

<p>上面的字符串是”a cat\n”，我们用粗线显示出了每个字符两边的边界，并且显示出了每个边界与哪些边界元字符匹配。</p>
<h2 id="6．环视边界匹配"><a href="#6．环视边界匹配" class="headerlink" title="6．环视边界匹配"></a>6．环视边界匹配</h2><p>对于边界匹配，除了使用上面介绍的边界元字符，还有一种更为通用的方式，那就是环视。<strong>环视的字面意思就是左右看看，需要左右符合一些条件，本质上，它也是匹配边界，对边界有一些要求，这个要求是针对左边或右边的字符串的</strong>。根据要求不同，分为4种环视：<br>1）<strong>肯定顺序环视</strong>，语法是<code>(?=...)</code>，要求右边的字符串匹配指定的表达式。比如表达式<code>abc(?=def)</code>, <code>(?=def)</code>在字符c右面，即匹配c右面的边界。对这个边界的要求是：它的右边有def，比如abcdef，如果没有，比如abcd，则不匹配。<br>2）<strong>否定顺序环视</strong>，语法是<code>(?!...)</code>，要求右边的字符串不能匹配指定的表达式。比如表达式<code>s(?!ing)</code>，匹配一般的s，但不匹配后面有ing的s。注意：避免与排除型字符组混淆，比如<code>s[^ing]</code>, <code>s[^ing]</code>匹配的是两个字符，第一个是s，第二个是i、n、g以外的任意一个字符。<br>3）<strong>肯定逆序环视</strong>，语法是<code>(?&lt;=...)</code>，要求左边的字符串匹配指定的表达式。比如表达式<code>(?&lt;=\s)abc</code>, <code>(?&lt;=\s)</code>在字符a左边，即匹配a左边的边界。对这个边界的要求是：它的左边必须是空白字符。<br>4）<strong>否定逆序环视</strong>，语法是<code>(?&lt;!...)</code>，要求左边的字符串不能匹配指定的表达式。比如表达式<code>(?&lt;!\w)cat</code>, <code>(?&lt;!\w)</code>在字符c左边，即匹配c左边的边界。对这个边界的要求是：它的左边不能是单词字符。</p>
<p>可以看出，环视也使用括号()，不过，它不是分组，不占用分组编号。</p>
<p>这些环视结构也被称为<strong>断言，断言的对象是边界，边界不占用字符，没有宽度，所以也被称为零宽度断言</strong>。</p>
<p>顺序环视也可以出现在左边，比如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?=.＊[A-Z])\w+</span><br></pre></td></tr></table></figure>

<p>这个表达式是什么意思呢？\w+匹配多个单词字符，(? =.*[A-Z])匹配单词字符的左边界，这是一个肯定顺序环视。对这个边界的要求是，它右边的字符串匹配表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.＊[A-Z]</span><br></pre></td></tr></table></figure>

<p>也就是说，它右边至少要有一个大写字母。</p>
<p>逆序环视也可以出现在右边，比如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\w.]+(?&lt;!\.)</span><br></pre></td></tr></table></figure>

<p><code>[\w.]+</code>匹配单词字符和字符’.’构成的字符串，比如”<code>hello.ma</code>“。<code>(?&lt;!\.)</code>匹配字符串的右边界，这是一个逆序否定环视。对这个边界的要求是：它左边的字符不能是’<code>.</code>‘，也就是说，如果字符串以’<code>.</code>‘结尾，则匹配的字符串中不能包括这个’<code>.</code>‘。比如，如果字符串是”<code>hello.ma.</code>“，则匹配的子字符串是”<code>hello.ma</code>“。</p>
<p><strong>环视匹配的是一个边界，里面的表达式是对这个边界左边或右边字符串的要求，对同一个边界，可以指定多个要求</strong>，即写多个环视，比如表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(? =.＊[A-Z])(? =.＊[0-9])\w+</span><br></pre></td></tr></table></figure>

<p><code>\w+</code>的左边界有两个要求，<code>(?=.*[A-Z])</code>要求后面至少有一个大写字母，<code>(?=.*[0-9])</code>要求后面至少有一位数字。</p>
<h2 id="7．转义与匹配模式"><a href="#7．转义与匹配模式" class="headerlink" title="7．转义与匹配模式"></a>7．转义与匹配模式</h2><p>我们知道，字符’&#39;表示转义，转义有两种。<br>1）<strong>把普通字符转义，使其具备特殊含义</strong>，比如’<code>\t</code>‘、’<code>\n</code>‘、’<code>\d</code>‘、’<code>\w</code>‘、’<code>\b</code>‘、’<code>\A</code>‘等，也就是说，这个转义把普通字符变为了元字符。<br>2）<strong>把元字符转义，使其变为普通字符</strong>，比如’<code>\.</code>‘、’<code>\*</code>‘、’<code>\?</code>‘、’<code>\(</code>‘、’<code>\\</code>‘等。</p>
<p>记住所有的元字符，并在需要的时候进行转义，这是比较困难的，有一个简单的办法，可以将所有元字符看作普通字符，就是在开始处加上<code>\Q</code>，在结束处加上<code>\E</code>，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\Q(.＊+)\E</span><br></pre></td></tr></table></figure>

<p><code>\Q</code>和<code>\E</code>之间的所有字符都会被视为普通字符。</p>
<p>正则表达式用字符串表示，在Java中，字符’<code>\</code>‘也是字符串语法中的元字符，这使得正则表达式中的’<code>\</code>‘，在Java字符串表示中，要用两个’<code>\</code>‘，即’<code>\\</code>‘，而要匹配字符’<code>\</code>‘本身，在Java字符串表示中，要用4个’<code>\</code>‘，即’<code>\\\</code>`‘，关于这点，下节我们会进一步说明。</p>
<p>前面提到了两种匹配模式，还有一种常用的匹配模式，就是不区分大小写的模式，指定方式也有两种。一种是在正则表达式开头使用(?i), i为ignore，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?i)the</span><br></pre></td></tr></table></figure>

<p>既可以匹配the，也可以匹配THE，还可以匹配The。匹配模式也可以在程序中指定，Java中对应的变量是Pattern.CASE_INSENSITIVE。需要说明的是，匹配模式间不是互斥的关系，它们可以一起使用，在正则表达式中，可以指定多个模式，比如(? smi)。</p>
<h2 id="8．语法总结"><a href="#8．语法总结" class="headerlink" title="8．语法总结"></a>8．语法总结</h2><p>下面，我们用表格的形式简要汇总下正则表达式的语法，如表25-1到表25-6所示。</p>
<center>表25-1 单个字符语法</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211140810.jpeg" alt="epub_923038_146"></p>
<center>表25-2 字符组语法</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211140836.jpeg" alt="epub_923038_147"></p>
<center>表25-3 量词语法</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211140851.jpeg" alt="epub_923038_148"></p>
<center>表25-4 分组语法</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211140906.jpeg" alt="epub_923038_149"></p>
<center>表25-5 边界和环视语法</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211140920.jpeg" alt="epub_923038_150"></p>
<center>表25-6 匹配模式和转义语法</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211140936.jpeg" alt="epub_923038_151"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/4731be14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/4731be14/" class="post-title-link" itemprop="url">24.5 自定义ClassLoader的应用：热部署</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-12-08 12:38:53 / 修改时间：12:50:35" itemprop="dateCreated datePublished" datetime="2021-12-08T12:38:53+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">6第六部分 动态与函数式编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/6%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86-%E5%8A%A8%E6%80%81%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/%E7%AC%AC24%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第24章 类加载机制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/4731be14/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/4731be14/" data-xid="/JavaReadingNotes/4731be14/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="24-5-自定义ClassLoader的应用：热部署"><a href="#24-5-自定义ClassLoader的应用：热部署" class="headerlink" title="24.5 自定义ClassLoader的应用：热部署"></a>24.5 自定义ClassLoader的应用：热部署</h1><p>所谓热部署，就是在不重启应用的情况下，当类的定义即字节码文件修改后，能够替换该Class创建的对象，怎么做到这一点呢？我们利用MyClassLoader，看个简单的示例。</p>
<p>我们使用面向接口的编程，定义一个接口IHelloService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类是shuo.laoma.dynamic.c87.HelloImpl, class文件放到MyClassLoader的加载目录中。</p>
<p>演示类是HotDeployDemo，它定义了以下静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLASS_NAME = <span class="string">&quot;shuo.laoma.dynamic.c87.HelloImpl&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILE_NAME = <span class="string">&quot;data/c87/&quot;</span></span><br><span class="line">            +CLASS_NAME.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>)+<span class="string">&quot;.class&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IHelloService helloService;</span><br></pre></td></tr></table></figure>

<p>CLASS_NAME表示实现类名称，FILE_NAME是具体的class文件路径，helloService是IHelloService实例。</p>
<p>当CLASS_NAME代表的类字节码改变后，我们希望重新创建helloService，反映最新的代码，怎么做呢？先看用户端获取IHelloService的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHelloService <span class="title">getHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(helloService ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (HotDeployDemo.class) &#123;</span><br><span class="line">        <span class="keyword">if</span>(helloService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            helloService = createHelloService();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个单例模式，createHelloService()的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IHelloService <span class="title">createHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MyClassLoader cl = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        Class&lt;? &gt; cls = cl.loadClass(CLASS_NAME);</span><br><span class="line">        <span class="keyword">if</span>(cls ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (IHelloService) cls.newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它使用MyClassLoader加载类，并利用反射创建实例，它假定实现类有一个public无参构造方法。</p>
<p>在调用IHelloService的方法时，客户端总是先通过getHelloService获取实例对象，我们模拟一个客户端线程，它不停地获取IHelloService对象，并调用其方法，然后睡眠1秒钟，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    IHelloService helloService = getHelloService();</span><br><span class="line">                    helloService.sayHello();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么知道类的class文件发生了变化，并重新创建helloService对象呢？我们使用一个单独的线程模拟这一过程，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastModified = <span class="keyword">new</span> File(FILE_NAME).lastModified();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="keyword">long</span> now = <span class="keyword">new</span> File(FILE_NAME).lastModified();</span><br><span class="line">                    <span class="keyword">if</span>(now ! = lastModified) &#123;</span><br><span class="line">                          lastModified = now;</span><br><span class="line">                          reloadHelloService();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用文件的最后修改时间来跟踪文件是否发生了变化，当文件修改后，调用reloadHelloService()来重新加载，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reloadHelloService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloService = createHelloService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是利用MyClassLoader重新创建HelloService，创建后，赋值给helloService，这样，下次getHelloService()获取到的就是最新的了。</p>
<p>在主程序中启动client和monitor线程，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    monitor();</span><br><span class="line">    client();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在运行过程中，替换HelloImpl.class，可以看到行为会变化，为便于演示，我们在data/c87/shuo/laoma/dynamic/c87/目录下准备了两个不同的实现类：HelloImpl_origin.class和HelloImpl_revised. class，在运行过程中替换，会看到输出不一样，如图24-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211211133947.jpeg" alt="epub_923038_143"></p>
<center>图24-1 动态替换实现类示例</center>

<p>使用cp命令修改HelloImpl.class，如果其内容与HelloImpl_origin.class一样，输出为”hello”；如果与HelloImpl_revised.class一样，输出为”hello revised”。</p>
<p>完整的代码和数据在github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.laoma.dynamic.c87下。</p>
<p>本章介绍了Java中的类加载机制，包括Java加载类的基本过程，类ClassLoader的用法，以及如何创建自定义的ClassLoader，探讨了两个简单应用示例，一个通过动态加载实现了可配置的策略，另一个通过自定义ClassLoader实现了热部署。</p>
<p>需要说明的是，Java 9引入了模块的概念。在模块化系统中，类加载的过程有一些变化，扩展类的目录被删除掉了，原来的扩展类加载器没有了，增加了一个平台类加载器（Platform Class Loader），角色类似于扩展类加载器，它分担了一部分启动类加载器的职责，另外，加载的顺序也有一些变化，限于篇幅，我们就不探讨了。</p>
<p>从第21章到本章，我们探讨了Java中的多个动态特性，包括反射、注解、动态代理和类加载器，作为应用程序员，大部分用得都比较少，用得较多的就是使用框架和库提供的各种注解了，但这些特性大量应用于各种系统程序、框架和库中，理解这些特性有助于我们更好地理解它们，也可以在需要的时候自己实现动态、通用、灵活的功能。</p>
<p>在注解一章，我们提到，注解是一种声明式编程风格，它提高了Java语言的表达能力，日常编程中一种常见的需求是文本处理，在计算机科学中，有一种技术大大提高了文本处理的表达能力，那就是<strong>正则表达式</strong>，大部分编程语言都有对它的支持，它有什么强大功能呢？让我们下一章探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/JavaReadingNotes/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
