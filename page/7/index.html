<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/7/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-mzjszagu6-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/eafc5858/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/eafc5858/" class="post-title-link" itemprop="url">13.4 文件和目录操作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 20:59:27" itemprop="dateCreated datePublished" datetime="2021-12-05T20:59:27+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">4第四部分 文件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">第13章 文件基本技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/eafc5858/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/eafc5858/" data-xid="/JavaReadingNotes/eafc5858/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-4-文件和目录操作"><a href="#13-4-文件和目录操作" class="headerlink" title="13.4 文件和目录操作"></a>13.4 文件和目录操作</h1><p>文件和目录操作最终是与操作系统和文件系统相关的，不同系统的实现是不一样的，但Java中的java.io.File类提供了统一的接口，底层会通过本地方法调用操作系统和文件系统的具体实现，本节，我们就来介绍File类。File类中的操作大概可以分为三类：文件元数据、文件操作、目录操作，在介绍这些操作之前，我们先来看下File的构造方法。</p>
<h2 id="13-4-1-构造方法"><a href="#13-4-1-构造方法" class="headerlink" title="13.4.1 构造方法"></a>13.4.1 构造方法</h2><p>File既可以表示文件，也可以表示目录，它的主要构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pathname表示完整路径，该路径可以是相对路径，也可以是绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">//parent表示父目录，child表示孩子</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent, String child)</span></span></span><br></pre></td></tr></table></figure>

<p>File中的路径可以是已经存在的，也可以是不存在的。通过new新建一个File对象，不会实际创建一个文件，只是创建一个表示文件或目录的对象，new之后，File对象中的路径是不可变的。</p>
<h2 id="13-4-2-文件元数据"><a href="#13-4-2-文件元数据" class="headerlink" title="13.4.2 文件元数据"></a>13.4.2 文件元数据</h2><p>文件元数据主要包括文件名和路径、文件基本信息以及一些安全和权限相关的信息。文件名和路径相关的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pathname表示完整路径，该路径可以是相对路径，也可以是绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span></span></span><br><span class="line"><span class="function"><span class="comment">//parent表示父目录，child表示孩子</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent, String child)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> <span class="comment">//返回文件或目录名称，不含路径名</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAbsolute</span><span class="params">()</span> <span class="comment">//判断File中的路径是否是绝对路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> <span class="comment">//返回构造File对象时的完整路径名，包括路径和文件名称</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span> <span class="comment">//返回完整的绝对路径名</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回标准的完整路径名，它会去掉路径中的冗余名称如&quot;.&quot;, &quot;..&quot;，跟踪软链接(Unix系统概念)等</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCanonicalPath</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParent</span><span class="params">()</span> <span class="comment">//返回父目录路径</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getParentFile</span><span class="params">()</span> <span class="comment">//返回父目录的File对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个新的File对象，新的File对象使用getAbsolutePath()的返回值作为参数构造</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getAbsoluteFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回一个新的File对象，新的File对象使用getCanonicalPath()的返回值作为参数构造</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getCanonicalFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>这些方法比较直观，我们就不解释了。File类中有4个静态变量，表示路径分隔符，它</p>
<p>们是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String separator</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> separatorChar</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String pathSeparator</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span> pathSeparatorChar</span><br></pre></td></tr></table></figure>

<p>separator和separatorChar表示文件路径分隔符，在Windows系统中，一般为’&#39;,Linux系统中一般为’/‘。pathSeparator和pathSeparatorChar表示多个文件路径中的分隔符，比如，环境变量PATH中的分隔符，Java类路径变量classpath中的分隔符，在执行命令时，操作系统会从PATH指定的目录中寻找命令，Java运行时加载class文件时，会从classpath指定的路径中寻找类文件。在Windows系统中，这个分隔符一般为’; ‘，在Linux系统中，这个分隔符一般为’:’。</p>
<p>除了文件名和路径，File对象还有如下方法，以获取文件或目录的基本信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> <span class="comment">//文件或目录是否存在</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> <span class="comment">//是否为目录</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> <span class="comment">//是否为文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//文件长度，字节数，对目录没有意义</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="comment">//最后修改时间，从纪元时开始的毫秒数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setLastModified</span><span class="params">(<span class="keyword">long</span> time)</span> <span class="comment">//设置最后修改时间，返回是否修改成功</span></span></span><br></pre></td></tr></table></figure>

<p>需要说明的是，File对象没有返回创建时间的方法，因为创建时间不是一个公共概念， Linux/Unix就没有创建时间的概念。</p>
<p>File类中与安全和权限相关的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHidden</span><span class="params">()</span> <span class="comment">//是否为隐藏文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canExecute</span><span class="params">()</span> <span class="comment">//是否可执行</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">()</span> <span class="comment">//是否可读</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">()</span> <span class="comment">//是否可写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setReadOnly</span><span class="params">()</span> <span class="comment">//设置文件为只读文件</span></span></span><br><span class="line"><span class="function"><span class="comment">//修改文件读权限</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setReadable</span><span class="params">(<span class="keyword">boolean</span> readable, <span class="keyword">boolean</span> ownerOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setReadable</span><span class="params">(<span class="keyword">boolean</span> readable)</span></span></span><br><span class="line"><span class="function"><span class="comment">//修改文件写权限</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWritable</span><span class="params">(<span class="keyword">boolean</span> writable, <span class="keyword">boolean</span> ownerOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setWritable</span><span class="params">(<span class="keyword">boolean</span> writable)</span></span></span><br><span class="line"><span class="function"><span class="comment">//修改文件可执行权限</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setExecutable</span><span class="params">(<span class="keyword">boolean</span> executable, <span class="keyword">boolean</span> ownerOnly)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setExecutable</span><span class="params">(<span class="keyword">boolean</span> executable)</span></span></span><br></pre></td></tr></table></figure>

<p>在修改方法中，如果修改成功，返回true，否则返回false。在设置权限方法中，owner-Only为true表示只针对owner，为false表示针对所有用户，没有指定ownerOnly的方法中，ownerOnly相当于是true。</p>
<h2 id="13-4-3-文件操作"><a href="#13-4-3-文件操作" class="headerlink" title="13.4.3 文件操作"></a>13.4.3 文件操作</h2><p>文件操作主要有创建、删除、重命名。</p>
<p>新建一个File对象不会实际创建文件，但如下方法可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>创建成功返回true，否则返回false，新创建的文件内容为空。如果文件已存在，不会创建。</p>
<p>File对象还有两个静态方法，可以创建临时文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">createTempFile</span><span class="params">(String prefix, String suffix)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">createTempFile</span><span class="params">(String prefix, String suffix,</span></span></span><br><span class="line"><span class="params"><span class="function">    File directory)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>临时文件的完整路径名是系统指定的、唯一的，但可以通过参数指定前缀（prefix）、后缀（suffix）和目录（directory）。prefix是必需的，且至少要三个字符；suffix如果为null，则默认为．tmp; directory如果不指定或指定为null，则使用系统默认目录。</p>
<p>File类的删除方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteOnExit</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>delete删除文件或目录，删除成功返回true，否则返回false。如果File是目录且不为空，则delete不会成功，返回false，换句话说，要删除目录，先要删除目录下的所有子目录和文件。deleteOnExit将File对象加入到待删列表，在Java虚拟机正常退出的时候进行实际删除。</p>
<p>File类的重命名方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renameTo</span><span class="params">(File dest)</span></span></span><br></pre></td></tr></table></figure>

<p>参数dest代表重命名后的文件，重命名能否成功与系统有关，返回值代表是否成功。</p>
<h2 id="13-4-4-目录操作"><a href="#13-4-4-目录操作" class="headerlink" title="13.4.4 目录操作"></a>13.4.4 目录操作</h2><p>当File对象代表目录时，可以执行目录相关的操作，如创建、遍历。有两个方法用于创建目录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>它们都是创建目录，创建成功返回true，失败返回false。需要注意的是，如果目录已存在，返回值是false。这两个方法的区别在于：如果某一个中间父目录不存在，则mkdir会失败，返回false，而mkdirs则会创建必需的中间父目录。</p>
<p>有如下方法访问一个目录下的子目录和文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list()</span><br><span class="line"><span class="keyword">public</span> String[] list(FilenameFilter filter)</span><br><span class="line"><span class="keyword">public</span> File[] listFiles()</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter)</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FilenameFilter filter)</span><br></pre></td></tr></table></figure>

<p>它们返回的都是直接子目录或文件，不会返回子目录下的文件。list返回的是文件名数组，而listFiles返回的是File对象数组。FilenameFilter和FileFilter都是接口，用于过滤， FileFilter的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FilenameFilter的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在遍历子目录和文件时，针对每个文件，会调用FilenameFilter或FileFilter的accept方法，只有accept方法返回true时，才将该子目录或文件包含到返回结果中。Filename-Filter和FileFilter的区别在于：FileFilter的accept方法参数只有一个File对象，而File-nameFilter的accept方法参数有两个，dir表示父目录，name表示子目录或文件名。我们来看个例子，列出当前目录下的所有扩展名为．txt的文件，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File f = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">File[] files = f.listFiles(<span class="keyword">new</span> FilenameFilter()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们创建了个FilenameFilter的匿名内部类对象并传递给了listFiles。</p>
<p>使用遍历方法，可以方便地进行递归遍历，完成一些更为高级的功能。比如，计算一个目录下的所有文件的大小（包括子目录），代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOfDirectory</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(directory.isFile()) &#123;</span><br><span class="line">        <span class="keyword">return</span> directory.length();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(File file : directory.listFiles()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">                size += file.length();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size += sizeOfDirectory(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再如，在一个目录下，查找所有给定文件名的文件，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;File&gt; <span class="title">findFile</span><span class="params">(<span class="keyword">final</span> File directory,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String fileName)</span> </span>&#123;</span><br><span class="line">    List&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(File f : directory.listFiles()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f.isFile() &amp;&amp; f.getName().equals(fileName)) &#123;</span><br><span class="line">            files.add(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">            files.addAll(findFile(f, fileName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> files;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面介绍了File类的delete方法，我们提到，如果要删除目录而目录不为空，需要先清空目录，利用遍历方法，我们可以写一个删除非空目录的方法，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteRecursively</span><span class="params">(<span class="keyword">final</span> File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(! file.delete()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Failed to delete &quot;</span></span><br><span class="line">                    + file.getCanonicalPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(File child : file.listFiles()) &#123;</span><br><span class="line">            deleteRecursively(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(! file.delete()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Failed to delete &quot;</span></span><br><span class="line">                    + file.getCanonicalPath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码在github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic%EF%BC%8C%E4%BD%8D%E4%BA%8E%E5%8C%85shuo">https://github.com/swiftma/program-logic，位于包shuo</a>. laoma.file.c59下。至此，关于File类就介绍完了，File类封装了操作系统和文件系统的差异，提供了统一的文件和目录API。</p>
<p>关于文件处理的基本技术，包括文件的基本概念、二进制文件与字节流、文本文件与字符流，以及文件和目录操作，至此，我们就介绍完了。下一章，我们来看文件处理相关的一些高级技术。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/4d7c2b19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/4d7c2b19/" class="post-title-link" itemprop="url">13.3 文本文件和字符流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 20:56:41" itemprop="dateCreated datePublished" datetime="2021-12-05T20:56:41+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">4第四部分 文件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">第13章 文件基本技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/4d7c2b19/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/4d7c2b19/" data-xid="/JavaReadingNotes/4d7c2b19/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-3-文本文件和字符流"><a href="#13-3-文本文件和字符流" class="headerlink" title="13.3 文本文件和字符流"></a>13.3 文本文件和字符流</h1><p>上节介绍了如何以字节流的方式处理文件，对于文本文件，字节流没有编码的概念，不能按行处理，使用不太方便，更适合的是使用字符流，本节就来介绍字符流。</p>
<p>我们首先简要介绍文本文件的基本概念、与二进制文件的区别、编码，以及字符流和字节流的区别，然后介绍Java中的主要字符流，它们有：<br>1）Reader/Writer：字符流的基类，它们是抽象类；<br>2）InputStreamReader/OutputStreamWriter：适配器类，将字节流转换为字符流；<br>3）FileReader/FileWriter：输入源和输出目标是文件的字符流；<br>4）CharArrayReader/CharArrayWriter：输入源和输出目标是char数组的字符流；<br>5）StringReader/StringWriter：输入源和输出目标是String的字符流；<br>6）BufferedReader/BufferedWriter：装饰类，对输入/输出流提供缓冲，以及按行读写功能；<br>7）PrintWriter：装饰类，可将基本类型和对象转换为其字符串形式输出的类。</p>
<p>除了这些类，Java中还有一个类Scanner，类似于一个Reader，但不是Reader的子类，可以读取基本类型的字符串形式，类似于PrintWriter的逆操作。理解了字节流和字符流后，我们介绍Java中的标准输入输出和错误流。最后，我们总结一些简单的实用方法。</p>
<h2 id="13-3-1-基本概念"><a href="#13-3-1-基本概念" class="headerlink" title="13.3.1 基本概念"></a>13.3.1 基本概念</h2><p>我们先来看一些基本概念，包括文本文件、编码和字符流。</p>
<h3 id="1．文本文件"><a href="#1．文本文件" class="headerlink" title="1．文本文件"></a>1．文本文件</h3><p>上节提到，<strong>处理文件要有二进制思维</strong>。从二进制角度，我们通过一个简单的例子解释下文本文件与二进制文件的区别。比如，要存储整数123，使用二进制形式保存到文件test. dat，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.dat&quot;</span>));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    output.writeInt(<span class="number">123</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用UltraEdit打开该文件，显示的却是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p>打开十六进制编辑器，显示如图13-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209214605.jpeg" alt="epub_923038_115"></p>
<center>图13-3 整数123的二进制存储</center>

<p>在文件中存储的实际有4个字节，最低位字节7B对应的十进制数是123，也就是说，对int类型，二进制文件保存的直接就是int的二进制形式。这个二进制形式，如果当成字符来解释，显示成什么字符则与编码有关，如果当成UTF-32BE编码，解释成的就是一个字符，即{。</p>
<p>如果使用文本文件保存整数123，则代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String data = Integer.toString(<span class="number">123</span>);</span><br><span class="line">    output.write(data.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码将整数123转换为字符串，然后将它的UTF-8编码输出到了文件中，使用Ultra-Edit打开该文件，显示的就是期望的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure>

<p>打开十六进制编辑器，显示如图13-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209214649.jpeg" alt="epub_923038_116"></p>
<center>图13-4 整数123的文本存储</center>

<p>文件中实际存储的有三个字节：31、32、33，对应的十进制数分别是49、50、51，分别对应字符’1’、’2’、’3’的ASCII编码。</p>
<h3 id="2．编码"><a href="#2．编码" class="headerlink" title="2．编码"></a>2．编码</h3><p>在文本文件中，编码非常重要，同一个字符，不同编码方式对应的二进制形式可能是不一样的。我们看个例子，对同样的文本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, <span class="number">123</span>, 老马</span><br></pre></td></tr></table></figure>

<p>1）UTF-8编码，十六进制如图13-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209214846.jpeg" alt="epub_923038_117"></p>
<center>图13-5 示例文本的UTF-8编码</center>

<p>英文和数字字符每个占一个字节，而每个中文占三个字节。</p>
<p>2）GB18030编码，十六进制如图13-6所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209214903.jpeg" alt="epub_923038_118"></p>
<center>图13-6 示例文本的GB18030编码</center>

<p>英文和数字字符与UTF-8编码是一样的，但中文不一样，每个中文占两个字节。</p>
<p>3）UTF-16BE编码，十六进制为如图13-7所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209214916.jpeg" alt="epub_923038_119"></p>
<center>图13-7 示例文本的UTF-16BE编码</center>

<p>无论是英文还是中文字符，每个字符都占两个字节。UTF-16BE也是Java内存中对字符的编码方式。</p>
<h3 id="3．字符流"><a href="#3．字符流" class="headerlink" title="3．字符流"></a>3．字符流</h3><p>字节流是按字节读取的，而<strong>字符流则是按char读取</strong>的，一个char在文件中保存的是几个字节与编码有关，但字符流封装了这种细节，我们操作的对象就是char。</p>
<p>需要说明的是，<strong>一个char不完全等同于一个字符</strong>，对于绝大部分字符，一个字符就是一个char，但我们之前介绍过，对于增补字符集中的字符，需要两个char表示，对于这种字符，Java中的字符流是按char而不是一个完整字符处理的。</p>
<p>理解了文本文件、编码和字符流的概念，我们再来看Java中的相关类，从基类开始。</p>
<h2 id="13-3-2-Reader-Writer"><a href="#13-3-2-Reader-Writer" class="headerlink" title="13.3.2 Reader/Writer"></a>13.3.2 Reader/Writer</h2><p>Reader与字节流的InputStream类似，也是抽象类，部分主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[])</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>方法的名称和含义与InputStream中的对应方法基本类似，但Reader中处理的单位是char，比如read读取的是一个char，取值范围为0～65 535。Reader没有available方法，对应的方法是ready()。</p>
<p>Writer与字节流的OutputStream类似，也是抽象类，部分主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> cbuf[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>含义与OutputStream的对应方法基本类似，但Writer处理的单位是char, Writer还接受String类型，我们知道，String的内部就是char数组，处理时，会调用String的getChar方法先获取char数组。</p>
<h2 id="13-3-3-InputStreamReader-OutputStreamWriter"><a href="#13-3-3-InputStreamReader-OutputStreamWriter" class="headerlink" title="13.3.3 InputStreamReader/OutputStreamWriter"></a>13.3.3 InputStreamReader/OutputStreamWriter</h2><p>InputStreamReader和OutputStreamWriter是适配器类，能将InputStream/OutputStream转换为Reader/Writer。</p>
<h3 id="1-OutputStreamWriter"><a href="#1-OutputStreamWriter" class="headerlink" title="1. OutputStreamWriter"></a>1. OutputStreamWriter</h3><p>OutputStreamWriter的主要构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OutputStreamWriter</span><span class="params">(OutputStream out, String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>一个重要的参数是编码类型，可以通过名字charsetName或Charset对象传入，如果没有传入，则为系统默认编码，默认编码可以通过Charset.defaultCharset()得到。Output-StreamWriter内部有一个类型为StreamEncoder的编码器，能将char转换为对应编码的字节。</p>
<p>我们看一段简单的代码，将字符串”hello, 123，老马”写到文件hello.txt中，编码格式为GB2312：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String str = <span class="string">&quot;hello, 123, 老马&quot;</span>;</span><br><span class="line">    writer.write(str);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个FileOutputStream，然后将其包在一个OutputStreamWriter中，就可以直接以字符串写入了。</p>
<h3 id="2-InputStreamReader"><a href="#2-InputStreamReader" class="headerlink" title="2. InputStreamReader"></a>2. InputStreamReader</h3><p>InputStreamReader的主要构造方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in, String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>与OutputStreamWriter一样，一个重要的参数是编码类型。InputStreamReader内部有一个类型为StreamDecoder的解码器，能将字节根据编码转换为char。</p>
<p>我们看一段简单的代码，将上面写入的文件读进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> charsRead = reader.read(cbuf);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(cbuf, <span class="number">0</span>, charsRead));</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码假定一次read调用就读到了所有内容，且假定长度不超过1024。为了确保读到所有内容，可以借助待会介绍的CharArrayWriter或StringWriter。</p>
<h2 id="13-3-4-FileReader-FileWriter"><a href="#13-3-4-FileReader-FileWriter" class="headerlink" title="13.3.4 FileReader/FileWriter"></a>13.3.4 FileReader/FileWriter</h2><p>FileReader/FileWriter的输入和目的是文件。FileReader是InputStreamReader的子类，它的主要构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>FileWriter是OutputStreamWriter的子类，它的主要构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileWriter</span><span class="params">(String fileName, <span class="keyword">boolean</span> append)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>append参数指定是追加还是覆盖，如果没传，则为覆盖。</p>
<p>需要注意的是，<strong>FileReader/FileWriter不能指定编码类型，只能使用默认编码，如果需要指定编码类型，可以使用InputStreamReader/OutputStreamWriter</strong>。</p>
<h2 id="13-3-5-CharArrayReader-CharArrayWriter"><a href="#13-3-5-CharArrayReader-CharArrayWriter" class="headerlink" title="13.3.5 CharArrayReader/CharArrayWriter"></a>13.3.5 CharArrayReader/CharArrayWriter</h2><p>CharArrayWriter与ByteArrayOutputStream类似，它的输出目标是char数组，这个数组的长度可以根据数据内容动态扩展。</p>
<p>CharArrayWriter有如下方法，可以方便地将数据转换为char数组或字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray()</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>使用CharArrayWriter，我们可以改进上面的读文件代码，确保将所有文件内容读入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">        <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter();</span><br><span class="line">    <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> charsRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((charsRead=reader.read(cbuf))! =-<span class="number">1</span>)&#123;</span><br><span class="line">        writer.write(cbuf, <span class="number">0</span>, charsRead);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(writer.toString());</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读入的数据先写入CharArrayWriter中，读完后，再调用其toString()方法获取完整数据。</p>
<p>CharArrayReader与上节介绍的ByteArrayInputStream类似，它将char数组包装为一个Reader，是一种适配器模式，它的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharArrayReader</span><span class="params">(<span class="keyword">char</span> buf[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CharArrayReader</span><span class="params">(<span class="keyword">char</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="13-3-6-StringReader-StringWriter"><a href="#13-3-6-StringReader-StringWriter" class="headerlink" title="13.3.6 StringReader/StringWriter"></a>13.3.6 StringReader/StringWriter</h2><p>StringReader/StringWriter与CharArrayReader/CharArrayWriter类似，只是输入源为String，输出目标为StringBuffer，而且，String/StringBuffer内部是由char数组组成的，所以它们本质上是一样的，具体我们就不赘述了。之所以要将char数组和String与Reader/Writer进行转换，也是为了能够方便地参与Reader/Writer构成的协作体系，复用代码。</p>
<h2 id="13-3-7-BufferedReader-BufferedWriter"><a href="#13-3-7-BufferedReader-BufferedWriter" class="headerlink" title="13.3.7 BufferedReader/BufferedWriter"></a>13.3.7 BufferedReader/BufferedWriter</h2><p>BufferedReader/BufferedWriter是装饰类，提供缓冲，以及按行读写功能。Buffered-Writer的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out, <span class="keyword">int</span> sz)</span></span></span><br></pre></td></tr></table></figure>

<p>参数sz是缓冲大小，如果没有提供，默认为8192。它有如下方法，可以输出平台特定的换行符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>BufferedReader的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in, <span class="keyword">int</span> sz)</span></span></span><br></pre></td></tr></table></figure>

<p>参数sz是缓冲大小，如果没有提供，默认为8192。它有如下方法，可以读入一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>字符’\r’或’\n’或’\r\n’被视为换行符，readLine返回一行内容，但不会包含换行符，当读到流结尾时，返回null。</p>
<p><strong>FileReader/FileWriter是没有缓冲的，也不能按行读写，所以，一般应该在它们的外面包上对应的缓冲类</strong>。我们来看个例子，还是学生列表，这次我们使用可读的文本进行保存，一行保存一条学生信息，学生字段之间用逗号分隔，保存的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStudents</span><span class="params">(List&lt;Student&gt; students)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;students.txt&quot;</span>));</span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            writer.write(s.getName()+<span class="string">&quot;, &quot;</span>+s.getAge()+<span class="string">&quot;, &quot;</span>+s.getScore());</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writer! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后的文件内容显示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">张三，18,80.9</span><br><span class="line">李四，17,67.5</span><br></pre></td></tr></table></figure>

<p>从文件中读取的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">readStudents</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(<span class="string">&quot;students.txt&quot;</span>));</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String line = reader.readLine();</span><br><span class="line">        <span class="keyword">while</span>(line! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            String[] fields = line.split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line">            s.setName(fields[<span class="number">0</span>]);</span><br><span class="line">            s.setAge(Integer.parseInt(fields[<span class="number">1</span>]));</span><br><span class="line">            s.setScore(Double.parseDouble(fields[<span class="number">2</span>]));</span><br><span class="line">            students.add(s);</span><br><span class="line">            line = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(reader! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用readLine读入每一行，然后使用String的方法分隔字段，再调用Integer和Double的方法将字符串转换为int和double。这种对每一行的解析可以使用类Scanner进行简化，待会我们介绍。</p>
<h2 id="13-3-8-PrintWriter"><a href="#13-3-8-PrintWriter" class="headerlink" title="13.3.8 PrintWriter"></a>13.3.8 PrintWriter</h2><p>PrintWriter有很多重载的print方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>

<p>它会将这些参数转换为其字符串形式，即调用String.valueOf()，然后再调用write。它也有很多重载形式的println方法，println除了调用对应的print，还会输出一个换行符。除此之外，PrintWriter还有格式化输出方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintWriter <span class="title">printf</span><span class="params">(String format, Object ... args)</span></span></span><br></pre></td></tr></table></figure>

<p>format表示格式化形式，比如，保留小数点后两位，格式可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter writer = …</span><br><span class="line">writer.format(<span class="string">&quot;%.2f&quot;</span>, <span class="number">123.456f</span>);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.45</span><br></pre></td></tr></table></figure>

<p>更多格式化的内容可以参看API文档，本节就不赘述了。</p>
<p>PrintWriter的方便之处在于，它有很多构造方法，可以接受文件路径名、文件对象、OutputStream、Writer等，对于文件路径名和File对象，还可以接受编码类型作为参数，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName, String csn)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(Writer out)</span></span></span><br></pre></td></tr></table></figure>

<p>参数csn表示编码类型，对于以文件对象和文件名为参数的构造方法，PrintWriter内部会构造一个BufferedWriter，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">        <span class="keyword">new</span> FileOutputStream(fileName))), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以OutputSream为参数的构造方法，PrintWriter也会构造一个BufferedWriter，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintWriter</span><span class="params">(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(out)), autoFlush);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以Writer为参数的构造方法，PrintWriter就不会包装BufferedWriter了。</p>
<p>构造方法中的autoFlush参数表示同步缓冲区的时机，如果为true，则在调用println、printf或format方法的时候，同步缓冲区，如果没有传，则不会自动同步，需要根据情况调用flush方法。</p>
<p>可以看出，PrintWriter是一个非常方便的类，可以直接指定文件名作为参数，可以指定编码类型，可以自动缓冲，可以自动将多种类型转换为字符串，在输出到文件时，可以优先选择该类。</p>
<p>上面的保存学生列表代码，使用PrintWriter，可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStudents</span><span class="params">(List&lt;Student&gt; students)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    PrintWriter writer = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;students.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            writer.println(s.getName()+<span class="string">&quot;, &quot;</span>+s.getAge()+<span class="string">&quot;, &quot;</span>+s.getScore());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrintWriter有一个非常相似的类PrintStream，除了不能接受Writer作为构造方法外， PrintStream的其他构造方法与PrintWriter一样。PrintStream也有几乎一样的重载的print和println方法，只是自动同步缓冲区的时机略有不同，在PrintStream中，只要碰到一个换行字符’\n’，就会自动同步缓冲区。PrintStream与PrintWriter的另一个区别是，虽然它们都有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br></pre></td></tr></table></figure>

<p>但含义是不一样的，PrintStream只使用最低的8位，输出一个字节，而PrintWriter是使用最低的两位，输出一个char。</p>
<h2 id="13-3-9-Scanner"><a href="#13-3-9-Scanner" class="headerlink" title="13.3.9 Scanner"></a>13.3.9 Scanner</h2><p>Scanner是一个单独的类，它是一个简单的文本扫描器，能够分析基本类型和字符串，它需要一个分隔符来将不同数据区分开来，默认是使用空白符，可以通过useDelimiter()方法进行指定。Scanner有很多形式的next()方法，可以读取下一个基本类型或行，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">nextFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">nextLine</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>Scanner也有很多构造方法，可以接受File对象、InputStream、Reader作为参数，它也可以将字符串作为参数，这时，它会创建一个StringReader。比如，以前面的解析学生记录为例，使用Scanner，代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">readStudents</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">            <span class="keyword">new</span> FileReader(<span class="string">&quot;students.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        String line = reader.readLine();</span><br><span class="line">        <span class="keyword">while</span>(line! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(line).useDelimiter(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">            s.setName(scanner.next());</span><br><span class="line">            s.setAge(scanner.nextInt());</span><br><span class="line">            s.setScore(scanner.nextDouble());</span><br><span class="line">            students.add(s);</span><br><span class="line">            line = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-10-标准流"><a href="#13-3-10-标准流" class="headerlink" title="13.3.10 标准流"></a>13.3.10 标准流</h2><p>我们之前一直在使用System.out向屏幕上输出，它是一个PrintStream对象，输出目标就是所谓的“标准”输出，经常是屏幕。除了System.out, Java中还有两个标准流：System. in和System.err。</p>
<p>System.in表示标准输入，它是一个InputStream对象，输入源经常是键盘。比如，从键盘接受一个整数并输出，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> num = in.nextInt();</span><br><span class="line">System.out.println(num);</span><br></pre></td></tr></table></figure>

<p>System.err表示标准错误流，一般异常和错误信息输出到这个流，它也是一个Print-Stream对象，输出目标默认与System.out一样，一般也是屏幕。</p>
<p>标准流的一个重要特点是，它们可以<strong>重定向</strong>，比如可以重定向到文件，从文件中接受输入，输出也写到文件中。在Java中，可以使用System类的setIn、setOut、setErr进行重定向，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.setIn(<span class="keyword">new</span> ByteArrayInputStream(<span class="string">&quot;hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">System.setOut(<span class="keyword">new</span> PrintStream(<span class="string">&quot;out.txt&quot;</span>));</span><br><span class="line">System.setErr(<span class="keyword">new</span> PrintStream(<span class="string">&quot;err.txt&quot;</span>));</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    System.out.println(in.nextLine());</span><br><span class="line">    System.out.println(in.nextLine());</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.err.println(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准输入重定向到了一个ByteArrayInputStream，标准输出和错误重定向到了文件，所以第一次调用in.nextLine就会读取到”hello”，输出文件out.txt中也包含该字符串，第二次调用in.nextLine会触发异常，异常消息会写到错误流中，即文件err.txt中会包含异常消息，为”No line found”。</p>
<p>在实际开发中，经常需要重定向标准流。比如，在一些自动化程序中，经常需要重定向标准输入流，以从文件中接受参数，自动执行，避免人手工输入。在后台运行的程序中，一般都需要重定向标准输出和错误流到日志文件，以记录和分析运行的状态和问题。</p>
<p>在Linux系统中，<strong>标准输入输出流也是一种重要的协作机制</strong>。很多命令都很小，只完成单一功能，实际完成一项工作经常需要组合使用多条命令，它们协作的模式就是通过标准输入输出流，每个命令都可以从标准输入接受参数，处理结果写到标准输出，这个标准输出可以连接到下一个命令作为标准输入，构成管道式的处理链条。比如，查找一个日志文件access.log中127.0.0.1出现的行数，可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log | grep 127.0.0.1 | wc -l</span><br></pre></td></tr></table></figure>

<p>有三个程序cat、grep、wc, |是管道符号，它将cat的标准输出重定向为了grep的标准输入，而grep的标准输出又成了wc的标准输入。</p>
<h2 id="13-3-11-实用方法"><a href="#13-3-11-实用方法" class="headerlink" title="13.3.11 实用方法"></a>13.3.11 实用方法</h2><p>可以看出，字符流也包含了很多的类，虽然很灵活，但对于一些简单的需求，却需要写很多代码，实际开发中，经常需要将一些常用功能进行封装，提供更为简单的接口。下面我们提供一些实用方法，以供参考，代码比较简单，就不解释了。</p>
<p>复制Reader到Writer，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">final</span> Reader input,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> Writer output)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">int</span> charsRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((charsRead = input.read(buf)) ! = -<span class="number">1</span>) &#123;</span><br><span class="line">        output.write(buf, <span class="number">0</span>, charsRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件全部内容读入到一个字符串，参数为文件名和编码类型，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFileToString</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String encoding)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(fileName), encoding));</span><br><span class="line">        StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        copy(reader, writer);</span><br><span class="line">        <span class="keyword">return</span> writer.toString();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(reader! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法利用了StringWriter，并调用了上面的复制方法。</p>
<p>将字符串写到文件，参数为文件名、字符串内容和编码类型，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStringToFile</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String data, <span class="keyword">final</span> String encoding)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Writer writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        writer = <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(fileName), encoding);</span><br><span class="line">        writer.write(data);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writer! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按行将多行数据写到文件，参数为文件名、编码类型、行的集合，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeLines</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> String encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> Collection&lt;? &gt; lines)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PrintWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        writer = <span class="keyword">new</span> PrintWriter(fileName, encoding);</span><br><span class="line">        <span class="keyword">for</span>(Object line : lines)&#123;</span><br><span class="line">            writer.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(writer! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按行将文件内容读到一个列表中，参数为文件名、编码类型，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">readLines</span><span class="params">(<span class="keyword">final</span> String fileName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String encoding)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(fileName), encoding));</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        String line = reader.readLine();</span><br><span class="line">        <span class="keyword">while</span>(line! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(line);</span><br><span class="line">            line = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(reader! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-3-12-小结"><a href="#13-3-12-小结" class="headerlink" title="13.3.12 小结"></a>13.3.12 小结</h2><p>本节介绍了如何在Java中以字符流的方式读写文本文件，我们强调了二进制思维、文本文本与二进制文件的区别、编码，以及字符流与字节流的不同，介绍了个各种字符流、Scanner以及标准流，最后总结了一些实用方法。完整的代码在github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.laoma.file.c58下。</p>
<p>写文件时，可以优先考虑PrintWriter，因为它使用方便，支持自动缓冲、指定编码类型、类型转换等。读文件时，如果需要指定编码类型，需要使用InputStreamReader；如果不需要指定编码类型，可使用FileReader，但都应该考虑在外面包上缓冲类Buffered-Reader。</p>
<p>通过前面两个小节，我们应该可以从容地读写文件内容了，但文件和目录本身的操作，如查看元数据信息、文件重命名、遍历文件、查找文件、新建目录等，又该如何进行呢？让我们下节介绍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a0f4cea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a0f4cea/" class="post-title-link" itemprop="url">13.2 二进制文件和字节流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 20:44:23" itemprop="dateCreated datePublished" datetime="2021-12-05T20:44:23+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">4第四部分 文件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">第13章 文件基本技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a0f4cea/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a0f4cea/" data-xid="/JavaReadingNotes/a0f4cea/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-2-二进制文件和字节流"><a href="#13-2-二进制文件和字节流" class="headerlink" title="13.2 二进制文件和字节流"></a>13.2 二进制文件和字节流</h1><p>本节介绍在Java中如何以二进制字节的方式来处理文件，前面我们提到Java中有流的概念，以二进制方式读写的主要流有：</p>
<ul>
<li>InputStream/OutputStream：这是基类，它们是抽象类。</li>
<li>FileInputStream/FileOutputStream：输入源和输出目标是文件的流。</li>
<li>ByteArrayInputStream/ByteArrayOutputStream：输入源和输出目标是字节数组的流。</li>
<li>DataInputStream/DataOutputStream：装饰类，按基本类型和字符串而非只是字节读写流。</li>
<li>BufferedInputStream/BufferedOutputStream：装饰类，对输入输出流提供缓冲功能。</li>
</ul>
<p>下面，我们就来介绍这些类的功能、用法、原理和使用场景，最后总结一些简单的实用方法。</p>
<h2 id="13-2-1-InputStream-OutputStream"><a href="#13-2-1-InputStream-OutputStream" class="headerlink" title="13.2.1 InputStream/OutputStream"></a>13.2.1 InputStream/OutputStream</h2><p>我们分别看下InputStream和OutputStream。</p>
<h3 id="1-InputStream"><a href="#1-InputStream" class="headerlink" title="1. InputStream"></a>1. InputStream</h3><h4 id="（1）InputStream的基本方法"><a href="#（1）InputStream的基本方法" class="headerlink" title="（1）InputStream的基本方法"></a>（1）InputStream的基本方法</h4><p>InputStream是抽象类，主要方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>read方法从流中读取下一个字节，返回类型为int，但取值为0～255，当读到流结尾的时候，返回值为-1，如果流中没有数据，read方法会阻塞直到数据到来、流关闭或异常出现。异常出现时，read方法抛出异常，类型为IOException，这是一个受检异常，调用者必须进行处理。read是一个抽象方法，具体子类必须实现，FileInputStream会调用本地方法。所谓本地方法，一般不是用Java写的，大多使用C语言实现，具体实现往往与虚拟机和操作系统有关。</p>
<p>InputStream还有如下方法，可以一次读取多个字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>读入的字节放入参数数组b中，第一个字节存入b[0]，第二个存入b[1]，以此类推，一次最多读入的字节个数为数组b的长度，但实际读入的个数可能小于数组长度，返回值为实际读入的字节个数。如果刚开始读取时已到流结尾，则返回-1；否则，只要数组长度大于0，该方法都会尽力至少读取一个字节，如果流中一个字节都没有，它会阻塞，异常出现时也是抛出IOException。该方法不是抽象方法，InputStream有一个默认实现，主要就是循环调用读一个字节的read方法，但子类如FileInputStream往往会提供更为高效的实现。</p>
<p>批量读取还有一个更为通用的重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>读入的第一个字节放入<code>b[off]</code>，最多读取len个字节，<code>read(byte b[])</code>就是调用了该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流读取结束后，应该关闭，以释放相关资源，关闭方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>不管read方法是否抛出了异常，都应该调用close方法，所以close方法通常应该放在finally语句内。close方法自己可能也会抛出IOException，但通常可以捕获并忽略。</p>
<h4 id="（2）InputStream的高级方法"><a href="#（2）InputStream的高级方法" class="headerlink" title="（2）InputStream的高级方法"></a>（2）InputStream的高级方法</h4><p>InputStream还定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>skip跳过输入流中n个字节，因为输入流中剩余的字节个数可能不到n，所以返回值为实际略过的字节个数。InputStream的默认实现就是尽力读取n个字节并扔掉，子类往往会提供更为高效的实现，FileInputStream会调用本地方法。在处理数据时，对于不感兴趣的部分，skip往往比读取然后扔掉的效率要高。</p>
<p>available返回下一次不需要阻塞就能读取到的大概字节个数。InputStream的默认实现是返回0，子类会根据具体情况返回适当的值，FileInputStream会调用本地方法。在文件读写中，这个方法一般没什么用，但在从网络读取数据时，可以根据该方法的返回值在网络有足够数据时才读，以避免阻塞。</p>
<p>一般的流读取都是一次性的，且只能往前读，不能往后读，但有时可能希望能够先看一下后面的内容，根据情况再重新读取。比如，处理一个未知的二进制文件，我们不确定它的类型，但可能可以通过流的前几十个字节判断出来，判读出来后，再重置到流开头，交给相应类型的代码进行处理。</p>
<p>InputStream定义了三个方法：mark、reset、markSupported，用于支持从读过的流中重复读取。怎么重复读取呢？先使用mark()方法将当前位置标记下来，在读取了一些字节，希望重新从标记位置读时，调用reset方法。能够重复读取不代表能够回到任意的标记位置，mark方法有一个参数readLimit，表示在设置了标记后，能够继续往后读的最多字节数，如果超过了，标记会无效。为什么会这样呢？因为之所以能够重读，是因为流能够将从标记位置开始的字节保存起来，而保存消耗的内存不能无限大，流只保证不会小于readLimit。</p>
<p>不是所有流都支持mark、reset方法，是否支持可以通过markSupported的返回值进行判断。InpuStream的默认实现是不支持，FileInputStream也不直接支持，但BufferedInput-Stream和ByteArrayInputStream可以支持。</p>
<h3 id="2-OutputStream"><a href="#2-OutputStream" class="headerlink" title="2. OutputStream"></a>2. OutputStream</h3><p>OutputStream的基本方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>向流中写入一个字节，参数类型虽然是int，但其实只会用到最低的8位。这个方法是抽象方法，具体子类必须实现，FileInputStream会调用本地方法。</p>
<p>OutputStream还有两个批量写入的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>在第二个方法中，第一个写入的字节是b[off]，写入个数为len，最后一个是b[off+len-1]，第一个方法等同于调用write(b, 0, b.length); 。OutputStream的默认实现是循环调用单字节的write()方法，子类往往有更为高效的实现，FileOutpuStream会调用对应的批量写本地方法。</p>
<p>OutputStream还有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>flush方法将缓冲而未实际写的数据进行实际写入，比如，在BufferedOutputStream中，调用flush方法会将其缓冲区的内容写到其装饰的流中，并调用该流的flush方法。基类OutputStream没有缓冲，flush方法代码为空。</p>
<p>需要说明的是文件输出流FileOutputStream，你可能会认为，调用flush方法会强制确保数据保存到硬盘上，但实际上不是这样，FileOutputStream没有缓冲，没有重写flush方法，调用flush方法没有任何效果，数据只是传递给了操作系统，但操作系统什么时候保存到硬盘上，这是不一定的。要确保数据保存到了硬盘上，可以调用FileOutputStream中的特有方法，具体待会介绍。</p>
<p>close方法一般会首先调用flush方法，然后再释放流占用的系统资源。同InputStream一样，close方法一般应该放在finally语句内。</p>
<h2 id="13-2-2-FileInputStream-FileOutputStream"><a href="#13-2-2-FileInputStream-FileOutputStream" class="headerlink" title="13.2.2 FileInputStream/FileOutputStream"></a>13.2.2 FileInputStream/FileOutputStream</h2><h3 id="1-FileOutputStream"><a href="#1-FileOutputStream" class="headerlink" title="1. FileOutputStream"></a>1. FileOutputStream</h3><p>FileOutputStream有多个构造方法，其中两个如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>File类型的参数file和字符串的类型的参数name都表示文件路径，路径可以是绝对路径，也可以是相对路径，如果文件已存在，append参数指定是追加还是覆盖，true表示追加， false表示覆盖，第二个构造方法没有append参数，表示覆盖。new一个FileOutputStream对象会实际打开文件，操作系统会分配相关资源。如果当前用户没有写权限，会抛出异常SecurityException，它是一种RuntimeException。如果指定的文件是一个已存在的目录，或者由于其他原因不能打开文件，会抛出异常FileNotFoundException，它是IOException的一个子类。</p>
<p>我们看一段简单的代码，将字符串”hello, 123，老马”写到文件hello.txt中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output =   <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    String data = <span class="string">&quot;hello, 123, 老马&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = data.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">    output.write(bytes);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OutputStream只能以byte或byte数组写文件，为了写字符串，我们调用String的get-Bytes方法得到它的UTF-8编码的字节数组，再调用write()方法，写的过程放在try语句内，在finally语句中调用close方法。</p>
<p>FileOutputStream还有两个额外的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FileChannel <span class="title">getChannel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> FileDescriptor <span class="title">getFD</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>FileChannel定义在java.nio中，表示文件通道概念。我们不会深入介绍通道，但内存映射文件方法定义在FileChannel中，我们会在下章介绍。FileDescriptor表示文件描述符，它与操作系统的一些文件内存结构相连，在大部分情况下，我们不会用到它，不过它有一个方法sync：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> SyncFailedException</span>;</span><br></pre></td></tr></table></figure>

<p>这是一个本地方法，它会确保将操作系统缓冲的数据写到硬盘上。注意与Output-Stream的flush方法相区别，flush方法只能将应用程序缓冲的数据写到操作系统，sync方法则确保数据写到硬盘，不过一般情况下，我们并不需要手工调用它，只要操作系统和硬件设备没问题，数据迟早会写入。在一定特定情况下，一定需要确保数据写入硬盘，则可以调用该方法。</p>
<h3 id="2-FileInputStream"><a href="#2-FileInputStream" class="headerlink" title="2. FileInputStream"></a>2. FileInputStream</h3><p>FileInputStream的主要构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileInputStream</span><span class="params">(File file)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br></pre></td></tr></table></figure>

<p>参数与FileOutputStream类似，可以是文件路径或File对象，但必须是一个已存在的文件，不能是目录。new一个FileInputStream对象也会实际打开文件，操作系统会分配相关资源，如果文件不存在，会抛出异常FileNotFoundException，如果当前用户没有读的权限，会抛出异常SecurityException。我们看一段简单的代码，将上面写入的文件”hello.txt”读到内存并输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead = input.read(buf);</span><br><span class="line">    String data = <span class="keyword">new</span> String(buf, <span class="number">0</span>, bytesRead, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读入到的是byte数组，我们使用String的带编码参数的构造方法将其转换为了String。这段代码假定一次read调用就读到了所有内容，且假定字节长度不超过1024。为了确保读到所有内容，可以逐个字节读取直到文件结束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((b=input.read())! =-<span class="number">1</span>)&#123;</span><br><span class="line">    buf[bytesRead++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有缓冲的情况下逐个字节读取性能很低，可以使用批量读入且确保读到结尾，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((bytesRead=input.read(buf, off, <span class="number">1024</span>-off ))! =-<span class="number">1</span>)&#123;</span><br><span class="line">    off += bytesRead;</span><br><span class="line">&#125;</span><br><span class="line">String data = <span class="keyword">new</span> String(buf, <span class="number">0</span>, off, <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>不过，这还是假定文件内容长度不超过一个固定的大小1024。如果不确定文件内容的长度，但不希望一次性分配过大的byte数组，又希望将文件内容全部读入，怎么做呢？可以借助ByteArrayOutputStream，我们下面进行介绍。</p>
<h2 id="13-2-3-ByteArrayInputStream-ByteArrayOutputStream"><a href="#13-2-3-ByteArrayInputStream-ByteArrayOutputStream" class="headerlink" title="13.2.3 ByteArrayInputStream/ByteArrayOutputStream"></a>13.2.3 ByteArrayInputStream/ByteArrayOutputStream</h2><p>它们的输入源和输出目标是字节数组，我们分别介绍。</p>
<h3 id="1-ByteArrayOutputStream"><a href="#1-ByteArrayOutputStream" class="headerlink" title="1. ByteArrayOutputStream"></a>1. ByteArrayOutputStream</h3><p>ByteArrayOutputStream的输出目标是一个byte数组，这个数组的长度是根据数据内容动态扩展的，它有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayOutputStream</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p>第二个构造方法中的size指定的就是初始的数组大小，如果没有指定，则长度为32。在调用write方法的过程中，如果数组大小不够，会进行扩展，扩展策略同样是指数扩展，每次至少增加一倍。</p>
<p>ByteArrayOutputStream有如下方法，可以方便地将数据转换为字节数组或字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] toByteArray()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">(String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>toString()方法使用系统默认编码。</p>
<p>ByteArrayOutputStream中的数据也可以方便地写到另一个OutputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<p>ByteArrayOutputStream还有如下额外方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>size方法返回当前写入的字节个数。reset方法重置字节个数为0, reset后，可以重用已分配的数组。</p>
<p>使用ByteArrayOutputStream，我们可以改进前面的读文件代码，确保将所有文件内容读入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead=input.read(buf))! =-<span class="number">1</span>)&#123;</span><br><span class="line">        output.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">    String data = output.toString(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(data);</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读入的数据先写入ByteArrayOutputStream中，读完后，再调用其toString方法获取完整数据。</p>
<h3 id="2-ByteArrayInputStream"><a href="#2-ByteArrayInputStream" class="headerlink" title="2. ByteArrayInputStream"></a>2. ByteArrayInputStream</h3><p>ByteArrayInputStream将byte数组包装为一个输入流，是一种适配器模式，它的构造方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure>

<p>第二个构造方法以buf中offset开始的length个字节为背后的数据。ByteArrayInput-Stream的所有数据都在内存，支持mark/reset重复读取。</p>
<p>为什么要将byte数组转换为InputStream呢？这与容器类中要将数组、单个元素转换为容器接口的原因是类似的，有很多代码是以InputStream/OutputSteam为参数构建的，它们构成了一个协作体系，将byte数组转换为InputStream可以方便地参与这种体系，复用代码。</p>
<h2 id="13-2-4-DataInputStream-DataOutputStream"><a href="#13-2-4-DataInputStream-DataOutputStream" class="headerlink" title="13.2.4 DataInputStream/DataOutputStream"></a>13.2.4 DataInputStream/DataOutputStream</h2><p>上面介绍的类都只能以字节为单位读写，如何以其他类型读写呢？比如int、double。可以使用DataInputStream/DataOutputStream，它们都是装饰类。</p>
<h3 id="1-DataOutputStream"><a href="#1-DataOutputStream" class="headerlink" title="1. DataOutputStream"></a>1. DataOutputStream</h3><p>DataOutputStream是装饰类基类FilterOutputStream的子类，FilterOutputStream是Output-Stream的子类，它的构造方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FilterOutputStream</span><span class="params">(OutputStream out)</span></span></span><br></pre></td></tr></table></figure>

<p>它接受一个已有的OutputStream，基本上将所有操作都代理给了它。DataOutputStream实现了DataOutput接口，可以以各种基本类型和字符串写入数据，部分方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeBoolean</span><span class="params">(<span class="keyword">boolean</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(<span class="keyword">int</span> v)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeUTF</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>在写入时，DataOutputStream会将这些类型的数据转换为其对应的二进制字节，比如：<br>1）writeBoolean：写入一个字节，如果值为true，则写入1，否则0。<br>2）writeInt：写入4个字节，最高位字节先写入，最低位最后写入。<br>3）writeUTF：将字符串的UTF-8编码字节写入，这个编码格式与标准的UTF-8编码略有不同，不过，我们不用关心这个细节。</p>
<p>与FilterOutputStream一样，DataOutputStream的构造方法也是接受一个已有的Output-Stream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataOutputStream</span><span class="params">(OutputStream out)</span></span></span><br></pre></td></tr></table></figure>

<p>我们来看一个例子，保存一个学生列表到文件中，学生类的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">//省略构造方法和getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生列表内容为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; students = Arrays.asList(<span class="keyword">new</span> Student[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="number">80.9d</span>), <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">17</span>, <span class="number">67.5d</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将该列表内容写到文件students.dat中的代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStudents</span><span class="params">(List&lt;Student&gt; students)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    DataOutputStream output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">            <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;students.dat&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        output.writeInt(students.size());</span><br><span class="line">        <span class="keyword">for</span>(Student s : students)&#123;</span><br><span class="line">            output.writeUTF(s.getName());</span><br><span class="line">            output.writeInt(s.getAge());</span><br><span class="line">            output.writeDouble(s.getScore());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先写了列表的长度，然后针对每个学生、每个字段，根据其类型调用了相应的write方法。</p>
<h3 id="2-DataInputStream"><a href="#2-DataInputStream" class="headerlink" title="2. DataInputStream"></a>2. DataInputStream</h3><p>DataInputStream是装饰类基类FilterInputStream的子类，FilterInputStream是Input-Stream的子类。DataInputStream实现了DataInput接口，可以以各种基本类型和字符串读取数据，部分方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function">String <span class="title">readUTF</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>在读取时，DataInputStream会先按字节读进来，然后转换为对应的类型。</p>
<p>DataInputStream的构造方法接受一个InputStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span></span></span><br></pre></td></tr></table></figure>

<p>还是以上面的学生列表为例，我们来看怎么从文件中读进来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Student&gt; <span class="title">readStudents</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    DataInputStream input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">                <span class="keyword">new</span> FileInputStream(<span class="string">&quot;students.dat&quot;</span>));</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = input.readInt();</span><br><span class="line">        List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;Student&gt;(size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">            Student s = <span class="keyword">new</span> Student();</span><br><span class="line">            s.setName(input.readUTF());</span><br><span class="line">            s.setAge(input.readInt());</span><br><span class="line">            s.setScore(input.readDouble());</span><br><span class="line">            students.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> students;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读基本是写的逆过程，代码比较简单，就不赘述了。使用DataInputStream/DataOutput-Stream读写对象，非常灵活，但比较麻烦，所以Java提供了序列化机制，我们在下章介绍。</p>
<h2 id="13-2-5-BufferedInputStream-BufferedOutputStream"><a href="#13-2-5-BufferedInputStream-BufferedOutputStream" class="headerlink" title="13.2.5 BufferedInputStream/BufferedOutputStream"></a>13.2.5 BufferedInputStream/BufferedOutputStream</h2><p>FileInputStream/FileOutputStream是没有缓冲的，按单个字节读写时性能比较低，虽然可以按字节数组读取以提高性能，但有时必须要按字节读写，怎么解决这个问题呢？方法是将文件流包装到缓冲流中。BufferedInputStream内部有个字节数组作为缓冲区，读取时，先从这个缓冲区读，缓冲区读完了再调用包装的流读，它的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>

<p>size表示缓冲区大小，如果没有，默认值为8192。除了提高性能，BufferedInputStream也支持mark/reset，可以重复读取。与BufferedInputStream类似，BufferedOutputStream的构造方法也有两个，默认的缓冲区大小也是8192，它的flush方法会将缓冲区的内容写到包装的流中。</p>
<p>在使用FileInputStream/FileOutputStream时，应该几乎总是在它的外面包上对应的缓冲类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">OutputStream output =   <span class="keyword">new</span> BufferedOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;hello.txt&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>再比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream output = <span class="keyword">new</span> DataOutputStream(</span><br><span class="line">        <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;students.dat&quot;</span>)));</span><br><span class="line">DataInputStream input = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">        <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;students.dat&quot;</span>)));</span><br></pre></td></tr></table></figure>

<h2 id="13-2-6-实用方法"><a href="#13-2-6-实用方法" class="headerlink" title="13.2.6 实用方法"></a>13.2.6 实用方法</h2><p>可以看出，即使只是按二进制字节读写流，Java也包括了很多的类，虽然很灵活，但对于一些简单的需求，却需要写很多代码。实际开发中，经常需要将一些常用功能进行封装，提供更为简单的接口。下面我们提供一些实用方法，以供参考，这些代码都比较简单易懂，我们就不解释了。</p>
<p>复制输入流的内容到输出流，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(InputStream input,</span></span></span><br><span class="line"><span class="params"><span class="function">        OutputStream output)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">int</span> bytesRead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((bytesRead = input.read(buf))! =-<span class="number">1</span>)&#123;</span><br><span class="line">        output.write(buf, <span class="number">0</span>, bytesRead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，在Java 9中，InputStream类增加了一个方法transferTo，可以实现相同功能，实现是类似的，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(out, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> transferred = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[DEFAULT_BUFFER_SIZE]; <span class="comment">//buf大小是8192</span></span><br><span class="line">    <span class="keyword">int</span> read;</span><br><span class="line">    <span class="keyword">while</span>((read = <span class="keyword">this</span>.read(buffer, <span class="number">0</span>, DEFAULT_BUFFER_SIZE)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">        transferred += read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transferred;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件读入字节数组，这个方法调用了上面的复制方法，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFileToByteArray(String fileName) <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">    ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        copy(input, output);</span><br><span class="line">        <span class="keyword">return</span> output.toByteArray();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将字节数组写到文件，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeByteArrayToFile</span><span class="params">(String fileName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(fileName);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        output.write(data);</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Apache有一个类库Commons IO，里面提供了很多简单易用的方法，实际开发中，可以考虑使用。</p>
<h3 id="13-2-7-小结"><a href="#13-2-7-小结" class="headerlink" title="13.2.7 小结"></a>13.2.7 小结</h3><p>本节介绍了如何在Java中以二进制字节的方式读写文件，介绍了主要的流。<br>1）InputStream/OutputStream：是抽象基类，有很多面向流的代码，以它们为参数，比如本节介绍的copy方法。<br>2）FileInputStream/FileOutputStream：流的源和目的地是文件。<br>3）ByteArrayInputStream/ByteArrayOutputStream：源和目的地是字节数组，作为输入相当于适配器，作为输出封装了动态数组，便于使用。<br>4）DataInputStream/DataOutputStream：装饰类，按基本类型和字符串读写流。<br>5）BufferedInputStream/BufferedOutputStream：装饰类，提供缓冲，FileInputStream/FileOutputStream一般总是应该用该类装饰。</p>
<p>最后，我们提供了一些实用方法，以方便常见的操作，在实际开发中，可以考虑使用专门的类库，如Apache Commons IO(<a target="_blank" rel="noopener" href="http://commons.apache.org/proper/commons-io/">http://commons.apache.org/proper/commons-io/</a> )。本节完整的代码在github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.laoma.file.c57下。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/c8c36b4f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/c8c36b4f/" class="post-title-link" itemprop="url">13.0 第13章 文件基本技术 13.1 文件概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 16:31:50" itemprop="dateCreated datePublished" datetime="2021-12-05T16:31:50+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">4第四部分 文件</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/4%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%96%87%E4%BB%B6/%E7%AC%AC13%E7%AB%A0-%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">第13章 文件基本技术</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/c8c36b4f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/c8c36b4f/" data-xid="/JavaReadingNotes/c8c36b4f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第13章-文件基本技术"><a href="#第13章-文件基本技术" class="headerlink" title="第13章 文件基本技术"></a>第13章 文件基本技术</h1><p>我们在日常计算机操作中，接触和处理最多的，除了上网，大概就是各种各样的文件了，从本章开始，我们就来探讨文件处理。文件处理的内容比较多，我们先在13.1节进行概述，并介绍后续章节的安排。</p>
<h1 id="13-1-文件概述"><a href="#13-1-文件概述" class="headerlink" title="13.1 文件概述"></a>13.1 文件概述</h1><p>在本节，我们主要介绍文件有关的一些基本概念和常识，Java中处理文件的基本思路和类结构，以及接下来的章节安排。</p>
<h2 id="13-1-1-基本概念和常识"><a href="#13-1-1-基本概念和常识" class="headerlink" title="13.1.1 基本概念和常识"></a>13.1.1 基本概念和常识</h2><p>下面，我们先介绍一些基本概念和常识，包括二进制思维、文件类型、文本文件的编码、文件系统和文件读写等。</p>
<h3 id="1．二进制思维"><a href="#1．二进制思维" class="headerlink" title="1．二进制思维"></a>1．二进制思维</h3><p>为了透彻理解文件，<strong>我们首先要有一个二进制思维</strong>。所有文件，不论是可执行文件、图片文件、视频文件、Word文件、压缩文件、txt文件，都没什么可神秘的，它们都是以0和1的二进制形式保存的。我们所看到的图片、视频、文本，都是应用程序对这些二进制的解析结果。</p>
<p>作为程序员，我们应该有一个编辑器，能查看文件的二进制形式，比如UltraEdit，它支持以十六进制进行查看和编辑。比如，一个文本文件，看到的内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, 123, 老马</span><br></pre></td></tr></table></figure>

<p>打开十六进制编辑，看到的内容如图13-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209213353.jpeg" alt="epub_923038_113"></p>
<center>图13-1 使用UltraEdit查看十六进制</center>

<p>左边的部分就是其对应的十六进制，”hello”对应的十六进制是”68 65 6C 6C 6F”，对应ASCII码编号”104 101 108 108 111”, “马”对应的十六进制是”E9 A9 AC”，这是”马”的UTF-8编码。</p>
<h3 id="2．文件类型"><a href="#2．文件类型" class="headerlink" title="2．文件类型"></a>2．文件类型</h3><p>虽然所有数据都是以二进制形式保存的，但为了方便处理数据，高级语言引入了数据类型的概念。文件处理也类似，所有文件都是以二进制形式保存的，但为了便于理解和处理文件，文件也有文件类型的概念。</p>
<p>文件类型通常以扩展名的形式体现，比如，PDF文件类型的扩展名是．pdf，图片文件的一种常见扩展名是．jpg，压缩文件的一种常见扩展名是．zip。每种文件类型都有一定的格式，代表着文件含义和二进制之间的映射关系。比如一个Word文件，其中有文本、图片、表格，文本可能有颜色、字体、字号等，doc文件类型就定义了这些内容和二进制表示之间的映射关系。有的文件类型的格式是公开的，有的可能是私有的，我们也可以定义自己私有的文件格式。</p>
<p>对于一种文件类型，往往有一种或多种应用程序可以解读它，进行查看和编辑，一个应用程序往往可以解读一种或多种文件类型。在操作系统中，一种扩展名往往关联一个应用程序，比如．doc后缀关联Word应用。用户通过双击试图打开某扩展名的文件时，操作系统查找关联的应用程序，启动该程序，传递该文件路径给它，程序再打开该文件。</p>
<p>需要说明的是，给文件加正确的扩展名是一种惯例，但并不是强制的，如果扩展名和文件类型不匹配，应用程序试图打开该文件时可能会报错。另外，一个文件可以选择使用多种应用程序进行解读，在操作系统中，一般通过右键单击文件，选择打开方式即可。</p>
<p>文件类型可以粗略分为两类：一类是文本文件；另一类是二进制文件。文本文件的例子有普通的文本文件（.txt），程序源代码文件（.java）、HTML文件（.html）等；二进制文件的例子有压缩文件（.zip）、PDF文件（.pdf）、MP3文件（.mp3）、Excel文件（.xlsx）等。</p>
<p>基本上，文本文件里的每个二进制字节都是某个可打印字符的一部分，都可以用最基本的文本编辑器进行查看和编辑，如Windows上的notepad、Linux上的vi。二进制文件中，每个字节就不一定表示字符，可能表示颜色、字体、声音大小等，如果用基本的文本编辑器打开，一般都是满屏的乱码，需要专门的应用程序进行查看和编辑。</p>
<h3 id="3．文本文件的编码"><a href="#3．文本文件的编码" class="headerlink" title="3．文本文件的编码"></a>3．文本文件的编码</h3><p>对于文本文件，我们还必须注意文件的编码方式。文本文件中包含的基本都是可打印字符，但字符到二进制的映射（即编码）却有多种方式，如GB18030、UTF-8，我们在第2章详细介绍过各种编码，这里就不赘述了。</p>
<p>对于一个给定的文本文件，它采用的是什么编码方式呢？一般而言，我们是不知道的。那应用程序用什么编码方式进行解读呢？一般使用某种默认的编码方式，可能是应用程序默认的，也可能是操作系统默认的，当然也可能采用一些比较智能的算法自动推断编码方式。</p>
<p>对于UTF-8编码的文件，我们需要特别说明。有一种方式，可以标记该文件是UTF-8编码的，那就是在文件最开头加入三个特殊字节（0xEF 0xBB 0xBF），这三个特殊字节被称为BOM头，BOM是Byte Order Mark（即字节序标记）的缩写。比如，对前面的hello.txt文件，带BOM头的UTF-8编码的十六进制形式如图13-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209213419.jpeg" alt="epub_923038_114"></p>
<center>图13-2 带BOM头的文件</center>

<p>图13-1和图13-2所示都是UTF-8编码，看到的字符内容也一样，但二进制内容不一样，一个带BOM头，一个不带BOM头。</p>
<p>需要注意的是，不是所有应用程序都支持带BOM头的UTF-8编码文件，比如PHP就不支持BOM，如果PHP源代码文件带BOM头，PHP运行就会出错。碰到这种问题时，前面介绍的<strong>二进制思维就特别重要，不要只看文件的显示，还要看文件背后的二进制</strong>。</p>
<p>另外，我们需要说明下文本文件的换行符。在Windows系统中，换行符一般是两个字符”\r\n”，即ASCII码的13（’\r’）和10（’\n’），在Linux系统中，换行符一般是一个字符”\n”。</p>
<h3 id="4．文件系统"><a href="#4．文件系统" class="headerlink" title="4．文件系统"></a>4．文件系统</h3><p>文件一般是放在硬盘上的，一个机器上可能有多个硬盘，但各种操作系统都会隐藏物理硬盘概念，提供一个逻辑上的统一结构。在Windows中，可以有多个逻辑盘，如C、D、E等，每个盘可以被格式化为一种不同的文件系统，常见的文件系统有FAT32和NTFS。在Linux中，只有一个逻辑的根目录，用斜线/表示。Linux支持多种不同的文件系统，如Ext2/Ext3/Ext4等。不同的文件系统有不同的文件组织方式、结构和特点，不过，一般编程时，语言和类库为我们提供了统一的API，我们并不需要关心其细节。</p>
<p>在逻辑上，Windows中有多个根目录，Linux中有一个根目录，每个根目录下有一棵子目录和文件构成的树。每个文件都有<strong>文件路径</strong>的概念，路径有两种形式：一种是<strong>绝对路径</strong>，另一种是<strong>相对路径</strong>。</p>
<p>所谓绝对路径，是从根目录开始到当前文件的完整路径，在Windows中，目录之间用反斜线分隔，如C:\code\hello.java，在Linux中，目录之间用斜线分隔，如/Users/laoma/Desktop/code/hello.java。在Java中，java.io.File类定义了一个静态变量File.separator，表示路径分隔符，编程时应使用该变量而避免硬编码。</p>
<p>所谓相对路径，是相对于<strong>当前目录</strong>而言的。在命令行终端上，通过cd命令进入的目录就是当前目录；在Java中，通过System.getProperty(“user.dir”)可以得到运行Java程序的当前目录。相对路径不以根目录开头，比如在Windows上，当前目录为D:\laoma，相对路径为code\hello.java，则完整路径为D:\laoma\code\hello.java。</p>
<p>每个文件除了有具体内容，还有<strong>元数据信息</strong>，如文件名、创建时间、修改时间、文件大小等。文件还有一个<strong>是否隐藏</strong>的性质。在Linux系统中，如果文件名以．开头，则为隐藏文件；在Windows系统中，隐藏是文件的一个属性，可以进行设置。</p>
<p>大部分文件系统的文件和目录具有<strong>访问权限</strong>的概念，对所有者、用户组可以有不同的权限，具体权限包括读、写、执行。</p>
<p>文件名有<strong>大小写是否敏感</strong>的概念。在Windows系统中，一般是大小写不敏感的，而Linux则一般是大小写敏感的。也就是说，同一个目录下，abc.txt和ABC.txt在Windows中被视为同一个文件，而在Linux中则被视为不同的文件。</p>
<p>操作系统中有一个<strong>临时文件</strong>的概念。临时文件位于一个特定目录，比如Windows7中，临时文件一般位于“C:\Users\用户名\AppData\Local\Temp”; Linux系统中，临时文件位于/tmp。操作系统会有一定的策略自动清理不用的临时文件。临时文件一般不是用户手工创建的，而是应用程序产生的，用于临时目的。</p>
<h3 id="5．文件读写"><a href="#5．文件读写" class="headerlink" title="5．文件读写"></a>5．文件读写</h3><p>文件是放在硬盘上的，程序处理文件需要将文件读入内存，修改后，需要写回硬盘。操作系统提供了对文件读写的基本API，不同操作系统的接口和实现是不一样的，不过，有一些共同的概念。Java封装了操作系统的功能，提供了统一的API。</p>
<p>一个基本常识是：<strong>硬盘的访问延时，相比内存，是很慢的</strong>。操作系统和硬盘一般是按块批量传输，而不是按字节，以摊销延时开销，块大小一般至少为512字节，即使应用程序只需要文件的一个字节，操作系统也会至少将一个块读进来。一般而言，应尽量减少接触硬盘，接触一次，就一次多做一些事情。对于网络请求和其他输入输出设备，原则都是类似的。</p>
<p>另一个基本常识是：<strong>一般读写文件需要两次数据复制</strong>，比如读文件，需要先从硬盘复制到操作系统内核，再从内核复制到应用程序分配的内存中。操作系统运行所在的环境和应用程序是不一样的，操作系统所在的环境是内核态，应用程序是用户态，应用程序调用操作系统的功能，需要两次环境的切换，先从用户态切到内核态，再从内核态切到用户态。<strong>这种用户态/内核态的切换是有开销的，应尽量减少这种切换</strong>。</p>
<p>为了提升文件操作的效率，应用程序经常使用一种常见的策略，即<strong>使用缓冲区</strong>。读文件时，即使目前只需要少量内容，但预知还会接着读取，就一次读取比较多的内容，放到读缓冲区，下次读取时，如果缓冲区有，就直接从缓冲区读，减少访问操作系统和硬盘。写文件时，先写到写缓冲区，写缓冲区满了之后，再一次性调用操作系统写到硬盘。不过，需要注意的是，在写结束的时候，要记住将缓冲区的剩余内容同步到硬盘。操作系统自身也会使用缓冲区，不过，应用程序更了解读写模式，恰当使用往往可以有更高的效率。</p>
<p>操作系统操作文件<strong>一般有打开和关闭的概念</strong>。打开文件会在操作系统内核建立一个有关该文件的内存结构，这个结构一般通过一个整数索引来引用，这个索引一般称为<strong>文件描述符</strong>。这个结构是消耗内存的，操作系统能同时打开的文件一般也是有限的，在不用文件的时候，应该记住<strong>关闭文件</strong>。关闭文件一般会同步缓冲区内容到硬盘，并释放占据的内存结构。</p>
<p>操作系统一般支持一种称为<strong>内存映射文件</strong>的高效的随机读写大文件的方法，将文件直接映射到内存，操作内存就是操作文件。在内存映射文件中，只有访问到的数据才会被实际复制到内存，且数据只会复制一次，被操作系统以及多个应用程序共享。</p>
<h2 id="13-1-2-Java文件概述"><a href="#13-1-2-Java文件概述" class="headerlink" title="13.1.2 Java文件概述"></a>13.1.2 Java文件概述</h2><p>在Java中处理文件有一些基本概念和类，包括流、装饰器设计模式、Reader/Writer、随机读写文件、File、NIO、序列化和反序列化，下面分别介绍。</p>
<h3 id="1．流"><a href="#1．流" class="headerlink" title="1．流"></a>1．流</h3><p>在Java中（很多其他语言也类似），文件一般不是单独处理的，而是视为输入输出（Input/Output, IO）设备的一种。Java使用基本统一的概念处理所有的IO，包括键盘、显示终端、网络等。</p>
<p>这个统一的概念是<strong>流</strong>，流有<strong>输入流</strong>和<strong>输出流</strong>之分。输入流就是可以从中获取数据，输入流的实际提供者可以是键盘、文件、网络等；输出流就是可以向其中写入数据，输出流的实际目的地可以是显示终端、文件、网络等。</p>
<p>Java IO的基本类大多位于包java.io中。类InputStream表示输入流，OutputStream表示输出流，而FileInputStream表示文件输入流，FileOutputStream表示文件输出流。</p>
<p>有了流的概念，就有了很多<strong>面向流的代码</strong>，比如对流做加密、压缩、计算信息摘要、计算检验和等，这些代码接受的参数和返回结果都是抽象的流，<strong>它们构成了一个协作体系，这类似于之前介绍的接口概念、面向接口的编程，以及容器类协作体系</strong>。一些实际上不是IO的数据源和目的地也转换为了流，以方便参与这种协作，比如字节数组，也包装为了流ByteArrayInputStream和ByteArrayOutputStream。</p>
<h3 id="2．装饰器设计模式"><a href="#2．装饰器设计模式" class="headerlink" title="2．装饰器设计模式"></a>2．装饰器设计模式</h3><p>基本的流按字节读写，没有缓冲区，这不方便使用。Java解决这个问题的方法是使用<strong>装饰器设计模式</strong>，引入了很多装饰类，对基本的流增加功能，以方便使用。一般一个类只关注一个方面，实际使用时，经常会需要多个装饰类。</p>
<p>Java中有很多装饰类，有两个基类：过滤器输入流FilterInputStream和过滤器输出流FilterOutputStream。过滤类似于自来水管道，流入的是水，流出的也是水，功能不变，或者只是增加功能。它有很多子类，这里列举一些：<br>1）对流起缓冲装饰的子类是BufferedInputStream和BufferedOutputStream。<br>2）可以按8种基本类型和字符串对流进行读写的子类是DataInputStream和DataOutput-Stream。<br>3）可以对流进行压缩和解压缩的子类有GZIPInputStream、ZipInputStream、GZIPOutput-Stream和ZipOutputStream。<br>4）可以将基本类型、对象输出为其字符串表示的子类有PrintStream。</p>
<p>众多的装饰类使得整个类结构变得比较复杂，完成基本的操作也需要比较多的代码；其优点是非常灵活，在解决某些问题时也很优雅。</p>
<h3 id="3-Reader-Writer"><a href="#3-Reader-Writer" class="headerlink" title="3. Reader/Writer"></a>3. Reader/Writer</h3><p>以InputStream/OutputStream为基类的流基本都是以二进制形式处理数据的，不能够方便地处理文本文件，没有编码的概念，能够方便地按字符处理文本数据的基类是Reader和Writer，它也有很多子类：<br>1）读写文件的子类是FileReader和FileWriter。<br>2）起缓冲装饰的子类是BufferedReader和BufferedWriter。<br>3）将字符数组包装为Reader/Writer的子类是CharArrayReader和CharArrayWriter。<br>4）将字符串包装为Reader/Writer的子类是StringReader和StringWriter。<br>5）将InputStream/OutputStream转换为Reader/Writer的子类是InputStreamReader和OutputStreamWriter。<br>6）将基本类型、对象输出为其字符串表示的子类是PrintWriter。</p>
<h3 id="4．随机读写文件"><a href="#4．随机读写文件" class="headerlink" title="4．随机读写文件"></a>4．随机读写文件</h3><p>大部分情况下，使用流或Reader/Writer读写文件内容，但Java提供了一个独立的可以随机读写文件的类RandomAccessFile，适用于大小已知的记录组成的文件。该类在日常应用开发中用得比较少，但在一些系统程序中用得比较多。</p>
<h3 id="5-File"><a href="#5-File" class="headerlink" title="5. File"></a>5. File</h3><p>上面介绍的都是操作数据本身，而关于文件路径、文件元数据、文件目录、临时文件、访问权限管理等，Java使用File这个类来表示。</p>
<h3 id="6-NIO"><a href="#6-NIO" class="headerlink" title="6. NIO"></a>6. NIO</h3><p>以上介绍的类基本都位于包java.io下，Java还有一个关于IO操作的包java.nio, nio表示New IO，这个包下同样包含大量的类。</p>
<p><strong>NIO代表一种不同的看待IO的方式，它有缓冲区和通道的概念</strong>。利用缓冲区和通道往往可以达成和流类似的目的，不过，它们更接近操作系统的概念，某些操作的性能也更高。比如，复制文件到网络，通道可以利用操作系统和硬件提供的DMA机制（Direct Memory Access，直接内存存取），不用CPU和应用程序参与，直接将数据从硬盘复制到网卡。</p>
<p>除了看待方式不同，<strong>NIO还支持一些比较底层的功能，如内存映射文件、文件加锁、自定义文件系统、非阻塞式IO、异步IO等</strong>。</p>
<p>不过，这些功能要么是比较底层，普通应用程序用到得比较少，要么主要适用于网络IO操作，我们大多不会介绍，只会介绍内存映射文件。</p>
<h3 id="7．序列化和反序列化"><a href="#7．序列化和反序列化" class="headerlink" title="7．序列化和反序列化"></a>7．序列化和反序列化</h3><p>简单来说，序列化就是将内存中的Java对象持久保存到一个流中，反序列化就是从流中恢复Java对象到内存。序列化和反序列化主要有两个用处：一是对象状态持久化，二是网络远程调用，用于传递和返回对象。</p>
<p>Java主要通过接口Serializable和类ObjectInputStream/ObjectOutputStream提供对序列化的支持，基本的使用是比较简单的，但也有一些复杂的地方。不过，Java的默认序列化有一些缺点，比如，序列化后的形式比较大、浪费空间，序列化/反序列化的性能也比较低，更重要的问题是，它是Java特有的技术，不能与其他语言交互。</p>
<p>XML是前几年最为流行的描述结构性数据的语言和格式，Java对象也可以序列化为XML格式。XML容易阅读和编辑，且可以方便地与其他语言进行交互。XML强调格式化但比较“笨重”, JSON是近几年来逐渐流行的轻量级的数据交换格式，在很多场合替代了XML，也非常容易阅读和编辑。Java对象也可以序列化为JSON格式，且与其他语言进行交互。</p>
<p>XML和JSON都是文本格式，人容易阅读，但占用的空间相对大一些，在只用于网络远程调用的情况下，有很多流行的、跨语言的、精简且高效的对象序列化机制，如ProtoBuf、Thrift、MessagePack等。其中，MessagePack是二进制形式的JSON，更小更快。</p>
<p>文件看起来是一件非常简单的事情，但实际却没有那么简单，Java的设计也不是太完美，包含了大量的类，这使得对于文件的理解变得困难。为便于理解，我们将采用以下思路在接下来的章节中进行探讨。</p>
<p>首先，我们介绍如何处理二进制文件，或者将所有文件看作二进制，介绍如何操作，对于常见操作，我们会封装，提供一些简单易用的方法。下一步，我们介绍如何处理文本文件，我们会考虑编码、按行处理等，同样，对于常见操作，我们会封装，提供简单易用的方法。接下来，我们介绍文件本身和目录操作File类，我们也会封装常见操作。以上这些内容是文件处理的基本技术，我们会在本章进行讨论。</p>
<p>在日常编程中，我们经常会需要处理一些具体类型的文件，如属性文件、CSV文件、Excel文件、HTML文件和压缩文件，直接使用字节流/字符流来处理一般是很不方便的，往往有一些更为高层的API，关于这些，我们下章介绍。此外，下章还会介绍比较底层的对文件的操作RandomAccessFile类、内存映射文件，以及序列化。文件看上去应该很简单，但实际却包含很多内容，让我们耐住性子，下一节，先从二进制开始。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a57a1807/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a57a1807/" class="post-title-link" itemprop="url">12.3 容器类总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 16:28:00" itemprop="dateCreated datePublished" datetime="2021-12-05T16:28:00+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 15:18:36" itemprop="dateModified" datetime="2021-12-07T15:18:36+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">第12章 通用容器类和总结</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a57a1807/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a57a1807/" data-xid="/JavaReadingNotes/a57a1807/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="12-3-容器类总结"><a href="#12-3-容器类总结" class="headerlink" title="12.3 容器类总结"></a>12.3 容器类总结</h1><p>前面章节中，我们介绍了多种容器类，本节进行简要总结，我们主要从三个角度进行总结：</p>
<ul>
<li>用法和特点；</li>
<li>数据结构和算法；</li>
<li>设计思维和模式。</li>
</ul>
<h2 id="12-3-1-用法和特点"><a href="#12-3-1-用法和特点" class="headerlink" title="12.3.1 用法和特点"></a>12.3.1 用法和特点</h2><p>图12-1包含了容器类主要的接口和类，我们还是用该图进行总结。容器类有两个根接口，分别是Collection和Map, Collection表示单个元素的集合，Map表示键值对的集合。</p>
<p>Collection表示的数据集合有基本的增、删、查、遍历等方法，但没有定义元素间的顺序或位置，也没有规定是否有重复元素。</p>
<p>List是Collection的子接口，表示有顺序或位置的数据集合，增加了根据索引位置进行操作的方法。它有两个主要的实现类：ArrayList和LinkedList。ArrayList基于数组实现， LinkedList基于链表实现；ArrayList的随机访问效率很高，但从中间插入和删除元素需要移动元素，效率比较低，LinkedList则正好相反，随机访问效率比较低，但增删元素只需要调整邻近节点的链接。</p>
<p>Set也是Collection的子接口，它没有增加新的方法，但保证不含重复元素。它有两个主要的实现类：HashSet和TreeSet。HashSet基于哈希表实现，要求键重写hashCode方法，效率更高，但元素间没有顺序；TreeSet基于排序二叉树实现，元素按比较有序，元素需要实现Comparable接口，或者创建TreeSet时提供一个Comparator对象。HashSet还有一个子类LinkedHashSet可以按插入有序。还有一个针对枚举类型的实现类EnumSet，它基于位向量实现，效率很高。</p>
<p>Queue是Collection的子接口，表示先进先出的队列，在尾部添加，从头部查看或删除。Deque是Queue的子接口，表示更为通用的双端队列，有明确的在头或尾进行查看、添加和删除的方法。普通队列有两个主要的实现类：LinkedList和ArrayDeque。LinkedList基于链表实现，ArrayDeque基于循环数组实现。一般而言，如果只需要Deque接口，Array-Deque的效率更高一些。</p>
<p>Queue还有一个特殊的实现类PriorityQueue，表示优先级队列，内部是用堆实现的。堆除了用于实现优先级队列，还可以高效方便地解决很多其他问题，比如求前K个最大的元素、求中值等。</p>
<p>Map接口表示键值对集合，经常根据键进行操作，它有两个主要的实现类：HashMap和TreeMap。HashMap基于哈希表实现，要求键重写hashCode方法，操作效率很高，但元素没有顺序。TreeMap基于排序二叉树实现，要求键实现Comparable接口，或提供一个Comparator对象，操作效率稍低，但可以按键有序。</p>
<p>HashMap还有一个子类LinkedHashMap，它可以按插入或访问有序。之所以能有序，是因为每个元素还加入到了一个双向链表中。如果键本来就是有序的，使用LinkedHashMap而非TreeMap可以提高效率。按访问有序的特点可以方便地用于实现LRU缓存。</p>
<p>如果键为枚举类型，可以使用专门的实现类EnumMap，它使用效率更高的数组实现。</p>
<p>需要说明的是，除了Hashtable、Vector和Stack，我们介绍的各种容器类都不是线程安全的，也就是说，如果多个线程同时读写同一个容器对象，是不安全的。如果需要线程安全，可以使用Collections提供的synchronizedXXX方法对容器对象进行同步，或者使用线程安全的专门容器类。</p>
<p>此外，容器类提供的迭代器都有一个特点，都会在迭代中间进行结构性变化检测，如果容器发生了结构性变化，就会抛出ConcurrentModificationException，所以不能在迭代中间直接调用容器类提供的add/remove方法，如需添加和删除，应调用迭代器的相关方法。</p>
<p>在解决一个特定问题时，经常需要综合使用多种容器类。比如，要统计一本书中出现次数最多的前10个单词，可以先使用HashMap统计每个单词出现的次数，再使用TopK类用PriorityQueue求前10个单词，或者使用Collections提供的sort方法。</p>
<p>在之前各节介绍的例子中，为简单起见，容器中的元素类型往往是简单的，但需要说明的是，它们也可以是复杂的自定义类型，还可以是容器类型。比如在一个新闻应用中，表示当天的前十大新闻可以用一个List表示，形如<code>List&lt;News&gt;</code>，而为了表示每个分类的前十大新闻，可以用一个Map表示，键为分类Category，值为<code>List&lt;News&gt;</code>，形如<code>Map&lt;Category, List&lt;News&gt;&gt;</code>，而表示每天的每个分类的前十大新闻，可以在Map中使用Map，键为日期，值也是一个Map，形如<code>Map&lt;Date, Map&lt;Category, List&lt;News&gt;&gt;</code>。</p>
<h2 id="12-3-2-数据结构和算法"><a href="#12-3-2-数据结构和算法" class="headerlink" title="12.3.2 数据结构和算法"></a>12.3.2 数据结构和算法</h2><p>在容器类中，我们看到了如下数据结构的应用：</p>
<p>1）<strong>动态数组：</strong>ArrayList内部就是动态数组，HashMap内部的链表数组也是动态扩展的，ArrayDeque和PriorityQueue内部也都是动态扩展的数组。<br>2）<strong>链表</strong>：LinkedList是用双向链表实现的，HashMap中映射到同一个链表数组的键值对是通过单向链表链接起来的，LinkedHashMap中每个元素还加入到了一个双向链表中以维护插入或访问顺序。<br>3）<strong>哈希表</strong>：HashMap是用哈希表实现的，HashSet、LinkedHashSet和LinkedHashMap基于HashMap，内部当然也是哈希表。<br>4）<strong>排序二叉树</strong>：TreeMap是用红黑树（基于排序二叉树）实现的，TreeSet内部使用TreeMap，当然也是红黑树，红黑树能保持元素的顺序且综合性能很高。<br>5）<strong>堆</strong>：PriorityQueue是用堆实现的，堆逻辑上是树，物理上是动态数组，堆可以高效地解决一些其他数据结构难以解决的问题。<br>6）<strong>循环数组</strong>：ArrayDeque是用循环数组实现的，通过对头尾变量的维护，实现了高效的队列操作。<br>7）<strong>位向量</strong>：EnumSet和BitSet是用位向量实现的，对于只有两种状态，且需要进行集合运算的数据，使用位向量进行表示、位运算进行处理，精简且高效。</p>
<p>每种数据结构中往往包含一定的算法策略，这种策略往往是一种折中，比如：</p>
<p>1）动态扩展算法：动态数组的扩展策略，一般是指数级扩展的，是在两方面进行平衡，一方面是希望减少内存消耗，另一方面希望减少内存分配、移动和复制的开销。<br>2）哈希算法：哈希表中键映射到链表数组索引的算法，算法要快，同时要尽量随机和均匀。<br>3）排序二叉树的平衡算法：排序二叉树的平衡非常重要，红黑树是一种平衡算法， AVL树是另一种平衡算法。平衡算法一方面要保证尽量平衡，另一方面要尽量减少综合开销。</p>
<p>Collections实现了一些通用算法，比如二分查找、排序、翻转列表顺序、随机化重排等，在实现大部分算法时，Collections也都根据容器大小和是否实现了RandomAccess接口采用了不同的实现方式。</p>
<h2 id="12-3-3-设计思维和模式"><a href="#12-3-3-设计思维和模式" class="headerlink" title="12.3.3 设计思维和模式"></a>12.3.3 设计思维和模式</h2><p>在容器类中，我们也看到了Java的多种语言机制和设计思维的运用：<br>1）<strong>封装</strong>：封装就是提供简单接口，并隐藏实现细节，这是程序设计的最重要思维。在容器类中，很多类、方法和变量都是私有的，比如迭代器方法，基本都是通过私有内部类或匿名内部类实现的。<br>2）<strong>继承和多态</strong>：继承可以复用代码，便于按父类统一处理，但继承是一把双刃剑。在容器类中，Collection是父接口，List/Set/Queue继承自Collection，通过Collection接口可以统一处理多种类型的集合对象。容器类定义了很多抽象容器类，具体类通过继承它们以复用代码，每个抽象容器类都有详细的文档说明，描述其实现机制，以及子类应该如何重写方法。容器类的设计展示了接口继承、类继承，以及抽象类的恰当应用。<br>3）<strong>组合</strong>：一般而言，组合应该优先于继承，我们看到HashSet通过组合的方式使用HashMap, TreeSet通过组合使用TreeMap，适配器和装饰器模式也都是通过组合实现的。<br>4）<strong>接口</strong>：面向接口编程是一种重要的思维，可降低代码间的耦合，提高代码复用程度，在容器类方法中，接受的参数和返回值往往都是接口，Collections提供的通用算法，操作的也都是接口对象，我们平时在使用容器类时，一般也只在创建对象时使用具体类，而其他地方都使用接口。<br>5）<strong>设计模式</strong>：我们在容器类中看到了迭代器、工厂方法、适配器、装饰器等多种设计模式的应用。</p>
<p>本节从用法和特点、数据结构和算法以及设计思维和模式三个角度简要总结了之前介绍的各种容器类。至此，关于容器类就介绍完了。到目前为止，我们还没有接触过文件处理，而我们在日常的计算机操作中，接触最多的就是各种文件了，让我们从下一章开始，一起探讨文件操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/903fcc76/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/903fcc76/" class="post-title-link" itemprop="url">12.2 Collections</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 16:22:52" itemprop="dateCreated datePublished" datetime="2021-12-05T16:22:52+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 15:18:36" itemprop="dateModified" datetime="2021-12-07T15:18:36+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">第12章 通用容器类和总结</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/903fcc76/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/903fcc76/" data-xid="/JavaReadingNotes/903fcc76/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="12-2-Collections"><a href="#12-2-Collections" class="headerlink" title="12.2 Collections"></a>12.2 Collections</h1><p>类Collections以静态方法的方式提供了很多通用算法和功能，这些功能大概可以分为两类。<br>1）对容器接口对象进行操作。<br>2）返回一个容器接口对象。</p>
<p>对于第1类，操作大概可以分为三组。</p>
<ul>
<li>查找和替换。</li>
<li>排序和调整顺序。</li>
<li>添加和修改。</li>
</ul>
<p>对于第2类，大概可以分为两组。</p>
<ul>
<li>适配器：将其他类型的数据转换为容器接口对象。</li>
<li>装饰器：修饰一个给定容器接口对象，增加某种性质。</li>
</ul>
<p>它们都是围绕容器接口对象的，第1类是针对容器接口的通用操作，这是面向接口编程的一种体现，是接口的典型用法；第2类是为了使更多类型的数据更为方便和安全地参与到容器类协作体系中。下面我们分别介绍这两类操作及其实现原理，代码分析基于Java 7。</p>
<h2 id="12-2-1-查找和替换"><a href="#12-2-1-查找和替换" class="headerlink" title="12.2.1 查找和替换"></a>12.2.1 查找和替换</h2><p>查找和替换包含多组方法。查找包括二分查找、查找最大值/最小值、查找元素出现次数、查找子List、查看两个集合是否有交集等，下面具体介绍。</p>
<h3 id="1．二分查找"><a href="#1．二分查找" class="headerlink" title="1．二分查找"></a>1．二分查找</h3><p>我们在介绍Arrays类的时候介绍过二分查找，Arrays类有针对数组对象的二分查找方法，Collections提供了针对List接口的二分查找，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends T&gt; list,</span></span></span><br><span class="line"><span class="params"><span class="function">    T key, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>从方法参数角度而言，一个要求List的每个元素实现Comparable接口，另一个不需要，但要求提供Comparator。二分查找假定List中的元素是从小到大排序的。如果是从大到小排序的，需要传递一个逆序Comparator对象，Collections提供了返回逆序Comparator的方法，之前我们也用过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">(Comparator&lt;T&gt; cmp)</span></span></span><br></pre></td></tr></table></figure>

<p>比如，可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        <span class="number">35</span>, <span class="number">24</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span></span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(Collections.binarySearch(list, <span class="number">7</span>,</span><br><span class="line">    Collections.reverseOrder()));</span><br></pre></td></tr></table></figure>

<p>输出为：5。List的二分查找的基本思路与Arrays中的是一样的，数组可以根据索引直接定位任意元素，实现效率很高，但List就不一定了，具体分为两种情况，如果List可以随机访问（如数组），即实现了RandomAccess接口，或者元素个数比较少，则实现思路与Arrays一样，根据索引直接访问中间元素进行比较，否则使用迭代器的方式移动到中间元素进行比较。从效率角度，如果List支持随机访问，效率为O(log2(N))，如果通过迭代器，那么比较的次数为O(log2(N))，但遍历移动的次数为O(N), N为列表长度。</p>
<h3 id="2．查找最大值-最小值"><a href="#2．查找最大值-最小值" class="headerlink" title="2．查找最大值/最小值"></a>2．查找最大值/最小值</h3><p>Collections提供了如下查找最大值/最小值的方法（省略了修饰符publicstatic）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Object &amp; Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;? extends T&gt; coll)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">max</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span></span><br><span class="line"><span class="function">&lt;T extends Object &amp; Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; T <span class="title">min</span><span class="params">(Collection&lt;? extends T&gt; coll)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">min</span><span class="params">(Collection&lt;? extends T&gt; coll, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span></span><br></pre></td></tr></table></figure>

<p>含义和用法都很直接，实现思路也很简单，就是通过迭代器进行比较，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Object &amp; Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      Collection&lt;? extends T&gt; coll)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class="line">    T candidate = i.next();</span><br><span class="line">    <span class="keyword">while</span>(i.hasNext()) &#123;</span><br><span class="line">        T next = i.next();</span><br><span class="line">        <span class="keyword">if</span>(next.compareTo(candidate) &gt; <span class="number">0</span>)</span><br><span class="line">            candidate = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3．其他方法"><a href="#3．其他方法" class="headerlink" title="3．其他方法"></a>3．其他方法</h3><p>查找元素出现次数，方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection&lt;? &gt; c, Object o)</span></span></span><br></pre></td></tr></table></figure>

<p>返回元素o在容器c中出现的次数，o可以为null。含义很简单，实现思路也很简单，就是通过迭代器进行比较计数。</p>
<p>Collections提供了如下方法，在source List中查找target List的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List&lt;? &gt; source, List&lt;? &gt; target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List&lt;? &gt; source, List&lt;? &gt; target)</span></span></span><br></pre></td></tr></table></figure>

<p>indexOfSubList从开头找，lastIndexOfSubList从结尾找，没找到返回-1，找到返回第一个匹配元素的索引位置。这两个方法的实现都是属于“暴力破解”型的，将target列表与source从第一个元素开始的列表逐个元素进行比较，如果不匹配，则与source从第二个元素开始的列表比较，再不匹配，与source从第三个元素开始的列表比较，以此类推。</p>
<p>查看两个集合是否有交集，方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection&lt;? &gt; c1, Collection&lt;? &gt; c2)</span></span></span><br></pre></td></tr></table></figure>

<p>如果c1和c2有交集，返回值为false；没有交集，返回值为true。实现原理也很简单，遍历其中一个容器，对每个元素，在另一个容器里通过contains方法检查是否包含该元素，如果包含，返回false，如果最后不包含任何元素返回true。这个方法的代码会根据容器是否为Set以及集合大小进行性能优化，即选择哪个容器进行遍历，哪个容器进行检查，以减少总的比较次数，具体我们就不介绍了。</p>
<p>替换方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List&lt;T&gt; list, T oldVal, T newVal)</span></span></span><br></pre></td></tr></table></figure>

<p>将List中的所有oldVal替换为newVal，如果发生了替换，返回值为true，否则为false。用法和实现都比较简单，就不赘述了。</p>
<h2 id="12-2-2-排序和调整顺序"><a href="#12-2-2-排序和调整顺序" class="headerlink" title="12.2.2 排序和调整顺序"></a>12.2.2 排序和调整顺序</h2><p>针对List接口对象，Collections除了提供基础的排序，还提供了若干调整顺序的方法，包括交换元素位置、翻转列表顺序、随机化重排、循环移位等，下面具体介绍。</p>
<h3 id="1．排序、交换位置与翻转"><a href="#1．排序、交换位置与翻转" class="headerlink" title="1．排序、交换位置与翻转"></a>1．排序、交换位置与翻转</h3><p>Arrays类有针对数组对象的排序方法，Collections提供了针对List接口的排序方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>使用很简单，就不举例了，内部它是通过Arrays.sort实现的，先将List元素复制到一个数组中，然后使用Arrays.sort，排序后，再复制回List。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    Object[] a = list.toArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    ListIterator&lt;T&gt; i = list.listIterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;a.length; j++) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((T)a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>交换元素位置的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;? &gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br></pre></td></tr></table></figure>

<p>交换list中第i个和第j个元素的内容。实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;? &gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻转列表顺序的方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;? &gt; list)</span></span></span><br></pre></td></tr></table></figure>

<p>将list中的元素顺序翻转过来。实现思路就是将第一个和最后一个交换，第二个和倒数第二个交换，以此类推，直到中间两个元素交换完毕。如果list实现了RandomAccess接口或列表比较小，根据索引位置，使用上面的swap方法进行交换，否则，由于直接根据索引位置定位元素效率比较低，使用一前一后两个listIterator定位待交换的元素，具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;? &gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span>(size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">            swap(list, i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator fwd = list.listIterator();</span><br><span class="line">        ListIterator rev = list.listIterator(size);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">            Object tmp = fwd.next();</span><br><span class="line">            fwd.set(rev.previous());</span><br><span class="line">            rev.set(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2．随机化重排"><a href="#2．随机化重排" class="headerlink" title="2．随机化重排"></a>2．随机化重排</h3><p>我们在随机一节介绍过洗牌算法，Collections直接提供了对List元素洗牌的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;? &gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;? &gt; list, Random rnd)</span></span></span><br></pre></td></tr></table></figure>

<p>实现思路与随机一节介绍的是一样的：从后往前遍历列表，逐个给每个位置重新赋值，值从前面的未重新赋值的元素中随机挑选。如果列表实现了RandomAccess接口，或者列表比较小，直接使用前面swap方法进行交换，否则，先将列表内容复制到一个数组中，洗牌，再复制回列表。代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;? &gt; list, Random rnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span>(size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line">        <span class="comment">//对数组进行洗牌</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">        <span class="comment">//将数组中洗牌后的结果保存回list</span></span><br><span class="line">        ListIterator it = list.listIterator();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3．循环移位"><a href="#3．循环移位" class="headerlink" title="3．循环移位"></a>3．循环移位</h3><p>我们解释下循环移位的概念，比如列表为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[8, 5, 3, 6, 2]</span><br></pre></td></tr></table></figure>

<p>循环右移2位，会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 2, 8, 5, 3]</span><br></pre></td></tr></table></figure>

<p>如果是循环左移2位，会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 6, 2, 8, 5]</span><br></pre></td></tr></table></figure>

<p>因为列表长度为5，循环左移3位和循环右移2位的效果是一样的。</p>
<p>循环移位的方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;? &gt; list, <span class="keyword">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>

<p>distance表示循环移位个数，一般正数表示向右移，负数表示向左移，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">Collections.rotate(list1, <span class="number">2</span>);</span><br><span class="line">System.out.println(list1);</span><br><span class="line">List&lt;Integer&gt; list2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span></span><br><span class="line">&#125;);</span><br><span class="line">Collections.rotate(list2, -<span class="number">2</span>);</span><br><span class="line">System.out.println(list2);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[6, 2, 8, 5, 3]</span><br><span class="line">[3, 6, 2, 8, 5]</span><br></pre></td></tr></table></figure>

<p>这个方法很有用的一点是：它也可以用于子列表，可以调整子列表内的顺序而不改变其他元素的位置。比如，将第j个元素向前移动到k（k&gt;j），可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.rotate(list.subList(j, k+<span class="number">1</span>), -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>再举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">19</span>, <span class="number">21</span></span><br><span class="line">&#125;);</span><br><span class="line">Collections.rotate(list.subList(<span class="number">1</span>, <span class="number">5</span>), <span class="number">2</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[8, 6, 2, 5, 3, 19, 21]</span><br></pre></td></tr></table></figure>

<p>这个类似于列表内的“剪切”和“粘贴”，将子列表[5, 3]“剪切”, “粘贴”到2后面。如果需要实现类似“剪切”和“粘贴”的功能，可以使用rotate()方法。</p>
<p>循环移位的内部实现比较巧妙，根据列表大小和是否实现了RandomAccess接口，有两个算法，都比较巧妙，两个算法在《编程珠玑》这本书的2.3节有描述。</p>
<p>限于篇幅，我们只解释下其中的第二个算法，<strong>它将循环移位看作列表的两个子列表进行顺序交换</strong>。再来看上面的例子，循环左移2位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[8, 5, 3, 6, 2] -&gt; [3, 6, 2, 8, 5]</span><br></pre></td></tr></table></figure>

<p>就是将[8, 5]和[3, 6, 2]两个子列表的顺序进行交换。循环右移两位：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[8, 5, 3, 6, 2] -&gt; [6, 2, 8, 5, 3]</span><br></pre></td></tr></table></figure>

<p>就是将[8, 5, 3]和[6, 2]两个子列表的顺序进行交换。</p>
<p>根据列表长度size和移位个数distance，可以计算出两个子列表的分隔点，有了两个子列表后，两个子列表的顺序交换可以通过三次翻转实现。比如，有A和B两个子列表，A有m个元素，B有n个元素：a1a2…amb1b2…bn，要变为b1b2…bna1a2…am，可经过三次翻转实现：</p>
<p>（1）翻转子列表A<br>$$<br>a_1a_2 … a_mb_1b_2 … b_n → a_m … a_2 a_1b_1b_2 … b_n<br>$$<br>（2）翻转子列表B<br>$$<br>a_m … a_2 a_1 b_1 b_2 … b_n → a_m … a_2 a_1 b_n … b_2 b_1<br>$$<br>（3）翻转整个列表<br>$$<br>a_m … a_2 a_1 b_n … b_2 b_1 → b_1 b_2 … b_n a_1 a_2 … a_m<br>$$</p>
<p>这个算法的整体实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate2</span><span class="params">(List&lt;? &gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =   -distance % size;</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; <span class="number">0</span>)</span><br><span class="line">        mid += size;</span><br><span class="line">    <span class="keyword">if</span>(mid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">    reverse(list.subList(mid, size));</span><br><span class="line">    reverse(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mid为两个子列表的分割点，调用了三次reverse方法以实现子列表顺序交换。</p>
<h2 id="12-2-3-添加和修改"><a href="#12-2-3-添加和修改" class="headerlink" title="12.2.3 添加和修改"></a>12.2.3 添加和修改</h2><p>Collections也提供了几个批量添加和修改的方法，逻辑都比较简单，我们看下。批量添加，方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; c, T... elements)</span></span></span><br></pre></td></tr></table></figure>

<p>elements为可变参数，将所有元素添加到容器c中。这个方法很方便，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;深入&quot;</span>, <span class="string">&quot;浅出&quot;</span>&#125;;</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;老马&quot;</span>, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">Collections.addAll(list, arr);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[hello, world, 老马， 编程， 深入， 浅出]</span><br></pre></td></tr></table></figure>

<p>批量填充固定值，方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list, T obj)</span></span></span><br></pre></td></tr></table></figure>

<p>这个方法与Arrays类中的fill方法是类似的，给每个元素设置相同的值。</p>
<p>批量复制，方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><br></pre></td></tr></table></figure>

<p>将列表src中的每个元素复制到列表dest的对应位置处，覆盖dest中原来的值，dest的列表长度不能小于src, dest中超过src长度部分的元素不受影响。</p>
<h2 id="12-2-4-适配器"><a href="#12-2-4-适配器" class="headerlink" title="12.2.4 适配器"></a>12.2.4 适配器</h2><p>所谓适配器，就是将一种类型的接口转换成另一种接口，类似于电子设备中的各种USB转接头，一端连接某种特殊类型的接口，一段连接标准的USB接口。Collections类提供了几组类似于适配器的方法：</p>
<ul>
<li>空容器方法：类似于将null或“空”转换为一个标准的容器接口对象。</li>
<li>单一对象方法：将一个单独的对象转换为一个标准的容器接口对象。</li>
<li>其他适配方法：将Map转换为Set等。</li>
</ul>
<p>它们接受其他类型的数据，转换为一个容器接口，目的是使其他类型的数据更为方便地参与到容器类协作体系中，下面，我们分别来看下。</p>
<h3 id="1．空容器方法"><a href="#1．空容器方法" class="headerlink" title="1．空容器方法"></a>1．空容器方法</h3><p>Collections中有一组方法，返回一个不包含任何元素的容器接口对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; Set&lt;T&gt; <span class="title">emptySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title">emptyMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Iterator&lt;T&gt; <span class="title">emptyIterator</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>分别返回一个空的List、Set、Map和Iterator对象。比如，可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.emptyList();</span><br><span class="line">Map&lt;String, Integer&gt; map = Collections.emptyMap();</span><br><span class="line">Set&lt;Integer&gt; set = Collections.emptySet();</span><br></pre></td></tr></table></figure>

<p>一个空容器对象有什么用呢？空容器对象经常用作方法返回值。比如，有一个方法，可以将可变长度的整数转换为一个List，方法声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">asList</span><span class="params">(<span class="keyword">int</span>... elements)</span></span></span><br></pre></td></tr></table></figure>

<p>在参数为空时，这个方法应该返回null还是一个空的List呢？如果返回null，方法调用者必须进行检查，然后分别处理，代码结构大概如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = …; <span class="comment">//从别的地方获取到的arr</span></span><br><span class="line">List&lt;Integer&gt; list = asList(arr);</span><br><span class="line"><span class="keyword">if</span>(list==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码比较烦琐，而且如果不小心忘记检查，则有可能会抛出空指针异常，所以推荐做法是返回一个空的List，以便调用者安全地进行统一处理，比如，asList可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">asList</span><span class="params">(<span class="keyword">int</span>... elements)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elements.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(elements.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> e : elements)&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回一个空的List。也可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<p>这与emptyList方法有什么区别呢？emptyList方法返回的是一个静态不可变对象，它可以节省创建新对象的内存和时间开销。我们来看下emptyList方法的具体定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">emptyList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (List&lt;T&gt;) EMPTY_LIST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EMPTY_LIST的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List EMPTY_LIST = <span class="keyword">new</span> EmptyList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>是一个静态不可变对象，类型为EmptyList，它是一个私有静态内部类，继承自Abstract-List，主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emptyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> emptyListIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object obj)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;? &gt; c)</span> </span>&#123; <span class="keyword">return</span> c.isEmpty(); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123; <span class="keyword">return</span> <span class="keyword">new</span> Object[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length &gt; <span class="number">0</span>)</span><br><span class="line">            a[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (o <span class="keyword">instanceof</span> List) &amp;&amp; ((List&lt;? &gt;)o).isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>emptyIterator和emptyListIterator返回空的迭代器。emptyIterator的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Iterator&lt;T&gt; <span class="title">emptyIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Iterator&lt;T&gt;) EmptyIterator.EMPTY_ITERATOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmptyIterator是一个静态内部类，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> EmptyIterator&lt;Object&gt; EMPTY_ITERATOR</span><br><span class="line">        = <span class="keyword">new</span> EmptyIterator&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上这些代码都比较简单，就不赘述了。需要注意的是，EmptyList不支持修改操作，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.emptyList().add(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>会抛出异常UnsupportedOperationException。</p>
<p>如果返回值只是用于读取，可以使用emptyList方法，但如果返回值还用于写入，则需要新建一个对象。其他空容器方法与emptyList方法类似，我们就不赘述了。它们都可以被用于方法返回值，以便调用者统一进行处理，同时节省时间和内存开销，它们的共同限制是返回值不能用于写入。我们将空容器方法看作适配器，是因为它将null或“空”转换为了容器对象。</p>
<p>需要说明的是，在Java 9中，可以使用List、Map和Set不带参数的of方法返回一个空的只读容器对象，也就是说，如下两行代码的效果是相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. List list = Collections.emptyList();</span><br><span class="line">2. List list = List.of();</span><br></pre></td></tr></table></figure>

<h3 id="2．单一对象方法"><a href="#2．单一对象方法" class="headerlink" title="2．单一对象方法"></a>2．单一对象方法</h3><p>Collections中还有一组方法，可以将一个单独的对象转换为一个标准的容器接口对象，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">singleton</span><span class="params">(T o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">singletonList</span><span class="params">(T o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title">singletonMap</span><span class="params">(K key, V value)</span></span></span><br></pre></td></tr></table></figure>

<p>比如，可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = Collections.singleton(<span class="string">&quot;编程&quot;</span>);</span><br><span class="line">Set&lt;String&gt; set = Collections.singleton(<span class="string">&quot;编程&quot;</span>);</span><br><span class="line">List&lt;String&gt; list = Collections.singletonList(<span class="string">&quot;老马&quot;</span>);</span><br><span class="line">Map&lt;String, String&gt; map = Collections.singletonMap(<span class="string">&quot;老马&quot;</span>, <span class="string">&quot;编程&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这些方法也经常用于构建方法返回值，相比新建容器对象并添加元素，这些方法更为简洁方便，此外，它们的实现更为高效，它们的实现类都针对单一对象进行了优化。比如， singleton方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Set&lt;T&gt; <span class="title">singleton</span><span class="params">(T o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SingletonSet&lt;&gt;(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了一个SingletonSet对象，SingletonSet是一个静态内部类，主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E element;</span><br><span class="line">    SingletonSet(E e) &#123;element = e; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonIterator(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;<span class="keyword">return</span> eq(o, element); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>singletonIterator是一个内部方法，将单一对象转换为了一个迭代器接口对象，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;E&gt; <span class="function">Iterator&lt;E&gt; <span class="title">singletonIterator</span><span class="params">(<span class="keyword">final</span> E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;E&gt;() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> hasNext = <span class="keyword">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext) &#123;</span><br><span class="line">                hasNext = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>eq方法就是比较两个对象是否相同，考虑了null的情况，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">eq</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1==<span class="keyword">null</span> ? o2==<span class="keyword">null</span> : o1.equals(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，singleton方法返回的也是不可变对象，只能用于读取，写入会抛出UnsupportedOperationException异常。其他singletonXXX方法的实现思路是类似的，返回值也都只能用于读取，不能写入，我们就不赘述了。</p>
<p>除了用于构建返回值，这些方法还可用于构建方法参数。比如，从容器中删除对象， Collection有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;? &gt; c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>remove方法只会删除第一条匹配的记录，removeAll方法可以删除所有匹配的记录，但需要一个容器接口对象，如果需要从一个List中删除所有匹配的某一对象呢？这时，就可以使用Collections.singleton封装这个要删除的对象。比如，从list中删除所有的”b”，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.removeAll(Collections.singleton(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>需要说明的是，在Java 9中，可以使用List、Map和Set的of方法达到singleton同样的功能，也就是说，如下两行代码的效果是相同的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. Set&lt;String&gt; b = Collections.singleton(&quot;b&quot;);</span><br><span class="line">2. Set&lt;String&gt; b = Set.of(&quot;b&quot;);</span><br></pre></td></tr></table></figure>

<p>除了以上两组方法，Collections中还有如下适配器方法，用的相对较少，我们就不详细介绍了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Map接口转换为Set接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将Deque接口转换为后进先出的队列接口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Queue&lt;T&gt; <span class="title">asLifoQueue</span><span class="params">(Deque&lt;T&gt; deque)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回包含n个相同对象o的List接口</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">nCopies</span><span class="params">(<span class="keyword">int</span> n, T o)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="12-2-5-装饰器"><a href="#12-2-5-装饰器" class="headerlink" title="12.2.5 装饰器"></a>12.2.5 装饰器</h2><p>装饰器接受一个接口对象，并返回一个同样接口的对象，不过，新对象可能会扩展一些新的方法或属性，扩展的方法或属性就是所谓的“装饰”，也可能会对原有的接口方法做一些修改，达到一定的“装饰”目的。Collections有三组装饰器方法，它们的返回对象都没有新的方法或属性，但改变了原有接口方法的性质，经过“装饰”后，它们更为安全了，具体分别是写安全、类型安全和线程安全，我们分别来看下。</p>
<h3 id="1．写安全"><a href="#1．写安全" class="headerlink" title="1．写安全"></a>1．写安全</h3><p>写安全的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">unmodifiableCollection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Collection&lt;? extends T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">unmodifiableList</span><span class="params">(List&lt;? extends T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title">unmodifiableMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">unmodifiableSet</span><span class="params">(Set&lt;? extends T&gt; s)</span></span></span><br></pre></td></tr></table></figure>

<p>顾名思义，这组unmodifiableXXX方法就是使容器对象变为只读的，写入会抛出UnsupportedOperationException异常。为什么要变为只读的呢？典型场景是：需要传递一个容器对象给一个方法，这个方法可能是第三方提供的，为避免第三方误写，所以在传递前，变为只读的，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thirdMethod</span><span class="params">(Collection&lt;String&gt; c)</span></span>&#123;</span><br><span class="line">    c.add(<span class="string">&quot;bad&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mainMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;));</span><br><span class="line">    thirdMethod(Collections.unmodifiableCollection(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，调用就会触发异常，从而避免了将错误数据插入。</p>
<p>这些方法是如何实现的呢？每个方法内部都对应一个类，这个类实现了对应的容器接口，它内部是待装饰的对象，只读方法传递给这个内部对象，写方法抛出异常。比如， unmodifiableCollection方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">unmodifiableCollection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableCollection&lt;&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnmodifiableCollection是一个静态内部类，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;,</span></span><br><span class="line"><span class="class">    <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1820017752578914078L</span>;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;? extends E&gt; c;</span><br><span class="line">      UnmodifiableCollection(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.isEmpty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;<span class="keyword">return</span> c.contains(o); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;<span class="keyword">return</span> c.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<span class="keyword">return</span> c.toArray(a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.toString(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;E&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;? extends E&gt; i = c.iterator();</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i.hasNext(); &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> i.next(); &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;? &gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.containsAll(coll);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;? &gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;? &gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，其他unmodifiableXXX方法的实现也都类似，我们就不赘述了。</p>
<h3 id="2．类型安全"><a href="#2．类型安全" class="headerlink" title="2．类型安全"></a>2．类型安全</h3><p>所谓类型安全是指确保容器中不会保存错误类型的对象。容器怎么会允许保存错误类型的对象呢？我们看段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>我们创建了一个Integer类型的List对象，但添加了字符串类型的对象”hello”，编译没有错误，运行也没有异常，程序输出为”[hello]”。</p>
<p>之所以会出现这种情况，是因为Java是通过擦除来实现泛型的，而且类型参数是可选的。正常情况下，我们会加上类型参数，让泛型机制来保证类型的正确性。但是，由于泛型是Java 5以后才加入的，之前的代码可能没有类型参数，而新的代码可能需要与老的代码互动。</p>
<p>为了避免老的代码用错类型，确保在泛型机制失灵的情况下类型的正确性，可以在传递容器对象给老代码之前，使用类似如下方法“装饰”容器对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">checkedList</span><span class="params">(List&lt;E&gt; list, Class&lt;E&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title">checkedMap</span><span class="params">(Map&lt;K, V&gt; m,</span></span></span><br><span class="line"><span class="params"><span class="function">    Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Set&lt;E&gt; <span class="title">checkedSet</span><span class="params">(Set&lt;E&gt; s, Class&lt;E&gt; type)</span></span></span><br></pre></td></tr></table></figure>

<p>使用这组checkedXXX方法，都需要传递类型对象，这些方法都会使容器对象的方法在运行时检查类型的正确性，如果不匹配，会抛出ClassCastException异常。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list = Collections.checkedList(list, Integer.class);</span><br><span class="line">list.add(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这次，运行就会抛出异常，从而避免错误类型的数据插入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException:  Attempt  to  insert  class  java.lang.String  element</span><br><span class="line">    into collection with element type class java.lang.Integer</span><br></pre></td></tr></table></figure>

<p>这些checkedXXX方法的实现机制是类似的，每个方法内部都对应一个类，这个类实现了对应的容器接口，它内部是待装饰的对象，大部分方法只是传递给这个内部对象，但对添加和修改方法，会首先进行类型检查，类型不匹配会抛出异常，类型匹配才传递给内部对象。以checkedCollection为例，我们来看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Collection&lt;E&gt; <span class="title">checkedCollection</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Collection&lt;E&gt; c, Class&lt;E&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CheckedCollection&lt;&gt;(c, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckedCollection是一个静态内部类，主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1578914078182001775L</span>;</span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;E&gt; type;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">typeCheck</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o ! = <span class="keyword">null</span> &amp;&amp; ! type.isInstance(o))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(badElementMsg(o));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">badElementMsg</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Attempt to insert &quot;</span> + o.getClass() +</span><br><span class="line">                <span class="string">&quot; element into collection with element type &quot;</span> + type;</span><br><span class="line">        &#125;</span><br><span class="line">        CheckedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="keyword">null</span> || type == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">this</span>.c = c;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                     </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> c.isEmpty(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> c.contains(o); &#125;</span><br><span class="line">        <span class="keyword">public</span> Object[] toArray()           &#123; <span class="keyword">return</span> c.toArray(); &#125;</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)      &#123; <span class="keyword">return</span> c.toArray(a); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> c.toString(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>    </span>&#123; <span class="keyword">return</span> c.remove(o); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>                   </span>&#123;          c.clear(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;? &gt; coll)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c.containsAll(coll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;? &gt; coll)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c.removeAll(coll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;? &gt; coll)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> c.retainAll(coll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Iterator&lt;E&gt; it = c.iterator();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;E&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> it.hasNext(); &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> it.next(); &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span>      </span>&#123;          it.remove(); &#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">            typeCheck(e);</span><br><span class="line">            <span class="keyword">return</span> c.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，add方法中，会先调用typeCheck进行类型检查。其他checkedXXX方法的实现也都类似，我们就不赘述了。</p>
<h3 id="3．线程安全"><a href="#3．线程安全" class="headerlink" title="3．线程安全"></a>3．线程安全</h3><p>关于线程，我们后续章节会详细介绍，这里简要说明下。之前我们介绍的各种容器类基本都不是线程安全的，也就是说，如果多个线程同时读写同一个容器对象，是不安全的。</p>
<p>Collections提供了一组方法，可以将一个容器对象变为线程安全的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; Map&lt;K, V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K, V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure>

<p>需要说明的是，这些方法都是通过给所有容器方法加锁来实现的，这种实现并不是最优的。Java提供了很多专门针对并发访问的容器类，我们在第17章介绍。</p>
<h2 id="12-2-6-小结"><a href="#12-2-6-小结" class="headerlink" title="12.2.6 小结"></a>12.2.6 小结</h2><p>本节介绍了类Collections中的两类操作。第一类操作是一些通用算法，包括查找、替换、排序、调整顺序、添加、修改等，这些算法操作的都是容器接口对象，这是面向接口编程的一种体现，只要对象实现了这些接口，就可以使用这些算法。第二类操作都返回一个容器接口对象，这些方法代表两种设计模式，一种是适配器，另一种是装饰器，我们介绍了这两种设计模式，以及这些方法的用法、适用场合和实现机制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/4a778d53/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/4a778d53/" class="post-title-link" itemprop="url">12.0 第12章 通用容器类和总结 12.1 抽象容器类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 15:58:27" itemprop="dateCreated datePublished" datetime="2021-12-05T15:58:27+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC12%E7%AB%A0-%E9%80%9A%E7%94%A8%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%92%8C%E6%80%BB%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">第12章 通用容器类和总结</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/4a778d53/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/4a778d53/" data-xid="/JavaReadingNotes/4a778d53/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第12章-通用容器类和总结"><a href="#第12章-通用容器类和总结" class="headerlink" title="第12章 通用容器类和总结"></a>第12章 通用容器类和总结</h1><p>之前的章节中，我们介绍的都是具体的容器类，本章介绍一些抽象容器类、一些通用的算法和功能，并对整个容器类体系进行梳理总结。</p>
<p>之前介绍的具体容器类其实都不是从头构建的，它们都继承了一些抽象容器类。这些抽象类提供了容器接口的部分实现，方便了Java具体容器类的实现。此外，通过继承抽象类，自定义的类也可以更为容易地实现容器接口。为什么需要实现容器接口呢？至少有两个原因。<br>1）容器类是一个大家庭，它们之间可以方便地协作，比如很多方法的参数和返回值都是容器接口对象，实现了容器接口，就可以方便地参与这种协作。<br>2）Java有一个类Collections，提供了很多针对容器接口的通用算法和功能，实现了容器接口，可以直接利用Collections中的算法和功能。</p>
<p>本章首先介绍抽象容器类，然后介绍Collections中的通用功能，最后对整个容器类体系进行梳理总结。</p>
<h1 id="12-1-抽象容器类"><a href="#12-1-抽象容器类" class="headerlink" title="12.1 抽象容器类"></a>12.1 抽象容器类</h1><p>抽象容器类与之前介绍的接口和具体容器类的关系如图12-1所示。</p>
<p>虚线框表示接口，有Collection、List、Set、Queue、Deque和Map。有6个抽象容器类。<br>1）AbstractCollection：实现了Collection接口，被抽象类AbstractList、AbstractSet、AbstractQueue继承，ArrayDeque也继承自AbstractCollection（图中未画出）。<br>2）AbstractList：父类是AbstractCollection，实现了List接口，被ArrayList、Abstract-SequentialList继承。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209144600.jpeg" alt="epub_923038_110"></p>
<center>图12-1 容器类体系与抽象容器类</center>

<p>3）AbstractSequentialList：父类是AbstractList，被LinkedList继承。<br>4）AbstractMap：实现了Map接口，被TreeMap、HashMap、EnumMap继承。<br>5）AbstractSet：父类是AbstractCollection，实现了Set接口，被HashSet、TreeSet和EnumSet继承。<br>6）AbstractQueue：父类是AbstractCollection，实现了Queue接口，被PriorityQueue继承。</p>
<p>下面，我们分别来介绍这些抽象类，包括它们提供的基础功能、如何实现、如何进行扩展等，代码分析基于Java 7。</p>
<h2 id="12-1-1-AbstractCollection"><a href="#12-1-1-AbstractCollection" class="headerlink" title="12.1.1 AbstractCollection"></a>12.1.1 AbstractCollection</h2><p>AbstractCollection提供了Collection接口的基础实现，具体来说，它实现了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;? &gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;? &gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;? &gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T&gt; T[] <span class="title">toArray</span><span class="params">(T[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>AbstractCollection又不知道数据是怎么存储的，它是如何实现这些方法的呢？它依赖于如下更为基础的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>add方法的默认实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出“操作不支持”异常，如果子类集合是不可被修改的，这个默认实现就可以了，否则，必须重写add方法。addAll方法的实现就是循环调用add方法。</p>
<p>size方法是抽象方法，子类必须重写。isEmpty方法就是检查size方法的返回值是否为0。toArray方法依赖size方法的返回值分配数组大小。</p>
<p>iterator方法也是抽象方法，它返回一个实现了迭代器接口的对象，子类必须重写。我们知道，迭代器定义了三个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果子类集合是不可被修改的，迭代器不用实现remove方法，否则，三个方法都必须实现。</p>
<p>AbstractCollection中的大部分方法都是基于迭代器的方法实现的，比如contains方法，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;E&gt; it = iterator();</span><br><span class="line">    <span class="keyword">if</span>(o==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">            <span class="keyword">if</span>(it.next()==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">            <span class="keyword">if</span>(o.equals(it.next()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过迭代器方法循环进行比较。</p>
<p>除了接口中的方法，Collection接口文档建议，每个Collection接口的实现类都应该提供至少两个标准的构造方法，一个是默认构造方法，另一个接受一个Collection类型的参数。</p>
<p>具体如何通过继承AbstractCollection来实现自定义容器呢？我们通过一个简单的例子来说明。我们使用在8.1节自己实现的动态数组容器类DynamicArray来实现一个简单的Collection。</p>
<p>DynamicArray当时没有实现根据索引添加和删除的方法，我们先来补充一下，如代码清单12-1所示。</p>
<center>代码清单12-1 添加方法后的DynamicArray</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        E oldValue = get(index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index,</span><br><span class="line">                    numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                          size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于DynamicArray，我们实现一个简单的迭代器类DynamicArrayIterator，如代码清单12-2所示。</p>
<center>代码清单12-2 一个简单的迭代器类DynamicArrayIterator</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArrayIterator</span>&lt;<span class="title">E</span>&gt;   <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    DynamicArray&lt;E&gt; darr;</span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicArrayIterator</span><span class="params">(DynamicArray&lt;E&gt; darr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.darr = darr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cursor ! = darr.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= darr.size())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        lastRet = i;</span><br><span class="line">        <span class="keyword">return</span> darr.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        darr.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就不解释了，为简单起见，我们没有实现实际容器类中的有关检测结构性变化的逻辑。</p>
<p>基于DynamicArray和DynamicArrayIterator，通过继承AbstractCollection，我们来实现一个简单的容器类MyCollection，如代码清单12-3所示。</p>
<center>代码清单12-3 一个简单的容器类MyCollection</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    DynamicArray&lt;E&gt; darr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCollection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        darr = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicArrayIterator&lt;&gt;(darr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> darr.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        darr.add(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是按建议提供了两个构造方法，并重写了size、add和iterator方法，这些方法内部使用了DynamicArray和DynamicArrayIterator。</p>
<h2 id="12-1-2-AbstractList"><a href="#12-1-2-AbstractList" class="headerlink" title="12.1.2 AbstractList"></a>12.1.2 AbstractList</h2><p>AbstractList提供了List接口的基础实现，具体来说，它实现了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>AbstractList是怎么实现这些方法的呢？它依赖于如下更为基础的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>size方法与AbstractCollection一样，也是抽象方法，子类必须重写。get方法根据索引index获取元素，它也是抽象方法，子类必须重写。</p>
<p>set、add、remove方法都是修改容器内容，它们不是抽象方法，但默认实现都是抛出异常UnsupportedOperationException。如果子类容器不可被修改，这个默认实现就可以了。如果可以根据索引修改内容，应该重写set方法。如果容器是长度可变的，应该重写add和remove方法。</p>
<p>与AbstractCollection不同，继承AbstractList不需要实现迭代器类和相关方法，AbstractList内部实现了两个迭代器类，一个实现了Iterator接口，另一个实现了ListIterator接口，它们是基于以上的这些基础方法实现的，逻辑比较简单，就不赘述了。</p>
<p>具体如何扩展AbstractList呢？我们来看个例子，也通过DynamicArray来实现一个简单的List，如代码清单12-4所示。</p>
<center>代码清单12-4 扩展AbstractList的List实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DynamicArray&lt;E&gt; darr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        darr = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> darr.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> darr.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> darr.set(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        darr.add(index, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> darr.remove(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是按建议提供了两个构造方法，并重写了size、get、set、add和remove方法，这些方法内部使用了DynamicArray。</p>
<h2 id="12-1-3-AbstractSequentialList"><a href="#12-1-3-AbstractSequentialList" class="headerlink" title="12.1.3 AbstractSequentialList"></a>12.1.3 AbstractSequentialList</h2><p>AbstractSequentialList是AbstractList的子类，也提供了List接口的基础实现，具体来说，它实现了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br></pre></td></tr></table></figure>

<p>可以看出，它实现了根据索引位置进行操作的get、set、add、remove方法，它是怎么实现的呢？它是基于ListIterator接口的方法实现的，在AbstractSequentialList中，listIterator方法被重写为了一个抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>子类必须重写该方法，并实现迭代器接口。</p>
<p>我们来看段具体的代码，看get、set、add、remove是如何基于ListIterator实现的。get方法代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;Index: &quot;</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，其他方法也都类似，就不赘述了。</p>
<p>注意与AbstractList相区别，可以说，虽然AbstractSequentialList是AbstractList的子类，但实现逻辑和用法上，与AbstractList正好相反。</p>
<ul>
<li>AbstractList需要具体子类重写根据索引操作的方法get、set、add、remove，它提供了迭代器，但迭代器是基于这些方法实现的。它假定子类可以高效地根据索引位置进行操作，适用于内部是随机访问类型的存储结构（如数组），比如ArrayList就继承自AbstractList。</li>
<li>AbstractSequentialList需要具体子类重写迭代器，它提供了根据索引操作的方法get、set、add、remove，但这些方法是基于迭代器实现的。它适用于内部是顺序访问类型的存储结构（如链表），比如LinkedList就继承自AbstractSequentialList。</li>
</ul>
<p>具体如何扩展AbstractSequentialList呢？我们还是以DynamicArray举例来说明，在实际应用中，如果内部存储结构类似DynamicArray，应该继承AbstractList，这里主要是演示其用法。</p>
<p>扩展AbstractSequentialList需要实现ListIterator，前面介绍的DynamicArrayIterator只实现了Iterator接口，通过继承DynamicArrayIterator，我们实现一个新的实现了List-Iterator接口的类DynamicArrayListIterator，如代码清单12-5所示。</p>
<center>代码清单12-5 实现了ListIterator接口的类DynamicArrayListIterator</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArrayListIterator</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">DynamicArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicArrayListIterator</span><span class="params">(<span class="keyword">int</span> index, DynamicArray&lt;E&gt; darr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(darr);</span><br><span class="line">        <span class="keyword">this</span>.cursor = index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(! hasPrevious())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        cursor--;</span><br><span class="line">        lastRet = cursor;</span><br><span class="line">        <span class="keyword">return</span> darr.get(lastRet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lastRet==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line">        darr.set(lastRet, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        darr.add(cursor, e);</span><br><span class="line">        cursor++;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑比较简单，就不解释了。有了DynamicArrayListIterator，我们看基于Abstract-SequentialList的List实现，如代码清单22-6所示。</p>
<center>代码清单12-6 基于AbstractSequentialList的List实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySeqList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DynamicArray&lt;E&gt; darr;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySeqList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        darr = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySeqList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicArrayListIterator&lt;&gt;(index, darr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> darr.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是按建议提供了两个构造方法，并重写了size和listIterator方法，迭代器的实现是DynamicArrayListIterator。</p>
<h2 id="12-1-4-AbstractMap"><a href="#12-1-4-AbstractMap" class="headerlink" title="12.1.4 AbstractMap"></a>12.1.4 AbstractMap</h2><p>AbstractMap提供了Map接口的基础实现，具体来说，它实现了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>AbstractMap是如何实现这些方法的呢？它依赖于如下更为基础的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Set&lt;Entry&lt;K, V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>putAll就是循环调用put。put方法的默认实现是抛出异常UnsupportedOperation-Exception，如果Map是允许写入的，则需要重写该方法。</p>
<p>其他方法都基于entrySet方法。entrySet方法是一个抽象方法，子类必须重写，它返回所有键值对的Set视图，如果Map是允许删除的，这个Set的迭代器实现类，即entrySet(). iterator()的返回对象，必须实现迭代器的remove方法，这是因为AbstractMap的remove方法是通过entrySet().iterator().remove()实现的。</p>
<p>除了提供基础方法的实现，AbstractMap类内部还定义了两个公有的静态内部类，表示键值对：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbstractMap.SimpleEntry implements Entry&lt;K, V&gt;</span><br><span class="line">AbstractMap.SimpleImmutableEntry implements Entry&lt;K, V&gt;</span><br></pre></td></tr></table></figure>

<p>SimpleImmutableEntry用于表示只读的键值对，而SimpleEntry用于表示可写的。</p>
<p>Map接口文档建议：每个Map接口的实现类都应该提供至少两个标准的构造方法，一个是默认构造方法，另一个接受一个Map类型的参数。</p>
<p>具体如何扩展AbstractMap呢？我们定义一个简单的Map实现类MyMap，内部还是用DynamicArray，如代码清单12-7所示。</p>
<center>代码清单12-7 一个简单的Map实现类MyMap</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DynamicArray&lt;Map.Entry&lt;K, V&gt;&gt; darr;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        darr = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>();</span><br><span class="line">        putAll(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K, V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> es ! = <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; darr.size(); i++) &#123;</span><br><span class="line">            Map.Entry&lt;K, V&gt; entry = darr.get(i);</span><br><span class="line">            <span class="keyword">if</span>((key == <span class="keyword">null</span> &amp;&amp; entry.getKey() == <span class="keyword">null</span>)</span><br><span class="line">                    || (key ! = <span class="keyword">null</span> &amp;&amp; key.equals(entry.getKey()))) &#123;</span><br><span class="line">                V oldValue = entry.getValue();</span><br><span class="line">                entry.setValue(value);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map.Entry&lt;K, V&gt; newEntry = <span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(key, value);</span><br><span class="line">        darr.add(newEntry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K, V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DynamicArrayIterator&lt;Map.Entry&lt;K, V&gt;&gt;(darr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> darr.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们定义了两个构造方法，实现了put和entrySet方法。put方法先通过循环查找是否已存在对应的键，如果存在则修改值，否则新建一个键值对（类型为AbstractMap.Simple-Entry）并添加。entrySet返回的类型是一个内部类EntrySet，它继承自AbstractSet，重写了size和iterator方法，iterator方法中，返回的是迭代器类型是DynamicArrayIterator，它支持remove方法。</p>
<h2 id="12-1-5-AbstractSet"><a href="#12-1-5-AbstractSet" class="headerlink" title="12.1.5 AbstractSet"></a>12.1.5 AbstractSet</h2><p>AbstractSet提供了Set接口的基础实现，它继承自AbstractCollection，增加了equals和hashCode方法的默认实现。Set接口要求容器内不能包含重复元素，AbstractSet并没有实现该约束，子类需要自己实现。</p>
<p>扩展AbstractSet与AbstractCollection是类似的，只是需要实现无重复元素的约束，比如，add方法内需要检查元素是否已经添加过了。具体实现比较简单，我们就不赘述了。</p>
<h2 id="12-1-6-AbstractQueue"><a href="#12-1-6-AbstractQueue" class="headerlink" title="12.1.6 AbstractQueue"></a>12.1.6 AbstractQueue</h2><p>AbstractQueue提供了Queue接口的基础实现，它继承自AbstractCollection，实现了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法是基于Queue接口的其他方法实现的，包括：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure>

<p>扩展AbstractQueue需要实现这些方法，具体逻辑也比较简单，我们就不赘述了。</p>
<h2 id="12-1-7-小结"><a href="#12-1-7-小结" class="headerlink" title="12.1.7 小结"></a>12.1.7 小结</h2><p>本小节介绍了Java容器类中的抽象类AbstractCollection、AbstractList、AbstractSequen-tialList、AbstractSet、AbstractQueue以及AbstractMap，介绍了它们与容器接口和具体类的关系，对每个抽象类，介绍了它提供的基础功能，如何实现，并举例说明了如何进行扩展，完整的代码在github上，地址为 <a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.lao-ma.collection.c52下。</p>
<p>前面我们提到，<strong>实现了容器接口，就可以方便地参与到容器类这个大家庭中进行相互协作，也可以方便地利用Collections这个类实现的通用算法和功能</strong>。</p>
<p>但Collections都实现了哪些算法和功能？都有什么用途？如何使用？内部又是如何实现的？有何参考价值？让我们下一小节来探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/9c1d855f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/9c1d855f/" class="post-title-link" itemprop="url">11.3 堆和PriorityQueue的应用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 15:48:30" itemprop="dateCreated datePublished" datetime="2021-12-05T15:48:30+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC11%E7%AB%A0-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">第11章 堆与优先级队列</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/9c1d855f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/9c1d855f/" data-xid="/JavaReadingNotes/9c1d855f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="11-3-堆和PriorityQueue的应用"><a href="#11-3-堆和PriorityQueue的应用" class="headerlink" title="11.3 堆和PriorityQueue的应用"></a>11.3 堆和PriorityQueue的应用</h1><p>PriorityQueue除了用作优先级队列，还可以用来解决一些别的问题，本章开头提到了如下两个应用。<br>1）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，但需要知道到目前为止的最大的前K个元素。这个问题的变体有：求前K个最小的元素，求第K个最大的元素，求第K个最小的元素。<br>2）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，数据量可能很大，甚至源源不断到来。</p>
<p>本节，我们就来探讨如何解决这两个问题。</p>
<h2 id="11-3-1-求前K个最大的元素"><a href="#11-3-1-求前K个最大的元素" class="headerlink" title="11.3.1 求前K个最大的元素"></a>11.3.1 求前K个最大的元素</h2><p>一个简单的思路是排序，排序后取最大的K个就可以了，排序可以使用Arrays.sort()方法，效率为O(N×log2(N))。不过，如果K很小，比如是1，就是取最大值，对所有元素完全排序是毫无必要的。另一个简单的思路是选择，循环选择K次，每次从剩下的元素中选择最大值，这个效率为O(N×K)，如果K的值大于log2(N)，这个就不如完全排序了。</p>
<p>不过，这两个思路都假定所有元素都是已知的，而不是动态添加的。如果元素个数不确定，且源源不断到来呢？</p>
<p>一个基本的思路是维护一个长度为K的数组，最前面的K个元素就是目前最大的K个元素，以后每来一个新元素的时候，都先找数组中的最小值，将新元素与最小值相比，如果小于最小值，则什么都不用变，如果大于最小值，则将最小值替换为新元素。</p>
<p>这有点类似于生活中的末位淘汰，新元素与原来最末尾的比即可，要么不如最末尾，上不去，要么替掉原来的末尾。</p>
<p>这样，数组中维护的永远是最大的K个元素，而且不管源数据有多少，需要的内存开销是固定的，就是长度为K的数组。不过，每来一个元素，都需要找最小值，都需要进行K次比较，能不能减少比较次数呢？</p>
<p>解决方法是使用最小堆维护这K个元素，最小堆中，根即第一个元素永远都是最小的，新来的元素与根比就可以了，如果小于根，则堆不需要变化，否则用新元素替换根，然后向下调整堆即可，调整的效率为O(log2(K))，这样，总体的效率就是O(N×log2(K))，这个效率非常高，而且存储成本也很低。</p>
<p>使用最小堆之后，第K个最大的元素也很容易获得，它就是堆的根。</p>
<p>理解了思路，下面我们来看代码。我们实现一个简单的TopK类，如代码清单11-1所示。</p>
<center>代码清单11-1 求前K个最大的元素：TopK</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopK</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; p;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> k;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopK</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.p = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(E e : c)&#123;</span><br><span class="line">            add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p.size()&lt;k)&#123;</span><br><span class="line">            p.add(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; head = (Comparable&lt;? <span class="keyword">super</span> E&gt;)p.peek();</span><br><span class="line">        <span class="keyword">if</span>(head.compareTo(e)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//小于TopK中的最小值，不用变</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新元素替换掉原来的最小值成为TopK之一</span></span><br><span class="line">        p.poll();</span><br><span class="line">        p.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;</span><br><span class="line">        <span class="keyword">return</span> p.toArray(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getKth</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们稍微解释一下。TopK内部使用一个优先级队列和k，构造方法接受一个参数k，使用PriorityQueue的默认构造方法，假定元素实现了Comparable接口。</p>
<p>add方法实现向其中动态添加元素，如果元素个数小于k直接添加，否则与最小值比较，只在大于最小值的情况下添加，添加前，先删掉原来的最小值。addAll方法循环调用add方法。</p>
<p>toArray方法返回当前的最大的K个元素，getKth方法返回第K个最大的元素。</p>
<p>我们来看一下使用的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TopK&lt;Integer&gt; top5 = <span class="keyword">new</span> TopK&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">top5.addAll(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">        <span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">23</span>, <span class="number">21</span>, <span class="number">90</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(Arrays.toString(top5.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>])));</span><br><span class="line">System.out.println(top5.getKth());</span><br></pre></td></tr></table></figure>

<p>保留5个最大的元素，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[21, 23, 34, 100, 90]</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就不解释了。</p>
<h2 id="11-3-2-求中值"><a href="#11-3-2-求中值" class="headerlink" title="11.3.2 求中值"></a>11.3.2 求中值</h2><p>中值就是排序后中间那个元素的值，如果元素个数为奇数，中值是没有歧义的，但如果是偶数，中值可能有不同的定义，可以为偏小的那个，也可以是偏大的那个，或者两者的平均值，或者任意一个，这里，我们假定任意一个都可以。</p>
<p>一个简单的思路是排序，排序后取中间那个值就可以了，排序可以使用Arrays.sort()方法，效率为O(N× log2(N))。</p>
<p>不过，这要求所有元素都是已知的，而不是动态添加的。如果元素源源不断到来，如何实时得到当前已经输入的元素序列的中位数？</p>
<p>可以使用两个堆，一个最大堆，一个最小堆，思路如下。<br>1）假设当前的中位数为m，最大堆维护的是&lt;=m的元素，最小堆维护的是&gt;=m的元素，但两个堆都不包含m。<br>2）当新的元素到达时，比如为e，将e与m进行比较，若e&lt;=m，则将其加入最大堆中，否则将其加入最小堆中。<br>3）第2步后，如果此时最小堆和最大堆的元素个数的差值&gt;=2 ，则将m加入元素个数少的堆中，然后从元素个数多的堆将根节点移除并赋值给m。</p>
<p>我们通过一个例子来解释下。比如输入元素依次为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34, 90, 67, 45,1</span><br></pre></td></tr></table></figure>

<p>输入第1个元素时，m即为34。</p>
<p>输入第2个元素时，90大于34，加入最小堆，中值不变，如图11-20所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209144104.jpeg" alt="epub_923038_105"></p>
<center>图11-20 求中值：输入第2个元素后</center>

<p>输入第3个元素时，67大于34，加入最小堆，但加入最小堆后，最小堆的元素个数为2，需调整中值和堆，现有中值34加入最大堆中，最小堆的根67从最小堆中删除并赋值给m，如图11-21所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209144114.jpeg" alt="epub_923038_106"></p>
<center>图11-21 求中值：输入第三个元素后</center>

<p>输入第4个元素45时，45小于67，加入最大堆，中值不变，如图11-22所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209144126.jpeg" alt="img"></p>
<center>图11-22 求中值：输入第四个元素后</center>

<p>输入第5个元素1时，1小于67，加入最大堆，此时需调整中值和堆，现有中值67加入最小堆中，最大堆的根45从最大堆中删除并赋值给m，如图11-23所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209144237.jpeg" alt="epub_923038_108"></p>
<center>图11-23 求中值：输入第五个元素后</center>

<p>理解了基本思路，我们来实现一个简单的中值类Median，如代码清单11-2所示。</p>
<center>代码清单11-2 求中值：Median</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Median</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; minP; <span class="comment">//最小堆</span></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;E&gt; maxP; <span class="comment">//最大堆</span></span><br><span class="line">    <span class="keyword">private</span> E m; <span class="comment">//当前中值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Median</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minP = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.maxP = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">11</span>, Collections.reverseOrder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(E e, E m)</span></span>&#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; cmpr = (Comparable&lt;? <span class="keyword">super</span> E&gt;)e;</span><br><span class="line">        <span class="keyword">return</span> cmpr.compareTo(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="keyword">null</span>)&#123; <span class="comment">//第一个元素</span></span><br><span class="line">            m = e;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(compare(e, m)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//小于中值， 加入最大堆</span></span><br><span class="line">            maxP.add(e);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minP.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minP.size()-maxP.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//最小堆元素个数多，即大于中值的数多</span></span><br><span class="line">            <span class="comment">//将m加入到最大堆中，然后将最小堆中的根移除赋给m</span></span><br><span class="line">            maxP.add(<span class="keyword">this</span>.m);</span><br><span class="line">            <span class="keyword">this</span>.m = minP.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxP.size()-minP.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            minP.add(<span class="keyword">this</span>.m);</span><br><span class="line">            <span class="keyword">this</span>.m = maxP.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(E e : c)&#123;</span><br><span class="line">            add(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">getM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码和思路基本是对应的，比较简单，就不解释了。我们来看一个使用的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Median&lt;Integer&gt; median = <span class="keyword">new</span> Median&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">              <span class="number">34</span>, <span class="number">90</span>, <span class="number">67</span>, <span class="number">45</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span></span><br><span class="line">&#125;);</span><br><span class="line">median.addAll(list);</span><br><span class="line">System.out.println(median.getM());</span><br></pre></td></tr></table></figure>

<p>输出为中值9。</p>
<h2 id="11-3-3-小结"><a href="#11-3-3-小结" class="headerlink" title="11.3.3 小结"></a>11.3.3 小结</h2><p>本节介绍了堆和PriorityQueue的两个应用，求前K个最大的元素和求中值，介绍了基本思路和实现代码，相比使用排序，使用堆不仅实现效率更高，而且可以应对数据量不确定且源源不断到来的情况，可以给出实时结果。</p>
<p>之前章节我们还介绍过ArrayDeque。<strong>PriorityQueue和ArrayDeque都是队列，都是基于数组的，但都不是简单的数组，通过一些特殊的约束、辅助成员和算法，它们都能高效地解决一些特定的问题，这大概是计算机程序中使用数据结构和算法的一种艺术吧</strong>。</p>
<p>至此，关于堆的概念与算法、优先级队列PriorityQueue及其应用，就介绍完了。之前的章节中，我们介绍的基本都是具体的容器类，下一章，我们看一些抽象容器类，以及针对容器接口的通用功能，并对整个容器类体系进行总结。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6a033f2c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6a033f2c/" class="post-title-link" itemprop="url">11.2 剖析PriorityQueue</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 15:43:02" itemprop="dateCreated datePublished" datetime="2021-12-05T15:43:02+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC11%E7%AB%A0-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">第11章 堆与优先级队列</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6a033f2c/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6a033f2c/" data-xid="/JavaReadingNotes/6a033f2c/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="11-2-剖析PriorityQueue"><a href="#11-2-剖析PriorityQueue" class="headerlink" title="11.2 剖析PriorityQueue"></a>11.2 剖析PriorityQueue</h1><p>本节探讨堆在Java中的具体实现类：PriorityQueue。顾名思义，PriorityQueue是优先级队列，它首先实现了队列接口（Queue），与LinkedList类似，它的队列长度也没有限制，与一般队列的区别是，它有优先级的概念，每个元素都有优先级，队头的元素永远都是优先级最高的。</p>
<p>PriorityQueue内部是用堆实现的，内部元素不是完全有序的，不过，逐个出队会得到有序的输出。虽然名字叫优先级队列，但也可以将PriorityQueue看作一种比较通用的实现了堆的性质的数据结构，可以用PriorityQueue来解决适合用堆解决的问题，下一小节我们会来看一些具体的例子。下面，我们先介绍其用法，接着分析实现代码，最后总结分析其特点。</p>
<h2 id="11-2-1-基本用法"><a href="#11-2-1-基本用法" class="headerlink" title="11.2.1 基本用法"></a>11.2.1 基本用法</h2><p>PriorityQueue实现了Queue接口，我们在LinkedList一节介绍过Queue，为便于阅读，这里重复下其定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>; <span class="comment">//在尾部添加元素，队列满时抛异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>; <span class="comment">//在尾部添加元素，队列满时返回false</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>; <span class="comment">//删除头部元素，队列空时抛异常</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>; <span class="comment">//删除头部元素，队列空时返回null</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>; <span class="comment">//查看头部元素，队列空时抛异常</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>; <span class="comment">//查看头部元素，队列空时返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PriorityQueue有多个构造方法，部分构造方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity, Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>PriorityQueue是用堆实现的，堆物理上就是数组，与ArrayList类似，PriorityQueue同样使用动态数组，根据元素个数动态扩展，initialCapacity表示初始的数组大小，可以通过参数传入。对于默认构造方法，initialCapacity使用默认值11。对于最后的构造方法，数组大小等于参数容器中的元素个数。与TreeMap/TreeSet类似，为了保持一定顺序， PriorityQueue要求要么元素实现Comparable接口，要么传递一个比较器Comparator。</p>
<p>我们来看个基本的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">pq.offer(<span class="number">10</span>);</span><br><span class="line">pq.add(<span class="number">22</span>);</span><br><span class="line">pq.addAll(Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">    <span class="number">11</span>, <span class="number">12</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">19</span>, <span class="number">13</span> &#125;));</span><br><span class="line"><span class="keyword">while</span>(pq.peek()! =<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.print(pq.poll() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，添加元素，然后逐个从头部删除，与普通队列不同，输出是从小到大有序的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 6 7 8 10 11 12 12 13 15 19 22 34</span><br></pre></td></tr></table></figure>

<p>如果希望是从大到小呢？传递一个逆序的Comparator，将第一行代码替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">11</span>, Collections.reverseOrder());</span><br></pre></td></tr></table></figure>

<p>输出就会变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34 22 19 15 13 12 12 11 10 8 7 6 4 2</span><br></pre></td></tr></table></figure>

<p>我们再来看个例子。模拟一个任务队列，定义一个内部类Task表示任务，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//省略构造方法和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Task有两个实例变量：priority表示优先级，值越大优先级越高；name表示任务名称。Task没有实现Comparable，我们定义一个单独的静态成员taskComparator表示比较器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Comparator&lt;Task&gt; taskComparator = <span class="keyword">new</span> Comparator&lt;Task&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Task o1, Task o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(o1.getPriority()&gt;o2.getPriority())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(o1.getPriority()&lt;o2.getPriority())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面来看任务队列的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Task&gt; tasks = <span class="keyword">new</span> PriorityQueue&lt;Task&gt;(<span class="number">11</span>, taskComparator);</span><br><span class="line">tasks.offer(<span class="keyword">new</span> Task(<span class="number">20</span>, <span class="string">&quot;写日记&quot;</span>));</span><br><span class="line">tasks.offer(<span class="keyword">new</span> Task(<span class="number">10</span>, <span class="string">&quot;看电视&quot;</span>));</span><br><span class="line">tasks.offer(<span class="keyword">new</span> Task(<span class="number">100</span>, <span class="string">&quot;写代码&quot;</span>));</span><br><span class="line">Task task = tasks.poll();</span><br><span class="line"><span class="keyword">while</span>(task! =<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;处理任务： &quot;</span>+task.getName()</span><br><span class="line">                +<span class="string">&quot;，优先级：&quot;</span>+task.getPriority()+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    task = tasks.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就不解释了，输出任务按优先级排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理任务： 写代码，优先级：100</span><br><span class="line">处理任务： 写日记，优先级：20</span><br><span class="line">处理任务： 看电视，优先级：10</span><br></pre></td></tr></table></figure>

<h2 id="11-2-2-实现原理"><a href="#11-2-2-实现原理" class="headerlink" title="11.2.2 实现原理"></a>11.2.2 实现原理</h2><p>理解了PriorityQueue的用法和特点，我们来看其具体实现代码（基于Java<br>7），从内部组成开始。内部有如下成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>queue就是实际存储元素的数组。size表示当前元素个数。comparator为比较器，可以为null。modCount记录修改次数，在介绍第一个容器类ArrayList时已介绍过。</p>
<p>如何实现各种操作，且保持堆的性质呢？我们来看代码，从基本构造方法开始。</p>
<p>几个基本构造方法的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="params"><span class="function">                      Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就是初始化了queue和comparator。下面介绍一些操作的代码，大部分的算法和图示我们在11.1节已经介绍过了。</p>
<p>添加元素（入队）的代码如下所示，我们添加了一些注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= queue.length) <span class="comment">//首先确保数组长度是够的，如果不够，调用grow方法动态扩展</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>; <span class="comment">//增加长度</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="comment">//如果是第一次添加，直接添加到第一个位置即可</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//否则将其放入最后一个位置，但同时向上调整（siftUp），直至满足堆的性质</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两步复杂一些，一步是grow，另一步是siftUp，我们来细看下。grow()方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>)</span><br><span class="line">                                      (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                      (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果原长度比较小，大概就是扩展为两倍，否则就是增加50%，使用Arrays.copyOf方法复制数组。siftUp的基本思路我们在11.1节介绍过了，其实际代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(comparator ! = <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据是否有comparator分为了两种情况，代码类似，我们只看一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span>(comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数k表示插入位置，x表示新元素。k初始等于数组大小，即在最后一个位置插入。代码的主要部分是：往上寻找x真正应该插入的位置，这个位置用k表示。</p>
<p>怎么找呢？新元素（x）不断与父节点（e）比较，如果新元素（x）大于等于父节点（e），则已满足堆的性质，退出循环，k就是新元素最终的位置，否则，将父节点往下移（queue [k]=e），继续向上寻找。这与11.1节介绍的算法和图示是对应的。</p>
<p>查看头部元素的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是返回第一个元素。</p>
<p>删除头部元素（出队）的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(s ! = <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果result为第一个元素，x指向最后一个元素，将最后位置设置为null（queue[s] =null），最后调用siftDown将原来的最后元素x插入头部并调整堆，siftDown的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(comparator ! = <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样分为两种情况，代码类似，我们只看一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;          <span class="comment">//loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span>(k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">//assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span>(key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k表示最终的插入位置，初始为0, x表示原来的最后元素。代码的主要部分是：向下寻找x真正应该插入的位置，这个位置用k表示。</p>
<p>怎么找呢？新元素key不断与较小的孩子节点比较，如果小于等于较小的孩子节点，则已满足堆的性质，退出循环，k就是最终位置，否则将较小的孩子节点往上移，继续向下寻找。这与11.1节介绍的算法和图示也是对应的。</p>
<p>解释下其中的一些代码：<br>1）<code>k&lt;half</code>表示编号为k的节点有孩子节点，没有孩子节点，就不需要继续找了；<br>2）child表示较小的孩子节点编号，初始为左孩子，如果有右孩子（编号right）且小于左孩子则child会变为right；<br>3）c表示较小的孩子节点。</p>
<p>根据值删除元素的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span>(i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        removeAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先查找元素的位置i，然后调用removeAt进行删除，removeAt的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; size;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span>(s == i) <span class="comment">// removed last element</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);</span><br><span class="line">        <span class="keyword">if</span>(queue[i] == moved) &#123;</span><br><span class="line">            siftUp(i, moved);</span><br><span class="line">            <span class="keyword">if</span>(queue[i] ! = moved)</span><br><span class="line">                <span class="keyword">return</span> moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是删除最后一个位置，直接删即可，否则移动最后一个元素到位置i并进行堆调整，调整有两种情况，如果大于孩子节点，则向下调整，否则如果小于父节点则向上调整。代码先向下调整(siftDown(i, moved))，如果没有调整过(queue[i] ==moved)，可能需向上调整，调用siftUp(i, moved)。如果向上调整过，返回值为moved，其他情况返回null，这个主要用于正确实现PriorityQueue迭代器的删除方法，迭代器的细节我们就不介绍了。</p>
<p>如果从一个既不是PriorityQueue也不是SortedSet的容器构造堆，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    initElementsFromCollection(c);</span><br><span class="line">    heapify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initElementsFromCollection的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initElementsFromCollection</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">if</span>(a.getClass() ! = Object[].class)</span><br><span class="line">        a = Arrays.copyOf(a, a.length, Object[].class);</span><br><span class="line">    <span class="keyword">this</span>.queue = a;</span><br><span class="line">    <span class="keyword">this</span>.size = a.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是初始化queue和size。heapify的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (size &gt;&gt;&gt; <span class="number">1</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前算法一样，heapify也在11.1节介绍过了，就是从最后一个非叶子节点开始，自底向上合并构建堆。如果构造方法中的参数是PriorityQueue或SortedSet，则它们的toArray方法返回的数组就是有序的，就满足堆的性质，就不需要执行heapify了。</p>
<h2 id="11-2-3-小结"><a href="#11-2-3-小结" class="headerlink" title="11.2.3 小结"></a>11.2.3 小结</h2><p>本节介绍了Java中堆的实现类PriorityQueue，它实现了队列接口Queue，但按优先级出队，内部是用堆实现的，有如下特点：<br>1）实现了优先级队列，最先出队的总是优先级最高的，即排序中的第一个。<br>2）优先级可以有相同的，内部元素不是完全有序的，如果遍历输出，除了第一个，其他没有特定顺序。<br>3）查看头部元素的效率很高，为O(1)，入队、出队效率比较高，为O(log2(N))，构建堆heapify的效率为O(N)。<br>4）根据值查找和删除元素的效率比较低，为O(N)。</p>
<p>除了用作基本的优先级队列，PriorityQueue还可以作为一种比较通用的数据结构，用于解决一些其他问题，让我们在下一节继续探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6c34a95f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6c34a95f/" class="post-title-link" itemprop="url">11.0 第11章 堆与优先级队列 11.1 堆的概念与算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-05 15:39:13" itemprop="dateCreated datePublished" datetime="2021-12-05T15:39:13+08:00">2021-12-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC11%E7%AB%A0-%E5%A0%86%E4%B8%8E%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">第11章 堆与优先级队列</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6c34a95f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6c34a95f/" data-xid="/JavaReadingNotes/6c34a95f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第11章-堆与优先级队列"><a href="#第11章-堆与优先级队列" class="headerlink" title="第11章 堆与优先级队列"></a>第11章 堆与优先级队列</h1><p>前面两章介绍了Java中的基本容器类，每个容器类背后都有一种数据结构，ArrayList是动态数组，LinkedList是链表，HashMap/HashSet是哈希表，TreeMap/TreeSet是红黑树，本章介绍另一种数据结构：堆。之前我们提到过堆，那里，堆指的是内存中的区域，保存动态分配的对象，与栈相对应。这里的堆是一种数据结构，与内存区域和分配无关。</p>
<p>堆到底是什么结构呢？这个待会再细看。我们先来说明，堆有什么用？为什么要介绍它？<strong>堆可以非常高效方便地解决很多问题</strong>，比如：<br>1）优先级队列，我们之前介绍的队列实现类LinkedList是按添加顺序排列的，但现实中，经常需要按优先级来，每次都应该处理当前队列中优先级最高的，高优先级的即使来得晚，也应该被优先处理。<br>2）求前K个最大的元素，元素个数不确定，数据量可能很大，甚至源源不断到来，但需要知道到目前为止的最大的前K个元素。这个问题的变体有：求前K个最小的元素，求第K个最大的元素，求第K个最小的元素。<br>3）求中值元素，中值不是平均值，而是排序后中间那个元素的值，同样，数据量可能很大，甚至源源不断到来。</p>
<p>堆还可以实现排序，称之为堆排序，不过有比它更好的排序算法，所以，我们就不介绍其在排序中的应用了。</p>
<p>Java容器中有一个类PriorityQueue，表示优先级队列，它实现了堆，本章我们会详细介绍。关于如何使用堆高效解决求前K个最大的元素和求中值元素，我们也会在本章中用代码实现并详细解释。</p>
<p>说了这么多好处，堆到底是什么呢？我们先来看堆的基本概念与算法。</p>
<h2 id="11-1-堆的概念与算法"><a href="#11-1-堆的概念与算法" class="headerlink" title="11.1 堆的概念与算法"></a>11.1 堆的概念与算法</h2><p>我们先来了解堆的概念，然后介绍堆的一些主要算法。</p>
<p>堆首先是一棵二叉树，但它是<strong>完全二叉树</strong>。什么是完全二叉树呢？我们先来看另一个相似的概念：<strong>满二叉树</strong>。满二叉树是指除了最后一层外，每个节点都有两个孩子，而最后一层都是叶子节点，都没有孩子。比如，图11-1所示两棵二叉树都是满二叉树。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142455.jpeg" alt="epub_923038_86"></p>
<center>图11-1 满二叉树示例</center>

<p>满二叉树一定是完全二叉树，但完全二叉树不要求最后一层是满的，但如果不满，则要求所有节点必须集中在最左边，从左到右是连续的，中间不能有空的。比如，图11-2所示几棵二叉树都是完全二叉树。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142511.jpeg" alt="epub_923038_87"></p>
<center>图11-2 完全二叉树示例</center>

<p>而图11-3所示的几棵二叉树则都不是完全二叉树。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142523.jpeg" alt="epub_923038_88"></p>
<center>图11-3 非完全二叉树示例</center>

<p>在完全二叉树中，可以给每个节点一个编号，编号从1开始连续递增，从上到下，从左到右，如图11-4所示。</p>
<p>完全二叉树有一个重要的特点：给定任意一个节点，可以根据其编号直接快速计算出其父节点和孩子节点编号。如果编号为i，则父节点编号即为i/2，左孩子编号即为2× i，右孩子编号即为2× i+1。比如，对于5号节点，父节点为5/2即2，左孩子为2× 5即10，右孩子为2× 5+1即11。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142536.jpeg" alt="epub_923038_89"></p>
<center>图11-4 完全二叉树编号</center>

<p>这个特点为什么重要呢？<strong>它使得逻辑概念上的二叉树可以方便地存储到数组中</strong>，数组中的元素索引就对应节点的编号，树中的父子关系通过其索引关系隐含维持，不需要单独保持。比如，图11-4所示的逻辑二叉树，保存到数组中，其结构如图11-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142548.jpeg" alt="epub_923038_90"></p>
<center>图11-5 用数组表示完全二叉树</center>

<p>父子关系是隐含的，比如对于第5个元素13，其父节点就是第2个元素15，左孩子就是第10个元素7，右孩子就是第11个元素4。</p>
<p>这种存储二叉树的方法与之前介绍的TreeMap是不一样的。在TreeMap中，有一个单独的内部类Entry, Entry有三个引用，分别指向父节点、左孩子、右孩子。使用数组存储的优点是节省空间，而且访问效率高。堆逻辑概念上是一棵完全二叉树，而物理存储上使用数组，还有一定的顺序要求。</p>
<p>之前介绍过排序二叉树。排序二叉树是完全有序的，每个节点都有确定的前驱和后继，而且不能有重复元素。与排序二叉树不同，在堆中，可以有重复元素，元素间不是完全有序的，但对于父子节点之间，有一定的顺序要求。根据顺序分为两种堆：一种是<strong>最大堆</strong>，另一种是<strong>最小堆</strong>。</p>
<p>最大堆是指每个节点都不大于其父节点。这样，对每个父节点，一定不小于其所有孩子节点，而根节点就是所有节点中最大的，对每个子树，子树的根也是子树所有节点中最大的。最小堆与最大堆正好相反，每个节点都不小于其父节点。这样，对每个父节点，一定不大于其所有孩子节点，而根节点就是所有节点中最小的，对每个子树，子树的根也是子树所有节点中最小的。我们看个例子，如图11-6所示。</p>
<p>总结来说，逻辑概念上，堆是完全二叉树，父子节点间有特定顺序，分为最大堆和最小堆，最大堆根是最大的，最小堆根是最小的，堆使用数组进行物理存储。</p>
<p>为什么堆可以高效地解决之前我们说的问题呢？在回答之前，我们需要先看下，如何在堆上进行数据的基本操作，在操作过程中如何保持堆的属性不变。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142603.jpeg" alt="epub_923038_91"></p>
<center>图11-6 最大堆与最小堆示例</center>


<h2 id="11-1-2-堆的算法"><a href="#11-1-2-堆的算法" class="headerlink" title="11.1.2 堆的算法"></a>11.1.2 堆的算法</h2><p>下面，我们介绍如何在堆上进行数据的基本操作。最大堆和最小堆的算法是类似的，我们以最小堆来说明。先来看如何添加元素。</p>
<h3 id="1．添加元素"><a href="#1．添加元素" class="headerlink" title="1．添加元素"></a>1．添加元素</h3><p>如果堆为空，则直接添加一个根就行了。我们假定已经有一个堆，要在其中添加元素，基本步骤为：</p>
<p>1）添加元素到最后位置。<br>2）与父节点比较，如果大于等于父节点则满足堆的性质，结束，否则与父节点进行交换，然后再与父节点比较和交换，直到父节点为空或者大于等于父节点。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142655.jpeg" alt="epub_923038_92"></p>
<center>图11-7 堆的算法示例：添加元素前的初始结构</center>

<p>我们来看个例子。图11-7是添加元素前的初始结构。</p>
<p>添加元素3，第一步后，结构如图11-8所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142707.jpeg" alt="epub_923038_93"></p>
<center>图11-8 堆的算法示例：添加元素3第一步后的结构</center>

<p>3小于父节点8，不满足最小堆的性质，所以与父节点交换，变为图11-9所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142718.jpeg" alt="epub_923038_94"></p>
<center>图11-9 堆的算法示例：添加元素3第一次交换后的结构</center>

<p>交换后，3还是小于父节点6，所以继续交换，变为图11-10所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142728.jpeg" alt="epub_923038_95"></p>
<center>图11-10 堆的算法示例：添加元素3第二次交换后的结构</center>

<p>交换后，3还是小于父节点，也是根节点4，继续交换，变为图11-11所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142740.jpeg" alt="epub_923038_96"></p>
<center>图11-11 堆的算法示例：添加元素3第三次交换后的结构</center>

<p>至此，调整结束，树保持了堆的性质。</p>
<p>从以上过程可以看出，添加一个元素，需要比较和交换的次数最多为树的高度，即<code>log2(N)</code>, N为节点数。这种自底向上比较、交换，使得树重新满足堆的性质的过程，我们称为向上调整（siftup）。</p>
<h3 id="2．从头部删除元素"><a href="#2．从头部删除元素" class="headerlink" title="2．从头部删除元素"></a>2．从头部删除元素</h3><p>在队列中，一般是从头部删除元素，Java中用堆实现优先级队列。下面介绍如何在堆中删除头部，其基本步骤为：<br>1）用最后一个元素替换头部元素，并删掉最后一个元素；<br>2）将新的头部与两个孩子节点中较小的比较，如果不大于该孩子节点，则满足堆的性质，结束，否则与较小的孩子节点进行交换，交换后，再与较小的孩子节点比较和交换，一直到没有孩子节点，或者不大于两个孩子节点。这个过程称为向下调整（siftdown）。</p>
<p>我们来看个例子。图11-12是删除元素前的初始结构。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142752.jpeg" alt="epub_923038_97"></p>
<center>图11-12 堆的算法示例：删除元素前的初始结构</center>

<p>执行第一步，用最后元素替换头部，如图11-13所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142803.jpeg" alt="epub_923038_98"></p>
<center>图11-13 堆的算法示例：删除头部元素第一步后的结构</center>

<p>现在根节点16大于孩子节点，与更小的孩子节点6进行替换，结构变为图11-14所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142815.jpeg" alt="epub_923038_99"></p>
<center>图11-14 堆的算法示例：删除头部元素第一次交换后的结构</center>

<p>16还是大于孩子节点，与更小的孩子8进行交换，结构如图11-15所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142825.jpeg" alt="epub_923038_100"></p>
<center>图11-15 堆的算法示例：删除头部元素第二次交换后的结构</center>

<p>至此，就满足堆的性质了。</p>
<h3 id="3．从中间删除元素"><a href="#3．从中间删除元素" class="headerlink" title="3．从中间删除元素"></a>3．从中间删除元素</h3><p>那如果需要从中间删除某个节点呢？与从头部删除一样，都是先用最后一个元素替换待删元素。不过替换后，有两种情况：如果该元素大于某孩子节点，则需向下调整（sift-down）；如果小于父节点，则需向上调整（siftup）。</p>
<p>我们来看个例子，删除值为21的节点，第一步如图11-16所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209142955.jpeg" alt="epub_923038_101"></p>
<center>图11-16 堆的算法示例：从中间删除元素21第一步后的结构</center>

<p>替换后，6没有子节点，小于父节点12，执行向上调整（siftup）过程，最后结果如图11-17所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209143005.jpeg" alt="epub_923038_102"></p>
<center>图11-17 堆的算法示例：从中间删除元素21调整后的结构</center>

<p>我们再来看个例子，删除值为9的节点，第一步如图11-18所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209143016.jpeg" alt="epub_923038_103"></p>
<center>图11-18 堆的算法示例：从中间删除元素9第一步后的结构</center>

<p>交换后，11大于右孩子10，所以执行向下调整（siftdown）过程，执行结束后如图11-19所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209143034.jpeg" alt="epub_923038_104"></p>
<center>图11-19 堆的算法示例：从中间删除元素9调整后的结构</center>

<h3 id="4．构建初始堆"><a href="#4．构建初始堆" class="headerlink" title="4．构建初始堆"></a>4．构建初始堆</h3><p>给定一个无序数组，如何使之成为一个最小堆呢？将普通无序数组变为堆的过程称为heapify。基本思路是：从最后一个非叶子节点开始，一直往前直到根，对每个节点，执行向下调整（siftdown）。换句话说，是自底向上，先使每个最小子树为堆，然后每对左右子树和其父节点合并，调整为更大的堆，因为每个子树已经为堆，所以调整就是对父节点执行向下调整（siftdown），这样一直合并调整直到根。这个算法的伪代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        siftdown(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>size表示节点个数，节点编号从1开始，size/2表示第一个非叶子节点的编号。</p>
<p>这个构建的时间效率为O(N), N为节点个数，具体就不证明了。</p>
<h3 id="5．查找和遍历"><a href="#5．查找和遍历" class="headerlink" title="5．查找和遍历"></a>5．查找和遍历</h3><p>在堆中进行查找没有特殊的算法，就是从数组的头找到尾，效率为O(N)。</p>
<p>在堆中进行遍历也是类似的，堆就是数组，堆的遍历就是数组的遍历，第一个元素是最大值或最小值，但后面的元素没有特定的顺序。</p>
<p>需要说明的是，如果是逐个从头部删除元素，那么堆可以确保输出是有序的。</p>
<h3 id="6．算法小结"><a href="#6．算法小结" class="headerlink" title="6．算法小结"></a>6．算法小结</h3><p>以上就是堆操作的主要算法，小结如下。<br>1）在添加和删除元素时，有两个关键的过程以保持堆的性质，一个是向上调整（siftup），另一个是向下调整（siftdown），它们的效率都为O(log2(N))。由无序数组构建堆的过程heapify是一个自底向上循环的过程，效率为O(N)。<br>2）查找和遍历就是对数组的查找和遍历，效率为O(N)。</p>
<h3 id="11-1-3-小结"><a href="#11-1-3-小结" class="headerlink" title="11.1.3 小结"></a>11.1.3 小结</h3><p>本节介绍了堆这一数据结构的基本概念和算法。<strong>堆是一种比较神奇的数据结构，概念上是树，存储为数组，父子有特殊顺序，根是最大值/最小值，构建/添加/删除效率都很高，可以高效解决很多问题</strong>。但在Java中，堆到底是如何实现的呢？本章开头提到的那些问题，用堆到底如何解决呢？让我们在接下来的小节中继续探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/JavaReadingNotes/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/7/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-mzjszagu6-lanlan2017.vercel.app","placeholder":"填写您的邮箱以便接收回复提醒,填写您个人网站地址以便为您增加访问量","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/7/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
