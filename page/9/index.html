<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/9/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8c1780e5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8c1780e5/" class="post-title-link" itemprop="url">2.4 char的真正含义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:04" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:04+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8c1780e5/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8c1780e5/" data-xid="/JavaReadingNotes/8c1780e5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-4-char的真正含义"><a href="#2-4-char的真正含义" class="headerlink" title="2.4 char的真正含义"></a>2.4 char的真正含义</h1><p>通过前面小节，我们应该对字符和文本的编码和乱码有了一个清晰的认识，但前面小节基本是与编程语言无关的，我们还是不知道怎么在程序中处理字符和文本。本节讨论在Java中进行字符处理的基础char, Java中还有Character、String、StringBuilder等类用于文本处理，它们的基础都是char，我们在第7章再介绍这些类。</p>
<p>char看上去是很简单的，正如我们在1.2节所说，char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。赋值时把常量字符用单引号括起来，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">z</span> <span class="operator">=</span> <span class="string">&#x27;马&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但为什么字符类型也可以进行算术运算和比较呢？它的本质到底是什么呢？</p>
<p>在Java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。简单回顾一下，UTF-16使用两个或4个字节表示一个字符，Unicode编号范围在65536以内的占两个字节，超出范围的占4个字节，BE就是先输出高位字节，再输出低位字节，这与整数的内存表示是一致的。</p>
<p><strong>char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符</strong>。由于固定占用两个字节，char只能表示Unicode编号在65 536以内的字符，而不能表示超出范围的字符。那超出范围的字符怎么表示呢？使用两个char。类Character、String有一些相关的方法，我们到第7章再介绍。</p>
<p>在这个认识的基础上，我们再来看下char的一些行为。</p>
<p>char有多种赋值方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. char c = &#x27;A&#x27;</span><br><span class="line">2. char c = &#x27;马&#x27;</span><br><span class="line">3. char c = 39532</span><br><span class="line">4. char c = 0x9a6c</span><br><span class="line">5. char c = &#x27;\u9a6c&#x27;</span><br></pre></td></tr></table></figure>

<p>第1种赋值方式是最常见的，将一个能用ASCII码表示的字符赋给一个字符变量。第2种赋值方式也很常见，但这里是个中文字符，需要注意的是，直接写字符常量的时候应该注意文件的编码，比如，GBK编码的代码文件按UTF-8打开，字符会变成乱码，赋值的时候是按当前的编码解读方式，将这个字符形式对应的Unicode编号值赋给变量，“马”对应的Unicode编号是39 532，所以第2种赋值方式和第3种赋值方式是一样的。第3种赋值方式是直接将十进制的常量赋给字符。第4种赋值方式是将十六进制常量赋给字符，第5种赋值方式是按Unicode字符形式。所以，第2、3、4、5种赋值方式都是一样的，本质都是将Unicode编号39 532赋给了字符。</p>
<p>由于char本质上是一个整数，所以可以进行整数能做的一些运算，在进行运算时会被看作int，但由于char占两个字节，运算结果不能直接赋值给char类型，需要进行强制类型转换，这和byte、short参与整数运算是类似的。char类型的比较就是其Unicode编号的比较。</p>
<p>char的加减运算就是按其Unicode编号进行运算，一般对字符做加减运算没什么意义，但ASCII码字符是有意义的。比如大小写转换，大写A～Z的编号是65～90，小写a～z的编号是97～122，正好相差32，所以大写转小写只需加32，而小写转大写只需减32。加减运算的另一个应用是加密和解密，将字符进行某种可逆的数学运算可以做加解密。</p>
<p>char的位运算可以看作是对应整数的位运算，只是它是无符号数，也就是说，有符号右移&gt;&gt;和无符号右移&gt;&gt;&gt;的结果是一样的。既然char本质上是整数，查看char的二进制表示，同样可以用Integer的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;马&#x27;</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(c));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001101001101100</span><br></pre></td></tr></table></figure>

<p>至此，关于整数、小数以及字符的二进制表示就介绍完了，下一章让我们一起来探索类的世界。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/91d12177/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/91d12177/" class="post-title-link" itemprop="url">2.3 字符的编码与乱码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:03" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:03+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/91d12177/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/91d12177/" data-xid="/JavaReadingNotes/91d12177/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-3-字符的编码与乱码"><a href="#2-3-字符的编码与乱码" class="headerlink" title="2.3 字符的编码与乱码"></a>2.3 字符的编码与乱码</h1><p>本节讨论与语言无关的字符和文本的编码以及乱码。我们在处理文件、浏览网页、编写程序时，时不时会碰到乱码的情况。乱码几乎总是令人心烦，让人困惑，通过阅读本节，相信你就可以自信从容地面对乱码，进而恢复乱码了。</p>
<p>编码和乱码听起来比较复杂，但其实并不复杂，请耐心阅读，让我们逐步来探讨。我们先介绍各种编码，然后介绍编码转换，分析乱码出现的原因，最后介绍如何从乱码中恢复。编码有两大类：一类是非Unicode编码；另一类是Unicode编码。我们先介绍非Unicode编码。</p>
<h2 id="2-3-1-常见非Unicode编码"><a href="#2-3-1-常见非Unicode编码" class="headerlink" title="2.3.1 常见非Unicode编码"></a>2.3.1 常见非Unicode编码</h2><p>下面我们看一些主要的非Unicode编码，包括ASCII、ISO 8859-1、Windows-1252、GB2312、GBK、GB18030和Big5。</p>
<h3 id="1-ASCII"><a href="#1-ASCII" class="headerlink" title="1. ASCII"></a>1. ASCII</h3><p>世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了美国的需求。美国大概只需要128个字符，所以就规定了128个字符的二进制表示方法。这个方法是一个标准，称为ASCII编码，全称是American StandardCode for InformationInterchange，即美国信息互换标准代码。</p>
<p>128个字符用7位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看作数字0～127, ASCII码规定了从0～127的每个数字代表什么含义。</p>
<p>我们先来看数字32～126的含义，如图2-1所示，除了中文之外，我们平常用的字符基本都涵盖了，键盘上的字符大部分也都涵盖了。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144602.jpeg" alt="epub_923038_22"></p>
<center>图2-1 ASCII编码：可打印字符</center>

<p>图2-1 ASCII编码：可打印字符数字32～126表示的字符都是可打印字符，0～31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，表2-4列出了其中相对常用的字符。</p>
<center>表2-4 ASCII编码：常用不可打印字符</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144653.jpeg" alt="epub_923038_23"><br>ASCII码对美国是够用了，但对其他国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各种的编码方式以表示自己国家的字符，为了保持与ASCII码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示ASCII码，当为1时就是各个国家自己的字符。在这些扩展的编码中，在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312、GBK、GB18030和Big5，我们逐个介绍这些编码。</p>
<h3 id="2-ISO-8859-1"><a href="#2-ISO-8859-1" class="headerlink" title="2. ISO 8859-1"></a>2. ISO 8859-1</h3><p>ISO 8859-1又称Latin-1，它也是使用一个字节表示一个字符，其中0～127与ASCII一样，128～255规定了不同的含义。在128～255中，128～159表示一些控制字符，这些字符也不常用，就不介绍了。160～255表示一些西欧字符，如图2-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144707.jpeg" alt="epub_923038_24"></p>
<center>图2-2 ISO 8859-1</center>

<h3 id="3-Windows-1252"><a href="#3-Windows-1252" class="headerlink" title="3. Windows-1252"></a>3. Windows-1252</h3><p>ISO 8859-1虽然号称是标准，用于西欧国家，但它连欧元（€）这个符号都没有，因为欧元比较晚，而标准比较早。实际中使用更为广泛的是Windows-1252编码，这个编码与ISO 8859-1基本是一样的，区别只在于数字128～159。Windows-1252使用其中的一些数字表示可打印字符，这些数字表示的含义如图2-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144724.jpeg"></p>
<center>图2-3 Windows-1252编码：区别于ISO8859-1的部分</center>

<p>这个编码中加入了欧元符号以及一些其他常用的字符。基本上可以认为，ISO8859-1已被Windows-1252取代，在很多应用程序中，即使文件声明它采用的是ISO 8859-1编码，解析的时候依然被当作Windows-1252编码。</p>
<p>HTML5甚至明确规定，如果文件声明的是ISO 8859-1编码，它应该被看作Win-dows-1252编码。为什么要这样呢？因为大部分人搞不清楚ISO 8859-1和Windows-1252的区别，当他说ISO 8859-1的时候，其实他指的是Windows-1252，所以标准干脆就这么强制规定了。</p>
<h3 id="4-GB2312"><a href="#4-GB2312" class="headerlink" title="4. GB2312"></a>4. GB2312</h3><p>美国和西欧字符用一个字节就够了，但中文显然是不够的。中文第一个标准是GB2312。GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字和一些罕用词和繁体字。</p>
<p>GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是ASCII字符。在这两个字节中，其中高位字节范围是0xA1～0xF7，低位字节范围是0xA1～0xFE。</p>
<p>比如，“老马”的GB2312编码（十六进制表示）如表2-5所示。</p>
<center>表2-5 GB2312编码示例</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208145753.jpeg" alt="epub_923038_26"></p>
<h3 id="5-GBK"><a href="#5-GBK" class="headerlink" title="5. GBK"></a>5. GBK</h3><p>GBK建立在GB2312的基础上，向下兼容GB2312，也就是说，GB2312编码的字符和二进制表示，在GBK编码里是完全一样的。GBK增加了14 000多个汉字，共计约21 000个汉字，其中包括繁体字。</p>
<p>GBK同样使用固定的两个字节表示，其中高位字节范围是0x81～0xFE，低位字节范围是0x40～0x7E和0x80～0xFE。</p>
<p>需要注意的是，低位字节是从0x40（也就是64）开始的，也就是说，低位字节的最高位可能为0。那怎么知道它是汉字的一部分，还是一个ASCII字符呢？其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。</p>
<h3 id="6-GB18030"><a href="#6-GB18030" class="headerlink" title="6. GB18030"></a>6. GB18030</h3><p>GB18030向下兼容GBK，增加了55 000多个字符，共76 000多个字符，包括了很多少数民族字符，以及中日韩统一字符。</p>
<p>用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节，有的是四个字节。在两字节编码中，字节表示范围与GBK一样。在四字节编码中，第一个字节的值为0x81～0xFE，第二个字节的值为0x30～0x39，第三个字节的值为0x81～0xFE，第四个字节的值为0x30～0x39。</p>
<p>解析二进制时，如何知道是两个字节还是4个字节表示一个字符呢？看第二个字节的范围，如果是0x30～0x39就是4个字节表示，因为两个字节编码中第二个字节都比这个大。</p>
<h3 id="7-Big5"><a href="#7-Big5" class="headerlink" title="7. Big5"></a>7. Big5</h3><p>Big5是针对繁体中文的，广泛用于我国台湾地区和我国香港特别行政区等地。Big5包括13 000多个繁体字，和GB2312类似，一个字符同样固定使用两个字节表示。在这两个字节中，高位字节范围是0x81～0xFE，低位字节范围是0x40～0x7E和0xA1～0xFE。</p>
<h3 id="8．编码汇总"><a href="#8．编码汇总" class="headerlink" title="8．编码汇总"></a>8．编码汇总</h3><p>我们简单汇总一下前面的内容。</p>
<p>ASCII码是基础，使用一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容ASCII的，最高位使用1来进行区分。</p>
<p>西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。</p>
<p>我国内地的三个主要编码GB2312、GBK、GB18030有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。</p>
<p>我国香港特别行政区和我国台湾地区的主要编码是Big5。</p>
<p>如果文本里的字符都是ASCII码字符，那么采用以上所说的任一编码方式都是一样的。</p>
<p>但如果有高位为1的字符，除了GB2312、GBK、GB18030外，其他编码都是不兼容的。比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码，具体我们稍后介绍。</p>
<h2 id="2-3-2-Unicode编码"><a href="#2-3-2-Unicode编码" class="headerlink" title="2.3.2 Unicode编码"></a>2.3.2 Unicode编码</h2><p>以上我们介绍了中文和西欧的字符与编码，但世界上还有很多其他国家的字符，每个国家的各种计算机厂商都对自己常用的字符进行编码，在编码的时候基本忽略了其他国家的字符和编码，甚至忽略了同一国家的其他计算机厂商，这样造成的结果就是，出现了太多的编码，且互相不兼容。</p>
<p>世界上所有的字符能不能统一编码呢？可以，这就是Unicode。</p>
<p>Unicode 做了一件事，就是给世界上所有字符都分配了一个唯一的数字编号，这个编号范围从0x000000～0x10FFFF，包括110多万。但大部分常用字符都在0x0000～0xFFFF之间，即65 536个数字之内。每个字符都有一个Unicode编号，这个编号一般写成十六进制，在前面加U+。大部分中文的编号范围为U+4E00～U+9FFF，例如，“马”的Unicode是U+9A6C。</p>
<p>简单理解，Unicode主要做了这么一件事，就是给所有字符分配了唯一数字编号。它并没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，其他编码都既规定了能表示哪些字符，又规定了每个字符对应的二进制是什么，而Unicode本身只规定了每个字符的数字编号是多少。</p>
<p>那编号怎么对应到二进制表示呢？有多种方案，主要有UTF-32、UTF-16和UTF-8。</p>
<h3 id="1-UTF-32"><a href="#1-UTF-32" class="headerlink" title="1. UTF-32"></a>1. UTF-32</h3><p>这个最简单，就是字符编号的整数二进制形式，4个字节。</p>
<p>但有个细节，就是字节的排列顺序，如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫“大端”（Big Endian,BE），否则，就叫“小端”（Little Endian, LE）。对应的编码方式分别是UTF-32BE和UTF-32LE。</p>
<p>可以看出，每个字符都用4个字节表示，非常浪费空间，实际采用的也比较少。</p>
<h3 id="2-UTF-16"><a href="#2-UTF-16" class="headerlink" title="2. UTF-16"></a>2. UTF-16</h3><p>UTF-16使用变长字节表示：</p>
<p>1）对于编号在U+0000～U+FFFF的字符（常用字符集），直接用两个字节表示。需要说明的是，U+D800～U+DBFF的编号其实是没有定义的。</p>
<p>2）字符值在U+10000～U+10FFFF的字符（也叫做增补字符集），需要用4个字节表示。前两个字节叫高代理项，范围是U+D800～U+DBFF；后两个字节叫低代理项，范围是U+DC00～U+DFFF。数字编号和这个二进制表示之间有一个转换算法，本书就不介绍了。</p>
<p>区分是两个字节还是4个字节表示一个字符就看前两个字节的编号范围，如果是U+D800～U+DBFF，就是4个字节，否则就是两个字节。</p>
<p>UTF-16也有和UTF-32一样的字节序问题，如果高位存放在前面就叫大端（BE），编码就叫UTF-16BE，否则就叫小端，编码就叫UTF-16LE。</p>
<p>UTF-16常用于系统内部编码，UTF-16比UTF-32节省了很多空间，但是任何一个字符都至少需要两个字节表示，对于美国和西欧国家而言，还是很浪费的。</p>
<h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>UTF-8使用变长字节表示，每个字符使用的字节个数与其Unicode编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多，使用的字节个数为1～4不等。</p>
<p>具体来说，各个Unicode编号范围对应的二进制格式如表2-6所示。</p>
<center>表2-6 UTF-8编码的编号范围与对应的二进制格式</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150056.jpeg" alt="epub_923038_27"><br>表2-6中的x表示可以用的二进制位，而每个字节开头的1或0是固定的。</p>
<p>小于128的，编码与ASCII码一样，最高位为0。其他编号的第一个字节有特殊含义，最高位有几个连续的1就表示用几个字节表示，而其他字节都以10开头。</p>
<p>对于一个Unicode编号，具体怎么编码呢？首先将其看作整数，转化为二进制形式（去掉高位的0），然后将二进制位从右向左依次填入对应的二进制格式x中，填完后，如果对应的二进制格式还有没填的x，则设为0。</p>
<p>我们来看个例子，“马”的Unicode编号是0x9A6C，整数编号是39 532，其对应的UTF-8二进制格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>

<p>整数编号39 532的二进制格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001 101001 101100</span><br></pre></td></tr></table></figure>

<p>将这个二进制位从右到左依次填入二进制格式中，结果就是其UTF-8编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11101001 10101001 10101100</span><br></pre></td></tr></table></figure>

<p>十六进制表示为0xE9A9AC。</p>
<p>和UTF-32&#x2F;UTF-16不同，UTF-8是兼容ASCII的，对大部分中文而言，一个中文字符需要用三个字节表示。</p>
<h3 id="4-Unicode编码小结"><a href="#4-Unicode编码小结" class="headerlink" title="4. Unicode编码小结"></a>4. Unicode编码小结</h3><p>Unicode给世界上所有字符都规定了一个统一的编号，编号范围达到110多万，但大部分字符都在65 536以内。Unicode本身没有规定怎么把这个编号对应到二进制形式。</p>
<p>UTF-32&#x2F;UTF-16&#x2F;UTF-8都在做一件事，就是把Unicode编号对应到二进制形式，其对应方法不同而已。UTF-32使用4个字节，UTF-16大部分是两个字节，少部分是4个字节，它们都不兼容ASCII编码，都有字节顺序的问题。UTF-8使用1～4个字节表示，兼容ASCII编码，英文字符使用1个字节，中文字符大多用3个字节。</p>
<h2 id="2-3-3-编码转换"><a href="#2-3-3-编码转换" class="headerlink" title="2.3.3 编码转换"></a>2.3.3 编码转换</h2><p>有了Unicode之后，每一个字符就有了多种不兼容的编码方式，比如说“马”这个字符，它的各种编码方式对应的十六进制如表2-7所示。</p>
<center>表2-7 字符“马”多种编码方式</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150313.jpeg" alt="epub_923038_28"><br>这几种格式之间可以借助Unicode编号进行编码转换。可以认为：每种编码都有一个映射表，存储其特有的字符编码和Unicode编号之间的对应关系，这个映射表是一个简化的说法，实际上可能是一个映射或转换方法。</p>
<p>编码转换的具体过程可以是：一个字符从A编码转到B编码，先找到字符的A编码格式，通过A的映射表找到其Unicode编号，然后通过Unicode编号再查B的映射表，找到字符的B编码格式。</p>
<p>举例来说，“马”从GB18030转到UTF-8，先查GB18030-&gt;Unicode编号表，得到其编号是9A 6C，然后查Uncode编号-&gt;UTF-8表，得到其UTF-8编码：E9 A9AC。</p>
<p>编码转换改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>
<h2 id="2-3-4-乱码的原因"><a href="#2-3-4-乱码的原因" class="headerlink" title="2.3.4 乱码的原因"></a>2.3.4 乱码的原因</h2><p>理解了编码，我们来看乱码。乱码有两种常见原因：一种比较简单，就是简单的解析错误；另外一种比较复杂，在错误解析的基础上进行了编码转换。我们分别介绍。</p>
<h3 id="1．解析错误"><a href="#1．解析错误" class="headerlink" title="1．解析错误"></a>1．解析错误</h3><p>看个简单的例子。一个法国人采用Windows-1252编码写了个文件，发送给了一个中国人，中国人使用GB18030来解析这个字符，看到的可能就是乱码。比如，法国人发送的是Pékin, Windows-1252的二进制（采用十六进制）是50 E9 6B 696E，第二个字节E9对应é，其他都是ASCII码，中国人收到的也是这个二进制，但是他把它看成了GB18030编码，GB18030中E9 6B对应的是字符“閗”，于是他看到的就是“P閗in”，这看来就是一个乱码。</p>
<p>反之也是一样的，一个GB18030编码的文件如果被看作Windows-1252也是乱码。</p>
<p>这种情况下，之所以看起来是乱码，是因为看待或者说解析数据的方式错了。只要使用正确的编码方式进行解读就可以纠正了。很多文件编辑器，如EditPlus、NotePad++、UltraEdit都有切换查看编码方式的功能，浏览器也都有切换查看编码方式的功能，如Fire-fox，在菜单“查看”→“文字编码”中即可找到该功能。</p>
<p>切换查看编码的方式并没有改变数据的二进制本身，而只是改变了解析数据的方式，从而改变了数据看起来的样子，这与前面提到的编码转换正好相反。很多时候，做这样一个编码查看方式的切换就可以解决乱码的问题，但有的时候这样是不够的。</p>
<h3 id="2．错误的解析和编码转换"><a href="#2．错误的解析和编码转换" class="headerlink" title="2．错误的解析和编码转换"></a>2．错误的解析和编码转换</h3><p>如果怎么改变查看方式都不对，那很有可能就不仅仅是解析二进制的方式不对，而是文本在错误解析的基础上还进行了编码转换。我们举个例子来说明：</p>
<p>1）两个字“老马”，本来的编码格式是GB18030，编码（十六进制）是C0 CF C2ED。<br>2）这个二进制形式被错误当成了Windows-1252编码，解读成了字符“ÀÏÂí”。<br>3）随后这个字符进行了编码转换，转换成了UTF-8编码，形式还是“ÀÏÂí”，但二进制变成了C3 80 C3 8F C3 82 C3 AD，每个字符两个字节。<br>4）这个时候再按照GB18030解析，字符就变成了乱码形式“脌脧脗铆”，而且这时无论怎么切换查看编码的方式，这个二进制看起来都是乱码。</p>
<p>这种情况是乱码产生的主要原因。</p>
<p>这种情况其实很常见，计算机程序为了便于统一处理，经常会将所有编码转换为一种方式，比如UTF-8，在转换的时候，需要知道原来的编码是什么，但可能会搞错，而一旦搞错并进行了转换，就会出现这种乱码。这种情况下，无论怎么切换查看编码方式都是不行的，如表2-8所示。</p>
<center>表2-8 用不同编码方式查看错误转换后的二进制</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150849.jpeg" alt="epub_923038_29"><br>虽然有这么多形式，但我们看到的乱码形式很可能是“ÀÏÂí”，因为在例子中UTF-8是编码转换的目标编码格式，既然转换为了UTF-8，一般也是要按UTF-8查看。</p>
<p>那有没有办法恢复呢？如果有，怎么恢复呢？</p>
<h2 id="2-3-5-从乱码中恢复"><a href="#2-3-5-从乱码中恢复" class="headerlink" title="2.3.5 从乱码中恢复"></a>2.3.5 从乱码中恢复</h2><p>“乱”主要是因为发生了一次错误的编码转换，所谓恢复，是指要恢复两个关键信息：一个是原来的二进制编码方式A；另一个是错误解读的编码方式B。</p>
<p>恢复的基本思路是尝试进行逆向操作，假定按一种编码转换方式B获取乱码的二进制格式，然后再假定一种编码解读方式A解读这个二进制，查看其看上去的形式，这要尝试多种编码，如果能找到看着正常的字符形式，应该就可以恢复。</p>
<p>这听上去可能比较抽象，我们举个例子来说明，假定乱码形式是“ÀÏÂí”，尝试多种B和A来看字符形式。我们先使用编辑器，以UltraEdit为例，然后使用Java编程来看。</p>
<h3 id="1．使用UltraEdit"><a href="#1．使用UltraEdit" class="headerlink" title="1．使用UltraEdit"></a>1．使用UltraEdit</h3><p>UltraEdit支持编码转换和切换查看编码方式，也支持文件的二进制显示和编辑，所以我们以UltraEdit为例，其他一些编辑器可能也有类似功能。</p>
<p>新建一个UTF-8编码的文件，复制“ÀÏÂí”到文件中。使用编码转换，转换到Win-dows-1252编码，执行“文件”→“转换到”→“西欧”→WIN-1252命令。</p>
<p>转换完后，打开十六进制编辑，查看其二进制形式，如图2-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150903.jpeg" alt="epub_923038_30"></p>
<center>图2-4 使用UltraEdit查看二进制</center>

<p>可以看出，其形式还是“ÀÏÂí”，但二进制格式变成了 C0 CF C2 ED。这个过程相当于假设B是Windows-1252。这个时候，再按照多种编码格式查看这个二进制，在UltraEdit中，关闭十六进制编辑，切换查看编码方式为GB18030，执行“视图”→“查看方式（文件编码）”→“东亚语言”→GB18030命令，切换完后，同样的二进制神奇地变为了正确的字符形式“老马”，打开十六进制编辑器，可以看出二进制还是C0 CF C2 ED，这个GB18030相当于假设A是GB18030。</p>
<p>这个例子我们碰巧第一次就猜对了。实际中，可能要做多次尝试，过程是类似的，先进行编码转换（使用B编码），然后使用不同编码方式查看（使用A编码），如果能找到看上去对的形式，就恢复了。表2-9列出了主要的B编码格式、对应的二进制，以及按A编码解读的各种形式。</p>
<center>表2-9 尝试不同编码方式进行恢复</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150917.jpeg" alt="epub_923038_31"><br>可以看出，第一行是正确的，也就是说原来的编码其实是A即GB18030，但被错误解读成了B即Windows-1252了。</p>
<h3 id="2．使用Java"><a href="#2．使用Java" class="headerlink" title="2．使用Java"></a>2．使用Java</h3><p>下面我们来看如何使用Java恢复乱码。关于使用Java我们还有很多知识没有介绍，为了完整性起见，本节一并列出相关代码，初学者不明白的可以暂时略过。Java中处理字符串的类有String, String中有我们需要的两个重要方法。<br>1）public byte[] getBytes(String charsetName)，这个方法可以获取一个字符串的给定编码格式的二进制形式。<br>2）public String(byte bytes[], String charsetName)，这个构造方法以给定的二进制数组bytes按照编码格式charsetName解读为一个字符串。</p>
<p>将A看作GB18030，将B看作Windows-1252，进行恢复的Java代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;ÀÏÂí&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;windows-1252&quot;</span>), <span class="string">&quot;GB18030&quot;</span>);</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure>

<p>先按照B编码（Windows-1252）获取字符串的二进制，然后按A编码（GB18030）解读这个二进制，得到一个新的字符串，然后输出这个字符串的形式，输出为“老马”。</p>
<p>同样，一次碰巧就对了，实际中，我们可以写一个循环，测试不同的A&#x2F;B编码中的结果形式，如代码清单2-1所示。</p>
<center>代码清单2-1 恢复乱码的方法</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recover</span><span class="params">(String str)</span></span><br><span class="line">        <span class="keyword">throws</span> UnsupportedEncodingException&#123;</span><br><span class="line">    String[] charsets = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">            <span class="string">&quot;windows-1252&quot;</span>, <span class="string">&quot;GB18030&quot;</span>, <span class="string">&quot;Big5&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;charsets.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;charsets.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i! =j)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(charsets[i]), charsets[j]);</span><br><span class="line">                System.out.println(<span class="string">&quot;---- 原来编码(A)假设是： &quot;</span></span><br><span class="line">                    +charsets[j]+<span class="string">&quot;, 被错误解读为了(B): &quot;</span>+charsets[i]);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码使用不同的编码格式进行测试，如果输出有正确的，那么就可以恢复。</p>
<p>可以看出，恢复的尝试需要进行很多次，上面例子尝试了常见编码GB18030、Windows 1252、Big5、UTF-8共12种组合。这4种编码是常见编码，在大部分实际应用中应该够了。如果有其他编码，可以增加一些尝试。</p>
<p>不是所有的乱码形式都是可以恢复的，如果形式中有很多不能识别的字符（如？），则很难恢复。另外，如果乱码是由于进行了多次解析和转换错误造成的，也很难恢复。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/21b11bb9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/21b11bb9/" class="post-title-link" itemprop="url">2.2 小数的二进制表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:02" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:02+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/21b11bb9/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/21b11bb9/" data-xid="/JavaReadingNotes/21b11bb9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-2-小数的二进制表示"><a href="#2-2-小数的二进制表示" class="headerlink" title="2.2 小数的二进制表示"></a>2.2 小数的二进制表示</h1><p>计算机之所以叫“计算”机，就是因为发明它主要是用来计算的，“计算”当然是它的特长，在大家的印象中，计算一定是非常准确的。但实际上，即使在一些非常基本的小数运算中，计算的结果也是不精确的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.1f</span>*<span class="number">0.1f</span>;</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure>

<p>这个结果看上去，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。看上去这么简单的运算，计算机怎么会出错了呢？</p>
<h2 id="2-2-1-小数计算为什么会出错"><a href="#2-2-1-小数计算为什么会出错" class="headerlink" title="2.2.1 小数计算为什么会出错"></a>2.2.1 小数计算为什么会出错</h2><p>实际上，不是运算本身会出错，而是计算机根本就不能精确地表示很多数，比如0.1这个数。计算机是用一种二进制格式存储小数的，这个二进制格式不能精确表示0.1，它只能表示一个非常接近0.1但又不等于0.1的一个数。数字都不能精确表示，在不精确数字上的运算结果不精确也就不足为奇了。</p>
<p>0.1怎么就不能精确表示呢？在十进制的世界里是可以的，但在二进制的世界里不行。在说二进制之前，我们先来看下熟悉的十进制。</p>
<p>实际上，十进制也只能表示那些可以表述为10的多少次方和的数，比如12.345，实际上表示的是1× 10+2× 1+3× 0.1+4× 0.01+5× 0.001，与整数的表示类似，小数点后面的每个位置也都有一个位权，从左到右，依次为0.1,0.01,0.001…即10^(-1),10^(-2),10^(-3)等。</p>
<p>很多数十进制也是不能精确表示的，比如1&#x2F;3，保留三位小数的话，十进制表示是0.333，但无论后面保留多少位小数，都是不精确的，用0.333进行运算，比如乘以3，期望结果是1，但实际上却是0.999。</p>
<p>二进制是类似的，但二进制只能表示那些可以表述为2的多少次方和的数。来看下2的次方的一些例子，如表2-3所示。</p>
<center>表2-3 2的次方</center>


<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211202133501.jpeg" alt="epub_923038_21"><br>可以精确表示为2的某次方之和的数可以精确表示，其他数则不能精确表示。</p>
<p>为什么计算机中不能用我们熟悉的十进制呢？在最底层，计算机使用的电子元器件只能表示两个状态，通常是低压和高压，对应0和1，使用二进制容易基于这些电子元器件构建硬件设备和进行运算。如果非要使用十进制，则这些硬件就会复杂很多，并且效率低下。</p>
<p>如果编写程序进行试验，会发现有的计算结果是准确的。比如，用Java写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.1f</span>+<span class="number">0.1f</span>);</span><br><span class="line">System.out.println(<span class="number">0.1f</span>*<span class="number">0.1f</span>);</span><br></pre></td></tr></table></figure>

<p>第一行输出0.2，第二行输出0.010000001。按照上面的说法，第一行的结果应该也不对。其实，这只是Java语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和0.2足够接近，在输出的时候，Java选择了输出0.2这个看上去非常精简的数字，而不是一个中间有很多0的小数。在误差足够小的时候，结果看上去是精确的，但不精确其实才是常态。</p>
<p>计算不精确，怎么办呢？大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。如果真的需要比较高的精度，一种方法是将小数转化为整数进行运算，运算结束后再转化为小数；另一种方法是使用十进制的数据类型，这个并没有统一的规范。在Java中是BigDecimal，运算更准确，但效率比较低，本节就不介绍了。</p>
<h2 id="2-2-2-二进制表示"><a href="#2-2-2-二进制表示" class="headerlink" title="2.2.2 二进制表示"></a>2.2.2 二进制表示</h2><p>我们之前一直在用“小数”这个词表示float和double类型，其实，这是不严谨的，“小数”是在数学中用的词，在计算机中，我们一般说的是“浮点数”。float和double被称为浮点数据类型，小数运算被称为浮点运算。</p>
<p>为什么要叫浮点数呢？这是由于小数的二进制表示中，表示那个小数点的时候，点不是固定的，而是浮动的。</p>
<p>我们还是用十进制类比，十进制有科学记数法，比如123.45这个数，直接这么写，就是固定表示法，如果用科学记数法，在小数点前只保留一位数字，可以写为1.2345E2即1.2345× (10^2)，即在科学记数法中，小数点向左浮动了两位。</p>
<p>二进制中为表示小数，也采用类似的科学表示法，形如m× (2^e)。m称为尾数，e称为指数。指数可以为正，也可以为负，负的指数表示那些接近0的比较小的数。在二进制中，单独表示尾数部分和指数部分，另外还有一个符号位表示正负。</p>
<p>几乎所有的硬件和编程语言表示小数的二进制格式都是一样的。这种格式是一个标准，叫做IEEE 754标准，它定义了两种格式：一种是32位的，对应于Java的float；另一种是64位的，对应于Java的double。</p>
<p>32位格式中，1位表示符号，23位表示尾数，8位表示指数。64位格式中，1位表示符号，52位表示尾数，11位表示指数。在两种格式中，除了表示正常的数，标准还规定了一些特殊的二进制形式表示一些特殊的值，比如负无穷、正无穷、0、NaN（非数值，比如0乘以无穷大）。IEEE 754标准有一些复杂的细节，初次看上去难以理解，对于日常应用也不常用，本书就不介绍了。</p>
<p>如果想查看浮点数的具体二进制形式，在Java中，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(Float.floatToIntBits(value))</span><br><span class="line">Long.toBinaryString(Double.doubleToLongBits(value));</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/9f845784/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/9f845784/" class="post-title-link" itemprop="url">2.0 第2章 理解数据背后的二进制 2.1 整数的二进制表示与位运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/9f845784/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/9f845784/" data-xid="/JavaReadingNotes/9f845784/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第2章-理解数据背后的二进制"><a href="#第2章-理解数据背后的二进制" class="headerlink" title="第2章 理解数据背后的二进制"></a>第2章 理解数据背后的二进制</h1><p>在第1章，我们遗留了几个问题。</p>
<ul>
<li>正整数相乘的结果居然出现了负数。</li>
<li>非常基本的小数运算结果居然不精确。</li>
<li>字符类型也可以进行算术运算和比较。</li>
</ul>
<p>要理解这些行为，我们需要理解数值和文本字符在计算机内部的二进制表示，本章就来介绍各种数据背后的二进制，具体分为4节：2.1节介绍整数；2.2节介绍小数；2.3节介绍与语言无关的字符和文本的编码以及乱码；2.4节介绍Java中表示字符的基本类型char。</p>
<h1 id="2-1-整数的二进制表示与位运算"><a href="#2-1-整数的二进制表示与位运算" class="headerlink" title="2.1 整数的二进制表示与位运算"></a>2.1 整数的二进制表示与位运算</h1><p>要理解整数的二进制，我们先来看下熟悉的十进制。我们对十进制是如此熟悉，可能已忽略了它的含义。比如123，不假思索我们就知道它的值是多少。</p>
<p>但其实123表示1× (10^2)+2× (10^1)+3× (10^0)（10^2表示10的二次方），它表示的是各个位置数字含义之和，每个位置的数字含义与位置有关，从右向左，第一位乘以10的0次方，即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，以此类推。</p>
<p>换句话说，每个位置都有一个<strong>位权</strong>，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，以此类推。</p>
<h2 id="2-1-1-正整数的二进制表示"><a href="#2-1-1-正整数的二进制表示" class="headerlink" title="2.1.1 正整数的二进制表示"></a>2.1.1 正整数的二进制表示</h2><p>正整数的二进制表示与此类似，只是在十进制中，每个位置可以有10个数字，为0～9，但在二进制中，每个位置只能是0或1。位权的概念是类似的，从右到左，第一位为1，然后依次乘以2，即第二位为2，第三位为4，以此类推。表2-1列出了一些数字的二进制与对应的十进制。</p>
<center>表2-1 二进制与对应的十进制</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201223406.jpeg" alt="epub_923038_19"></p>
<h3 id="2-1-2-负整数的二进制表示"><a href="#2-1-2-负整数的二进制表示" class="headerlink" title="2.1.2 负整数的二进制表示"></a>2.1.2 负整数的二进制表示</h3><p>十进制的负数表示就是在前面加一个负数符号-，例如-123。但二进制如何表示负数呢？其实概念是类似的，二进制使用最高位表示符号位，用1表示负数，用0表示正数。但哪个是最高位呢？整数有4种类型byte、short、int、long，分别占1、2、4、8个字节，即分别占8、16、32、64位，每种类型的符号位都是其最左边的一位。为方便举例，下面假定类型是byte，即从右到左的第8位表示符号位。</p>
<p>但负数表示不是简单地将最高位变为1，比如：<br>1）byte a&#x3D;-1，如果只是将最高位变为1，二进制应该是10000001，但实际上，它应该是11111111。<br>2）byte a&#x3D;-127，如果只是将最高位变为1，二进制应该是11111111，但实际上，它却应该是10000001。</p>
<p>和我们的直觉正好相反，这是什么表示法？这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加1。取反就是将0变为1,1变为0。负数的二进制表示就是对应的正数的补码表示，比如：<br>1）-1:1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。<br>2）-2:2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。<br>3）-127:127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。</p>
<p>给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样。</p>
<p>对于byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是-128～127。其他类型的整数也类似，负数能多表示一个数。</p>
<p>负整数为什么要采用这种奇怪的表示形式呢？原因是，只有这种形式，计算机才能实现正确的加减法。</p>
<p>计算机其实只能做加法，1-1其实是1+(-1)。如果用原码表示，计算结果是不对的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   -&gt; 00000001</span><br><span class="line">-1 -&gt; 10000001</span><br><span class="line">+ ------------------</span><br><span class="line">-2 -&gt; 10000010</span><br></pre></td></tr></table></figure>

<p>用符合直觉的原码表示，1-1的结果是-2，如果是补码表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   -&gt; 00000001</span><br><span class="line">-1 -&gt; 11111111</span><br><span class="line">+ ------------------</span><br><span class="line">0   -&gt; 00000000</span><br></pre></td></tr></table></figure>

<p>结果是正确的。再如，5-3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5   -&gt; 00000101</span><br><span class="line">-3 -&gt; 11111101</span><br><span class="line">+ ------------------</span><br><span class="line">2   -&gt; 00000010</span><br></pre></td></tr></table></figure>

<p>结果也是正确的。就是这样，看上去可能比较奇怪和难以理解，但这种表示其实是非常严谨和正确的，是不是很奇妙？</p>
<p>理解了二进制加减法，我们就能理解为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是1，然后就会被看作负数。比如，127+1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127    -&gt; 01111111</span><br><span class="line">1      -&gt; 00000001</span><br><span class="line">+ ------------------</span><br><span class="line">-128   -&gt; 10000000</span><br></pre></td></tr></table></figure>

<p>计算结果超出了byte的表示范围，会被看作-128。</p>
<h2 id="2-1-3-十六进制"><a href="#2-1-3-十六进制" class="headerlink" title="2.1.3 十六进制"></a>2.1.3 十六进制</h2><p>二进制写起来太长，为了简化写法，可以将4个二进制位简化为一个0～15的数，10～15用字符A～F表示，这种表示方法称为十六进制，如表2-2所示。</p>
<center>表2-2 十六进制</center>


<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201223630.jpeg" alt="epub_923038_20"><br>可以用十六进制直接写常量数字，在数字前面加0x即可。比如十进制的123，用十六进制表示是0x7B，即123&#x3D;7×16+11。给整数赋值或者进行运算的时候，都可以直接使用十六进制，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 0x7B;</span><br></pre></td></tr></table></figure>

<p>Java 7之前不支持直接写二进制常量。比如，想写二进制形式的11001, Java 7之前不能直接写，可以在前面补0，补足8位，为00011001，然后用十六进制表示，即0x19。Java 7开始支持二进制常量，在前面加0b或0B即可，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 0b11001;</span><br></pre></td></tr></table></figure>

<p>在Java中，可以方便地使用Integer和Long的方法查看整数的二进制和十六进制表示，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 25;</span><br><span class="line">System.out.println(Integer.toBinaryString(a)); //二进制</span><br><span class="line">System.out.println(Integer.toHexString(a));  //十六进制</span><br><span class="line">System.out.println(Long.toBinaryString(a)); //二进制</span><br><span class="line">System.out.println(Long.toHexString(a));  //十六进制</span><br></pre></td></tr></table></figure>

<h2 id="2-1-4-位运算"><a href="#2-1-4-位运算" class="headerlink" title="2.1.4 位运算"></a>2.1.4 位运算</h2><p>理解了二进制表示，我们来看二进制级别的操作：位运算。Java 7之前不能单独表示一个位，但可以用byte表示8位，用十六进制写二进制常量。比如，0010表示成十六进制是0x2,110110表示成十六进制是0x36。</p>
<p>位运算有移位运算和逻辑运算。移位有以下几种。<br>1）左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看作整数，左移1位就相当于乘以2。<br>2）无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。<br>3）有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看作整数，右移1位相当于除以2。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 4; //100</span><br><span class="line">a = a &gt;&gt; 2; //001，等于1</span><br><span class="line">a = a &lt;&lt; 3 //1000，变为8</span><br></pre></td></tr></table></figure>

<p>逻辑运算有以下几种。</p>
<ul>
<li>按位与&amp;：两位都为1才为1。</li>
<li>按位或|：只要有一位为1，就为1。</li>
<li>按位取反~:1变为0,0变为1。</li>
<li>按位异或^：相异为真，相同为假。</li>
</ul>
<p>大部分都比较简单，如下所示，具体就不赘述了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = …;</span><br><span class="line">a = a &amp; 0x1 //返回0或1，就是a最右边一位的值</span><br><span class="line">a   = a | 0x1 //不管a原来最右边一位是什么，都将设为1</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d32d4643/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d32d4643/" class="post-title-link" itemprop="url">3.2 类的组合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC3%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第3章 类的基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d32d4643/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d32d4643/" data-xid="/JavaReadingNotes/d32d4643/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="3-2-类的组合"><a href="#3-2-类的组合" class="headerlink" title="3.2 类的组合"></a>3.2 类的组合</h1><p>程序是用来解决现实问题的，将现实中的概念映射为程序中的概念，是初学编程过程中的一步跨越。本节通过一些例子来演示如何将一些现实概念和问题通过类以及类的组合来表示和处理，涉及的概念包括图形处理、电商、人之间的血缘关系以及计算机中的文件和目录。</p>
<p>我们先介绍两个基础类String和Date，它们都是Java API中的类，分别表示文本字符串和日期。</p>
<h2 id="3-2-1-String和Date"><a href="#3-2-1-String和Date" class="headerlink" title="3.2.1 String和Date"></a>3.2.1 String和Date</h2><p>String是Java API中的一个类，表示多个字符，即一段文本或字符串，它内部是一个char的数组，提供了若干方法用于操作字符串。</p>
<p>String可以用一个字符串常量初始化，字符串常量用双引号括起来（注意与字符常量区别，字符常量是用单引号）。例如，如下语句声明了一个String变量name，并赋值为“老马说编程”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;老马说编程&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>String类提供了很多方法，用于操作字符串。在Java中，由于String用得非常普遍， Java对它有一些特殊的处理，本节暂不介绍这些内容，只是把它当作一个表示字符串的类型来看待。</p>
<p>Date也是Java API中的一个类，表示日期和时间，它内部是一个long类型的值，也提供了若干方法用于操作日期和时间。</p>
<p>用无参的构造方法新建一个Date对象，这个对象就表示当前时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>

<p>日期和时间处理是一个比较大的话题，我们留待第7章详解，本节我们只是把它当作表示日期和时间的类型来看待。</p>
<h2 id="3-2-2-图形类"><a href="#3-2-2-图形类" class="headerlink" title="3.2.2 图形类"></a>3.2.2 图形类</h2><p>我们先扩展一下Point类，在其中增加一个方法，计算到另一个点的距离，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point p)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x-p.getX(), <span class="number">2</span>)+Math.pow(y-p.getY(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类Point中，属性x、y都是基本类型，但类的属性也可以是类。我们考虑一个表示线的类，它由两个点组成，有一个实例方法计算线的长度，如代码清单3-2所示。</p>
<center>代码清单3-2 表示线的类Line</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point start;</span><br><span class="line">    <span class="keyword">private</span> Point end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">(Point start, Point end)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start= start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start.distance(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Line由两个Point组成，在创建Line时这两个Point是必需的，所以只有一个构造方法，且需传递这两个点，length方法计算线的长度，它调用了Point计算距离的方法获取线的长度。可以看出，<strong>在设计线时，我们考虑的层次是点，而不考虑点的内部细节。每个类封装其内部细节，对外提供高层次的功能，使其他类在更高层次上考虑和解决问题，是程序设计的一种基本思维方式</strong>。</p>
<p>使用这个类的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">start</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="type">Point</span> <span class="variable">end</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="type">Line</span> <span class="variable">line</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Line</span>(start, end);</span><br><span class="line">    System.out.println(line.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也很简单。我们再说明一下内存布局，line的两个实例成员都是引用类型，引用实际的point，整体内存布局如图3-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208153346.jpeg" alt="epub_923038_36"></p>
<center>图3-1 图形类Point和Line对象的内存布局</center>

<p>start、end、line三个引用型变量分配在栈中，保存的是实际内容的地址，实际内容保存在堆中，line的两个实例变量line.start和line.end还是引用，同样保存的是实际内容的地址。</p>
<h2 id="3-2-3-用类描述电商概念"><a href="#3-2-3-用类描述电商概念" class="headerlink" title="3.2.3 用类描述电商概念"></a>3.2.3 用类描述电商概念</h2><p>接下来，我们用类来描述一下电商系统中的一些基本概念，电商系统中最基本的有产品、用户和订单。</p>
<p>1）产品：有产品唯一id、名称、描述、图片、价格等属性。<br>2）用户：有用户名、密码等属性。<br>3）订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。</p>
<p>当然，实际情况可能非常复杂，这是一个非常简化的描述。</p>
<p>产品类Product如代码清单3-3所示。</p>
<center>代码清单3-3 表示产品的类Product</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="comment">//唯一id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//产品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//产品图片链接</span></span><br><span class="line">    <span class="keyword">private</span> String pictureUrl;</span><br><span class="line">    <span class="comment">//产品描述</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">//产品价格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们省略了类的构造方法，以及属性的getter&#x2F;setter方法，下面大部分示例代码也都会省略。</p>
<p>这是用户类User的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个订单可能会有多个产品，每个产品可能有不同的数量，我们用订单条目OrderItem这个类来描述单个产品及选购的数量，如代码清单3-4所示。</p>
<center>代码清单3-4 表示订单条目的类OrderItem</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderItem</span> &#123;</span><br><span class="line">    <span class="comment">//购买产品</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">//购买数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> quantity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderItem</span><span class="params">(Product product, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">        <span class="built_in">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computePrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product.getPrice()＊quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OrderItem引用了产品类Product，我们定义了一个构造方法，以及计算该订单条目价格的方法。</p>
<p>订单类Order如代码清单3-5所示。</p>
<center>代码清单3-5 表示订单的类Order</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">//订单号</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//购买用户</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">//购买产品列表及数量</span></span><br><span class="line">    <span class="keyword">private</span> OrderItem[] items;</span><br><span class="line">    <span class="comment">//下单时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String   receiver;</span><br><span class="line">    <span class="comment">//收货地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">//订单状态</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">computeTotalPrice</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">totalPrice</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(items! =<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(OrderItem item : items)&#123;</span><br><span class="line">                totalPrice+=item.computePrice();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Order类引用了用户类User，以及一个订单条目的数组OrderItem，它定义了一个计算总价的方法。这里用一个String类表示状态status，更合适的应该是枚举类型，枚举我们第5章再介绍。</p>
<p>以上类定义是非常简化的，但是大致演示了将现实概念映射为类以及类组合的过程，这个过程大概就是，<strong>想想现实问题有哪些概念，这些概念有哪些属性、哪些行为，概念之间有什么关系，然后定义类、定义属性、定义方法、定义类之间的关系。概念的属性和行为可能是非常多的，但定义的类只需要包括那些与现实问题相关的就行了</strong>。</p>
<h2 id="3-2-4-用类描述人之间的血缘关系"><a href="#3-2-4-用类描述人之间的血缘关系" class="headerlink" title="3.2.4 用类描述人之间的血缘关系"></a>3.2.4 用类描述人之间的血缘关系</h2><p>上面介绍的图形类和电商类只会引用别的类，但一个类定义中还可以引用它自己，比如我们要描述人以及人之间的血缘关系。我们用类Person表示一个人，它的实例成员包括其父亲、母亲、和孩子，这些成员也都是Person类型，如代码清单3-6所示。</p>
<center>代码清单3-6 表示人的类Person</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//父亲</span></span><br><span class="line">    <span class="keyword">private</span> Person father;</span><br><span class="line">    <span class="comment">//母亲</span></span><br><span class="line">    <span class="keyword">private</span> Person mother;</span><br><span class="line">    <span class="comment">//孩子数组</span></span><br><span class="line">    <span class="keyword">private</span> Person[] children;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样省略了setter&#x2F;getter方法。对初学者，初看起来这是比较难以理解的，有点类似于函数调用中的递归调用，这里面的关键点是，实例变量不需要一开始就有值。我们来看下如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">laoma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;老马&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">xiaoma</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小马&quot;</span>);</span><br><span class="line">    xiaoma.setFather(laoma);</span><br><span class="line">    laoma.setChildren(<span class="keyword">new</span> <span class="title class_">Person</span>[]&#123;xiaoma&#125;);</span><br><span class="line">    System.out.println(xiaoma.getFather().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码先创建了老马（laoma），然后创建了小马（xiaoma），接着调用xiaoma的set-Father方法和laoma的setChildren方法设置了父子关系，Person类对象的内存布局如图3-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208153756.jpeg" alt="epub_923038_37"></p>
<center>图3-2 Person类对象的内存布局</center>

<h2 id="3-2-5-目录和文件"><a href="#3-2-5-目录和文件" class="headerlink" title="3.2.5 目录和文件"></a>3.2.5 目录和文件</h2><p>接下来，我们介绍两个类MyFile和MyFolder，分别表示文件管理中的两个概念：文件和文件夹。文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。文件类MyFile如代码清单3-7所示。代码清单3-7 文件类MyFile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line">    <span class="comment">//文件名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//文件大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//上级目录</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder parent;</span><br><span class="line">    <span class="comment">//其他方法……</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件夹类MyFolder如代码清单3-8所示。</p>
<center>代码清单3-8 文件夹类MyFolder</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFolder</span> &#123;</span><br><span class="line">    <span class="comment">//文件夹名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//上级文件夹</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder parent;</span><br><span class="line">    <span class="comment">//包含的文件</span></span><br><span class="line">    <span class="keyword">private</span> MyFile[] files;</span><br><span class="line">    <span class="comment">//包含的子文件夹</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder[] subFolders;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(files! =<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(MyFile file : files)&#123;</span><br><span class="line">                totalSize+=file.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(subFolders! =<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(MyFolder folder : subFolders)&#123;</span><br><span class="line">                totalSize+=folder.totalSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyFile和MyFolder都省略了构造方法、settter&#x2F;getter方法，以及关于父子关系维护的代码，主要演示实例变量间的组合关系。<strong>两个类之间可以互相引用，MyFile引用了MyFolder，而MyFolder也引用了MyFile</strong>，这是没有问题的。因为正如之前所说，这些属性不需要一开始就设置，也不是必须设置的。另外，演示了一个递归方法totalSize()，返回当前文件夹下所有文件的大小，这是使用递归函数的一个很好的场景。</p>
<h2 id="3-2-6-一些说明"><a href="#3-2-6-一些说明" class="headerlink" title="3.2.6 一些说明"></a>3.2.6 一些说明</h2><p>类中应该定义哪些变量和方法，这是与要解决的问题密切相关的，本节中并没有特别强调问题是什么，定义的属性和方法主要用于演示基本概念，实际应用中应该根据具体问题进行调整。</p>
<p>类中实例变量的类型可以是当前定义的类型，两个类之间可以互相引用，这些初听起来可能难以理解，但现实世界就是这样的，创建对象的时候这些值不需要一开始就有，也可以没有，所以是没有问题的。</p>
<p>类之间的组合关系在Java中实现的都是引用，但在逻辑关系上，有两种明显不同的关系，一种是包含，另一种是单纯引用。比如，在订单类Order中，Order与User的关系就是单纯引用，User是独立存在的；而Order与OrderItem的关系就是包含，OrderItem总是从属于某一个Order。</p>
<h2 id="3-2-7-小结"><a href="#3-2-7-小结" class="headerlink" title="3.2.7 小结"></a>3.2.7 小结</h2><p>对初学编程的人来说，不清楚如何用程序概念表示现实问题，本节通过一些简化的例子来解释如何将现实中的概念映射为程序中的类。</p>
<p>分解现实问题中涉及的概念以及概念间的关系，将概念表示为多个类，通过类之间的组合来表达更为复杂的概念以及概念间的关系，是计算机程序的一种基本思维方式。</p>
<p>正所谓，道生一，一生二，二生三，三生万物，如果将二进制表示和运算看作一，将基本数据类型看作二，基本数据类型形成的类看作三，那么，类的组合以及下章介绍的继承则使得三生万物。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/4bc606d7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/4bc606d7/" class="post-title-link" itemprop="url">3.3 代码的组织机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC3%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第3章 类的基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/4bc606d7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/4bc606d7/" data-xid="/JavaReadingNotes/4bc606d7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="3-3-代码的组织机制"><a href="#3-3-代码的组织机制" class="headerlink" title="3.3 代码的组织机制"></a>3.3 代码的组织机制</h1><p>使用任何语言进行编程都有一个类似的问题，那就是如何组织代码。具体来说，如何避免命名冲突？如何合理组织各种源文件？如何使用第三方库？各种代码和依赖库如何编译链接为一个完整的程序？本节就来讨论Java中的解决机制，具体包括包、jar包、程序的编译与链接等。</p>
<h2 id="3-3-1-包的概念"><a href="#3-3-1-包的概念" class="headerlink" title="3.3.1 包的概念"></a>3.3.1 包的概念</h2><p>使用任何语言进行编程都有一个相同的问题，就是命名冲突。程序一般不全是一个人写的，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人就不同的目的可能定义同样的类名&#x2F;接口名，Java中解决这个问题的主要方法就是<strong>包</strong>。</p>
<p>即使代码都是一个人写的，将多个关系不太大的类和接口都放在一起，也不便于理解和维护，Java中组织类和接口的方式也是包。</p>
<p>包是一个比较容易理解的概念，类似于计算机中的文件夹，正如我们在计算机中管理文件，文件放在文件夹中一样，类和接口放在包中，为便于组织，文件夹一般是一个层次结构，包也类似。</p>
<p>包有包名，这个名称以点号（.）分隔表示层次结构。比如，我们之前常用的String类就位于包java.lang下，其中java是上层包名，lang是下层包名。带完整包名的类名称为其<strong>完全限定名</strong>，比如String类的完全限定名为java.lang.String。Java API中所有的类和接口都位于包Java或javax下，Java是标准包，javax是扩展包。</p>
<p>接下来，我们讨论包的细节，包括包的声明、使用和包范围可见性。</p>
<h3 id="1．声明类所在的包"><a href="#1．声明类所在的包" class="headerlink" title="1．声明类所在的包"></a>1．声明类所在的包</h3><p>我们之前定义类的时候没有定义其所在的包，默认情况下，类位于默认包下，使用默认包是不建议的，我们使用默认包只是简单起见。</p>
<p>定义类的时候，应该先使用关键字package声明其包名，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuo.laoma;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="comment">//类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上声明类Hello的包名为shuo.laoma，包声明语句应该位于源代码的最前面，前面不能有注释外的其他语句。</p>
<p>包名和文件目录结构必须匹配，如果源文件的根目录为E:\src\，则上面的Hello类对应的文件Hello.java，其全路径就应该是E:\src\shuo\laoma\Hello.java。如果不匹配，Java会提示编译错误。</p>
<p>为避免命名冲突，Java中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是apache.org，包名就以org.apache开头。</p>
<p>没有域名的也没关系，使用一个其他代码不太会用的包名即可，比如本节使用的shuo. laoma。如果代码需要公开给其他人用，最好有一个域名以确保唯一性，如果只是内部使用，则确保内部没有其他代码使用该包名即可。</p>
<p>除了避免命名冲突，包也是一种方便组织代码的机制。一般而言，同一个项目下的所有代码都有一个相同的包前缀，这个前缀是唯一的，不会与其他代码重名，在项目内部，根据不同目的再细分为子包，子包可能又会分为下一级子包，形成层次结构，内部实现一般位于比较底层的包。</p>
<p>包可以方便模块化开发，不同功能可以位于不同包内，不同开发人员负责不同的包。包也可以方便封装，供外部使用的类可以放在包的上层，而内部的实现细节则可以放在比较底层的子包内。</p>
<h3 id="2．通过包使用类"><a href="#2．通过包使用类" class="headerlink" title="2．通过包使用类"></a>2．通过包使用类</h3><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包。使用有两种方式：一种是通过类的完全限定名；另外一种是将用到的类引入当前类。只有一个例外，java.lang包下的类可以直接使用，不需要引入，也不需要使用完全限定名，比如String类、System类，其他包内的类则不行。</p>
<p>看个例子，使用Arrays类中的sort方法，通过完全限定名可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">java.util.Arrays.sort(arr);</span><br><span class="line">System.out.println(java.util.Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>显然，这样比较烦琐，另外一种就是将该类引入当前类。引入的关键字是import,import需要放在package定义之后，类定义之前，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuo.laoma;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做import操作时，可以一次将某个包下的所有类引入，语法是使用<code>.*</code>，比如，将<code>java.util</code>包下的所有类引入，语法是：<code>import java.util.*</code>。需要注意的是，这个引入不能递归，它只会引入<code>java.util</code>包下的直接类，而不会引入<code>java.util</code>下嵌套包内的类，比如，不会引入包<code>java.util.zip</code>下面的类。试图嵌套引入的形式也是无效的，如<code>import java.util.*.*</code>。</p>
<p>在一个类内，对其他类的引用必须是唯一确定的，不能有重名的类，如果有，则通过import只能引入其中的一个类，其他同名的类则必须要使用完全限定名。</p>
<p>引入类是一个比较烦琐的工作，不过，大多数Java开发环境都提供工具自动做这件事。比如，在Eclipse中，通过执行Source→Organize Imports命令或按对应的快捷键Ctrl+Shift+O就可以自动管理引用的类。</p>
<p>有一种特殊类型的导入，称为静态导入，它有一个static关键字，可以直接导入类的公开静态方法和成员。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.＊; <span class="comment">//静态导入Arrays中的所有静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out; <span class="comment">//导入静态变量out</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        sort(arr);  <span class="comment">//可以直接使用Arrays中的sort方法</span></span><br><span class="line">        out.println(Arrays.toString(arr)); <span class="comment">//可以直接使用out变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态导入不应过度使用，否则难以区分访问的是哪个类的代码。</p>
<h3 id="3．包范围可见性"><a href="#3．包范围可见性" class="headerlink" title="3．包范围可见性"></a>3．包范围可见性</h3><p>前面章节我们介绍过，对于类、变量和方法，都可以有一个可见性修饰符public&#x2F;private，我们还提到，可以不写修饰符。如果什么修饰符都不写，它的可见性范围就是同一个包内，同一个包内的其他类可以访问，而其他包内的类则不可以访问。</p>
<p>需要说明的是，同一个包指的是同一个直接包，子包下的类并不能访问。比如，类shuo.laoma.Hello和shuo.laoma.inner.Test，其所在的包shuo.laoma和shuo.laoma.inner是两个完全独立的包，并没有逻辑上的联系，Hello类和Test类不能互相访问对方的包可见性方法和属性。</p>
<p>除了public和private修饰符，还有一个与继承有关的修饰符protected。关于protected的细节我们下章介绍，这里需要说明的是，protected<strong>可见性包括包可见性</strong>，也就是说，声明为protected不仅表明子类可以访问，还表明同一个包内的其他类可以访问，即使这些类不是子类也可以。</p>
<p>总结来说，可见性范围从小到大是：private &lt; <strong>默认(包)</strong> &lt; protected &lt; public。</p>
<h2 id="3-3-2-jar包"><a href="#3-3-2-jar包" class="headerlink" title="3.3.2 jar包"></a>3.3.2 jar包</h2><p>为方便使用第三方代码，也为了方便我们写的代码给其他人使用，各种程序语言大多有打包的概念，打包的一般不是源代码，而是编译后的代码。打包将多个编译后的文件打包为一个文件，方便其他程序调用。</p>
<p>在Java中，编译后的一个或多个包的Java class文件可以打包为一个文件，Java中打包命令为jar，打包后的文件扩展名为．jar，一般称之为jar包。</p>
<p>可以使用如下方式打包，首先到编译后的java class文件根目录，然后运行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf &lt;包名&gt;.jar &lt;最上层包名&gt;</span><br></pre></td></tr></table></figure>

<p>比如，对前面介绍的类打包，如果Hello.class位于E:\bin\shuo\laoma\Hello.class，则可以到目录 E:\bin下，然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf hello.jar shuo</span><br></pre></td></tr></table></figure>

<p>hello.jar就是jar包，jar包其实就是一个压缩文件，可以使用解压缩工具打开。</p>
<p>Java类库、第三方类库都是以jar包形式提供的。如何使用jar包呢？将其加入<strong>类路径</strong>（classpath）中即可。类路径是什么呢？我们下面来看。</p>
<h2 id="3-3-3-程序的编译与链接"><a href="#3-3-3-程序的编译与链接" class="headerlink" title="3.3.3 程序的编译与链接"></a>3.3.3 程序的编译与链接</h2><p>从Java源代码到运行的程序，有编译和链接两个步骤。编译是将源代码文件变成扩展名是．class的一种字节码，这个工作一般是由javac命令完成的。链接是在运行时动态执行的，.class文件不能直接运行，运行的是Java虚拟机，虚拟机听起来比较抽象，执行的就是Java命令，这个命令解析．class文件，转换为机器能识别的二进制代码，然后运行。所谓链接就是根据引用到的类加载相应的字节码并执行。</p>
<p>Java编译和运行时，都需要以参数指定一个classpath，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录；对于jar包，路径是jar包的完整名称（包括路径和jar包名）。在Windows系统中，多个路径用分号“; ”分隔；在其他系统中，以冒号“:”分隔。</p>
<p>在Java源代码编译时，Java编译器会确定引用的每个类的完全限定名，确定的方式是根据import语句和classpath。如果导入的是完全限定类名，则可以直接比较并确定。如果是模糊导入（import带．*），则根据classpath找对应父包，再在父包下寻找是否有对应的类。如果多个模糊导入的包下都有同样的类名，则Java会提示编译错误，此时应该明确指定导入哪个类。</p>
<p>Java运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，则首先在内存中解压文件，然后再查看是否有对应的类。</p>
<p>总结来说，<strong>import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并加载类</strong>，编译和运行时都依赖类路径，类路径中的jar文件会被解压缩用于寻找和加载类。</p>
<h2 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h2><p>本节介绍了Java中代码组织的机制、包和jar包，以及程序的编译和链接。将类和接口放在合适的具有层次结构的包内，避免命名冲突，代码可以更为清晰，便于实现封装和模块化开发；通过jar包使用第三方代码，将自身代码打包为jar包供其他程序使用。这些都是解决复杂问题所必需的。</p>
<p>在Java 9中，清晰地引入了<strong>模块</strong>的概念，JDK和JRE都按模块化进行了重构，传统的组织机制依然是支持的，但新的应用可以使用模块。一个应用可由多个模块组成，一个模块可由多个包组成。模块之间可以有一定的依赖关系，一个模块可以导出包给其他模块用，可以提供服务给其他模块用，也可以使用其他模块提供的包，调用其他模块提供的服务。对于复杂的应用，模块化有很多好处，比如更强的封装、更为可靠的配置、更为松散的耦合、更动态灵活等。模块是一个很大的主题，限于篇幅，我们就不详细介绍了。</p>
<p>至此，关于类的基础知识就介绍完了。类之间除了组合关系，还有一种非常重要的关系，那就是继承，我们下章来探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/65d3d518/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/65d3d518/" class="post-title-link" itemprop="url">4.0 第4章 类的继承 4.1 基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/" itemprop="url" rel="index"><span itemprop="name">第4章 类的继承</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/65d3d518/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/65d3d518/" data-xid="/JavaReadingNotes/65d3d518/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第4章-类的继承"><a href="#第4章-类的继承" class="headerlink" title="第4章 类的继承"></a>第4章 类的继承</h1><p>上一章，我们谈到了如何将现实中的概念映射为程序中的概念，我们谈了类以及类之间的组合，现实中的概念间还有一种非常重要的关系，就是<strong>分类</strong>。分类有个根，然后向下不断细化，形成一个层次分类体系，这种例子是非常多的。</p>
<p>1）在自然世界中，生物有动物和植物，动物有不同的科目，食肉动物、食草动物、杂食动物等，食肉动物有狼、豹、虎等，这些又细分为不同的种类。<br>2）打开电商网站，在显著位置一般都有分类列表，比如家用电器、服装，服装有女装、男装，男装有衬衫、牛仔裤等。</p>
<p>计算机程序经常使用类之间的<strong>继承</strong>关系来表示对象之间的分类关系。在继承关系中，有<strong>父类</strong>和<strong>子类</strong>，比如动物类Animal和狗类Dog, Animal是父类，Dog是子类。父类也叫<strong>基类</strong>，子类也叫<strong>派生类</strong>。父类、子类是相对的，一个类B可能是类A的子类，但又是类C的父类。</p>
<p>之所以叫继承，是因为子类继承了父类的属性和行为，父类有的属性和行为子类都有。但子类可以增加子类特有的属性和行为，某些父类有的行为，子类的实现方式可能与父类也不完全一样。</p>
<p>使用继承一方面可以复用代码，公共的属性和行为可以放到父类中，而子类只需要关注子类特有的就可以了；另一方面，不同子类的对象可以更为方便地被统一处理。</p>
<p>本章详细介绍继承。我们先介绍继承的基本概念，然后详述继承的一些细节，理解了继承的用法之后，我们探讨继承实现的基本原理，最后讨论继承的注意事项，解释为什么说继承是把双刃剑，以及如何正确地使用继承。</p>
<h1 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h1><p>本节介绍Java中继承的基本概念，在Java中，所有类都有一个父类Object，我们先来看这个类，然后主要通过图形处理中的一些简单例子来介绍继承的基本概念。</p>
<h2 id="4-1-1-根父类Object"><a href="#4-1-1-根父类Object" class="headerlink" title="4.1.1 根父类Object"></a>4.1.1 根父类Object</h2><p>在Java中，即使没有声明父类，也有一个隐含的父类，这个父类叫Object。Object没有定义属性，但定义了一些方法，如图4-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208154219.jpeg" alt="epub_923038_39"></p>
<center>图4-1 类Object中的方法</center>

<p>本节我们会介绍toString()方法，其他方法我们会在后续章节中逐步介绍。toString()方法的目的是返回一个对象的文本描述，这个方法可以直接被所有类使用。</p>
<p>比如，对于我们上一章介绍的Point类，可以这样使用toString方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(p.toString());</span><br></pre></td></tr></table></figure>

<p>输出类似这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point@76f9aa66</span><br></pre></td></tr></table></figure>

<p>这是什么意思呢？@之前是类名，@之后的内容是什么呢？我们来看下toString()方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getClass().getName() 返回当前对象的类名，hashCode()返回一个对象的哈希值，哈希我们会在后续章节进一步介绍，这里可以理解为是一个整数，这个整数默认情况下，通常是对象的内存地址值，Integer.toHexString(hashCode())返回这个哈希值的十六进制表示。</p>
<p>为什么要这么写呢？写类名是可以理解的，表示对象的类型，而写哈希值则是不得已的，因为Object类并不知道具体对象的属性，不知道怎么用文本描述，但又需要区分不同对象，只能是写一个哈希值。</p>
<p>但子类是知道自己的属性的，子类可以<strong>重写</strong>父类的方法，以反映自己的不同实现。所谓重写，就是定义和父类一样的方法，并重新实现。</p>
<h2 id="4-1-2-方法重写"><a href="#4-1-2-方法重写" class="headerlink" title="4.1.2 方法重写"></a>4.1.2 方法重写</h2><p>上一章，我们介绍了一些图形处理类，其中有Point类，这次我们重写其toString()方法，如代码清单4-1所示。</p>
<center>代码清单4-1 Point类：重写toString()方法</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">(Point point)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(Math.pow(<span class="built_in">this</span>.x-point.getX(),<span class="number">2</span>)</span><br><span class="line">                +Math.pow(<span class="built_in">this</span>.y-point.getY(), <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getY</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;, &quot;</span>+y+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString()方法前面有一个<code>@Override</code>，这表示toString()这个方法是重写的父类的方法，重写后的方法返回Point的x和y坐标的值。重写后，将调用子类的实现。比如，如下代码的输出就变成了(2,3)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(p.toString());</span><br></pre></td></tr></table></figure>

<h2 id="4-1-3-图形类继承体系"><a href="#4-1-3-图形类继承体系" class="headerlink" title="4.1.3 图形类继承体系"></a>4.1.3 图形类继承体系</h2><p>接下来，我们以一些图形处理中的例子来进一步解释。先来看一些图形的例子，如图4-2所示。</p>
<p>这都是一些基本的图形，图形有线、正方形、三角形、圆形等，图形有不同的颜色。接下来，我们定义以下类来说明关于继承的一些概念：</p>
<ul>
<li>父类Shape，表示图形。</li>
<li>类Circle，表示圆。</li>
<li>类Line，表示直线。</li>
<li>类ArrowLine，表示带箭头的直线。</li>
</ul>
<h3 id="1．图形"><a href="#1．图形" class="headerlink" title="1．图形"></a>1．图形</h3><p>所有图形（Shape）都有一个表示颜色的属性，有一个表示绘制的方法，如代码清单4-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208154418.jpeg" alt="epub_923038_40"></p>
<center>图4-2 一些图形的例子</center>


<center>代码清单4-2 类Shape</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_COLOR</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(DEFAULT_COLOR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Shape</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw shape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码非常简单，实例变量color表示颜色，draw方法表示绘制，我们没有写实际的绘制代码，主要是演示继承关系。</p>
<h3 id="2．圆"><a href="#2．圆" class="headerlink" title="2．圆"></a>2．圆</h3><p>圆（Circle）继承自Shape，但包括了额外的属性：中心点和半径，以及额外的方法area，用于计算面积，另外，重写了draw方法，如代码清单4-3所示。</p>
<p>圆（Circle）继承自Shape，但包括了额外的属性：中心点和半径，以及额外的方法area，用于计算面积，另外，重写了draw方法，如代码清单4-3所示。</p>
<center>代码清单4-3 类Circle</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="comment">//中心点</span></span><br><span class="line">    <span class="keyword">private</span> Point center;</span><br><span class="line">    <span class="comment">//半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> r;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(Point center, <span class="type">double</span> r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.center = center;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw circle at &quot;</span> +center.toString()+<span class="string">&quot; with r &quot;</span>+r</span><br><span class="line">                +<span class="string">&quot;, using color : &quot;</span>+getColor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">area</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI＊r＊r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）Java使用extends关键字表示继承关系，一个类最多只能有一个父类；<br>2）子类不能直接访问父类的私有属性和方法。比如，在Circle中，不能直接访问Shape的私有实例变量color；<br>3）除了私有的外，子类继承了父类的其他属性和方法。比如，在Circle的draw方法中，可以直接调用getColor()方法。</p>
<p>使用它的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">center</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//创建圆，赋值给circle</span></span><br><span class="line">    <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(center,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//调用draw方法，会执行Circle的draw方法</span></span><br><span class="line">    circle.draw();</span><br><span class="line">    <span class="comment">//输出圆面积</span></span><br><span class="line">    System.out.println(circle.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">draw circle at (2,3) with r 2.0, using color : black</span><br><span class="line">12.566370614359172</span><br></pre></td></tr></table></figure>

<p>这里比较奇怪的是，color是什么时候赋值的？在new的过程中，父类的构造方法也会执行，且会优先于子类执行。在这个例子中，父类Shape的默认构造方法会在子类Circle的构造方法之前执行。关于new过程的细节，我们会在4.3节进一步介绍。</p>
<h3 id="3．直线"><a href="#3．直线" class="headerlink" title="3．直线"></a>3．直线</h3><p>线（Line）继承自Shape，但有两个点，以及一个获取长度的方法，并重写了draw方法，如代码清单4-4所示。</p>
<center>代码清单4-4 类Line</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Line</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Point start;</span><br><span class="line">    <span class="keyword">private</span> Point end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">(Point start, Point end, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(color);</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">length</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start.distance(end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getStart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Point <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;draw line from &quot;</span></span><br><span class="line">        + start.toString()+<span class="string">&quot; to &quot;</span>+end.toString()</span><br><span class="line">        + <span class="string">&quot;, using color &quot;</span>+<span class="built_in">super</span>.getColor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要说明的是super这个关键字，super用于指代父类，可用于调用父类构造方法，访问父类方法和变量。</p>
<p>1）在Line构造方法中，super(color)表示调用父类的带color参数的构造方法。调用父类构造方法时，super必须放在第一行。<br>2）在draw方法中，super.getColor()表示调用父类的getColor方法，当然不写super.也是可以的，因为这个方法子类没有同名的，没有歧义，当有歧义的时候，通过super．可以明确表示调用父类的方法。<br>3）super同样可以引用父类非私有的变量。</p>
<h3 id="4．带箭头直线"><a href="#4．带箭头直线" class="headerlink" title="4．带箭头直线"></a>4．带箭头直线</h3><p>带箭头直线（ArrowLine）继承自Line，但多了两个属性，分别表示两端是否有箭头，也重写了draw方法，如代码清单4-5所示。</p>
<center>代码清单4-5 类ArrowLine</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrowLine</span> <span class="keyword">extends</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> startArrow;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> endArrow;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrowLine</span><span class="params">(Point start, Point end, String color,</span></span><br><span class="line"><span class="params">            <span class="type">boolean</span> startArrow, <span class="type">boolean</span> endArrow)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(start, end, color);</span><br><span class="line">        <span class="built_in">this</span>.startArrow = startArrow;</span><br><span class="line">        <span class="built_in">this</span>.endArrow = endArrow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.draw();</span><br><span class="line">        <span class="keyword">if</span>(startArrow)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;draw start arrow&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(endArrow)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;draw end arrow&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrowLine继承自Line，而Line继承自Shape, ArrowLine的对象也有Shape的属性和方法。</p>
<p>注意draw()方法的第一行，super.draw()表示调用父类的draw()方法，这时候不带super．是不行的，因为当前的方法也叫draw()。</p>
<p>需要说明的是，这里ArrowLine继承了Line，也可以直接在类Line里加上属性，而不需要单独设计一个类ArrowLine，这里主要是演示继承的层级性。</p>
<h3 id="5．图形管理器"><a href="#5．图形管理器" class="headerlink" title="5．图形管理器"></a>5．图形管理器</h3><p>使用继承的一个好处是可以统一处理不同子类型的对象。比如，我们来看一个图形管理者类，它负责管理画板上的所有图形对象并负责绘制，在绘制代码中，只需要将每个对象当作Shape并调用draw方法就可以了，系统会自动执行子类的draw方法。如代码清单4-6所示。</p>
<center>代码清单4-6 图形管理器类ShapeManager</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Shape[] shapes = <span class="keyword">new</span> <span class="title class_">Shape</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">shapeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addShape</span><span class="params">(Shape shape)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shapeNum&lt;MAX_NUM)&#123;</span><br><span class="line">            shapes[shapeNum++] = shape;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;shapeNum; i++)&#123;</span><br><span class="line">            shapes[i].draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShapeManager使用一个数组保存所有的shape，在draw方法中调用每个shape的draw方法。ShapeManager并不知道每个shape具体的类型，也不关心，但可以调用到子类的draw方法。</p>
<p>我们来看下使用ShapeManager的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ShapeManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeManager</span>();</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">4</span>,<span class="number">4</span>),<span class="number">3</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">Line</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">3</span>,<span class="number">4</span>), <span class="string">&quot;green&quot;</span>));</span><br><span class="line">    manager.addShape(<span class="keyword">new</span> <span class="title class_">ArrowLine</span>(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">5</span>,<span class="number">5</span>), <span class="string">&quot;black&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>));</span><br><span class="line">    manager.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了三个shape，分别是一个圆、直线和带箭头的线，然后加到了shapemanager中，然后调用manager的draw方法。</p>
<p>需要说明的是，在addShape方法中，参数Shape shape，声明的类型是Shape，而实际的类型则分别是Circle、Line和ArrowLine。子类对象赋值给父类引用变量，这叫<strong>向上转型</strong>，转型就是转换类型，向上转型就是转换为父类类型。</p>
<p>变量shape可以引用任何Shape子类类型的对象，这叫<strong>多态，即一种类型的变量，可引用多种实际类型对象</strong>。这样，对于变量shape，它就有两个类型：类型Shape，我们称之为shape的<strong>静态类型</strong>；类型Circle&#x2F;Line&#x2F;ArrowLine，我们称之为shape的<strong>动态类型</strong>。在ShapeManager的draw方法中，shapes[i].draw()调用的是其对应动态类型的draw方法，这称之为方法的<strong>动态绑定</strong>。</p>
<p>为什么要有多态和动态绑定呢？创建对象的代码（ShapeManager以外的代码）和操作对象的代码（ShapeManager本身的代码），经常不在一起，操作对象的代码往往只知道对象是某种父类型，也往往只需要知道它是某种父类型就可以了。</p>
<p><strong>可以说，多态和动态绑定是计算机程序的一种重要思维方式，使得操作对象的程序不需要关注对象的实际类型，从而可以统一处理不同对象，但又能实现每个对象的特有行为</strong>。在4.3节，我们会进一步介绍动态绑定的实现原理。</p>
<h2 id="4-1-4-小结"><a href="#4-1-4-小结" class="headerlink" title="4.1.4 小结"></a>4.1.4 小结</h2><p>本节介绍了继承和多态的基本概念。</p>
<p>1）每个类有且只有一个父类，没有声明父类的，其父类为Object，子类继承了父类非private的属性和方法，可以增加自己的属性和方法，以及重写父类的方法实现。<br>2）new过程中，父类先进行初始化，可通过super调用父类相应的构造方法，没有使用super的情况下，调用父类的默认构造方法。<br>3）子类变量和方法与父类重名的情况下，可通过super强制访问父类的变量和方法。<br>4）子类对象可以赋值给父类引用变量，这叫多态；实际执行调用的是子类实现，这叫动态绑定。</p>
<p>继承和多态的基本概念是比较简单的，子类继承父类，自动拥有父类的属性和行为，并可扩展属性和行为，同时，可重写父类的方法以修改行为。但关于继承，还有很多细节，我们下一节继续讨论。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/af863e05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/af863e05/" class="post-title-link" itemprop="url">4.2 继承的细节</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/" itemprop="url" rel="index"><span itemprop="name">第4章 类的继承</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/af863e05/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/af863e05/" data-xid="/JavaReadingNotes/af863e05/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="4-2-继承的细节"><a href="#4-2-继承的细节" class="headerlink" title="4.2 继承的细节"></a>4.2 继承的细节</h1><p>本节探讨继续的一些细节，具体包括：</p>
<ul>
<li>构造方法；</li>
<li>重名与静态绑定；</li>
<li>重载和重写；</li>
<li>父子类型转换；</li>
<li>继承访问权限（protected）；</li>
<li>可见性重写；</li>
<li>防止继承（final）。</li>
</ul>
<p>下面我们逐个介绍。</p>
<h2 id="4-2-1-构造方法"><a href="#4-2-1-构造方法" class="headerlink" title="4.2.1 构造方法"></a>4.2.1 构造方法</h2><p>前面我们说过，子类可以通过super调用父类的构造方法，如果子类没有通过super调用，则会自动调动父类的默认构造方法，那如果父类没有默认构造方法呢？如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String member;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">(String member)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.member = member;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类只有一个带参数的构造方法，没有默认构造方法。这个时候，它的任何子类都必须在构造方法中通过super调用Base的带参数构造方法，如下所示，否则，Java会提示编译错误。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">(String member)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(member);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是，如果在父类构造方法中调用了可被重写的方法，则可能会出现意想不到的结果。我们来看个例子，下面是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造方法调用了test()方法。这是子类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类有一个实例变量a，初始赋值为123，重写了test()方法，输出a的值。看下使用的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>第一次输出为0，第二次输出为123。第一行为什么是0呢？第一次输出是在new过程中输出的，在new过程中，首先是初始化父类，父类构造方法调用test()方法，test()方法被子类重写了，就会调用子类的test()方法，子类方法访问子类实例变量a，而这个时候子类的实例变量的赋值语句和构造方法还没有执行，所以输出的是其默认值0。</p>
<p>像这样，在父类构造方法中调用可被子类重写的方法，是一种不好的实践，容易引起混淆，应该只调用private的方法。</p>
<h2 id="4-2-2-重名与静态绑定"><a href="#4-2-2-重名与静态绑定" class="headerlink" title="4.2.2 重名与静态绑定"></a>4.2.2 重名与静态绑定</h2><p>4.1节我们提到，子类可以重写父类非private的方法，当调用的时候，会动态绑定，执行子类的方法。那实例变量、静态方法和静态变量呢？它们可以重名吗？如果重名，访问的是哪一个呢？</p>
<p>重名是可以的，重名后实际上有两个变量或方法。private变量和方法只能在类内访问，访问的也永远是当前类的，即：在子类中访问的是子类的；在父类中访问的是父类的，它们只是碰巧名字一样而已，没有任何关系。</p>
<p>public变量和方法，则要看如何访问它。在类内，访问的是当前类的，但子类可以通过super．明确指定访问父类的。在类外，则要看访问变量的静态类型：静态类型是父类，则访问父类的变量和方法；静态类型是子类，则访问的是子类的变量和方法。我们来看个例子，这是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;static_base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base static: &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了一个public静态变量s，一个public实例变量m，一个静态方法staticTest。这是子类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;child_base&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">m</span> <span class="operator">=</span> <span class="string">&quot;child&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child static: &quot;</span>+s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类定义了和父类重名的变量和方法。对于一个子类对象，它就有了两份变量和方法，在子类内部访问的时候，访问的是子类的，或者说，子类变量和方法隐藏了父类对应的变量和方法，下面看一下外部访问的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">    System.out.println(b.s);</span><br><span class="line">    System.out.println(b.m);</span><br><span class="line">    b.staticTest();</span><br><span class="line">    System.out.println(c.s);</span><br><span class="line">    System.out.println(c.m);</span><br><span class="line">    c.staticTest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码创建了一个子类对象，然后将对象分别赋值给了子类引用变量c和父类引用变量b，然后通过b和c分别引用变量和方法。这里需要说明的是，静态变量和静态方法一般通过类名直接访问，但也可以通过类的对象访问。程序输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static_base</span><br><span class="line">base</span><br><span class="line">base static: static_base</span><br><span class="line">child_base</span><br><span class="line">child</span><br><span class="line">child static: child_base</span><br></pre></td></tr></table></figure>
<p>当通过b（静态类型Base）访问时，访问的是Base的变量和方法，当通过c（静态类型Child）访问时，访问的是Child的变量和方法，这称之为<strong>静态绑定</strong>，即访问绑定到变量的静态类型。静态绑定在程序编译阶段即可决定，而动态绑定则要等到程序运行时。<strong>实例变量</strong>、<strong>静态变量</strong>、<strong>静态方法</strong>、<strong>private方法，都是静态绑定的</strong>。</p>
<h2 id="4-2-3-重载和重写"><a href="#4-2-3-重载和重写" class="headerlink" title="4.2.3 重载和重写"></a>4.2.3 重载和重写</h2><p>重载是指方法名称相同但参数签名不同（参数个数、类型或顺序不同），重写是指子类重写与父类相同参数签名的方法。对一个函数调用而言，可能有多个匹配的方法，有时候选择哪一个并不是那么明显。我们来看个例子，这是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base_int_int&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它定义了方法sum，下面是子类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child_long_long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是调用的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    c.sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Child和Base都定义了sum方法，这里调用的是哪个sum方法呢？子类的sum方法参数类型虽然不完全匹配但是是兼容的，父类的sum方法参数类型是完全匹配的。程序输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_int_int</span><br></pre></td></tr></table></figure>

<p>父类类型完全匹配的方法被调用了。如果父类代码改成下面这样呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base_int_long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类方法类型也不完全匹配了。程序输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_int_long</span><br></pre></td></tr></table></figure>

<p>调用的还是父类的方法。父类和子类的两个方法的类型都不完全匹配，为什么调用父类的呢？因为父类的更匹配一些。现在修改一下子类代码，更改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child_int_long&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序输出变为了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child_int_long</span><br></pre></td></tr></table></figure>

<p>终于调用了子类的方法。可以看出，<strong>当有多个重名函数的时候，在决定要调用哪个函数的过程中，首先是按照参数类型进行匹配的，换句话说，寻找在所有重载版本中最匹配的，然后才看变量的动态类型，进行动态绑定</strong>。</p>
<h2 id="4-2-4-父子类型转换"><a href="#4-2-4-父子类型转换" class="headerlink" title="4.2.4 父子类型转换"></a>4.2.4 父子类型转换</h2><p>之前我们说过，子类型的对象可以赋值给父类型的引用变量，这叫向上转型，那父类型的变量可以赋值给子类型的变量吗？或者说可以<strong>向下转型</strong>吗？语法上可以进行强制类型转换，但不一定能转换成功。我们以前面的例子来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)b;</span><br></pre></td></tr></table></figure>

<p>Child c &#x3D; (Child)b就是将变量b的类型强制转换为Child并赋值为c，这是没有问题的，因为b的动态类型就是Child，但下面的代码是不行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> (Child)b;</span><br></pre></td></tr></table></figure>

<p>语法上Java不会报错，但运行时会抛出错误，错误为类型转换异常。</p>
<p>一个父类的变量能不能转换为一个子类的变量，取决于这个父类变量的动态类型（即引用的对象类型）是不是这个子类或这个子类的子类。</p>
<p>给定一个父类的变量能不能知道它到底是不是某个子类的对象，从而安全地进行类型转换呢？答案是可以，通过instanceof关键字，看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canCast</span><span class="params">(Base b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b <span class="keyword">instanceof</span> Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数返回Base类型变量是否可以转换为Child类型，instanceof前面是变量，后面是类，返回值是boolean值，表示变量引用的对象是不是该类或其子类的对象。</p>
<h2 id="4-2-5-继承访问权限protected"><a href="#4-2-5-继承访问权限protected" class="headerlink" title="4.2.5 继承访问权限protected"></a>4.2.5 继承访问权限protected</h2><p>变量和函数有public&#x2F;private修饰符，public表示外部可以访问，private表示只能内部使用，还有一种可见性介于中间的修饰符protected，表示虽然不能被外部任意访问，但可被子类访问。另外，protected还表示可被同一个包中的其他类访问，不管其他类是不是该类的子类。我们来看个例子，这是基类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>   <span class="type">int</span> currentStep;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.currentStep = <span class="number">1</span>;</span><br><span class="line">        step1();</span><br><span class="line">        <span class="built_in">this</span>.currentStep = <span class="number">2</span>;</span><br><span class="line">        step2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>action表示对外提供的行为，内部有两个步骤step1()和step2()，使用currentStep变量表示当前进行到了哪个步骤，step1()、step2()和currentStep是protected的，子类一般不重写action，而只重写step1和step2，同时，子类可以直接访问currentStep查看进行到了哪一步。子类的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child step &quot;</span> + <span class="built_in">this</span>.currentStep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child step &quot;</span> + <span class="built_in">this</span>.currentStep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Child的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.action();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child step 1</span><br><span class="line">child step 2</span><br></pre></td></tr></table></figure>

<p>基类定义了表示对外行为的方法action，并定义了可以被子类重写的两个步骤step1()和step2()，以及被子类查看的变量currentStep，子类通过重写protected方法step1()和step2()来修改对外的行为。</p>
<p>这种思路和设计是一种设计模式，称之为<strong>模板方法</strong>。action方法就是一个模板方法，它定义了实现的模板，而具体实现则由子类提供。<strong>模板方法在很多框架中有广泛的应用，这是使用protected的一种常见场景</strong>。</p>
<h2 id="4-2-6-可见性重写"><a href="#4-2-6-可见性重写" class="headerlink" title="4.2.6 可见性重写"></a>4.2.6 可见性重写</h2><p>重写方法时，一般并不会修改方法的可见性。但我们还是要说明一点，<strong>重写时，子类方法不能降低父类方法的可见性</strong>。不能降低是指，父类如果是public，则子类也必须是public，父类如果是protected，子类可以是protected，也可以是public，即子类可以升级父类方法的可见性但不能降低。看个例子，基类代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">protect</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//以下是不允许的，会有编译错误</span></span><br><span class="line">    <span class="comment">//private void protect()&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//以下是不允许的，会有编译错误</span></span><br><span class="line">    <span class="comment">//protected void open()&#123;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">protect</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要这样规定呢？继承反映的是“is-a”的关系，即子类对象也属于父类，子类必须支持父类所有对外的行为，将可见性降低就会减少子类对外的行为，从而破坏“is-a”的关系，但子类可以增加父类的行为，所以提升可见性是没有问题的。</p>
<h2 id="4-2-7-防止继承final"><a href="#4-2-7-防止继承final" class="headerlink" title="4.2.7 防止继承final"></a>4.2.7 防止继承final</h2><p>4.3节我们会提到，继承是把双刃剑，带来的影响就是，有的时候我们不希望父类方法被子类重写，有的时候甚至不希望类被继承，可以通过final关键字实现。final关键字可以修饰变量，而这是final的另一种用法。一个Java类，默认情况下都是可以被继承的，但加了final关键字之后就不能被继承了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个非final的类，其中的public&#x2F;protected实例方法默认情况下都是可以被重写的，但加了final关键字后就不能被重写了，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不能被重写&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，关于Java继承概念一些细节就介绍完了。但还有些重要的地方我们没有讨论，比如，创建子类对象的具体过程？动态绑定是如何实现的？让我们下节来探讨继承实现的基本原理。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/2f6bd32b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/2f6bd32b/" class="post-title-link" itemprop="url">4.3 继承实现的基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/" itemprop="url" rel="index"><span itemprop="name">第4章 类的继承</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/2f6bd32b/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/2f6bd32b/" data-xid="/JavaReadingNotes/2f6bd32b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="4-3-继承实现的基本原理"><a href="#4-3-继承实现的基本原理" class="headerlink" title="4.3 继承实现的基本原理"></a>4.3 继承实现的基本原理</h1><p>本节通过一个例子来介绍继承实现的基本原理。需要说明的是，本节主要从概念上来介绍原理，实际实现细节可能与此不同。</p>
<h2 id="4-3-1-示例"><a href="#4-3-1-示例" class="headerlink" title="4.3.1 示例"></a>4.3.1 示例</h2><p>基类Base如代码清单4-7所示。</p>
<center>代码清单4-7 演示继承原理：Base类</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;基类静态代码块， s: &quot;</span>+s);</span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;基类实例代码块， a: &quot;</span>+a);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Base</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;基类构造方法， a: &quot;</span>+a);</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;base s: &quot;</span> + s +<span class="string">&quot;, a: &quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        step();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Base包括一个静态变量s，一个实例变量a，一段静态初始化代码块，一段实例初始化代码块，一个构造方法，两个方法step和action。子类Child如代码清单4-8所示。</p>
<center>代码清单4-8 演示继承原理：Child类</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块， s: &quot;</span>+s);</span><br><span class="line">        s = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;子类实例代码块， a: &quot;</span>+a);</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法， a: &quot;</span>+a);</span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">step</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;child s: &quot;</span> + s +<span class="string">&quot;, a: &quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Child继承了Base，也定义了和基类同名的静态变量s和实例变量a，静态初始化代码块，实例初始化代码块，构造方法，重写了方法step。使用的例子如代码清单4-9所示。</p>
<center>代码清单4-9 演示继承原理：main方法</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;---- new Child()&quot;</span>);</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- c.action()&quot;</span>);</span><br><span class="line">    c.action();</span><br><span class="line">    <span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> c;</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- b.action()&quot;</span>);</span><br><span class="line">    b.action();</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- b.s: &quot;</span> + b.s);</span><br><span class="line">    System.out.println(<span class="string">&quot;\n---- c.s: &quot;</span> + c.s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了Child类型的对象，赋值给了Child类型的引用变量c，通过c调用action方法，又赋值给了Base类型的引用变量b，通过b也调用了action，最后通过b和c访问静态变量s并输出。这是屏幕的输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---- new Child()</span><br><span class="line">基类静态代码块， s: 0</span><br><span class="line">子类静态代码块， s: 0</span><br><span class="line">基类实例代码块， a: 0</span><br><span class="line">基类构造方法， a: 1</span><br><span class="line">子类实例代码块， a: 0</span><br><span class="line">子类构造方法， a: 10</span><br><span class="line">---- c.action()</span><br><span class="line">start</span><br><span class="line">child s: 10, a: 20</span><br><span class="line">end</span><br><span class="line">---- b.action()</span><br><span class="line">start</span><br><span class="line">child s: 10, a: 20</span><br><span class="line">end</span><br><span class="line">---- b.s: 1</span><br><span class="line">---- c.s: 10</span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下背后都发生了一些什么事情，从类的加载开始。</p>
<h2 id="4-3-2-类加载过程"><a href="#4-3-2-类加载过程" class="headerlink" title="4.3.2 类加载过程"></a>4.3.2 类加载过程</h2><p>在Java中，所谓类的加载是指将类的相关信息加载到内存。在Java中，类是动态加载的，当第一次使用这个类的时候才会加载，加载一个类时，会查看其父类是否已加载，如果没有，则会加载其父类。<br>1）一个类的信息主要包括以下部分：</p>
<ul>
<li>类变量（静态变量）；</li>
<li>类初始化代码；</li>
<li>类方法（静态方法）；</li>
<li>实例变量；</li>
<li>实例初始化代码；</li>
<li>实例方法；</li>
<li>父类信息引用。<br>2）类初始化代码包括：</li>
<li>定义静态变量时的赋值语句；</li>
<li>静态初始化代码块。<br>3）实例初始化代码包括：</li>
<li>定义实例变量时的赋值语句；</li>
<li>实例初始化代码块；</li>
<li>构造方法。<br>4）类加载过程包括：</li>
<li>分配内存保存类的信息；</li>
<li>给类变量赋默认值；</li>
<li>加载父类；</li>
<li>设置父子关系；</li>
<li>执行类初始化代码。</li>
</ul>
<p>注意，类初始化代码，是先执行父类的，再执行子类的。不过，父类执行时，子类静态变量的值也是有的，是默认值。对于默认值，我们之前说过，数字型变量都是0, boolean是false, char是’\u0000’，引用型变量是null。</p>
<p>之前我们说过，内存分为栈和堆，栈存放函数的局部变量，而堆存放动态分配的对象，还有一个内存区，存放类的信息，这个区在Java中称为<strong>方法区</strong>。</p>
<p>加载后，Java方法区就有了一份这个类的信息。以我们的例子来说，有3份类信息，分别是Child、Base、Object，内存布局如图4-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208181542.jpeg" alt="epub_923038_41"></p>
<center>图4-3 继承原理：类信息内存布局</center>

<p>我们用class_init()来表示类初始化代码，用instance_init()表示实例初始化代码，实例初始化代码包括了实例初始化代码块和构造方法。例子中只有一个构造方法，实际情况则可能有多个实例初始化方法。</p>
<p>本例中，类的加载大致就是在内存中形成了类似上面的布局，然后分别执行了Base和Child的类初始化代码。接下来，我们看对象创建的过程。</p>
<h2 id="4-3-3-对象创建的过程"><a href="#4-3-3-对象创建的过程" class="headerlink" title="4.3.3 对象创建的过程"></a>4.3.3 对象创建的过程</h2><p>在类加载之后，new Child()就是创建Child对象，创建对象过程包括：<br>1）分配内存；<br>2）对所有实例变量赋默认值；<br>3）执行实例初始化代码。</p>
<p>分配的内存包括本类和所有父类的实例变量，但不包括任何静态变量。实例初始化代码的执行从父类开始，再执行子类的。但在任何类执行初始化代码之前，所有实例变量都已设置完默认值。</p>
<p>每个对象除了保存类的实例变量之外，还保存着实际类信息的引用。</p>
<p>Child c &#x3D; new Child()；会将新创建的Child对象引用赋给变量c，而Base b &#x3D; c；会让b也引用这个Child对象。创建和赋值后，内存布局如图4-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208181557.jpeg" alt="epub_923038_42"></p>
<center>图4-4 继承原理：对象内存布局</center>

<p>引用型变量c和b分配在栈中，它们指向相同的堆中的Child对象。Child对象存储着方法区中Child类型的地址，还有Base中的实例变量a和Child中的实例变量a。创建了对象，接下来，来看方法调用的过程。</p>
<h2 id="4-3-4-方法调用的过程"><a href="#4-3-4-方法调用的过程" class="headerlink" title="4.3.4 方法调用的过程"></a>4.3.4 方法调用的过程</h2><p>我们先来看c.action(); ，这句代码的执行过程：<br>1）查看c的对象类型，找到Child类型，在Child类型中找action方法，发现没有，到父类中寻找；<br>2）在父类Base中找到了方法action，开始执行action方法；<br>3）action先输出了start，然后发现需要调用step()方法，就从Child类型开始寻找step()方法；<br>4）在Child类型中找到了step()方法，执行Child中的step()方法，执行完后返回action方法；<br>5）继续执行action方法，输出end。</p>
<p>寻找要执行的实例方法的时候，是从对象的实际类型信息开始查找的，找不到的时候，再查找父类类型信息。</p>
<p>我们来看b.action()，这句代码的输出和c.action()是一样的，这称为<strong>动态绑定，而动态绑定实现的机制就是根据对象的实际类型查找要执行的方法，子类型中找不到的时候再查找父类</strong>。这里，因为b和c指向相同的对象，所以执行结果是一样的。</p>
<p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要进行很多次查找。大多数系统使用一种称为虚方法表的方法来优化调用的效率。</p>
<p>所谓虚方法表，就是在类加载的时候为每个类创建一个表，记录该类的对象所有动态绑定的方法（包括父类的方法）及其地址，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。对于本例来说，Child和Base的虚方法表如图4-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208181615.jpeg" alt="epub_923038_43"></p>
<center>图4-5 继承原理：虚方法表</center>

<p>对Child类型来说，action方法指向Base中的代码，toString方法指向Object中的代码，而step()指向本类中的代码。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。接下来，我们介绍变量访问的过程。</p>
<h2 id="4-3-5-变量访问的过程"><a href="#4-3-5-变量访问的过程" class="headerlink" title="4.3.5 变量访问的过程"></a>4.3.5 变量访问的过程</h2><p><strong>对变量的访问是静态绑定的</strong>，无论是类变量还是实例变量。代码中演示的是类变量：b.s和c.s，通过对象访问类变量，系统会转换为直接访问类变量Base.s和Child.s。</p>
<p>例子中的实例变量都是private的，不能直接访问；如果是public的，则b.a访问的是对象中Base类定义的实例变量a，而c.a访问的是对象中Child类定义的实例变量a。</p>
<p>本节通过一个例子来介绍类的加载、对象创建、方法调用以及变量访问的内部过程。现在，我们应该对继承的实现有了比较清楚的理解。之前我们提到，继承是把双刃剑，为什么这么说呢？让我们下节来探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/9e3ae50a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/9e3ae50a/" class="post-title-link" itemprop="url">4.4 为什么说继承是把双刃剑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC4%E7%AB%A0-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/" itemprop="url" rel="index"><span itemprop="name">第4章 类的继承</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/9e3ae50a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/9e3ae50a/" data-xid="/JavaReadingNotes/9e3ae50a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="4-4-为什么说继承是把双刃剑"><a href="#4-4-为什么说继承是把双刃剑" class="headerlink" title="4.4 为什么说继承是把双刃剑"></a>4.4 为什么说继承是把双刃剑</h1><p>继承其实是把双刃剑：一方面继承是非常强大的；另一方面继承的破坏力也是很强的。</p>
<p>继承广泛应用于各种Java API、框架和类库之中，一方面它们内部大量使用继承，另一方面它们设计了良好的框架结构，提供了大量基类和基础公共代码。使用者可以使用继承，重写适当方法进行定制，就可以简单方便地实现强大的功能。</p>
<p>但，<strong>继承为什么会有破坏力呢？主要是因为继承可能破坏封装，而封装可以说是程序设计的第一原则；另外，继承可能没有反映出is-a关系</strong>。下面我们详细来说明。</p>
<h2 id="4-4-1-继承破坏封装"><a href="#4-4-1-继承破坏封装" class="headerlink" title="4.4.1 继承破坏封装"></a>4.4.1 继承破坏封装</h2><p>什么是封装呢？<strong>封装就是隐藏实现细节，提供简化接口</strong>。使用者只需要关注怎么用，而不需要关注内部是怎么实现的。实现细节可以随时修改，而不影响使用者。函数是封装，类也是封装。通过封装，才能在更高的层次上考虑和解决问题。可以说，封装是程序设计的第一原则，没有封装，代码之间会到处存在着实现细节的依赖，则构建和维护复杂的程序是难以想象的。</p>
<p>继承可能破坏封装是因为<strong>子类和父类之间可能存在着实现细节的依赖</strong>。子类在继承父类的时候，往往不得不关注父类的实现细节，而父类在修改其内部实现的时候，如果不考虑子类，也往往会影响到子类。我们通过一些例子来说明。这些例子主要用于演示，可以基本忽略其实际意义。</p>
<h2 id="4-4-2-封装是如何被破坏的"><a href="#4-4-2-封装是如何被破坏的" class="headerlink" title="4.4.2 封装是如何被破坏的"></a>4.4.2 封装是如何被破坏的</h2><p>我们来看一个简单的例子，基类Base如代码清单4-10所示。</p>
<center>代码清单4-10 继承破坏封装：基类Base</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_NUM</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAX_NUM];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;MAX_NUM)&#123;</span><br><span class="line">            arr[count++] = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : numbers)&#123;</span><br><span class="line">            add(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Base提供了两个方法add和addAll，将输入数字添加到内部数组中。对使用者来说， add和addAll就是能够添加数字，具体是怎么添加的，不用关心。</p>
<p>子类代码Child如代码清单4-11所示。</p>
<center>代码清单4-11 继承破坏封装：子类Child</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.add(number);</span><br><span class="line">        sum+=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.addAll(numbers);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)&#123;</span><br><span class="line">            sum+=numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类重写了基类的add和addAll方法，在添加数字的同时汇总数字，存储数字的和到实例变量sum中，并提供了方法getSum获取sum的值。使用Child的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.addAll(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(c.getSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用addAll添加1、2、3，期望的输出是1+2+3&#x3D;6，实际输出为12！为什么是12呢？查看代码不难看出，同一个数字被汇总了两次。子类的addAll方法首先调用了父类的add-All方法，而父类的addAll方法通过add方法添加，由于动态绑定，子类的add方法会执行，子类的add也会做汇总操作。</p>
<p>可以看出，<strong>如果子类不知道基类方法的实现细节，它就不能正确地进行扩展</strong>。知道了错误，现在我们修改子类实现，修改addAll方法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.addAll(numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，addAll方法不再进行重复汇总。这次，程序就可以输出正确结果6了。</p>
<p>但是，基类Base决定修改addAll方法的实现，改为下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : numbers)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;MAX_NUM)&#123;</span><br><span class="line">            arr[count++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，它不再通过调用add方法添加，这是Base类的实现细节。但是，<strong>修改了基类的内部细节后，上面使用子类的程序却错了</strong>，输出由正确值6变为了0。</p>
<p>从这个例子，可以看出，<strong>子类和父类之间是细节依赖，子类扩展父类，仅仅知道父类能做什么是不够的，还需要知道父类是怎么做的，而父类的实现细节也不能随意修改，否则可能影响子类</strong>。</p>
<p>更具体地说，<strong>子类需要知道父类的可重写方法之间的依赖关系</strong>，具体到上例中，就是add和addAll方法之间的关系，<strong>而且这个依赖关系，父类不能随意改变</strong>。</p>
<p>但<strong>即使这个依赖关系不变，封装还是可能被破坏</strong>。还是上面的例子，我们先将addAll方法改回去，这次，我们在基类Base中添加一个方法clear，这个方法的作用是将所有添加的数字清空，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">        arr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基类添加一个方法不需要告诉子类，Child类不知道Base类添加了这么一个方法，但因为继承关系，Child类却自动拥有了这么一个方法。因此，Child类的使用者可能会这么使用Child类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    c.addAll(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    c.clear();</span><br><span class="line">    c.addAll(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    System.out.println(c.getSum());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先添加一次，之后调用clear清空，又添加一次，最后输出sum，期望结果是6，但实际输出是12。因为Child没有重写clear方法，它需要增加如下代码，重置其内部的sum值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.clear();</span><br><span class="line">    <span class="built_in">this</span>.sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<strong>父类不能随意增加公开方法，因为给父类增加就是给所有子类增加，而子类可能必须要重写该方法才能确保方法的正确性</strong>。</p>
<p>总结一下：<strong>对于子类而言，通过继承实现是没有安全保障的，因为父类修改内部实现细节，它的功能就可能会被破坏；而对于基类而言，让子类继承和重写方法，就可能丧失随意修改内部实现的自由</strong>。</p>
<h2 id="4-4-3-继承没有反映is-a关系"><a href="#4-4-3-继承没有反映is-a关系" class="headerlink" title="4.4.3 继承没有反映is-a关系"></a>4.4.3 继承没有反映is-a关系</h2><p>继承关系是设计用来反映is-a关系的，子类是父类的一种，子类对象也属于父类，父类的属性和行为也适用于子类。就像橙子是水果一样，水果有的属性和行为，橙子也必然都有。</p>
<p>但现实中，设计完全符合is-a关系的继承关系是困难的。比如，绝大部分鸟都会飞，可能就想给鸟类增加一个方法fly()表示飞，但有一些鸟就不会飞，比如企鹅。</p>
<p>在is-a关系中，重写方法时，子类不应该改变父类预期的行为，但是这是没有办法约束的。还是以鸟为例，你可能给父类增加了fly()方法，对企鹅，你可能想，企鹅不会飞，但可以走和游泳，就在企鹅的fly()方法中，实现了有关走或游泳的逻辑。</p>
<p>继承是应该被当作is-a关系使用的，但是，Java并没有办法约束，父类有的属性和行为，子类并不一定都适用，子类还可以重写方法，实现与父类预期完全不一样的行为。</p>
<p>但对于通过父类引用操作子类对象的程序而言，它是把对象当作父类对象来看待的，期望对象符合父类中声明的属性和行为。如果不符合，结果是什么呢？混乱。</p>
<h2 id="4-4-4-如何应对继承的双面性"><a href="#4-4-4-如何应对继承的双面性" class="headerlink" title="4.4.4 如何应对继承的双面性"></a>4.4.4 如何应对继承的双面性</h2><p>继承既强大又有破坏性，那怎么办呢？<br>1）避免使用继承；<br>2）正确使用继承。</p>
<p>我们先来看怎么避免继承，有三种方法：</p>
<ul>
<li>使用final关键字；</li>
<li>优先使用组合而非继承；</li>
<li>使用接口。</li>
</ul>
<h3 id="1．使用final避免继承"><a href="#1．使用final避免继承" class="headerlink" title="1．使用final避免继承"></a>1．使用final避免继承</h3><p>在4.2节，我们提到过final类和final方法，final方法不能被重写，final类不能被继承，我们没有解释为什么需要它们。通过上面的介绍，我们就应该能够理解其中的一些原因了。</p>
<p><strong>给方法加final修饰符，父类就保留了随意修改这个方法内部实现的自由</strong>，使用这个方法的程序也可以确保其行为是符合父类声明的。</p>
<p><strong>给类加final修饰符，父类就保留了随意修改这个类实现的自由</strong>，使用者也可以放心地使用它，而不用担心一个父类引用的变量，实际指向的却是一个完全不符合预期行为的子类对象。</p>
<h2 id="2．优先使用组合而非继承"><a href="#2．优先使用组合而非继承" class="headerlink" title="2．优先使用组合而非继承"></a>2．优先使用组合而非继承</h2><p><strong>使用组合可以抵挡父类变化对子类的影响，从而保护子类，应该优先使用组合</strong>。还是上面的例子，我们使用组合来重写一下子类，如代码清单4-12所示。</p>
<center>代码清单4-12 使用组合实现子类Child</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Base base;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span>&#123;</span><br><span class="line">        base = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        base.add(number);</span><br><span class="line">        sum+=number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        base.addAll(numbers);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)&#123;</span><br><span class="line">            sum+=numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getSum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，子类就不需要关注基类是如何实现的了，基类修改实现细节，增加公开方法，也不会影响到子类了。但组合的问题是，子类对象不能当作基类对象来统一处理了。解决方法是<strong>使用接口</strong>。接口是什么呢？我们留待下章介绍。</p>
<h3 id="3．正确使用继承"><a href="#3．正确使用继承" class="headerlink" title="3．正确使用继承"></a>3．正确使用继承</h3><p>如果要使用继承，怎么正确使用呢？使用继承大概主要有三种场景：<br>1）基类是别人写的，我们写子类；<br>2）我们写基类，别人可能写子类；<br>3）基类、子类都是我们写的。</p>
<p>第1种场景中，基类主要是Java API、其他框架或类库中的类，在这种情况下，我们主要通过扩展基类，实现自定义行为，这种情况下需要注意的是：</p>
<ul>
<li>重写方法不要改变预期的行为；</li>
<li>阅读文档说明，理解可重写方法的实现机制，尤其是方法之间的依赖关系；</li>
<li>在基类修改的情况下，阅读其修改说明，相应修改子类。</li>
</ul>
<p>第2种场景中，我们写基类给别人用，在这种情况下，需要注意的是：</p>
<ul>
<li>使用继承反映真正的is-a关系，只将真正公共的部分放到基类；</li>
<li>对不希望被重写的公开方法添加final修饰符；</li>
<li>写文档，说明可重写方法的实现机制，为子类提供指导，告诉子类应该如何重写；</li>
<li>在基类修改可能影响子类时，写修改说明。</li>
</ul>
<p>第3种场景，我们既写基类也写子类，关于基类，注意事项和第2种场景类似，关于子类，注意事项和第1种场景类似，不过程序都由我们控制，要求可以适当放松一些。</p>
<p>至此，关于继承就介绍完了，本章最后，我们提到了一个概念：接口，接口到底是什么呢？让我们下章探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/JavaReadingNotes/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:07</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/9/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/9/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
