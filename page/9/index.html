<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/9/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/9/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/9/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/49b20a37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/49b20a37/" class="post-title-link" itemprop="url">9.0 第9章 列表和队列 9.1 剖析ArrayList</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 21:37:16" itemprop="dateCreated datePublished" datetime="2021-12-04T21:37:16+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC9%E7%AB%A0-%E5%88%97%E8%A1%A8%E5%92%8C%E9%98%9F%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">第9章 列表和队列</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/49b20a37/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/49b20a37/" data-xid="/JavaReadingNotes/49b20a37/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第9章-列表和队列"><a href="#第9章-列表和队列" class="headerlink" title="第9章 列表和队列"></a>第9章 列表和队列</h1><p>从本章开始，我们探讨Java中的容器类。所谓容器，顾名思义就是容纳其他数据的。计算机课程中有一门课叫数据结构，可以粗略对应于Java中的容器类。容器类可以说是日常程序开发中天天用到的，没有容器类，难以想象能开发什么真正有用的程序。</p>
<p>我们不会介绍所有数据结构的内容，但会介绍Java中的主要实现。在本章中，我们先介绍关于列表和队列的一些主要类，具体包括ArrayList、LinkedList以及ArrayDeque，我们会介绍它们的用法、背后的实现原理、数据结构和算法，以及应用场景等。</p>
<h1 id="9-1-剖析ArrayList"><a href="#9-1-剖析ArrayList" class="headerlink" title="9.1 剖析ArrayList"></a>9.1 剖析ArrayList</h1><p>第8章介绍泛型的时候，我们自己实现了一个简单的动态数组容器类DynaArray，本节将介绍Java中真正的动态数组容器类ArrayList。本节会介绍它的基本用法、迭代操作、实现的一些接口（Collection、List和RandAccess），最后分析它的特点。</p>
<h2 id="9-1-1-基本用法"><a href="#9-1-1-基本用法" class="headerlink" title="9.1.1 基本用法"></a>9.1.1 基本用法</h2><p>ArrayList是一个泛型容器，新建ArrayList需要实例化泛型参数，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<p>ArrayList的主要方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> <span class="comment">//添加元素到末尾</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">//判断是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="comment">//获取长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//访问指定位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> <span class="comment">//查找元素， 如果找到，返回索引位置，否则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> <span class="comment">//从后往前找</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> <span class="comment">//是否包含指定元素，依据是equals方法的返回值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//删除指定位置的元素， 返回值为被删对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除指定对象，只删除第一个相同的对象，返回值表示是否删除了元素</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果o为null，则删除值为null的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="comment">//删除所有元素</span></span></span><br><span class="line"><span class="function"><span class="comment">//在指定位置插入元素，index为0表示插入最前面，index为ArrayList的长度表示插到最后面</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> <span class="comment">//修改指定位置的元素内容</span></span></span><br></pre></td></tr></table></figure>

<p>这些方法简单直接，就不多解释了，我们看个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">strList.add(<span class="string">&quot;老马&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;编程&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strList.size(); i++)&#123;</span><br><span class="line">    System.out.println(strList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-1-2-基本原理"><a href="#9-1-2-基本原理" class="headerlink" title="9.1.2 基本原理"></a>9.1.2 基本原理</h2><p>可以看出，ArrayList的基本用法是比较简单的，它的基本原理也是比较简单的。Array-List的基本原理与我们在上一章介绍的DynaArray类似，内部有一个数组elementData，一般会有一些预留的空间，有一个整数size记录实际的元素个数（基于Java<br>7），如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>我们暂时可以忽略transient这个关键字。各种public方法内部操作的基本都是这个数组和这个整数，elementData会随着实际元素个数的增多而重新分配，而size则始终记录实际的元素个数。</p>
<p>下面，我们具体来看下add和remove方法的实现。add方法的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它首先调用ensureCapacityInternal确保数组容量是够的，ensureCapacityInternal的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它先判断数组是不是空的，如果是空的，则首次至少要分配的大小为DEFAULT_CAPACITY, DEFAULT_CAPACITY的值为10，接下来调用ensureExplicitCapacity，主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span>(minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modCount++是什么意思呢？modCount表示内部的修改次数，modCount++当然就是增加修改次数，为什么要记录修改次数呢？我们待会解释。</p>
<p>如果需要的长度大于当前数组的长度，则调用grow方法，其主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//右移一位相当于除2，所以，newCapacity相当于oldCapacity的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果扩展1.5倍还是小于minCapacity，就扩展为minCapacity</span></span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中已有注释说明，不再赘述。我们再来看remove方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>; <span class="comment">//计算要移动的元素个数</span></span><br><span class="line">    <span class="keyword">if</span>(numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">//将size减1，同时释放引用以便原对象被垃圾回收</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也增加了modCount，然后计算要移动的元素个数，从index往后的元素都往前移动一位，实际调用System.arraycopy方法移动元素。<code>elementData[--size] =null</code>；这行代码将size减1，同时将最后一个位置设为null，设为null后不再引用原来对象，如果原来对象也不再被其他对象引用，就可以被垃圾回收。</p>
<p>其他方法大多是比较简单的，我们就不赘述了。上面的代码中，为便于理解，我们删减了一些边界情况处理的代码，完整代码要晦涩复杂一些，但接口一般都是简单直接的，这就是使用容器类的好处，这也是计算机程序中的基本思维方式，<strong>封装复杂操作，提供简化接口</strong>。</p>
<h2 id="9-1-3-迭代"><a href="#9-1-3-迭代" class="headerlink" title="9.1.3 迭代"></a>9.1.3 迭代</h2><p>理解了ArrayList的基本用法和原理，接下来，我们来看一个ArrayList的常见操作：迭代。我们看一个迭代操作的例子，循环打印ArrayList中的每个元素，ArrayList支持foreach语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">intList.add(<span class="number">123</span>);</span><br><span class="line">intList.add(<span class="number">456</span>);</span><br><span class="line">intList.add(<span class="number">789</span>);</span><br><span class="line"><span class="keyword">for</span>(Integer a : intList)&#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种循环也可以使用如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;intList.size(); i++)&#123;</span><br><span class="line">    System.out.println(intList.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，foreach看上去更为简洁，而且它适用于各种容器，更为通用。</p>
<p>这种foreach语法背后是怎么实现的呢？其实，编译器会将它转换为类似如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = intList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们解释其中的代码。</p>
<h3 id="1．迭代器接口"><a href="#1．迭代器接口" class="headerlink" title="1．迭代器接口"></a>1．迭代器接口</h3><p>ArrayList实现了Iterable接口，Iterable表示可迭代，Java 7中的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义很简单，就是要求实现iterator方法。iterator方法的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>它返回一个实现了Iterator接口的对象，Java 7中Iterator接口的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hasNext()判断是否还有元素未访问，next()返回下一个元素，remove()删除最后返回的元素，只读访问的基本模式类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = intList.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们待会再看迭代中间要删除元素的情况。</p>
<p>只要对象实现了Iterable接口，就可以使用foreach语法，编译器会转换为调用Iterable和Iterator接口的方法。初次见到Iterable和Iterator，可能会比较容易混淆，我们再澄清一下：</p>
<ul>
<li>Iterable表示对象可以被迭代，它有一个方法iterator()，返回Iterator对象，实际通过Iterator接口的方法进行遍历；</li>
<li>如果对象实现了Iterable，就可以使用foreach语法；</li>
<li>类可以不实现Iterable，也可以创建Iterator对象。</li>
</ul>
<p>需要了解的是，Java 8对Iterable添加了默认方法forEach和spliterator，对Iterator增加了默认方法forEachRemaining和remove，具体可参见API文档，我们就不介绍了。</p>
<h3 id="2-ListIterator"><a href="#2-ListIterator" class="headerlink" title="2. ListIterator"></a>2. ListIterator</h3><p>除了iterator(), ArrayList还提供了两个返回Iterator接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>ListIterator扩展了Iterator接口，增加了一些方法，向前遍历、添加元素、修改元素、返回索引位置等，添加的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasPrevious</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">previousIndex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>listIterator()方法返回的迭代器从0开始，而listIterator(int index)方法返回的迭代器从指定位置index开始。比如，从末尾往前遍历，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseTraverse</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    ListIterator&lt;Integer&gt; it = list.listIterator(list.size());</span><br><span class="line">    <span class="keyword">while</span>(it.hasPrevious())&#123;</span><br><span class="line">        System.out.println(it.previous());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3．迭代的陷阱"><a href="#3．迭代的陷阱" class="headerlink" title="3．迭代的陷阱"></a>3．迭代的陷阱</h3><p>关于迭代器，有一种常见的误用，就是在迭代的中间调用容器的删除方法。比如，要删除一个整数ArrayList中所有小于100的数，直觉上，代码可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Integer a : list)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            list.remove(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但运行时会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br></pre></td></tr></table></figure>

<p>发生了并发修改异常，为什么呢？因为迭代器内部会维护一些索引位置相关的数据，要求在迭代过程中，容器不能发生结构性变化，否则这些索引位置就失效了。所谓结构性变化就是添加、插入和删除元素，只是修改元素内容不算结构性变化。</p>
<p>如何避免异常呢？可以使用迭代器的remove方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">if</span>(it.next()&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器如何知道发生了结构性变化，并抛出异常？它自己的remove方法为何又可以使用呢？我们需要看下迭代器实现的原理。</p>
<h3 id="4．迭代器实现的原理"><a href="#4．迭代器实现的原理" class="headerlink" title="4．迭代器实现的原理"></a>4．迭代器实现的原理</h3><p>我们来看下ArrayList中iterator方法的实现，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建了一个Itr对象，Itr是一个成员内部类，实现了Iterator接口，声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它有三个实例成员变量，为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cursor;        <span class="comment">//下一个要返回的元素位置</span></span><br><span class="line"><span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">//最后一个返回的索引位置，如果没有，为-1</span></span><br><span class="line"><span class="keyword">int</span> expectedModCount = modCount;</span><br></pre></td></tr></table></figure>

<p>cursor表示下一个要返回的元素位置，lastRet表示最后一个返回的索引位置，expected-ModCount表示期望的修改次数，初始化为外部类当前的修改次数modCount，回顾一下，成员内部类可以直接访问外部类的实例变量。每次发生结构性变化的时候modCount都会增加，而每次迭代器操作的时候都会检查expectedModCount是否与modCount相同，这样就能检测出结构性变化。</p>
<p>我们来具体看下，它是如何实现Iterator接口中的每个方法的，先看hasNext()，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor ! = size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cursor与size比较，比较直接，看next方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用了checkForComodification，它的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(modCount ! = expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，next前面部分主要就是在检查是否发生了结构性变化，如果没有变化，就更新cursor和lastRet的值，以保持其语义，然后返回对应的元素。remove的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它调用了ArrayList的remove方法，但同时更新了cursor、lastRet和expectedModCount的值，所以它可以正确删除。不过，需要注意的是，调用remove方法前必须先调用next，比如，通过迭代器删除所有元素，直觉上，可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际运行，会抛出异常java.lang.IllegalStateException，正确写法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">(ArrayList&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        it.next();</span><br><span class="line">        it.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果只是要删除所有元素，ArrayList有现成的方法clear()。</p>
<p>listIterator()的实现使用了另一个内部类ListItr，它继承自Itr，基本思路类似，我们就不赘述了。</p>
<h3 id="5．迭代器的好处"><a href="#5．迭代器的好处" class="headerlink" title="5．迭代器的好处"></a>5．迭代器的好处</h3><p>为什么要通过迭代器这种方式访问元素呢？直接使用size()/get(index)语法不也可以吗？在一些场景下，确实没有什么差别，两者都可以。不过，foreach语法更为简洁一些，更重要的是，迭代器语法更为通用，它适用于各种容器类。</p>
<p>此外，<strong>迭代器表示的是一种关注点分离的思想，将数据的实际组织方式与数据的迭代遍历相分离，是一种常见的设计模式</strong>。需要访问容器元素的代码只需要一个Iterator接口的引用，不需要关注数据的实际组织方式，可以使用一致和统一的方式进行访问。</p>
<p>而提供Iterator接口的代码了解数据的组织方式，可以提供高效的实现。在ArrayList中， size/get(index)语法与迭代器性能是差不多的，但在后续介绍的其他容器中，则不一定，比如LinkedList，迭代器性能就要高很多。</p>
<p>从封装的思路上讲，迭代器封装了各种数据组织方式的迭代操作，提供了简单和一致的接口。</p>
<h2 id="9-1-4-ArrayList实现的接口"><a href="#9-1-4-ArrayList实现的接口" class="headerlink" title="9.1.4 ArrayList实现的接口"></a>9.1.4 ArrayList实现的接口</h2><p>Java的各种容器类有一些共性的操作，这些共性以接口的方式体现，我们刚刚介绍的Iterable接口就是，此外，ArrayList还实现了三个主要的接口：Collection、List和Random-Access，我们逐个介绍。</p>
<h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h3><p>Collection表示一个数据集合，数据间没有位置或顺序的概念，Java 7中的接口定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;? &gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;? &gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;? &gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些方法中，除了两个toArray方法和几个xxxAll()方法外，其他我们已经介绍过了。toArray方法我们待会再介绍。这几个xxxAll()方法的含义基本也是可以顾名思义的， addAll表示添加，removeAll表示删除，containsAll表示检查是否包含了参数容器中的所有元素，只有全包含才返回true, retainAll表示只保留参数容器中的元素，其他元素会进行删除。Java 8对Collection接口添加了几个默认方法，包括removeIf、stream、spliterator等，具体可参见API文档。</p>
<p>抽象类AbstractCollection对这几个方法都提供了默认实现，实现的方式就是利用迭代器方法逐个操作。比如，我们看removeAll方法，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;? &gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    Iterator&lt;? &gt; it = iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c.contains(it.next())) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就不解释了。ArrayList继承了AbstractList，而AbstractList又继承了AbstractCollection, ArrayList对其中一些方法进行了重写，以提供更为高效的实现，具体不再介绍。</p>
<h3 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h3><p>List表示有顺序或位置的数据集合，它扩展了Collection，增加的主要方法有（Java 7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这些方法都与位置有关，容易理解，就不介绍了。Java 8对List接口增加了几个默认方法，包括sort、replaceAll和spliterator; Java 9增加了多个重载的of方法，可以根据一个或多个元素生成一个不变的List，具体就不介绍了，可参看API文档。</p>
<h3 id="3-RandomAccess"><a href="#3-RandomAccess" class="headerlink" title="3. RandomAccess"></a>3. RandomAccess</h3><p>RandomAccess的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有定义任何代码。这有什么用呢？这种没有任何代码的接口在Java中被称为<strong>标记接口</strong>，用于声明类的一种属性。</p>
<p>这里，实现了RandomAccess接口的类表示可以随机访问，可随机访问就是具备类似数组那样的特性，数据在内存是连续存放的，根据索引值就可以直接定位到具体的元素，访问效率很高。下节我们会介绍LinkedList，它就不能随机访问。</p>
<p>有没有声明RandomAccess有什么关系呢？主要用于一些通用的算法代码中，它可以根据这个声明而选择效率更高的实现。比如，Collections类中有一个方法binarySearch，在List中进行二分查找，它的实现代码就根据list是否实现了RandomAccess而采用不同的实现机制，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-1-5-ArrayList的其他方法"><a href="#9-1-5-ArrayList的其他方法" class="headerlink" title="9.1.5 ArrayList的其他方法"></a>9.1.5 ArrayList的其他方法</h2><p>ArrayList中还有一些其他方法，包括构造方法、与数组的相互转换、容量大小控制等，我们来看下。ArrayList还有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>第一个方法以指定的大小initialCapacity初始化内部的数组大小，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br></pre></td></tr></table></figure>

<p>在事先知道元素长度的情况下，或者，预先知道长度上限的情况下，使用这个构造方法可以避免重新分配和复制数组。第二个构造方法以一个已有的Collection构建，数据会新复制一份。</p>
<p>ArrayList中有两个方法可以返回数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray()</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)</span><br></pre></td></tr></table></figure>

<p>第一个方法返回是Object数组，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个方法返回对应类型的数组，如果参数数组长度足以容纳所有元素，就使用该数组，否则就新建一个数组，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">intList.add(<span class="number">123</span>);</span><br><span class="line">intList.add(<span class="number">456</span>);</span><br><span class="line">intList.add(<span class="number">789</span>);</span><br><span class="line">Integer[] arrA = <span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">intList.toArray(arrA);</span><br><span class="line">Integer[] arrB = intList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line">System.out.println(Arrays.equals(arrA, arrB));</span><br></pre></td></tr></table></figure>

<p>输出为true，表示两种方式都是可以的。</p>
<p>Arrays中有一个静态方法asList可以返回对应的List，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这个方法返回的List，它的实现类并不是本节介绍的ArrayList，而是Arrays类的一个内部类，在这个内部类的实现中，内部用的数组就是传入的数组，没有拷贝，也不会动态改变大小，所以对数组的修改也会反映到List中，对List调用add、remove方法会抛出异常。</p>
<p>要使用ArrayList完整的方法，应该新建一个ArrayList，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(a));</span><br></pre></td></tr></table></figure>

<p>ArrayList还提供了两个public方法，可以控制内部使用的数组大小，一个是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span></span></span><br></pre></td></tr></table></figure>

<p>它可以确保数组的大小至少为minCapacity，如果不够，会进行扩展。如果已经预知ArrayList需要比较大的容量，调用这个方法可以减少ArrayList内部分配和扩展的次数。</p>
<p>另一个方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>它会重新分配一个数组，大小刚好为实际内容的长度。调用这个方法可以节省数组占用的空间。</p>
<h2 id="9-1-6-ArrayList特点分析"><a href="#9-1-6-ArrayList特点分析" class="headerlink" title="9.1.6 ArrayList特点分析"></a>9.1.6 ArrayList特点分析</h2><p>后续我们会介绍各种容器类和数据组织方式。之所以有各种不同的方式，是因为不同方式有不同特点，而不同特点有不同适用场合。考虑特点时，性能是其中一个很重要的部分，但性能不是一个简单的高低之分，对于一种数据结构，有的操作性能高，有的操作性能比较低。</p>
<p>作为程序员，就是要理解每种数据结构的特点，根据场合的不同，选择不同的数据结构。</p>
<p>对于ArrayList，它的特点是内部采用动态数组实现，这决定了以下几点。<br>1）可以随机访问，按照索引位置进行访问效率很高，用算法描述中的术语，效率是O(1)，简单说就是可以一步到位。<br>2）除非数组已排序，否则按照内容查找元素效率比较低，具体是O(N), N为数组内容长度，也就是说，性能与数组长度成正比。<br>3）添加元素的效率还可以，重新分配和复制数组的开销被平摊了，具体来说，添加N个元素的效率为O(N)。<br>4）插入和删除元素的效率比较低，因为需要移动元素，具体为O(N)。</p>
<h3 id="9-1-7-小结"><a href="#9-1-7-小结" class="headerlink" title="9.1.7 小结"></a>9.1.7 小结</h3><p>本节详细介绍了ArrayList, ArrayList是日常开发中最常用的类之一。我们介绍了ArrayList的用法、基本实现原理、迭代器及其实现、Collection/List/RandomAccess接口、ArrayList与数组的相互转换，最后分析了ArrayList的特点。</p>
<p>需要说明的是，ArrayList不是线程安全的，关于线程我们在第15章介绍，实现线程安全的一种方式是使用Collections提供的方法装饰ArrayList，这个我们会在12.2节介绍。此外，需要了解的是，还有一个类Vector，它是Java最早实现的容器类之一，也实现了List接口，基本原理与ArrayList类似，内部使用synchronized（15.2节介绍）实现了线程安全，不需要线程安全的情况下，推荐使用ArrayList。</p>
<p>ArrayList的插入和删除的性能比较低，下一节，我们来看另一个同样实现了List接口的容器类：LinkedList，它的特点可以说与ArrayList正好相反。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/bb617281/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/bb617281/" class="post-title-link" itemprop="url">8.2 解析通配符</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 21:26:05" itemprop="dateCreated datePublished" datetime="2021-12-04T21:26:05+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">第8章 泛型</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/bb617281/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/bb617281/" data-xid="/JavaReadingNotes/bb617281/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="8-2-解析通配符"><a href="#8-2-解析通配符" class="headerlink" title="8.2 解析通配符"></a>8.2 解析通配符</h1><p>本节主要讨论泛型中的通配符概念。通配符有着令人费解和混淆的语法，但通配符大量应用于Java容器类中，它到底是什么？下面我们逐步来解析。</p>
<h2 id="8-2-1-更简洁的参数类型限定"><a href="#8-2-1-更简洁的参数类型限定" class="headerlink" title="8.2.1 更简洁的参数类型限定"></a>8.2.1 更简洁的参数类型限定</h2><p>在8.1节最后，我们提到一个例子，为了将Integer对象添加到Number容器中，我们的类型参数使用了其他类型参数作为上界，我们提到，这种写法有点烦琐，它可以替换为更为简洁的通配符形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.size; i++)&#123;</span><br><span class="line">        add(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法没有定义类型参数，c的类型是<code>DynamicArray&lt;? extends E&gt;</code>, ？表示通配符，<code>&lt;? extends E&gt;</code>表示有限定通配符，匹配E或E的某个子类型，具体什么子类型是未知的。使用这个方法的代码不需要做任何改动，还可以是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">numbers.addAll(ints);</span><br></pre></td></tr></table></figure>

<p>这里，E是Number类型，<code>DynamicArray&lt;? extends E&gt;</code>可以匹配<code>DynamicArray&lt;Integer&gt;</code>。</p>
<p>那么问题来了，同样是extends关键字，同样应用于泛型，<code>&lt;T extends E&gt;</code>和<code>&lt;?extends E&gt;</code>到底有什么关系？它们用的地方不一样，我们解释一下：<br>1）<code>&lt;T extends E&gt;</code>用于<strong>定义</strong>类型参数，它声明了一个类型参数T，可放在泛型类定义中类名后面、泛型方法返回值前面。<br>2）<code>&lt;? extends E&gt;</code>用于<strong>实例化</strong>类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。</p>
<p>虽然它们不一样，但两种写法经常可以达成相同目标，比如，前面例子中，下面两种写法都可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;? extends E&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;T extends E&gt; <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;T&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>那么，到底应该用哪种形式呢？我们先进一步理解通配符，然后再解释。</p>
<h2 id="8-2-2-理解通配符"><a href="#8-2-2-理解通配符" class="headerlink" title="8.2.2 理解通配符"></a>8.2.2 理解通配符</h2><p>除了有限定通配符，还有一种通配符，形如DynamicArray&lt;? &gt;，称为<strong>无限定通配符</strong>。我们来看个例子，在DynamicArray中查找指定元素，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(DynamicArray&lt;? &gt; arr, Object elm)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.get(i).equals(elm))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，这种无限定通配符形式也可以改为使用类型参数。也就是说，下面的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(DynamicArray&lt;? &gt; arr, Object elm)</span></span></span><br></pre></td></tr></table></figure>

<p>可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(DynamicArray&lt;T&gt; arr, Object elm)</span></span></span><br></pre></td></tr></table></figure>

<p>不过，通配符形式更为简洁。虽然通配符形式更为简洁，但上面两种通配符都有一个重要的限制：<strong>只能读，不能写</strong>。怎么理解呢？看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">DynamicArray&lt;? extends Number&gt; numbers = ints;</span><br><span class="line">Integer a = <span class="number">200</span>;</span><br><span class="line">numbers.add(a); <span class="comment">//错误！</span></span><br><span class="line">numbers.add((Number)a); <span class="comment">//错误！</span></span><br><span class="line">numbers.add((Object)a); <span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>三种add方法都是非法的，无论是Integer，还是Number或Object，编译器都会报错。为什么呢？问号就是表示类型安全无知，? extends Number表示是Number的某个子类型，但不知道具体子类型，如果允许写入，Java就无法确保类型安全性，所以干脆禁止。我们来看个例子，看看如果允许写入会发生什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">DynamicArray&lt;? extends Number&gt; numbers = ints;</span><br><span class="line">Number n = <span class="keyword">new</span> Double(<span class="number">23.0</span>);</span><br><span class="line">Object o = <span class="keyword">new</span> String(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">numbers.add(n);</span><br><span class="line">numbers.add(o);</span><br></pre></td></tr></table></figure>

<p>如果允许写入Object或Number类型，则最后两行编译就是正确的，也就是说，Java将允许把Double或String对象放入Integer容器，这显然违背了Java关于类型安全的承诺。</p>
<p>大部分情况下，这种限制是好的，但这使得一些理应正确的基本操作无法完成，比如交换两个元素的位置，看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(DynamicArray&lt;? &gt; arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Object tmp = arr.get(i);</span><br><span class="line">    arr.set(i, arr.get(j));</span><br><span class="line">    arr.set(j, tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码看上去应该是正确的，但Java会提示编译错误，两行set语句都是非法的。不过，借助带类型参数的泛型方法，这个问题可以如下解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">swapInternal</span><span class="params">(DynamicArray&lt;T&gt; arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    T tmp = arr.get(i);</span><br><span class="line">    arr.set(i, arr.get(j));</span><br><span class="line">    arr.set(j, tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(DynamicArray&lt;? &gt; arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    swapInternal(arr, i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>swap可以调用swapInternal，而带类型参数的swapInternal可以写入。Java容器类中就有类似这样的用法，公共的API是通配符形式，形式更简单，但内部调用带类型参数的方法。</p>
<p>除了这种需要写的场合，如果参数类型之间有依赖关系，也只能用类型参数，比如，将src容器中的内容复制到dest中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;D, S extends D&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(DynamicArray&lt;D&gt; dest,</span></span></span><br><span class="line"><span class="params"><span class="function">        DynamicArray&lt;S&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++)&#123;</span><br><span class="line">        dest.add(src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>S和D有依赖关系，要么相同，要么S是D的子类，否则类型不兼容，有编译错误。不过，上面的声明可以使用通配符简化，两个参数可以简化为一个，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;D&gt; <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(DynamicArray&lt;D&gt; dest,</span></span></span><br><span class="line"><span class="params"><span class="function">        DynamicArray&lt;? extends D&gt; src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;src.size(); i++)&#123;</span><br><span class="line">        dest.add(src.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果返回值依赖于类型参数，也不能用通配符，比如，计算动态数组中的最大值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(DynamicArray&lt;T&gt; arr)</span></span>&#123;</span><br><span class="line">    T max = arr.get(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.get(i).compareTo(max)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            max = arr.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就难以用通配符代替。</p>
<p>现在我们再来看泛型方法到底应该用通配符的形式还是加类型参数。两者到底有什么关系？我们总结如下。<br>1）通配符形式都可以用类型参数的形式来替代，通配符能做的，用类型参数都能做。<br>2）通配符形式可以减少类型参数，形式上往往更为简单，可读性也更好，所以，能用通配符的就用通配符。<br>3）如果类型参数之间有依赖关系，或者返回值依赖类型参数，或者需要写操作，则只能用类型参数。<br>4）通配符形式和类型参数往往配合使用，比如，上面的copy方法，定义必要的类型参数，使用通配符表达依赖，并接受更广泛的数据类型。</p>
<h2 id="8-2-3-超类型通配符"><a href="#8-2-3-超类型通配符" class="headerlink" title="8.2.3 超类型通配符"></a>8.2.3 超类型通配符</h2><p>还有一种通配符，与形式&lt;? extends E&gt;正好相反，它的形式为&lt;? super E&gt;，称为<strong>超类型通配符</strong>，表示E的某个父类型。它有什么用呢？有了它，我们就可以更灵活地写入了。</p>
<p>如果没有这种语法，写入会有一些限制。来看个例子，我们给DynamicArray添加一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(DynamicArray&lt;E&gt; dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        dest.add(get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也很简单，将当前容器中的元素添加到传入的目标容器中。我们可能希望这么使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;Integer&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> DynamicArray&lt;Number&gt;();</span><br><span class="line">ints.copyTo(numbers);</span><br></pre></td></tr></table></figure>

<p>Integer是Number的子类，将Integer对象拷贝入Number容器，这种用法应该是合情合理的，但Java会提示编译错误，理由我们之前也说过了，期望的参数类型是<code>Dynamic-Array&lt;Integer&gt;</code>, <code>DynamicArray&lt;Number&gt;</code>并不适用。</p>
<p>如之前所说，一般而言，不能将<code>DynamicArray&lt;Integer&gt;</code>看作<code>DynamicArray&lt;Number&gt;</code>，但我们这里的用法是没有问题的，Java解决这个问题的方法就是超类型通配符，可以将copyTo代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(DynamicArray&lt;? <span class="keyword">super</span> E&gt; dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">        dest.add(get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，就没有问题了。</p>
<p>超类型通配符另一个常用的场合是Comparable/Comparator接口。同样，我们先来看下如果不使用会有什么限制。以前面计算最大值的方法为例，它的方法声明是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(DynamicArray&lt;T&gt; arr)</span></span></span><br></pre></td></tr></table></figure>

<p>这个声明有什么限制呢？举个简单的例子，有两个类Base和Child, Base的代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Base</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sortOrder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">(<span class="keyword">int</span> sortOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sortOrder = sortOrder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Base o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sortOrder &lt; o.sortOrder)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sortOrder &gt; o.sortOrder)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Base代码很简单，实现了Comparable接口，根据实例变量sortOrder进行比较。Child代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(<span class="keyword">int</span> sortOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(sortOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，Child非常简单，只是继承了Base。注意：Child没有重新实现Comparable接口，因为Child的比较规则和Base是一样的。我们可能希望使用前面的max方法操作Child容器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Child&gt; childs = <span class="keyword">new</span> DynamicArray&lt;Child&gt;();</span><br><span class="line">childs.add(<span class="keyword">new</span> Child(<span class="number">20</span>));</span><br><span class="line">childs.add(<span class="keyword">new</span> Child(<span class="number">80</span>));</span><br><span class="line">Child maxChild = max(childs);</span><br></pre></td></tr></table></figure>

<p>遗憾的是，Java会提示编译错误，类型不匹配。为什么不匹配呢？我们可能会认为，Java会将max方法的类型参数T推断为Child类型，但类型T的要求是<code>extendsComparable&lt;T&gt;</code>，而Child并没有实现<code>Comparable&lt;Child&gt;</code>，它实现的是<code>Comparable&lt;Base&gt;</code>。</p>
<p>但我们的需求是合理的，Base类的代码已经有了关于比较所需要的全部数据，它应该可以用于比较Child对象。解决这个问题的方法，就是修改max的方法声明，使用超类型通配符，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(DynamicArray&lt;T&gt; arr)</span></span></span><br></pre></td></tr></table></figure>

<p>这么修改一下就可以了，这种写法比较抽象，将T替换为Child，就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child extends Comparable&lt;? <span class="keyword">super</span> Child&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;? super Child&gt;</code>可以匹配Base，所以整体就是匹配的。</p>
<p>我们比较一下类型参数限定与超类型通配符，类型参数限定只有extends形式，没有super形式，比如，前面的copyTo方法的通配符形式的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(DynamicArray&lt;? <span class="keyword">super</span> E&gt; dest)</span></span></span><br></pre></td></tr></table></figure>

<p>如果类型参数限定支持super形式，则应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T <span class="keyword">super</span> E&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(DynamicArray&lt;T&gt; dest)</span></span></span><br></pre></td></tr></table></figure>

<p>事实是，Java并不支持这种语法。</p>
<p>前面我们说过，对于有限定的通配符形式<code>&lt;? extends E&gt;</code>，可以用类型参数限定替代，但是对于类似上面的<strong>超类型通配符，则无法用类型参数替代</strong>。</p>
<h2 id="8-2-4-通配符比较"><a href="#8-2-4-通配符比较" class="headerlink" title="8.2.4 通配符比较"></a>8.2.4 通配符比较</h2><p>本节介绍了泛型中的三种通配符形式<code>&lt;? &gt;</code>、<code>&lt;? super E&gt;</code>和<code>&lt;? extends E&gt;</code>，并分析了与类型参数形式的区别和联系，它们比较容易混淆，我们总结比较如下：<br>1）它们的目的都是为了使方法接口更为灵活，可以接受更为广泛的类型。<br>2）**<code>&lt;? super E&gt;</code>用于灵活写入或比较<strong>，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象，它不能被类型参数形式替代。<br>3）</strong><code>&lt;? &gt;</code>和<code>&lt;? extends E&gt;</code>用于灵活读取**，使得方法可以读取E或E的任意子类型的容器对象，它们可以用类型参数的形式替代，但通配符形式更为简洁。</p>
<p>Java容器类的实现中，有很多使用通配符的例子，比如，类Collections中就有如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">copy</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title">max</span><span class="params">(Collection&lt;? extends T&gt; coll,Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span></span><br></pre></td></tr></table></figure>

<p>通过前面两节，我们应该可以理解这些方法声明的含义了。关于泛型，还有一些细节以及限制，让我们下一节继续探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/59a6fc0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/59a6fc0/" class="post-title-link" itemprop="url">8.3 细节和局限性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 21:26:05" itemprop="dateCreated datePublished" datetime="2021-12-04T21:26:05+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">第8章 泛型</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/59a6fc0/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/59a6fc0/" data-xid="/JavaReadingNotes/59a6fc0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="8-3-细节和局限性"><a href="#8-3-细节和局限性" class="headerlink" title="8.3 细节和局限性"></a>8.3 细节和局限性</h1><p>本节介绍泛型中的一些细节和局限性，这些局限性主要与Java的实现机制有关。Java中，泛型是通过类型擦除来实现的，类型参数在编译时会被替换为Object，运行时Java虚拟机不知道泛型这回事，这带来了很多局限性，其中有的部分是比较容易理解的，有的则是非常违反直觉的。</p>
<p>一项技术，往往只有理解了其局限性，才算是真正理解了它，才能更好地应用它。下面我们将从以下几个方面来介绍这些细节和局限性：</p>
<ul>
<li>使用泛型类、方法和接口。</li>
<li>定义泛型类、方法和接口。</li>
<li>泛型与数组。</li>
</ul>
<h2 id="8-3-1-使用泛型类、方法和接口"><a href="#8-3-1-使用泛型类、方法和接口" class="headerlink" title="8.3.1 使用泛型类、方法和接口"></a>8.3.1 使用泛型类、方法和接口</h2><p>在使用泛型类、方法和接口时，有一些值得注意的地方，比如：</p>
<ul>
<li>基本类型不能用于实例化类型参数。</li>
<li>运行时类型信息不适用于泛型。</li>
<li>类型擦除可能会引发一些冲突。</li>
</ul>
<p>我们逐个来看下。Java中，因为类型参数会被替换为Object，所以Java泛型中不能使用基本数据类型，也就是说，类似下面的写法是不合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;<span class="keyword">int</span>&gt; minmax = <span class="keyword">new</span> Pair&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>解决方法是使用基本类型对应的包装类。</p>
<p>在介绍继承的实现原理时，我们提到在内存中每个类都有一份类型信息，而每个对象也都保存着其对应类型信息的引用。关于运行时信息，后续章节我们会进一步详细介绍，这里简要说明一下。在Java中，这个类型信息也是一个对象，它的类型为Class, Class本身也是一个泛型类，每个类的类型对象可以通过&lt;类名&gt;.class的方式引用，比如String. class、Integer.class。这个类型对象也可以通过对象的getClass()方法获得，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;? &gt; cls = <span class="string">&quot;hello&quot;</span>.getClass();</span><br></pre></td></tr></table></figure>

<p>这个类型对象只有一份，与泛型无关，所以Java不支持类似如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt;.class</span><br></pre></td></tr></table></figure>

<p>一个泛型对象的getClass方法的返回值与原始类型对象也是相同的，比如，下面代码的输出都是true：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; p1 = <span class="keyword">new</span> Pair&lt;Integer&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">Pair&lt;String&gt; p2 = <span class="keyword">new</span> Pair&lt;String&gt;(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">System.out.println(Pair.class==p1.getClass()); <span class="comment">//true</span></span><br><span class="line">System.out.println(Pair.class==p2.getClass()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>之前，我们介绍过instanceof关键字，instanceof后面是接口或类名，instanceof是运行时判断，也与泛型无关，所以，Java也不支持类似如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Pair&lt;Integer&gt;)</span><br></pre></td></tr></table></figure>

<p>不过，Java支持如下写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Pair&lt;?&gt;)</span><br></pre></td></tr></table></figure>

<p>由于类型擦除，可能会引发一些编译冲突，这些冲突初看上去并不容易理解，我们通过一些例子介绍。8.2.3节我们介绍过一个例子，有两个类Base和Child, Base的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Base</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Child的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br></pre></td></tr></table></figure>

<p>Child没有专门实现Comparable接口，8.2.3节我们说Base类已经有了比较所需的全部信息，所以Child没有必要实现，可是如果Child希望自定义这个比较方法呢？直觉上，可以这样修改Child类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Child</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，Java编译器会提示错误，Comparable接口不能被实现两次，且两次实现的类型参数还不同，一次是<code>Comparable&lt;Base&gt;</code>，一次是<code>Comparable&lt;Child&gt;</code>。为什么不允许呢？因为类型擦除后，实际上只能有一个。</p>
<p>那Child有什么办法修改比较方法呢？只能是重写Base类的实现，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Base o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(! (o <span class="keyword">instanceof</span> Child))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        Child c = (Child)o;</span><br><span class="line">        <span class="comment">//比较代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，你可能认为可以如下定义重载方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(DynamicArray&lt;Integer&gt; intArr)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(DynamicArray&lt;String&gt; strArr)</span></span></span><br></pre></td></tr></table></figure>

<p>虽然参数都是DynamicArray，但实例化类型不同，一个是<code>DynamicArray&lt;Integer&gt;</code>，另一个是<code>DynamicArray&lt;String&gt;</code>，同样，遗憾的是，Java不允许这种写法，理由同样是类型擦除后它们的声明是一样的。</p>
<h2 id="8-3-2-定义泛型类、方法和接口"><a href="#8-3-2-定义泛型类、方法和接口" class="headerlink" title="8.3.2 定义泛型类、方法和接口"></a>8.3.2 定义泛型类、方法和接口</h2><p>在定义泛型类、方法和接口时，也有一些需要注意的地方，比如：</p>
<ul>
<li>不能通过类型参数创建对象。</li>
<li>泛型类类型参数不能用于静态变量和方法。</li>
<li>了解多个类型限定的语法。</li>
</ul>
<p>我们逐个介绍。不能通过类型参数创建对象，比如，T是类型参数，下面的写法都是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T elm = <span class="keyword">new</span> T();</span><br><span class="line">T[] arr = <span class="keyword">new</span> T[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>为什么非法呢？因为如果允许，那么用户会以为创建的就是对应类型的对象，但由于类型擦除，Java只能创建Object类型的对象，而无法创建T类型的对象，容易引起误解，所以Java干脆禁止这么做。</p>
<p>那如果确实希望根据类型创建对象呢？需要设计API接受类型对象，即Class对象，并使用Java中的反射机制。第21章会介绍反射，这里简要说明一下。如果类型有默认构造方法，可以调用Class的newInstance方法构建对象，类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = create(Date.class);</span><br><span class="line">StringBuilder sb = create(StringBuilder.class);</span><br></pre></td></tr></table></figure>

<p>对于泛型类声明的类型参数，可以在实例变量和方法中使用，但在静态变量和静态方法中是不能使用的。类似下面这种写法是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> T <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//创建实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果合法，那么对于每种实例化类型，都需要有一个对应的静态变量和方法。但由于类型擦除，Singleton类型只有一份，静态变量和方法都是类型的属性，且与类型参数无关，所以不能使用泛型类类型参数。</p>
<p>不过，对于静态方法，它可以是泛型方法，可以声明自己的类型参数，这个参数与泛型类的类型参数是没有关系的。</p>
<p>之前介绍类型参数限定的时候，我们提到上界可以为某个类、某个接口或者其他类型参数，但上界都是只有一个，Java中还支持多个上界，多个上界之间以&amp;分隔，类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T extends Base &amp; Comparable &amp; Serializable</span><br></pre></td></tr></table></figure>

<p>Base为上界类，Comparable和Serializable为上界接口。如果有上界类，类应该放在第一个，类型擦除时，会用第一个上界替换。</p>
<h2 id="8-3-3-泛型与数组"><a href="#8-3-3-泛型与数组" class="headerlink" title="8.3.3 泛型与数组"></a>8.3.3 泛型与数组</h2><p>泛型与数组的关系稍微复杂一些，我们单独介绍。</p>
<p>引入泛型后，一个令人惊讶的事实是，<strong>不能创建泛型数组</strong>。比如，我们可能想这样创建一个Pair的泛型数组，以表示7.6节中介绍的奖励面额和权重。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Object, Integer&gt;[] options = <span class="keyword">new</span> Pair&lt;Object, Integer&gt;[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Pair(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>), <span class="keyword">new</span> Pair(<span class="string">&quot;2元&quot;</span>, <span class="number">2</span>), <span class="keyword">new</span> Pair(<span class="string">&quot;10元&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Java会提示编译错误，不能创建泛型数组。这是为什么呢？我们先来进一步理解一下数组。</p>
<p>前面我们解释过，类型参数之间有继承关系的容器之间是没有关系的，比如，一个<code>DynamicArray&lt;Integer&gt;</code>对象不能赋值给一个<code>DynamicArray&lt;Number&gt;</code>变量。不过，数组是可以的，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] ints = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">Number[] numbers = ints;</span><br><span class="line">Object[] objs = ints;</span><br></pre></td></tr></table></figure>

<p>后面两种赋值都是允许的。数组为什么可以呢？数组是Java直接支持的概念，它知道数组元素的实际类型，知道Object和Number都是Integer的父类型，所以这个操作是允许的。</p>
<p>虽然Java允许这种转换，但如果使用不当，可能会引起运行时异常，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] ints = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">Object[] objs = ints;</span><br><span class="line">objs[<span class="number">0</span>] = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>编译是没有问题的，运行时会抛出ArrayStoreException，因为Java知道实际的类型是Integer，所以写入String会抛出异常。</p>
<p>理解了数组的这个行为，我们再来看泛型数组。如果Java允许创建泛型数组，则会发生非常严重的问题，我们看看具体会发生什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Object, Integer&gt;[] options = <span class="keyword">new</span> Pair&lt;Object, Integer&gt;[<span class="number">3</span>];</span><br><span class="line">Object[] objs = options;</span><br><span class="line">objs[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Double, String&gt;(<span class="number">12.34</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果可以创建泛型数组options，那它就可以赋值给其他类型的数组objs，而最后一行明显错误的赋值操作，则既不会引起编译错误，也不会触发运行时异常，因为<code>Pair&lt;Double, String&gt;</code>的运行时类型是Pair，和objs的运行时类型<code>Pair[]</code>是匹配的。但我们知道，它的实际类型是不匹配的，在程序的其他地方，当把<code>objs[0]</code>作为<code>Pair&lt;Object, Integer&gt;</code>进行处理的时候，一定会触发异常。</p>
<p>也就是说，如果允许创建泛型数组，那就可能会有上面这种错误操作，它既不会引起编译错误，也不会立即触发运行时异常，却相当于埋下了一颗炸弹，不定什么时候爆发，为避免这种情况，Java干脆就禁止创建泛型数组。</p>
<p>但现实需要能够存放泛型对象的容器，怎么办呢？可以使用原始类型的数组，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair[] options = <span class="keyword">new</span> Pair[]&#123;</span><br><span class="line">    <span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>),</span><br><span class="line">    <span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;2元&quot;</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;10元&quot;</span>, <span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>更好的选择是，使用后续章节介绍的泛型容器。目前，可以使用我们自己实现的Dy-namicArray，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Pair&lt;String, Integer&gt;&gt; options = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">options.add(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>));</span><br><span class="line">options.add(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;2元&quot;</span>,<span class="number">2</span>));</span><br><span class="line">options.add(<span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;10元&quot;</span>,<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>DynamicArray内部的数组为Object类型，一些操作插入了强制类型转换，外部接口是类型安全的，对数组的访问都是内部代码，可以避免误用和类型异常。</p>
<p>有时，我们希望转换泛型容器为一个数组，比如，对于DynamicArray，我们可能希望它有这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray()</span><br></pre></td></tr></table></figure>

<p>而希望可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;Integer&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">Integer[] arr = ints.toArray();</span><br></pre></td></tr></table></figure>

<p>先使用动态容器收集一些数据，然后转换为一个固定数组，这也是一个常见的合理需求，怎么来实现这个toArray方法呢？可能想先这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E[] arr = <span class="keyword">new</span> E[size];</span><br></pre></td></tr></table></figure>

<p>遗憾的是，如之前所述，这是不合法的。Java运行时根本不知道E是什么，也就无法做到创建E类型的数组。另一种想法是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray()&#123;</span><br><span class="line">    Object[] copy = <span class="keyword">new</span> Object[size];</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, copy, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> (E[])copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者使用之前介绍的Arrays方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray()&#123;</span><br><span class="line">    <span class="keyword">return</span> (E[])Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果都是一样的，没有编译错误了，但运行时会抛出ClassCastException异常，原因是Object类型的数组不能转换为Integer类型的数组。</p>
<p>那怎么办呢？可以利用Java中的运行时类型信息和反射机制，这些概念我们后续章节再详细介绍。这里我们简要介绍下。Java必须在运行时知道要转换成的数组类型，类型可以作为参数传递给toArray方法，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E[] toArray(Class&lt;E&gt; type)&#123;</span><br><span class="line">    Object copy = Array.newInstance(type, size);</span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, copy, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> (E[])copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Class&lt;E&gt;</code>表示要转换成的数组类型信息，有了这个类型信息，Array类的newInstance方法就可以创建出真正类型的数组对象。调用toArray方法时，需要传递需要的类型，比如，可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = ints.toArray(Integer.class);</span><br></pre></td></tr></table></figure>

<p>我们来稍微总结下泛型与数组的关系：</p>
<ul>
<li>Java不支持创建泛型数组。</li>
<li>如果要存放泛型对象，可以使用原始类型的数组，或者使用泛型容器。</li>
<li>泛型容器内部使用Object数组，如果要转换泛型容器为对应类型的数组，需要使用反射。</li>
</ul>
<h2 id="8-3-4-小结"><a href="#8-3-4-小结" class="headerlink" title="8.3.4 小结"></a>8.3.4 小结</h2><p>本节介绍了泛型的一些细节和局限性，这些局限性主要是由于Java泛型的实现机制引起的，这些局限性包括：不能使用基本类型，没有运行时类型信息，类型擦除会引发一些冲突，不能通过类型参数创建对象，不能用于静态变量等。我们还单独讨论了泛型与数组的关系。</p>
<p>我们需要理解这些局限性，幸运的是，一般并不需要特别去记忆，因为用错的时候， Java开发环境和编译器会进行提示，当被提示时能够理解并从容应对即可。</p>
<p>至此，关于泛型的介绍就结束了。泛型是Java容器类的基础，理解了泛型，接下来，就让我们开始探索Java中的容器类。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6022b970/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6022b970/" class="post-title-link" itemprop="url">8.0 第8章 泛型 8.1 基本概念和原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 21:26:05" itemprop="dateCreated datePublished" datetime="2021-12-04T21:26:05+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:09" itemprop="dateModified" datetime="2021-12-07T12:07:09+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">3第三部分 泛型与容器</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/3%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%B3%9B%E5%9E%8B%E4%B8%8E%E5%AE%B9%E5%99%A8/%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">第8章 泛型</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6022b970/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6022b970/" data-xid="/JavaReadingNotes/6022b970/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第8章-泛型"><a href="#第8章-泛型" class="headerlink" title="第8章 泛型"></a>第8章 泛型</h1><p>之前章节中我们多次提到过泛型这个概念，本章我们就来详细讨论Java中的泛型。虽然泛型的基本思维和概念是比较简单的，但它有一些非常令人费解的语法、细节，以及局限性。</p>
<p>后续章节我们会介绍各种容器类。容器类可以说是日常程序开发中天天用到的，没有容器类，难以想象能开发什么真正有用的程序。而容器类是基于泛型的，不理解泛型，就难以深刻理解容器类。那泛型到底是什么呢？本章我们分为三节逐步来讨论：8.1节主要介绍泛型的基本概念和原理；8.2节重点介绍令人费解的通配符；8.3节介绍一些细节和泛型的局限性。</p>
<h1 id="8-1-基本概念和原理"><a href="#8-1-基本概念和原理" class="headerlink" title="8.1 基本概念和原理"></a>8.1 基本概念和原理</h1><p>之前我们一直强调数据类型的概念，Java有8种基本类型，可以定义类，类相当于自定义数据类型，类之间还可以有组合和继承。我们也介绍了接口，其中提到，很多时候我们关心的不是类型，而是能力，针对接口和能力编程，不仅可以复用代码，还可以降低耦合，提高灵活性。</p>
<p>泛型将接口的概念进一步延伸，“泛型”的字面意思就是广泛的类型。类、接口和方法代码可以应用于非常广泛的类型，代码与它们能够操作的数据类型不再绑定在一起，同一套代码可以用于多种数据类型，这样，不仅可以复用代码，降低耦合，而且可以提高代码的可读性和安全性。</p>
<p>这么说可能比较抽象，接下来，我们通过一些例子逐步进行说明。在Java中，类、接口、方法都可以是泛型的，我们先来看泛型类。</p>
<h2 id="8-1-1-一个简单泛型类"><a href="#8-1-1-一个简单泛型类" class="headerlink" title="8.1.1 一个简单泛型类"></a>8.1.1 一个简单泛型类</h2><p>我们通过一个简单的例子来说明泛型类的基本概念、基本原理和泛型的好处。</p>
<h3 id="1．基本概念"><a href="#1．基本概念" class="headerlink" title="1．基本概念"></a>1．基本概念</h3><p>我们直接来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pair就是一个泛型类，与普通类的区别体现在：</p>
<p>1）类名后面多了一个<code>&lt;T&gt;</code>；<br>2）first和second的类型都是T。</p>
<p>T是什么呢？T表示类型参数，<strong>泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入</strong>。怎么用这个泛型类，并传递类型参数呢？看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;Integer&gt; minmax = <span class="keyword">new</span> Pair&lt;Integer&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">Integer min = minmax.getFirst();</span><br><span class="line">Integer max = minmax.getSecond();</span><br></pre></td></tr></table></figure>

<p><code>Pair&lt;Integer&gt;</code>中的Integer就是传递的实际类型参数。Pair类的代码和它处理的数据类型不是绑定的，具体类型可以变化。上面是Integer，也可以是String，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; kv = <span class="keyword">new</span> Pair&lt;String&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>类型参数可以有多个，Pair类中的first和second可以是不同的类型，多个类型之间以逗号分隔，来看改进后的Pair类定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T first;</span><br><span class="line">    T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;String&gt; kv = <span class="keyword">new</span> Pair&lt;String&gt;(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br><span class="line">Pair&lt;Integer&gt; minmax = <span class="keyword">new</span> Pair&lt;Integer&gt;(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">Integer min = minmax.getFirst();</span><br><span class="line">Integer max = minmax.getSecond();</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">U</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        U first;</span><br><span class="line">        V second;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(U first, V second)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.first = first;</span><br><span class="line">            <span class="keyword">this</span>.second = second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> U <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; pair = <span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">&quot;老马&quot;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><code>&lt;String, Integer&gt;</code>既出现在了声明变量时，也出现在了new后面，比较烦琐，从Java 7开始，支持省略后面的类型参数，可以如下使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;老马&quot;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2．基本原理"><a href="#2．基本原理" class="headerlink" title="2．基本原理"></a>2．基本原理</h3><p>泛型类型参数到底是什么呢？为什么一定要定义类型参数呢？定义普通类，直接使用Object不就行了吗？比如，Pair类可以写为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    Object first;</span><br><span class="line">    Object second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object first, Object second)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Pair的代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pair minmax = <span class="keyword">new</span> Pair(<span class="number">1</span>,<span class="number">100</span>);</span><br><span class="line">Integer min = (Integer)minmax.getFirst();</span><br><span class="line">Integer max = (Integer)minmax.getSecond();</span><br><span class="line">Pair kv = <span class="keyword">new</span> Pair(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老马&quot;</span>);</span><br><span class="line">String key = (String)kv.getFirst();</span><br><span class="line">String value = (String)kv.getSecond();</span><br></pre></td></tr></table></figure>

<p>这样是可以的。实际上，Java泛型的内部原理就是这样的。</p>
<p>我们知道，Java有Java编译器和Java虚拟机，编译器将Java源代码转换为．class文件，虚拟机加载并运行．class文件。对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，就像上面的普通Pair类代码及其使用代码一样，将类型参数T擦除，替换为Object，插入必要的强制类型转换。Java虚拟机实际执行的时候，它是不知道泛型这回事的，只知道普通的类及代码。</p>
<p>再强调一下，Java泛型是通过擦除实现的，类定义中的类型参数如T会被替换为Object，在程序运行过程中，不知道泛型的实际类型参数，比如<code>Pair&lt;Integer&gt;</code>，运行中只知道Pair，而不知道Integer。认识到这一点是非常重要的，它有助于我们理解Java泛型的很多限制。</p>
<p>Java为什么要这么设计呢？泛型是Java 5以后才支持的，这么设计是为了兼容性而不得已的一个选择。</p>
<h3 id="3．泛型的好处"><a href="#3．泛型的好处" class="headerlink" title="3．泛型的好处"></a>3．泛型的好处</h3><p>既然只使用普通类和Object就可以，而且泛型最后也转换为了普通类，那为什么还要用泛型呢？或者说，泛型到底有什么好处呢？泛型主要有两个好处：</p>
<ul>
<li>更好的安全性。</li>
<li>更好的可读性。</li>
</ul>
<p>语言和程序设计的一个重要目标是将bug尽量消灭在摇篮里，能消灭在写代码的时候，就不要等到代码写完程序运行的时候。只使用Object，代码写错的时候，开发环境和编译器不能帮我们发现问题，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair pair = <span class="keyword">new</span> Pair(<span class="string">&quot;老马&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Integer id = (Integer)pair.getFirst();</span><br><span class="line">String name = (String)pair.getSecond();</span><br></pre></td></tr></table></figure>

<p>看出问题了吗？写代码时不小心把类型弄错了，不过，代码编译时是没有任何问题的，但运行时程序抛出了类型转换异常ClassCastException。如果使用泛型，则不可能犯这个错误，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String, Integer&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(<span class="string">&quot;老马&quot;</span>,<span class="number">1</span>);</span><br><span class="line">Integer id = pair.getFirst(); <span class="comment">//有编译错误</span></span><br><span class="line">String name = pair.getSecond(); <span class="comment">//有编译错误</span></span><br></pre></td></tr></table></figure>

<p>开发环境（如Eclipse）会提示类型错误，即使没有好的开发环境，编译时Java编译器也会提示。这称之为类型安全，也就是说，通过使用泛型，开发环境和编译器能确保不会用错类型，为程序多设置一道安全防护网。使用泛型，还可以省去烦琐的强制类型转换，再加上明确的类型信息，代码可读性也会更好。</p>
<h3 id="8-1-2-容器类"><a href="#8-1-2-容器类" class="headerlink" title="8.1.2 容器类"></a>8.1.2 容器类</h3><p>泛型类最常见的用途是作为容器类。所谓容器类，简单地说，就是容纳并管理多项数据的类。数组就是用来管理多项数据的，但数组有很多限制，比如，长度固定，插入、删除操作效率比较低。计算机技术有一门课程叫数据结构，专门讨论管理数据的各种方式。</p>
<p>这些数据结构在Java中的实现主要就是Java中的各种容器类，甚至Java泛型的引入主要也是为了更好地支持Java容器。后续章节我们会详细讨论主要的Java容器，本节先实现一个非常简单的Java容器，来解释泛型的一些概念。</p>
<p>我们来实现一个简单的动态数组容器。所谓动态数组，就是长度可变的数组。底层数组的长度当然是不可变的，但我们提供一个类，对这个类的使用者而言，好像就是一个长度可变的数组。Java容器中有一个对应的类ArrayList，本节我们来实现一个简化版，如代码清单8-1所示。</p>
<center>代码清单8-1 动态数组DynamicArray</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">if</span>(oldCapacity &gt;= minCapacity)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity ＊ <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newCapacity &lt; minCapacity)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E)elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        E oldValue = get(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DynamicArray就是一个动态数组，内部代码与我们之前分析过的StringBuilder类似，通过ensureCapacity方法来根据需要扩展数组。作为一个容器类，它容纳的数据类型是作为参数传递过来的，比如，存放Double类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Double&gt; arr = <span class="keyword">new</span> DynamicArray&lt;Double&gt;();</span><br><span class="line">Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">1</span>+rnd.nextInt(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">    arr.add(Math.random());</span><br><span class="line">&#125;</span><br><span class="line">Double d = arr.get(rnd.nextInt(size));</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的容器类，适用于各种数据类型，且类型安全。后文还会以Dynamic-Array为例进行扩展，以解释泛型概念。</p>
<p>具体的类型还可以是一个泛型类，比如，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Pair&lt;Integer, String&gt;&gt; arr = new DynamicArray&lt;&gt;()</span><br></pre></td></tr></table></figure>

<p>arr表示一个动态数组，每个元素是<code>Pair&lt;Integer, String&gt;</code>类型。</p>
<h2 id="8-1-3-泛型方法"><a href="#8-1-3-泛型方法" class="headerlink" title="8.1.3 泛型方法"></a>8.1.3 泛型方法</h2><p>除了泛型类，方法也可以是泛型的，而且，一个方法是不是泛型的，与它所在的类是不是泛型没有什么关系。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T[] arr, T elm)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].equals(elm))&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是一个泛型方法，类型参数为<code>T</code>，放在返回值前面，它可以如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>也可以如下调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indexOf(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;老马&quot;</span>, <span class="string">&quot;编程&quot;</span>&#125;, <span class="string">&quot;老马&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>indexOf</code>表示一个算法，在给定数组中寻找某个元素，这个算法的基本过程与具体数据类型没有什么关系，通过泛型，它可以方便地应用于各种数据类型，且由编译器保证类型安全。</p>
<p>与泛型类一样，类型参数可以有多个，以逗号分隔，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U, V&gt; <span class="function">Pair&lt;U, V&gt; <span class="title">makePair</span><span class="params">(U first, V second)</span></span>&#123;</span><br><span class="line">    Pair&lt;U, V&gt; pair = <span class="keyword">new</span> Pair&lt;&gt;(first, second);</span><br><span class="line">    <span class="keyword">return</span> pair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与泛型类不同，调用方法时一般并不需要特意指定类型参数的实际类型，比如调用make-Pair：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">makePair(<span class="number">1</span>, <span class="string">&quot;老马&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>并不需要告诉编译器U的类型是Integer, V的类型是<code>String, Java</code>编译器可以自动推断出来。</p>
<h2 id="8-1-4-泛型接口"><a href="#8-1-4-泛型接口" class="headerlink" title="8.1.4 泛型接口"></a>8.1.4 泛型接口</h2><p>接口也可以是泛型的，我们之前介绍过的Comparable和Comparator接口都是泛型的，它们的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与前面一样，T是类型参数。实现接口时，应该指定具体的类型，比如，对Integer类，实现代码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过implements <code>Comparable&lt;Integer&gt;</code>, Integer实现了Comparable接口，指定了实际类型参数为Integer，表示Integer只能与Integer对象进行比较。</p>
<p>再看Comparator的一个例子，String类内部一个Comparator的接口实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略主体代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，指定了实际类型参数为String。</p>
<h2 id="8-1-5-类型参数的限定"><a href="#8-1-5-类型参数的限定" class="headerlink" title="8.1.5 类型参数的限定"></a>8.1.5 类型参数的限定</h2><p>在之前的介绍中，无论是泛型类、泛型方法还是泛型接口，关于类型参数，我们都知之甚少，只能把它当作Object，但Java支持限定这个参数的一个上界，也就是说，参数必须为给定的上界类型或其子类型，这个限定是通过extends关键字来表示的。这个上界可以是某个具体的类或者某个具体的接口，也可以是其他的类型参数，我们逐个介绍其应用。</p>
<h3 id="1．上界为某个具体类"><a href="#1．上界为某个具体类" class="headerlink" title="1．上界为某个具体类"></a>1．上界为某个具体类</h3><p>比如，上面的Pair类，可以定义一个子类NumberPair，限定两个类型参数必须为Number，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPair</span>&lt;<span class="title">U</span> <span class="keyword">extends</span> <span class="title">Number</span>, <span class="title">V</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">U</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberPair</span><span class="params">(U first, V second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(first, second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限定类型后，就可以使用该类型的方法了。比如，对于NumberPair类，first和second变量就可以当作Number进行处理了。比如可以定义一个求和方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst().doubleValue() +getSecond().doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这么用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumberPair&lt;Integer, Double&gt; pair = <span class="keyword">new</span> NumberPair&lt;&gt;(<span class="number">10</span>, <span class="number">12.34</span>);</span><br><span class="line"><span class="keyword">double</span> sum = pair.sum();</span><br></pre></td></tr></table></figure>

<p>限定类型后，如果类型使用错误，编译器会提示。指定边界后，类型擦除时就不会转换为Object了，而是会转换为它的边界类型，这也是容易理解的。</p>
<h3 id="2．上界为某个接口"><a href="#2．上界为某个接口" class="headerlink" title="2．上界为某个接口"></a>2．上界为某个接口</h3><p>在泛型方法中，一种常见的场景是限定类型必须实现Comparable接口，我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">max</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">    T max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i].compareTo(max)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>max方法计算一个泛型数组中的最大值。计算最大值需要进行元素之间的比较，要求元素实现Comparable接口，所以给类型参数设置了一个上边界Comparable, T必须实现Comparable接口。</p>
<p>不过，直接这么编写代码，Java中会给一个警告信息，因为Comparable是一个泛型接口，它也需要一个类型参数，所以完整的方法声明应该是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">    <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;T extends Comparable&lt;T&gt;&gt;</code>是一种令人费解的语法形式，这种形式称为<strong>递归类型限制</strong>，可以这么解读：T表示一种数据类型，必须实现Comparable接口，且必须可以与相同类型的元素进行比较。</p>
<h3 id="3．上界为其他类型参数"><a href="#3．上界为其他类型参数" class="headerlink" title="3．上界为其他类型参数"></a>3．上界为其他类型参数</h3><p>上面的限定都是指定了一个明确的类或接口，Java支持一个类型参数以另一个类型参数作为上界。为什么需要这个呢？我们看个例子，给上面的DynamicArray类增加一个实例方法addAll，这个方法将参数容器中的所有元素都添加到当前容器里来，直觉上，代码可以如下书写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.size; i++)&#123;</span><br><span class="line">        add(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这么写有一些局限性，我们看使用它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">numbers.addAll(ints); <span class="comment">//会提示编译错误</span></span><br></pre></td></tr></table></figure>

<p>numbers是一个Number类型的容器，ints是一个Integer类型的容器，我们希望将ints添加到numbers中，因为Integer是Number的子类，应该说，这是一个合理的需求和操作。</p>
<p>但Java会在numbers.addAll(ints)这行代码上提示编译错误：addAll需要的参数类型为<code>DynamicArray&lt;Number&gt;</code>，而传递过来的参数类型为<code>DynamicArray&lt;Integer&gt;</code>，不适用。Integer是Number的子类，怎么会不适用呢？</p>
<p>事实就是这样，确实不适用，而且是很有道理的，假设适用，我们看下会发生什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Number&gt; numbers = ints; <span class="comment">//假设这行是合法的</span></span><br><span class="line">numbers.add(<span class="keyword">new</span> Double(<span class="number">12.34</span>));</span><br></pre></td></tr></table></figure>

<p>那最后一行就是合法的，这时，<code>DynamicArray&lt;Integer&gt;</code>中就会出现Double类型的值，而这显然破坏了Java泛型关于类型安全的保证。</p>
<p>我们强调一下，虽然Integer是Number的子类，但<code>DynamicArray&lt;Integer&gt;</code>并不是<code>DynamicArray&lt;Number&gt;</code>的子类，<code>DynamicArray&lt;Integer&gt;</code>的对象也不能赋值给Dynamic-<code>Array&lt;Number&gt;</code>的变量，这一点初看上去是违反直觉的，但这是事实，必须要理解这一点。</p>
<p>不过，我们的需求是合理的，将Integer添加到Number容器中并没有问题。这个问题可以通过类型限定来解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(DynamicArray&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.size; i++)&#123;</span><br><span class="line">        add(c.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>E是DynamicArray的类型参数，T是addAll的类型参数，T的上界限定为E，这样，下面的代码就没有问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicArray&lt;Number&gt; numbers = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">DynamicArray&lt;Integer&gt; ints = <span class="keyword">new</span> DynamicArray&lt;&gt;();</span><br><span class="line">ints.add(<span class="number">100</span>);</span><br><span class="line">ints.add(<span class="number">34</span>);</span><br><span class="line">numbers.addAll(ints);</span><br></pre></td></tr></table></figure>

<p>对于这个例子，这种写法有点烦琐，8.2节中我们会介绍一种简化的方式。</p>
<h2 id="8-1-6-小结"><a href="#8-1-6-小结" class="headerlink" title="8.1.6 小结"></a>8.1.6 小结</h2><p><strong>泛型是计算机程序中一种重要的思维方式，它将数据结构和算法与数据类型相分离，使得同一套数据结构和算法能够应用于各种数据类型，而且可以保证类型安全，提高可读性</strong>。在Java中，泛型广泛应用于各种容器类中，理解泛型是深刻理解容器的基础。</p>
<p>本节介绍了泛型的基本概念，包括泛型类、泛型方法和泛型接口，关于类型参数，我们介绍了多种上界限定，限定为某具体类、某具体接口或其他类型参数。泛型类最常见的用途是容器类，我们实现了一个简单的容器类DynamicArray，以解释泛型概念。</p>
<p>在Java中，泛型是通过类型擦除来实现的，它是Java编译器的概念，Java虚拟机运行时对泛型基本一无所知，理解这一点是很重要的，它有助于我们理解Java泛型的很多局限性。</p>
<p>关于泛型，Java中有一个通配符的概念，用得很广泛，但语法非常令人费解，而且容易混淆，8.2节中，我们力图对它进行清晰的剖析。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8c1780e5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8c1780e5/" class="post-title-link" itemprop="url">2.4 char的真正含义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:04" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:04+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8c1780e5/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8c1780e5/" data-xid="/JavaReadingNotes/8c1780e5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-4-char的真正含义"><a href="#2-4-char的真正含义" class="headerlink" title="2.4 char的真正含义"></a>2.4 char的真正含义</h1><p>通过前面小节，我们应该对字符和文本的编码和乱码有了一个清晰的认识，但前面小节基本是与编程语言无关的，我们还是不知道怎么在程序中处理字符和文本。本节讨论在Java中进行字符处理的基础char, Java中还有Character、String、StringBuilder等类用于文本处理，它们的基础都是char，我们在第7章再介绍这些类。</p>
<p>char看上去是很简单的，正如我们在1.2节所说，char用于表示一个字符，这个字符可以是中文字符，也可以是英文字符。赋值时把常量字符用单引号括起来，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> z = <span class="string">&#x27;马&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但为什么字符类型也可以进行算术运算和比较呢？它的本质到底是什么呢？</p>
<p>在Java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。简单回顾一下，UTF-16使用两个或4个字节表示一个字符，Unicode编号范围在65536以内的占两个字节，超出范围的占4个字节，BE就是先输出高位字节，再输出低位字节，这与整数的内存表示是一致的。</p>
<p><strong>char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符</strong>。由于固定占用两个字节，char只能表示Unicode编号在65 536以内的字符，而不能表示超出范围的字符。那超出范围的字符怎么表示呢？使用两个char。类Character、String有一些相关的方法，我们到第7章再介绍。</p>
<p>在这个认识的基础上，我们再来看下char的一些行为。</p>
<p>char有多种赋值方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. char c = &#x27;A&#x27;</span><br><span class="line">2. char c = &#x27;马&#x27;</span><br><span class="line">3. char c = 39532</span><br><span class="line">4. char c = 0x9a6c</span><br><span class="line">5. char c = &#x27;\u9a6c&#x27;</span><br></pre></td></tr></table></figure>

<p>第1种赋值方式是最常见的，将一个能用ASCII码表示的字符赋给一个字符变量。第2种赋值方式也很常见，但这里是个中文字符，需要注意的是，直接写字符常量的时候应该注意文件的编码，比如，GBK编码的代码文件按UTF-8打开，字符会变成乱码，赋值的时候是按当前的编码解读方式，将这个字符形式对应的Unicode编号值赋给变量，“马”对应的Unicode编号是39 532，所以第2种赋值方式和第3种赋值方式是一样的。第3种赋值方式是直接将十进制的常量赋给字符。第4种赋值方式是将十六进制常量赋给字符，第5种赋值方式是按Unicode字符形式。所以，第2、3、4、5种赋值方式都是一样的，本质都是将Unicode编号39 532赋给了字符。</p>
<p>由于char本质上是一个整数，所以可以进行整数能做的一些运算，在进行运算时会被看作int，但由于char占两个字节，运算结果不能直接赋值给char类型，需要进行强制类型转换，这和byte、short参与整数运算是类似的。char类型的比较就是其Unicode编号的比较。</p>
<p>char的加减运算就是按其Unicode编号进行运算，一般对字符做加减运算没什么意义，但ASCII码字符是有意义的。比如大小写转换，大写A～Z的编号是65～90，小写a～z的编号是97～122，正好相差32，所以大写转小写只需加32，而小写转大写只需减32。加减运算的另一个应用是加密和解密，将字符进行某种可逆的数学运算可以做加解密。</p>
<p>char的位运算可以看作是对应整数的位运算，只是它是无符号数，也就是说，有符号右移&gt;&gt;和无符号右移&gt;&gt;&gt;的结果是一样的。既然char本质上是整数，查看char的二进制表示，同样可以用Integer的方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;马&#x27;</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(c));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001101001101100</span><br></pre></td></tr></table></figure>

<p>至此，关于整数、小数以及字符的二进制表示就介绍完了，下一章让我们一起来探索类的世界。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/91d12177/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/91d12177/" class="post-title-link" itemprop="url">2.3 字符的编码与乱码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:03" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:03+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/91d12177/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/91d12177/" data-xid="/JavaReadingNotes/91d12177/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-3-字符的编码与乱码"><a href="#2-3-字符的编码与乱码" class="headerlink" title="2.3 字符的编码与乱码"></a>2.3 字符的编码与乱码</h1><p>本节讨论与语言无关的字符和文本的编码以及乱码。我们在处理文件、浏览网页、编写程序时，时不时会碰到乱码的情况。乱码几乎总是令人心烦，让人困惑，通过阅读本节，相信你就可以自信从容地面对乱码，进而恢复乱码了。</p>
<p>编码和乱码听起来比较复杂，但其实并不复杂，请耐心阅读，让我们逐步来探讨。我们先介绍各种编码，然后介绍编码转换，分析乱码出现的原因，最后介绍如何从乱码中恢复。编码有两大类：一类是非Unicode编码；另一类是Unicode编码。我们先介绍非Unicode编码。</p>
<h2 id="2-3-1-常见非Unicode编码"><a href="#2-3-1-常见非Unicode编码" class="headerlink" title="2.3.1 常见非Unicode编码"></a>2.3.1 常见非Unicode编码</h2><p>下面我们看一些主要的非Unicode编码，包括ASCII、ISO 8859-1、Windows-1252、GB2312、GBK、GB18030和Big5。</p>
<h3 id="1-ASCII"><a href="#1-ASCII" class="headerlink" title="1. ASCII"></a>1. ASCII</h3><p>世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本上只考虑了美国的需求。美国大概只需要128个字符，所以就规定了128个字符的二进制表示方法。这个方法是一个标准，称为ASCII编码，全称是American StandardCode for InformationInterchange，即美国信息互换标准代码。</p>
<p>128个字符用7位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设置为0，用剩下的7位表示字符。这7位可以看作数字0～127, ASCII码规定了从0～127的每个数字代表什么含义。</p>
<p>我们先来看数字32～126的含义，如图2-1所示，除了中文之外，我们平常用的字符基本都涵盖了，键盘上的字符大部分也都涵盖了。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144602.jpeg" alt="epub_923038_22"></p>
<center>图2-1 ASCII编码：可打印字符</center>

<p>图2-1 ASCII编码：可打印字符数字32～126表示的字符都是可打印字符，0～31和127表示一些不可以打印的字符，这些字符一般用于控制目的，这些字符中大部分都是不常用的，表2-4列出了其中相对常用的字符。</p>
<center>表2-4 ASCII编码：常用不可打印字符</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144653.jpeg" alt="epub_923038_23"><br>ASCII码对美国是够用了，但对其他国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各种的编码方式以表示自己国家的字符，为了保持与ASCII码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示ASCII码，当为1时就是各个国家自己的字符。在这些扩展的编码中，在西欧国家中流行的是ISO 8859-1和Windows-1252，在中国是GB2312、GBK、GB18030和Big5，我们逐个介绍这些编码。</p>
<h3 id="2-ISO-8859-1"><a href="#2-ISO-8859-1" class="headerlink" title="2. ISO 8859-1"></a>2. ISO 8859-1</h3><p>ISO 8859-1又称Latin-1，它也是使用一个字节表示一个字符，其中0～127与ASCII一样，128～255规定了不同的含义。在128～255中，128～159表示一些控制字符，这些字符也不常用，就不介绍了。160～255表示一些西欧字符，如图2-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144707.jpeg" alt="epub_923038_24"></p>
<center>图2-2 ISO 8859-1</center>

<h3 id="3-Windows-1252"><a href="#3-Windows-1252" class="headerlink" title="3. Windows-1252"></a>3. Windows-1252</h3><p>ISO 8859-1虽然号称是标准，用于西欧国家，但它连欧元（€）这个符号都没有，因为欧元比较晚，而标准比较早。实际中使用更为广泛的是Windows-1252编码，这个编码与ISO 8859-1基本是一样的，区别只在于数字128～159。Windows-1252使用其中的一些数字表示可打印字符，这些数字表示的含义如图2-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208144724.jpeg"></p>
<center>图2-3 Windows-1252编码：区别于ISO8859-1的部分</center>

<p>这个编码中加入了欧元符号以及一些其他常用的字符。基本上可以认为，ISO8859-1已被Windows-1252取代，在很多应用程序中，即使文件声明它采用的是ISO 8859-1编码，解析的时候依然被当作Windows-1252编码。</p>
<p>HTML5甚至明确规定，如果文件声明的是ISO 8859-1编码，它应该被看作Win-dows-1252编码。为什么要这样呢？因为大部分人搞不清楚ISO 8859-1和Windows-1252的区别，当他说ISO 8859-1的时候，其实他指的是Windows-1252，所以标准干脆就这么强制规定了。</p>
<h3 id="4-GB2312"><a href="#4-GB2312" class="headerlink" title="4. GB2312"></a>4. GB2312</h3><p>美国和西欧字符用一个字节就够了，但中文显然是不够的。中文第一个标准是GB2312。GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字和一些罕用词和繁体字。</p>
<p>GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是ASCII字符。在这两个字节中，其中高位字节范围是0xA1～0xF7，低位字节范围是0xA1～0xFE。</p>
<p>比如，“老马”的GB2312编码（十六进制表示）如表2-5所示。</p>
<center>表2-5 GB2312编码示例</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208145753.jpeg" alt="epub_923038_26"></p>
<h3 id="5-GBK"><a href="#5-GBK" class="headerlink" title="5. GBK"></a>5. GBK</h3><p>GBK建立在GB2312的基础上，向下兼容GB2312，也就是说，GB2312编码的字符和二进制表示，在GBK编码里是完全一样的。GBK增加了14 000多个汉字，共计约21 000个汉字，其中包括繁体字。</p>
<p>GBK同样使用固定的两个字节表示，其中高位字节范围是0x81～0xFE，低位字节范围是0x40～0x7E和0x80～0xFE。</p>
<p>需要注意的是，低位字节是从0x40（也就是64）开始的，也就是说，低位字节的最高位可能为0。那怎么知道它是汉字的一部分，还是一个ASCII字符呢？其实很简单，因为汉字是用固定两个字节表示的，在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进来一起解析为一个汉字，而不用考虑它的最高位，解析完后，跳到第三个字节继续解析。</p>
<h3 id="6-GB18030"><a href="#6-GB18030" class="headerlink" title="6. GB18030"></a>6. GB18030</h3><p>GB18030向下兼容GBK，增加了55 000多个字符，共76 000多个字符，包括了很多少数民族字符，以及中日韩统一字符。</p>
<p>用两个字节已经表示不了GB18030中的所有字符，GB18030使用变长编码，有的字符是两个字节，有的是四个字节。在两字节编码中，字节表示范围与GBK一样。在四字节编码中，第一个字节的值为0x81～0xFE，第二个字节的值为0x30～0x39，第三个字节的值为0x81～0xFE，第四个字节的值为0x30～0x39。</p>
<p>解析二进制时，如何知道是两个字节还是4个字节表示一个字符呢？看第二个字节的范围，如果是0x30～0x39就是4个字节表示，因为两个字节编码中第二个字节都比这个大。</p>
<h3 id="7-Big5"><a href="#7-Big5" class="headerlink" title="7. Big5"></a>7. Big5</h3><p>Big5是针对繁体中文的，广泛用于我国台湾地区和我国香港特别行政区等地。Big5包括13 000多个繁体字，和GB2312类似，一个字符同样固定使用两个字节表示。在这两个字节中，高位字节范围是0x81～0xFE，低位字节范围是0x40～0x7E和0xA1～0xFE。</p>
<h3 id="8．编码汇总"><a href="#8．编码汇总" class="headerlink" title="8．编码汇总"></a>8．编码汇总</h3><p>我们简单汇总一下前面的内容。</p>
<p>ASCII码是基础，使用一个字节表示，最高位设为0，其他7位表示128个字符。其他编码都是兼容ASCII的，最高位使用1来进行区分。</p>
<p>西欧主要使用Windows-1252，使用一个字节，增加了额外128个字符。</p>
<p>我国内地的三个主要编码GB2312、GBK、GB18030有时间先后关系，表示的字符数越来越多，且后面的兼容前面的，GB2312和GBK都是用两个字节表示，而GB18030则使用两个或四个字节表示。</p>
<p>我国香港特别行政区和我国台湾地区的主要编码是Big5。</p>
<p>如果文本里的字符都是ASCII码字符，那么采用以上所说的任一编码方式都是一样的。</p>
<p>但如果有高位为1的字符，除了GB2312、GBK、GB18030外，其他编码都是不兼容的。比如，Windows-1252和中文的各种编码是不兼容的，即使Big5和GB18030都能表示繁体字，其表示方式也是不一样的，而这就会出现所谓的乱码，具体我们稍后介绍。</p>
<h2 id="2-3-2-Unicode编码"><a href="#2-3-2-Unicode编码" class="headerlink" title="2.3.2 Unicode编码"></a>2.3.2 Unicode编码</h2><p>以上我们介绍了中文和西欧的字符与编码，但世界上还有很多其他国家的字符，每个国家的各种计算机厂商都对自己常用的字符进行编码，在编码的时候基本忽略了其他国家的字符和编码，甚至忽略了同一国家的其他计算机厂商，这样造成的结果就是，出现了太多的编码，且互相不兼容。</p>
<p>世界上所有的字符能不能统一编码呢？可以，这就是Unicode。</p>
<p>Unicode 做了一件事，就是给世界上所有字符都分配了一个唯一的数字编号，这个编号范围从0x000000～0x10FFFF，包括110多万。但大部分常用字符都在0x0000～0xFFFF之间，即65 536个数字之内。每个字符都有一个Unicode编号，这个编号一般写成十六进制，在前面加U+。大部分中文的编号范围为U+4E00～U+9FFF，例如，“马”的Unicode是U+9A6C。</p>
<p>简单理解，Unicode主要做了这么一件事，就是给所有字符分配了唯一数字编号。它并没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，其他编码都既规定了能表示哪些字符，又规定了每个字符对应的二进制是什么，而Unicode本身只规定了每个字符的数字编号是多少。</p>
<p>那编号怎么对应到二进制表示呢？有多种方案，主要有UTF-32、UTF-16和UTF-8。</p>
<h3 id="1-UTF-32"><a href="#1-UTF-32" class="headerlink" title="1. UTF-32"></a>1. UTF-32</h3><p>这个最简单，就是字符编号的整数二进制形式，4个字节。</p>
<p>但有个细节，就是字节的排列顺序，如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫“大端”（Big Endian,BE），否则，就叫“小端”（Little Endian, LE）。对应的编码方式分别是UTF-32BE和UTF-32LE。</p>
<p>可以看出，每个字符都用4个字节表示，非常浪费空间，实际采用的也比较少。</p>
<h3 id="2-UTF-16"><a href="#2-UTF-16" class="headerlink" title="2. UTF-16"></a>2. UTF-16</h3><p>UTF-16使用变长字节表示：</p>
<p>1）对于编号在U+0000～U+FFFF的字符（常用字符集），直接用两个字节表示。需要说明的是，U+D800～U+DBFF的编号其实是没有定义的。</p>
<p>2）字符值在U+10000～U+10FFFF的字符（也叫做增补字符集），需要用4个字节表示。前两个字节叫高代理项，范围是U+D800～U+DBFF；后两个字节叫低代理项，范围是U+DC00～U+DFFF。数字编号和这个二进制表示之间有一个转换算法，本书就不介绍了。</p>
<p>区分是两个字节还是4个字节表示一个字符就看前两个字节的编号范围，如果是U+D800～U+DBFF，就是4个字节，否则就是两个字节。</p>
<p>UTF-16也有和UTF-32一样的字节序问题，如果高位存放在前面就叫大端（BE），编码就叫UTF-16BE，否则就叫小端，编码就叫UTF-16LE。</p>
<p>UTF-16常用于系统内部编码，UTF-16比UTF-32节省了很多空间，但是任何一个字符都至少需要两个字节表示，对于美国和西欧国家而言，还是很浪费的。</p>
<h3 id="3-UTF-8"><a href="#3-UTF-8" class="headerlink" title="3. UTF-8"></a>3. UTF-8</h3><p>UTF-8使用变长字节表示，每个字符使用的字节个数与其Unicode编号的大小有关，编号小的使用的字节就少，编号大的使用的字节就多，使用的字节个数为1～4不等。</p>
<p>具体来说，各个Unicode编号范围对应的二进制格式如表2-6所示。</p>
<center>表2-6 UTF-8编码的编号范围与对应的二进制格式</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150056.jpeg" alt="epub_923038_27"><br>表2-6中的x表示可以用的二进制位，而每个字节开头的1或0是固定的。</p>
<p>小于128的，编码与ASCII码一样，最高位为0。其他编号的第一个字节有特殊含义，最高位有几个连续的1就表示用几个字节表示，而其他字节都以10开头。</p>
<p>对于一个Unicode编号，具体怎么编码呢？首先将其看作整数，转化为二进制形式（去掉高位的0），然后将二进制位从右向左依次填入对应的二进制格式x中，填完后，如果对应的二进制格式还有没填的x，则设为0。</p>
<p>我们来看个例子，“马”的Unicode编号是0x9A6C，整数编号是39 532，其对应的UTF-8二进制格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure>

<p>整数编号39 532的二进制格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1001 101001 101100</span><br></pre></td></tr></table></figure>

<p>将这个二进制位从右到左依次填入二进制格式中，结果就是其UTF-8编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11101001 10101001 10101100</span><br></pre></td></tr></table></figure>

<p>十六进制表示为0xE9A9AC。</p>
<p>和UTF-32/UTF-16不同，UTF-8是兼容ASCII的，对大部分中文而言，一个中文字符需要用三个字节表示。</p>
<h3 id="4-Unicode编码小结"><a href="#4-Unicode编码小结" class="headerlink" title="4. Unicode编码小结"></a>4. Unicode编码小结</h3><p>Unicode给世界上所有字符都规定了一个统一的编号，编号范围达到110多万，但大部分字符都在65 536以内。Unicode本身没有规定怎么把这个编号对应到二进制形式。</p>
<p>UTF-32/UTF-16/UTF-8都在做一件事，就是把Unicode编号对应到二进制形式，其对应方法不同而已。UTF-32使用4个字节，UTF-16大部分是两个字节，少部分是4个字节，它们都不兼容ASCII编码，都有字节顺序的问题。UTF-8使用1～4个字节表示，兼容ASCII编码，英文字符使用1个字节，中文字符大多用3个字节。</p>
<h2 id="2-3-3-编码转换"><a href="#2-3-3-编码转换" class="headerlink" title="2.3.3 编码转换"></a>2.3.3 编码转换</h2><p>有了Unicode之后，每一个字符就有了多种不兼容的编码方式，比如说“马”这个字符，它的各种编码方式对应的十六进制如表2-7所示。</p>
<center>表2-7 字符“马”多种编码方式</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150313.jpeg" alt="epub_923038_28"><br>这几种格式之间可以借助Unicode编号进行编码转换。可以认为：每种编码都有一个映射表，存储其特有的字符编码和Unicode编号之间的对应关系，这个映射表是一个简化的说法，实际上可能是一个映射或转换方法。</p>
<p>编码转换的具体过程可以是：一个字符从A编码转到B编码，先找到字符的A编码格式，通过A的映射表找到其Unicode编号，然后通过Unicode编号再查B的映射表，找到字符的B编码格式。</p>
<p>举例来说，“马”从GB18030转到UTF-8，先查GB18030-&gt;Unicode编号表，得到其编号是9A 6C，然后查Uncode编号-&gt;UTF-8表，得到其UTF-8编码：E9 A9AC。</p>
<p>编码转换改变了字符的二进制内容，但并没有改变字符看上去的样子。</p>
<h2 id="2-3-4-乱码的原因"><a href="#2-3-4-乱码的原因" class="headerlink" title="2.3.4 乱码的原因"></a>2.3.4 乱码的原因</h2><p>理解了编码，我们来看乱码。乱码有两种常见原因：一种比较简单，就是简单的解析错误；另外一种比较复杂，在错误解析的基础上进行了编码转换。我们分别介绍。</p>
<h3 id="1．解析错误"><a href="#1．解析错误" class="headerlink" title="1．解析错误"></a>1．解析错误</h3><p>看个简单的例子。一个法国人采用Windows-1252编码写了个文件，发送给了一个中国人，中国人使用GB18030来解析这个字符，看到的可能就是乱码。比如，法国人发送的是Pékin, Windows-1252的二进制（采用十六进制）是50 E9 6B 696E，第二个字节E9对应é，其他都是ASCII码，中国人收到的也是这个二进制，但是他把它看成了GB18030编码，GB18030中E9 6B对应的是字符“閗”，于是他看到的就是“P閗in”，这看来就是一个乱码。</p>
<p>反之也是一样的，一个GB18030编码的文件如果被看作Windows-1252也是乱码。</p>
<p>这种情况下，之所以看起来是乱码，是因为看待或者说解析数据的方式错了。只要使用正确的编码方式进行解读就可以纠正了。很多文件编辑器，如EditPlus、NotePad++、UltraEdit都有切换查看编码方式的功能，浏览器也都有切换查看编码方式的功能，如Fire-fox，在菜单“查看”→“文字编码”中即可找到该功能。</p>
<p>切换查看编码的方式并没有改变数据的二进制本身，而只是改变了解析数据的方式，从而改变了数据看起来的样子，这与前面提到的编码转换正好相反。很多时候，做这样一个编码查看方式的切换就可以解决乱码的问题，但有的时候这样是不够的。</p>
<h3 id="2．错误的解析和编码转换"><a href="#2．错误的解析和编码转换" class="headerlink" title="2．错误的解析和编码转换"></a>2．错误的解析和编码转换</h3><p>如果怎么改变查看方式都不对，那很有可能就不仅仅是解析二进制的方式不对，而是文本在错误解析的基础上还进行了编码转换。我们举个例子来说明：</p>
<p>1）两个字“老马”，本来的编码格式是GB18030，编码（十六进制）是C0 CF C2ED。<br>2）这个二进制形式被错误当成了Windows-1252编码，解读成了字符“ÀÏÂí”。<br>3）随后这个字符进行了编码转换，转换成了UTF-8编码，形式还是“ÀÏÂí”，但二进制变成了C3 80 C3 8F C3 82 C3 AD，每个字符两个字节。<br>4）这个时候再按照GB18030解析，字符就变成了乱码形式“脌脧脗铆”，而且这时无论怎么切换查看编码的方式，这个二进制看起来都是乱码。</p>
<p>这种情况是乱码产生的主要原因。</p>
<p>这种情况其实很常见，计算机程序为了便于统一处理，经常会将所有编码转换为一种方式，比如UTF-8，在转换的时候，需要知道原来的编码是什么，但可能会搞错，而一旦搞错并进行了转换，就会出现这种乱码。这种情况下，无论怎么切换查看编码方式都是不行的，如表2-8所示。</p>
<center>表2-8 用不同编码方式查看错误转换后的二进制</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150849.jpeg" alt="epub_923038_29"><br>虽然有这么多形式，但我们看到的乱码形式很可能是“ÀÏÂí”，因为在例子中UTF-8是编码转换的目标编码格式，既然转换为了UTF-8，一般也是要按UTF-8查看。</p>
<p>那有没有办法恢复呢？如果有，怎么恢复呢？</p>
<h2 id="2-3-5-从乱码中恢复"><a href="#2-3-5-从乱码中恢复" class="headerlink" title="2.3.5 从乱码中恢复"></a>2.3.5 从乱码中恢复</h2><p>“乱”主要是因为发生了一次错误的编码转换，所谓恢复，是指要恢复两个关键信息：一个是原来的二进制编码方式A；另一个是错误解读的编码方式B。</p>
<p>恢复的基本思路是尝试进行逆向操作，假定按一种编码转换方式B获取乱码的二进制格式，然后再假定一种编码解读方式A解读这个二进制，查看其看上去的形式，这要尝试多种编码，如果能找到看着正常的字符形式，应该就可以恢复。</p>
<p>这听上去可能比较抽象，我们举个例子来说明，假定乱码形式是“ÀÏÂí”，尝试多种B和A来看字符形式。我们先使用编辑器，以UltraEdit为例，然后使用Java编程来看。</p>
<h3 id="1．使用UltraEdit"><a href="#1．使用UltraEdit" class="headerlink" title="1．使用UltraEdit"></a>1．使用UltraEdit</h3><p>UltraEdit支持编码转换和切换查看编码方式，也支持文件的二进制显示和编辑，所以我们以UltraEdit为例，其他一些编辑器可能也有类似功能。</p>
<p>新建一个UTF-8编码的文件，复制“ÀÏÂí”到文件中。使用编码转换，转换到Win-dows-1252编码，执行“文件”→“转换到”→“西欧”→WIN-1252命令。</p>
<p>转换完后，打开十六进制编辑，查看其二进制形式，如图2-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150903.jpeg" alt="epub_923038_30"></p>
<center>图2-4 使用UltraEdit查看二进制</center>

<p>可以看出，其形式还是“ÀÏÂí”，但二进制格式变成了 C0 CF C2 ED。这个过程相当于假设B是Windows-1252。这个时候，再按照多种编码格式查看这个二进制，在UltraEdit中，关闭十六进制编辑，切换查看编码方式为GB18030，执行“视图”→“查看方式（文件编码）”→“东亚语言”→GB18030命令，切换完后，同样的二进制神奇地变为了正确的字符形式“老马”，打开十六进制编辑器，可以看出二进制还是C0 CF C2 ED，这个GB18030相当于假设A是GB18030。</p>
<p>这个例子我们碰巧第一次就猜对了。实际中，可能要做多次尝试，过程是类似的，先进行编码转换（使用B编码），然后使用不同编码方式查看（使用A编码），如果能找到看上去对的形式，就恢复了。表2-9列出了主要的B编码格式、对应的二进制，以及按A编码解读的各种形式。</p>
<center>表2-9 尝试不同编码方式进行恢复</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208150917.jpeg" alt="epub_923038_31"><br>可以看出，第一行是正确的，也就是说原来的编码其实是A即GB18030，但被错误解读成了B即Windows-1252了。</p>
<h3 id="2．使用Java"><a href="#2．使用Java" class="headerlink" title="2．使用Java"></a>2．使用Java</h3><p>下面我们来看如何使用Java恢复乱码。关于使用Java我们还有很多知识没有介绍，为了完整性起见，本节一并列出相关代码，初学者不明白的可以暂时略过。Java中处理字符串的类有String, String中有我们需要的两个重要方法。<br>1）public byte[] getBytes(String charsetName)，这个方法可以获取一个字符串的给定编码格式的二进制形式。<br>2）public String(byte bytes[], String charsetName)，这个构造方法以给定的二进制数组bytes按照编码格式charsetName解读为一个字符串。</p>
<p>将A看作GB18030，将B看作Windows-1252，进行恢复的Java代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;ÀÏÂí&quot;</span>;</span><br><span class="line">String newStr = <span class="keyword">new</span> String(str.getBytes(<span class="string">&quot;windows-1252&quot;</span>), <span class="string">&quot;GB18030&quot;</span>);</span><br><span class="line">System.out.println(newStr);</span><br></pre></td></tr></table></figure>

<p>先按照B编码（Windows-1252）获取字符串的二进制，然后按A编码（GB18030）解读这个二进制，得到一个新的字符串，然后输出这个字符串的形式，输出为“老马”。</p>
<p>同样，一次碰巧就对了，实际中，我们可以写一个循环，测试不同的A/B编码中的结果形式，如代码清单2-1所示。</p>
<center>代码清单2-1 恢复乱码的方法</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException</span>&#123;</span><br><span class="line">    String[] charsets = <span class="keyword">new</span> String[]&#123;</span><br><span class="line">            <span class="string">&quot;windows-1252&quot;</span>, <span class="string">&quot;GB18030&quot;</span>, <span class="string">&quot;Big5&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;charsets.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;charsets.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i! =j)&#123;</span><br><span class="line">                String s = <span class="keyword">new</span> String(str.getBytes(charsets[i]), charsets[j]);</span><br><span class="line">                System.out.println(<span class="string">&quot;---- 原来编码(A)假设是： &quot;</span></span><br><span class="line">                    +charsets[j]+<span class="string">&quot;, 被错误解读为了(B): &quot;</span>+charsets[i]);</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码使用不同的编码格式进行测试，如果输出有正确的，那么就可以恢复。</p>
<p>可以看出，恢复的尝试需要进行很多次，上面例子尝试了常见编码GB18030、Windows 1252、Big5、UTF-8共12种组合。这4种编码是常见编码，在大部分实际应用中应该够了。如果有其他编码，可以增加一些尝试。</p>
<p>不是所有的乱码形式都是可以恢复的，如果形式中有很多不能识别的字符（如？），则很难恢复。另外，如果乱码是由于进行了多次解析和转换错误造成的，也很难恢复。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/21b11bb9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/21b11bb9/" class="post-title-link" itemprop="url">2.2 小数的二进制表示</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:02" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:02+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/21b11bb9/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/21b11bb9/" data-xid="/JavaReadingNotes/21b11bb9/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="2-2-小数的二进制表示"><a href="#2-2-小数的二进制表示" class="headerlink" title="2.2 小数的二进制表示"></a>2.2 小数的二进制表示</h1><p>计算机之所以叫“计算”机，就是因为发明它主要是用来计算的，“计算”当然是它的特长，在大家的印象中，计算一定是非常准确的。但实际上，即使在一些非常基本的小数运算中，计算的结果也是不精确的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>*<span class="number">0.1f</span>;</span><br><span class="line">System.out.println(f);</span><br></pre></td></tr></table></figure>

<p>这个结果看上去，应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。看上去这么简单的运算，计算机怎么会出错了呢？</p>
<h2 id="2-2-1-小数计算为什么会出错"><a href="#2-2-1-小数计算为什么会出错" class="headerlink" title="2.2.1 小数计算为什么会出错"></a>2.2.1 小数计算为什么会出错</h2><p>实际上，不是运算本身会出错，而是计算机根本就不能精确地表示很多数，比如0.1这个数。计算机是用一种二进制格式存储小数的，这个二进制格式不能精确表示0.1，它只能表示一个非常接近0.1但又不等于0.1的一个数。数字都不能精确表示，在不精确数字上的运算结果不精确也就不足为奇了。</p>
<p>0.1怎么就不能精确表示呢？在十进制的世界里是可以的，但在二进制的世界里不行。在说二进制之前，我们先来看下熟悉的十进制。</p>
<p>实际上，十进制也只能表示那些可以表述为10的多少次方和的数，比如12.345，实际上表示的是1× 10+2× 1+3× 0.1+4× 0.01+5× 0.001，与整数的表示类似，小数点后面的每个位置也都有一个位权，从左到右，依次为0.1,0.01,0.001…即10^(-1),10^(-2),10^(-3)等。</p>
<p>很多数十进制也是不能精确表示的，比如1/3，保留三位小数的话，十进制表示是0.333，但无论后面保留多少位小数，都是不精确的，用0.333进行运算，比如乘以3，期望结果是1，但实际上却是0.999。</p>
<p>二进制是类似的，但二进制只能表示那些可以表述为2的多少次方和的数。来看下2的次方的一些例子，如表2-3所示。</p>
<center>表2-3 2的次方</center>


<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211202133501.jpeg" alt="epub_923038_21"><br>可以精确表示为2的某次方之和的数可以精确表示，其他数则不能精确表示。</p>
<p>为什么计算机中不能用我们熟悉的十进制呢？在最底层，计算机使用的电子元器件只能表示两个状态，通常是低压和高压，对应0和1，使用二进制容易基于这些电子元器件构建硬件设备和进行运算。如果非要使用十进制，则这些硬件就会复杂很多，并且效率低下。</p>
<p>如果编写程序进行试验，会发现有的计算结果是准确的。比如，用Java写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">0.1f</span>+<span class="number">0.1f</span>);</span><br><span class="line">System.out.println(<span class="number">0.1f</span>*<span class="number">0.1f</span>);</span><br></pre></td></tr></table></figure>

<p>第一行输出0.2，第二行输出0.010000001。按照上面的说法，第一行的结果应该也不对。其实，这只是Java语言给我们造成的假象，计算结果其实也是不精确的，但是由于结果和0.2足够接近，在输出的时候，Java选择了输出0.2这个看上去非常精简的数字，而不是一个中间有很多0的小数。在误差足够小的时候，结果看上去是精确的，但不精确其实才是常态。</p>
<p>计算不精确，怎么办呢？大部分情况下，我们不需要那么高的精度，可以四舍五入，或者在输出的时候只保留固定个数的小数位。如果真的需要比较高的精度，一种方法是将小数转化为整数进行运算，运算结束后再转化为小数；另一种方法是使用十进制的数据类型，这个并没有统一的规范。在Java中是BigDecimal，运算更准确，但效率比较低，本节就不介绍了。</p>
<h2 id="2-2-2-二进制表示"><a href="#2-2-2-二进制表示" class="headerlink" title="2.2.2 二进制表示"></a>2.2.2 二进制表示</h2><p>我们之前一直在用“小数”这个词表示float和double类型，其实，这是不严谨的，“小数”是在数学中用的词，在计算机中，我们一般说的是“浮点数”。float和double被称为浮点数据类型，小数运算被称为浮点运算。</p>
<p>为什么要叫浮点数呢？这是由于小数的二进制表示中，表示那个小数点的时候，点不是固定的，而是浮动的。</p>
<p>我们还是用十进制类比，十进制有科学记数法，比如123.45这个数，直接这么写，就是固定表示法，如果用科学记数法，在小数点前只保留一位数字，可以写为1.2345E2即1.2345× (10^2)，即在科学记数法中，小数点向左浮动了两位。</p>
<p>二进制中为表示小数，也采用类似的科学表示法，形如m× (2^e)。m称为尾数，e称为指数。指数可以为正，也可以为负，负的指数表示那些接近0的比较小的数。在二进制中，单独表示尾数部分和指数部分，另外还有一个符号位表示正负。</p>
<p>几乎所有的硬件和编程语言表示小数的二进制格式都是一样的。这种格式是一个标准，叫做IEEE 754标准，它定义了两种格式：一种是32位的，对应于Java的float；另一种是64位的，对应于Java的double。</p>
<p>32位格式中，1位表示符号，23位表示尾数，8位表示指数。64位格式中，1位表示符号，52位表示尾数，11位表示指数。在两种格式中，除了表示正常的数，标准还规定了一些特殊的二进制形式表示一些特殊的值，比如负无穷、正无穷、0、NaN（非数值，比如0乘以无穷大）。IEEE 754标准有一些复杂的细节，初次看上去难以理解，对于日常应用也不常用，本书就不介绍了。</p>
<p>如果想查看浮点数的具体二进制形式，在Java中，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(Float.floatToIntBits(value))</span><br><span class="line">Long.toBinaryString(Double.doubleToLongBits(value));</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/9f845784/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/9f845784/" class="post-title-link" itemprop="url">2.0 第2章 理解数据背后的二进制 2.1 整数的二进制表示与位运算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC2%E7%AB%A0-%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">第2章 理解数据背后的二进制</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/9f845784/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/9f845784/" data-xid="/JavaReadingNotes/9f845784/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第2章-理解数据背后的二进制"><a href="#第2章-理解数据背后的二进制" class="headerlink" title="第2章 理解数据背后的二进制"></a>第2章 理解数据背后的二进制</h1><p>在第1章，我们遗留了几个问题。</p>
<ul>
<li>正整数相乘的结果居然出现了负数。</li>
<li>非常基本的小数运算结果居然不精确。</li>
<li>字符类型也可以进行算术运算和比较。</li>
</ul>
<p>要理解这些行为，我们需要理解数值和文本字符在计算机内部的二进制表示，本章就来介绍各种数据背后的二进制，具体分为4节：2.1节介绍整数；2.2节介绍小数；2.3节介绍与语言无关的字符和文本的编码以及乱码；2.4节介绍Java中表示字符的基本类型char。</p>
<h1 id="2-1-整数的二进制表示与位运算"><a href="#2-1-整数的二进制表示与位运算" class="headerlink" title="2.1 整数的二进制表示与位运算"></a>2.1 整数的二进制表示与位运算</h1><p>要理解整数的二进制，我们先来看下熟悉的十进制。我们对十进制是如此熟悉，可能已忽略了它的含义。比如123，不假思索我们就知道它的值是多少。</p>
<p>但其实123表示1× (10^2)+2× (10^1)+3× (10^0)（10^2表示10的二次方），它表示的是各个位置数字含义之和，每个位置的数字含义与位置有关，从右向左，第一位乘以10的0次方，即1，第二位乘以10的1次方，即10，第三位乘以10的2次方，即100，以此类推。</p>
<p>换句话说，每个位置都有一个<strong>位权</strong>，从右到左，第一位为1，然后依次乘以10，即第二位为10，第三位为100，以此类推。</p>
<h2 id="2-1-1-正整数的二进制表示"><a href="#2-1-1-正整数的二进制表示" class="headerlink" title="2.1.1 正整数的二进制表示"></a>2.1.1 正整数的二进制表示</h2><p>正整数的二进制表示与此类似，只是在十进制中，每个位置可以有10个数字，为0～9，但在二进制中，每个位置只能是0或1。位权的概念是类似的，从右到左，第一位为1，然后依次乘以2，即第二位为2，第三位为4，以此类推。表2-1列出了一些数字的二进制与对应的十进制。</p>
<center>表2-1 二进制与对应的十进制</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201223406.jpeg" alt="epub_923038_19"></p>
<h3 id="2-1-2-负整数的二进制表示"><a href="#2-1-2-负整数的二进制表示" class="headerlink" title="2.1.2 负整数的二进制表示"></a>2.1.2 负整数的二进制表示</h3><p>十进制的负数表示就是在前面加一个负数符号-，例如-123。但二进制如何表示负数呢？其实概念是类似的，二进制使用最高位表示符号位，用1表示负数，用0表示正数。但哪个是最高位呢？整数有4种类型byte、short、int、long，分别占1、2、4、8个字节，即分别占8、16、32、64位，每种类型的符号位都是其最左边的一位。为方便举例，下面假定类型是byte，即从右到左的第8位表示符号位。</p>
<p>但负数表示不是简单地将最高位变为1，比如：<br>1）byte a=-1，如果只是将最高位变为1，二进制应该是10000001，但实际上，它应该是11111111。<br>2）byte a=-127，如果只是将最高位变为1，二进制应该是11111111，但实际上，它却应该是10000001。</p>
<p>和我们的直觉正好相反，这是什么表示法？这种表示法称为补码表示法，而符合我们直觉的表示称为原码表示法，补码表示就是在原码表示的基础上取反然后加1。取反就是将0变为1,1变为0。负数的二进制表示就是对应的正数的补码表示，比如：<br>1）-1:1的原码表示是00000001，取反是11111110，然后再加1，就是11111111。<br>2）-2:2的原码表示是00000010，取反是11111101，然后再加1，就是11111110。<br>3）-127:127的原码表示是01111111，取反是10000000，然后再加1，就是10000001。</p>
<p>给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算。比如：10010010，首先取反，变为01101101，然后加1，结果为01101110，它的十进制值为110，所以原值就是-110。直觉上，应该是先减1，然后再取反，但计算机只能做加法，而补码的一个良好特性就是，对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样。</p>
<p>对于byte类型，正数最大表示是01111111，即127，负数最小表示（绝对值最大）是10000000，即-128，表示范围就是-128～127。其他类型的整数也类似，负数能多表示一个数。</p>
<p>负整数为什么要采用这种奇怪的表示形式呢？原因是，只有这种形式，计算机才能实现正确的加减法。</p>
<p>计算机其实只能做加法，1-1其实是1+(-1)。如果用原码表示，计算结果是不对的，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   -&gt; 00000001</span><br><span class="line">-1 -&gt; 10000001</span><br><span class="line">+ ------------------</span><br><span class="line">-2 -&gt; 10000010</span><br></pre></td></tr></table></figure>

<p>用符合直觉的原码表示，1-1的结果是-2，如果是补码表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1   -&gt; 00000001</span><br><span class="line">-1 -&gt; 11111111</span><br><span class="line">+ ------------------</span><br><span class="line">0   -&gt; 00000000</span><br></pre></td></tr></table></figure>

<p>结果是正确的。再如，5-3：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5   -&gt; 00000101</span><br><span class="line">-3 -&gt; 11111101</span><br><span class="line">+ ------------------</span><br><span class="line">2   -&gt; 00000010</span><br></pre></td></tr></table></figure>

<p>结果也是正确的。就是这样，看上去可能比较奇怪和难以理解，但这种表示其实是非常严谨和正确的，是不是很奇妙？</p>
<p>理解了二进制加减法，我们就能理解为什么正数的运算结果可能出现负数了。当计算结果超出表示范围的时候，最高位往往是1，然后就会被看作负数。比如，127+1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127    -&gt; 01111111</span><br><span class="line">1      -&gt; 00000001</span><br><span class="line">+ ------------------</span><br><span class="line">-128   -&gt; 10000000</span><br></pre></td></tr></table></figure>

<p>计算结果超出了byte的表示范围，会被看作-128。</p>
<h2 id="2-1-3-十六进制"><a href="#2-1-3-十六进制" class="headerlink" title="2.1.3 十六进制"></a>2.1.3 十六进制</h2><p>二进制写起来太长，为了简化写法，可以将4个二进制位简化为一个0～15的数，10～15用字符A～F表示，这种表示方法称为十六进制，如表2-2所示。</p>
<center>表2-2 十六进制</center>


<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201223630.jpeg" alt="epub_923038_20"><br>可以用十六进制直接写常量数字，在数字前面加0x即可。比如十进制的123，用十六进制表示是0x7B，即123=7×16+11。给整数赋值或者进行运算的时候，都可以直接使用十六进制，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 0x7B;</span><br></pre></td></tr></table></figure>

<p>Java 7之前不支持直接写二进制常量。比如，想写二进制形式的11001, Java 7之前不能直接写，可以在前面补0，补足8位，为00011001，然后用十六进制表示，即0x19。Java 7开始支持二进制常量，在前面加0b或0B即可，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 0b11001;</span><br></pre></td></tr></table></figure>

<p>在Java中，可以方便地使用Integer和Long的方法查看整数的二进制和十六进制表示，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 25;</span><br><span class="line">System.out.println(Integer.toBinaryString(a)); //二进制</span><br><span class="line">System.out.println(Integer.toHexString(a));  //十六进制</span><br><span class="line">System.out.println(Long.toBinaryString(a)); //二进制</span><br><span class="line">System.out.println(Long.toHexString(a));  //十六进制</span><br></pre></td></tr></table></figure>

<h2 id="2-1-4-位运算"><a href="#2-1-4-位运算" class="headerlink" title="2.1.4 位运算"></a>2.1.4 位运算</h2><p>理解了二进制表示，我们来看二进制级别的操作：位运算。Java 7之前不能单独表示一个位，但可以用byte表示8位，用十六进制写二进制常量。比如，0010表示成十六进制是0x2,110110表示成十六进制是0x36。</p>
<p>位运算有移位运算和逻辑运算。移位有以下几种。<br>1）左移：操作符为&lt;&lt;，向左移动，右边的低位补0，高位的就舍弃掉了，将二进制看作整数，左移1位就相当于乘以2。<br>2）无符号右移：操作符为&gt;&gt;&gt;，向右移动，右边的舍弃掉，左边补0。<br>3）有符号右移：操作符为&gt;&gt;，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是1就补1，原来是0就补0，将二进制看作整数，右移1位相当于除以2。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 4; //100</span><br><span class="line">a = a &gt;&gt; 2; //001，等于1</span><br><span class="line">a = a &lt;&lt; 3 //1000，变为8</span><br></pre></td></tr></table></figure>

<p>逻辑运算有以下几种。</p>
<ul>
<li>按位与&amp;：两位都为1才为1。</li>
<li>按位或|：只要有一位为1，就为1。</li>
<li>按位取反~:1变为0,0变为1。</li>
<li>按位异或^：相异为真，相同为假。</li>
</ul>
<p>大部分都比较简单，如下所示，具体就不赘述了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = …;</span><br><span class="line">a = a &amp; 0x1 //返回0或1，就是a最右边一位的值</span><br><span class="line">a   = a | 0x1 //不管a原来最右边一位是什么，都将设为1</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d32d4643/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d32d4643/" class="post-title-link" itemprop="url">3.2 类的组合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC3%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第3章 类的基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d32d4643/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d32d4643/" data-xid="/JavaReadingNotes/d32d4643/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="3-2-类的组合"><a href="#3-2-类的组合" class="headerlink" title="3.2 类的组合"></a>3.2 类的组合</h1><p>程序是用来解决现实问题的，将现实中的概念映射为程序中的概念，是初学编程过程中的一步跨越。本节通过一些例子来演示如何将一些现实概念和问题通过类以及类的组合来表示和处理，涉及的概念包括图形处理、电商、人之间的血缘关系以及计算机中的文件和目录。</p>
<p>我们先介绍两个基础类String和Date，它们都是Java API中的类，分别表示文本字符串和日期。</p>
<h2 id="3-2-1-String和Date"><a href="#3-2-1-String和Date" class="headerlink" title="3.2.1 String和Date"></a>3.2.1 String和Date</h2><p>String是Java API中的一个类，表示多个字符，即一段文本或字符串，它内部是一个char的数组，提供了若干方法用于操作字符串。</p>
<p>String可以用一个字符串常量初始化，字符串常量用双引号括起来（注意与字符常量区别，字符常量是用单引号）。例如，如下语句声明了一个String变量name，并赋值为“老马说编程”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;老马说编程&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>String类提供了很多方法，用于操作字符串。在Java中，由于String用得非常普遍， Java对它有一些特殊的处理，本节暂不介绍这些内容，只是把它当作一个表示字符串的类型来看待。</p>
<p>Date也是Java API中的一个类，表示日期和时间，它内部是一个long类型的值，也提供了若干方法用于操作日期和时间。</p>
<p>用无参的构造方法新建一个Date对象，这个对象就表示当前时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date now = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<p>日期和时间处理是一个比较大的话题，我们留待第7章详解，本节我们只是把它当作表示日期和时间的类型来看待。</p>
<h2 id="3-2-2-图形类"><a href="#3-2-2-图形类" class="headerlink" title="3.2.2 图形类"></a>3.2.2 图形类</h2><p>我们先扩展一下Point类，在其中增加一个方法，计算到另一个点的距离，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x-p.getX(), <span class="number">2</span>)+Math.pow(y-p.getY(), <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类Point中，属性x、y都是基本类型，但类的属性也可以是类。我们考虑一个表示线的类，它由两个点组成，有一个实例方法计算线的长度，如代码清单3-2所示。</p>
<center>代码清单3-2 表示线的类Line</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point start;</span><br><span class="line">    <span class="keyword">private</span> Point end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Line</span><span class="params">(Point start, Point end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start= start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start.distance(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Line由两个Point组成，在创建Line时这两个Point是必需的，所以只有一个构造方法，且需传递这两个点，length方法计算线的长度，它调用了Point计算距离的方法获取线的长度。可以看出，<strong>在设计线时，我们考虑的层次是点，而不考虑点的内部细节。每个类封装其内部细节，对外提供高层次的功能，使其他类在更高层次上考虑和解决问题，是程序设计的一种基本思维方式</strong>。</p>
<p>使用这个类的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Point start = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    Point end = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    Line line = <span class="keyword">new</span> Line(start, end);</span><br><span class="line">    System.out.println(line.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也很简单。我们再说明一下内存布局，line的两个实例成员都是引用类型，引用实际的point，整体内存布局如图3-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208153346.jpeg" alt="epub_923038_36"></p>
<center>图3-1 图形类Point和Line对象的内存布局</center>

<p>start、end、line三个引用型变量分配在栈中，保存的是实际内容的地址，实际内容保存在堆中，line的两个实例变量line.start和line.end还是引用，同样保存的是实际内容的地址。</p>
<h2 id="3-2-3-用类描述电商概念"><a href="#3-2-3-用类描述电商概念" class="headerlink" title="3.2.3 用类描述电商概念"></a>3.2.3 用类描述电商概念</h2><p>接下来，我们用类来描述一下电商系统中的一些基本概念，电商系统中最基本的有产品、用户和订单。</p>
<p>1）产品：有产品唯一id、名称、描述、图片、价格等属性。<br>2）用户：有用户名、密码等属性。<br>3）订单：有订单号、下单用户、选购产品列表及数量、下单时间、收货人、收货地址、联系电话、订单状态等属性。</p>
<p>当然，实际情况可能非常复杂，这是一个非常简化的描述。</p>
<p>产品类Product如代码清单3-3所示。</p>
<center>代码清单3-3 表示产品的类Product</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">//唯一id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//产品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//产品图片链接</span></span><br><span class="line">    <span class="keyword">private</span> String pictureUrl;</span><br><span class="line">    <span class="comment">//产品描述</span></span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">//产品价格</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们省略了类的构造方法，以及属性的getter/setter方法，下面大部分示例代码也都会省略。</p>
<p>这是用户类User的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个订单可能会有多个产品，每个产品可能有不同的数量，我们用订单条目OrderItem这个类来描述单个产品及选购的数量，如代码清单3-4所示。</p>
<center>代码清单3-4 表示订单条目的类OrderItem</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span> </span>&#123;</span><br><span class="line">    <span class="comment">//购买产品</span></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="comment">//购买数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> quantity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderItem</span><span class="params">(Product product, <span class="keyword">int</span> quantity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.product = product;</span><br><span class="line">        <span class="keyword">this</span>.quantity = quantity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computePrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product.getPrice()＊quantity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OrderItem引用了产品类Product，我们定义了一个构造方法，以及计算该订单条目价格的方法。</p>
<p>订单类Order如代码清单3-5所示。</p>
<center>代码清单3-5 表示订单的类Order</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">//订单号</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//购买用户</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="comment">//购买产品列表及数量</span></span><br><span class="line">    <span class="keyword">private</span> OrderItem[] items;</span><br><span class="line">    <span class="comment">//下单时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//收货人</span></span><br><span class="line">    <span class="keyword">private</span> String   receiver;</span><br><span class="line">    <span class="comment">//收货地址</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//联系电话</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">//订单状态</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">computeTotalPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalPrice = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(items! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(OrderItem item : items)&#123;</span><br><span class="line">                totalPrice+=item.computePrice();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Order类引用了用户类User，以及一个订单条目的数组OrderItem，它定义了一个计算总价的方法。这里用一个String类表示状态status，更合适的应该是枚举类型，枚举我们第5章再介绍。</p>
<p>以上类定义是非常简化的，但是大致演示了将现实概念映射为类以及类组合的过程，这个过程大概就是，<strong>想想现实问题有哪些概念，这些概念有哪些属性、哪些行为，概念之间有什么关系，然后定义类、定义属性、定义方法、定义类之间的关系。概念的属性和行为可能是非常多的，但定义的类只需要包括那些与现实问题相关的就行了</strong>。</p>
<h2 id="3-2-4-用类描述人之间的血缘关系"><a href="#3-2-4-用类描述人之间的血缘关系" class="headerlink" title="3.2.4 用类描述人之间的血缘关系"></a>3.2.4 用类描述人之间的血缘关系</h2><p>上面介绍的图形类和电商类只会引用别的类，但一个类定义中还可以引用它自己，比如我们要描述人以及人之间的血缘关系。我们用类Person表示一个人，它的实例成员包括其父亲、母亲、和孩子，这些成员也都是Person类型，如代码清单3-6所示。</p>
<center>代码清单3-6 表示人的类Person</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//父亲</span></span><br><span class="line">    <span class="keyword">private</span> Person father;</span><br><span class="line">    <span class="comment">//母亲</span></span><br><span class="line">    <span class="keyword">private</span> Person mother;</span><br><span class="line">    <span class="comment">//孩子数组</span></span><br><span class="line">    <span class="keyword">private</span> Person[] children;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里同样省略了setter/getter方法。对初学者，初看起来这是比较难以理解的，有点类似于函数调用中的递归调用，这里面的关键点是，实例变量不需要一开始就有值。我们来看下如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Person laoma = <span class="keyword">new</span> Person(<span class="string">&quot;老马&quot;</span>);</span><br><span class="line">    Person xiaoma = <span class="keyword">new</span> Person(<span class="string">&quot;小马&quot;</span>);</span><br><span class="line">    xiaoma.setFather(laoma);</span><br><span class="line">    laoma.setChildren(<span class="keyword">new</span> Person[]&#123;xiaoma&#125;);</span><br><span class="line">    System.out.println(xiaoma.getFather().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码先创建了老马（laoma），然后创建了小马（xiaoma），接着调用xiaoma的set-Father方法和laoma的setChildren方法设置了父子关系，Person类对象的内存布局如图3-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208153756.jpeg" alt="epub_923038_37"></p>
<center>图3-2 Person类对象的内存布局</center>

<h2 id="3-2-5-目录和文件"><a href="#3-2-5-目录和文件" class="headerlink" title="3.2.5 目录和文件"></a>3.2.5 目录和文件</h2><p>接下来，我们介绍两个类MyFile和MyFolder，分别表示文件管理中的两个概念：文件和文件夹。文件和文件夹都有名称、创建时间、父文件夹，根文件夹没有父文件夹，文件夹还有子文件列表和子文件夹列表。文件类MyFile如代码清单3-7所示。代码清单3-7 文件类MyFile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFile</span> </span>&#123;</span><br><span class="line">    <span class="comment">//文件名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//文件大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//上级目录</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder parent;</span><br><span class="line">    <span class="comment">//其他方法……</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件夹类MyFolder如代码清单3-8所示。</p>
<center>代码清单3-8 文件夹类MyFolder</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//文件夹名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//创建时间</span></span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line">    <span class="comment">//上级文件夹</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder parent;</span><br><span class="line">    <span class="comment">//包含的文件</span></span><br><span class="line">    <span class="keyword">private</span> MyFile[] files;</span><br><span class="line">    <span class="comment">//包含的子文件夹</span></span><br><span class="line">    <span class="keyword">private</span> MyFolder[] subFolders;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(files! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(MyFile file : files)&#123;</span><br><span class="line">                totalSize+=file.getSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(subFolders! =<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(MyFolder folder : subFolders)&#123;</span><br><span class="line">                totalSize+=folder.totalSize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyFile和MyFolder都省略了构造方法、settter/getter方法，以及关于父子关系维护的代码，主要演示实例变量间的组合关系。<strong>两个类之间可以互相引用，MyFile引用了MyFolder，而MyFolder也引用了MyFile</strong>，这是没有问题的。因为正如之前所说，这些属性不需要一开始就设置，也不是必须设置的。另外，演示了一个递归方法totalSize()，返回当前文件夹下所有文件的大小，这是使用递归函数的一个很好的场景。</p>
<h2 id="3-2-6-一些说明"><a href="#3-2-6-一些说明" class="headerlink" title="3.2.6 一些说明"></a>3.2.6 一些说明</h2><p>类中应该定义哪些变量和方法，这是与要解决的问题密切相关的，本节中并没有特别强调问题是什么，定义的属性和方法主要用于演示基本概念，实际应用中应该根据具体问题进行调整。</p>
<p>类中实例变量的类型可以是当前定义的类型，两个类之间可以互相引用，这些初听起来可能难以理解，但现实世界就是这样的，创建对象的时候这些值不需要一开始就有，也可以没有，所以是没有问题的。</p>
<p>类之间的组合关系在Java中实现的都是引用，但在逻辑关系上，有两种明显不同的关系，一种是包含，另一种是单纯引用。比如，在订单类Order中，Order与User的关系就是单纯引用，User是独立存在的；而Order与OrderItem的关系就是包含，OrderItem总是从属于某一个Order。</p>
<h2 id="3-2-7-小结"><a href="#3-2-7-小结" class="headerlink" title="3.2.7 小结"></a>3.2.7 小结</h2><p>对初学编程的人来说，不清楚如何用程序概念表示现实问题，本节通过一些简化的例子来解释如何将现实中的概念映射为程序中的类。</p>
<p>分解现实问题中涉及的概念以及概念间的关系，将概念表示为多个类，通过类之间的组合来表达更为复杂的概念以及概念间的关系，是计算机程序的一种基本思维方式。</p>
<p>正所谓，道生一，一生二，二生三，三生万物，如果将二进制表示和运算看作一，将基本数据类型看作二，基本数据类型形成的类看作三，那么，类的组合以及下章介绍的继承则使得三生万物。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/4bc606d7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/4bc606d7/" class="post-title-link" itemprop="url">3.3 代码的组织机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC3%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第3章 类的基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/4bc606d7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/4bc606d7/" data-xid="/JavaReadingNotes/4bc606d7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="3-3-代码的组织机制"><a href="#3-3-代码的组织机制" class="headerlink" title="3.3 代码的组织机制"></a>3.3 代码的组织机制</h1><p>使用任何语言进行编程都有一个类似的问题，那就是如何组织代码。具体来说，如何避免命名冲突？如何合理组织各种源文件？如何使用第三方库？各种代码和依赖库如何编译链接为一个完整的程序？本节就来讨论Java中的解决机制，具体包括包、jar包、程序的编译与链接等。</p>
<h2 id="3-3-1-包的概念"><a href="#3-3-1-包的概念" class="headerlink" title="3.3.1 包的概念"></a>3.3.1 包的概念</h2><p>使用任何语言进行编程都有一个相同的问题，就是命名冲突。程序一般不全是一个人写的，会调用系统提供的代码、第三方库中的代码、项目中其他人写的代码等，不同的人就不同的目的可能定义同样的类名/接口名，Java中解决这个问题的主要方法就是<strong>包</strong>。</p>
<p>即使代码都是一个人写的，将多个关系不太大的类和接口都放在一起，也不便于理解和维护，Java中组织类和接口的方式也是包。</p>
<p>包是一个比较容易理解的概念，类似于计算机中的文件夹，正如我们在计算机中管理文件，文件放在文件夹中一样，类和接口放在包中，为便于组织，文件夹一般是一个层次结构，包也类似。</p>
<p>包有包名，这个名称以点号（.）分隔表示层次结构。比如，我们之前常用的String类就位于包java.lang下，其中java是上层包名，lang是下层包名。带完整包名的类名称为其<strong>完全限定名</strong>，比如String类的完全限定名为java.lang.String。Java API中所有的类和接口都位于包Java或javax下，Java是标准包，javax是扩展包。</p>
<p>接下来，我们讨论包的细节，包括包的声明、使用和包范围可见性。</p>
<h3 id="1．声明类所在的包"><a href="#1．声明类所在的包" class="headerlink" title="1．声明类所在的包"></a>1．声明类所在的包</h3><p>我们之前定义类的时候没有定义其所在的包，默认情况下，类位于默认包下，使用默认包是不建议的，我们使用默认包只是简单起见。</p>
<p>定义类的时候，应该先使用关键字package声明其包名，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuo.laoma;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上声明类Hello的包名为shuo.laoma，包声明语句应该位于源代码的最前面，前面不能有注释外的其他语句。</p>
<p>包名和文件目录结构必须匹配，如果源文件的根目录为E:\src\，则上面的Hello类对应的文件Hello.java，其全路径就应该是E:\src\shuo\laoma\Hello.java。如果不匹配，Java会提示编译错误。</p>
<p>为避免命名冲突，Java中命名包名的一个惯例是使用域名作为前缀，因为域名是唯一的，一般按照域名的反序来定义包名，比如，域名是apache.org，包名就以org.apache开头。</p>
<p>没有域名的也没关系，使用一个其他代码不太会用的包名即可，比如本节使用的shuo. laoma。如果代码需要公开给其他人用，最好有一个域名以确保唯一性，如果只是内部使用，则确保内部没有其他代码使用该包名即可。</p>
<p>除了避免命名冲突，包也是一种方便组织代码的机制。一般而言，同一个项目下的所有代码都有一个相同的包前缀，这个前缀是唯一的，不会与其他代码重名，在项目内部，根据不同目的再细分为子包，子包可能又会分为下一级子包，形成层次结构，内部实现一般位于比较底层的包。</p>
<p>包可以方便模块化开发，不同功能可以位于不同包内，不同开发人员负责不同的包。包也可以方便封装，供外部使用的类可以放在包的上层，而内部的实现细节则可以放在比较底层的子包内。</p>
<h3 id="2．通过包使用类"><a href="#2．通过包使用类" class="headerlink" title="2．通过包使用类"></a>2．通过包使用类</h3><p>同一个包下的类之间互相引用是不需要包名的，可以直接使用。但如果类不在同一个包内，则必须要知道其所在的包。使用有两种方式：一种是通过类的完全限定名；另外一种是将用到的类引入当前类。只有一个例外，java.lang包下的类可以直接使用，不需要引入，也不需要使用完全限定名，比如String类、System类，其他包内的类则不行。</p>
<p>看个例子，使用Arrays类中的sort方法，通过完全限定名可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">java.util.Arrays.sort(arr);</span><br><span class="line">System.out.println(java.util.Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>显然，这样比较烦琐，另外一种就是将该类引入当前类。引入的关键字是import,import需要放在package定义之后，类定义之前，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuo.laoma;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做import操作时，可以一次将某个包下的所有类引入，语法是使用<code>.*</code>，比如，将<code>java.util</code>包下的所有类引入，语法是：<code>import java.util.*</code>。需要注意的是，这个引入不能递归，它只会引入<code>java.util</code>包下的直接类，而不会引入<code>java.util</code>下嵌套包内的类，比如，不会引入包<code>java.util.zip</code>下面的类。试图嵌套引入的形式也是无效的，如<code>import java.util.*.*</code>。</p>
<p>在一个类内，对其他类的引用必须是唯一确定的，不能有重名的类，如果有，则通过import只能引入其中的一个类，其他同名的类则必须要使用完全限定名。</p>
<p>引入类是一个比较烦琐的工作，不过，大多数Java开发环境都提供工具自动做这件事。比如，在Eclipse中，通过执行Source→Organize Imports命令或按对应的快捷键Ctrl+Shift+O就可以自动管理引用的类。</p>
<p>有一种特殊类型的导入，称为静态导入，它有一个static关键字，可以直接导入类的公开静态方法和成员。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.＊; <span class="comment">//静态导入Arrays中的所有静态方法</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out; <span class="comment">//导入静态变量out</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        sort(arr);  <span class="comment">//可以直接使用Arrays中的sort方法</span></span><br><span class="line">        out.println(Arrays.toString(arr)); <span class="comment">//可以直接使用out变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态导入不应过度使用，否则难以区分访问的是哪个类的代码。</p>
<h3 id="3．包范围可见性"><a href="#3．包范围可见性" class="headerlink" title="3．包范围可见性"></a>3．包范围可见性</h3><p>前面章节我们介绍过，对于类、变量和方法，都可以有一个可见性修饰符public/private，我们还提到，可以不写修饰符。如果什么修饰符都不写，它的可见性范围就是同一个包内，同一个包内的其他类可以访问，而其他包内的类则不可以访问。</p>
<p>需要说明的是，同一个包指的是同一个直接包，子包下的类并不能访问。比如，类shuo.laoma.Hello和shuo.laoma.inner.Test，其所在的包shuo.laoma和shuo.laoma.inner是两个完全独立的包，并没有逻辑上的联系，Hello类和Test类不能互相访问对方的包可见性方法和属性。</p>
<p>除了public和private修饰符，还有一个与继承有关的修饰符protected。关于protected的细节我们下章介绍，这里需要说明的是，protected<strong>可见性包括包可见性</strong>，也就是说，声明为protected不仅表明子类可以访问，还表明同一个包内的其他类可以访问，即使这些类不是子类也可以。</p>
<p>总结来说，可见性范围从小到大是：private &lt; <strong>默认(包)</strong> &lt; protected &lt; public。</p>
<h2 id="3-3-2-jar包"><a href="#3-3-2-jar包" class="headerlink" title="3.3.2 jar包"></a>3.3.2 jar包</h2><p>为方便使用第三方代码，也为了方便我们写的代码给其他人使用，各种程序语言大多有打包的概念，打包的一般不是源代码，而是编译后的代码。打包将多个编译后的文件打包为一个文件，方便其他程序调用。</p>
<p>在Java中，编译后的一个或多个包的Java class文件可以打包为一个文件，Java中打包命令为jar，打包后的文件扩展名为．jar，一般称之为jar包。</p>
<p>可以使用如下方式打包，首先到编译后的java class文件根目录，然后运行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf &lt;包名&gt;.jar &lt;最上层包名&gt;</span><br></pre></td></tr></table></figure>

<p>比如，对前面介绍的类打包，如果Hello.class位于E:\bin\shuo\laoma\Hello.class，则可以到目录 E:\bin下，然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar -cvf hello.jar shuo</span><br></pre></td></tr></table></figure>

<p>hello.jar就是jar包，jar包其实就是一个压缩文件，可以使用解压缩工具打开。</p>
<p>Java类库、第三方类库都是以jar包形式提供的。如何使用jar包呢？将其加入<strong>类路径</strong>（classpath）中即可。类路径是什么呢？我们下面来看。</p>
<h2 id="3-3-3-程序的编译与链接"><a href="#3-3-3-程序的编译与链接" class="headerlink" title="3.3.3 程序的编译与链接"></a>3.3.3 程序的编译与链接</h2><p>从Java源代码到运行的程序，有编译和链接两个步骤。编译是将源代码文件变成扩展名是．class的一种字节码，这个工作一般是由javac命令完成的。链接是在运行时动态执行的，.class文件不能直接运行，运行的是Java虚拟机，虚拟机听起来比较抽象，执行的就是Java命令，这个命令解析．class文件，转换为机器能识别的二进制代码，然后运行。所谓链接就是根据引用到的类加载相应的字节码并执行。</p>
<p>Java编译和运行时，都需要以参数指定一个classpath，即类路径。类路径可以有多个，对于直接的class文件，路径是class文件的根目录；对于jar包，路径是jar包的完整名称（包括路径和jar包名）。在Windows系统中，多个路径用分号“; ”分隔；在其他系统中，以冒号“:”分隔。</p>
<p>在Java源代码编译时，Java编译器会确定引用的每个类的完全限定名，确定的方式是根据import语句和classpath。如果导入的是完全限定类名，则可以直接比较并确定。如果是模糊导入（import带．*），则根据classpath找对应父包，再在父包下寻找是否有对应的类。如果多个模糊导入的包下都有同样的类名，则Java会提示编译错误，此时应该明确指定导入哪个类。</p>
<p>Java运行时，会根据类的完全限定名寻找并加载类，寻找的方式就是在类路径中寻找，如果是class文件的根目录，则直接查看是否有对应的子目录及文件，如果是jar文件，则首先在内存中解压文件，然后再查看是否有对应的类。</p>
<p>总结来说，<strong>import是编译时概念，用于确定完全限定名，在运行时，只根据完全限定名寻找并加载类</strong>，编译和运行时都依赖类路径，类路径中的jar文件会被解压缩用于寻找和加载类。</p>
<h2 id="3-3-4-小结"><a href="#3-3-4-小结" class="headerlink" title="3.3.4 小结"></a>3.3.4 小结</h2><p>本节介绍了Java中代码组织的机制、包和jar包，以及程序的编译和链接。将类和接口放在合适的具有层次结构的包内，避免命名冲突，代码可以更为清晰，便于实现封装和模块化开发；通过jar包使用第三方代码，将自身代码打包为jar包供其他程序使用。这些都是解决复杂问题所必需的。</p>
<p>在Java 9中，清晰地引入了<strong>模块</strong>的概念，JDK和JRE都按模块化进行了重构，传统的组织机制依然是支持的，但新的应用可以使用模块。一个应用可由多个模块组成，一个模块可由多个包组成。模块之间可以有一定的依赖关系，一个模块可以导出包给其他模块用，可以提供服务给其他模块用，也可以使用其他模块提供的包，调用其他模块提供的服务。对于复杂的应用，模块化有很多好处，比如更强的封装、更为可靠的配置、更为松散的耦合、更动态灵活等。模块是一个很大的主题，限于篇幅，我们就不详细介绍了。</p>
<p>至此，关于类的基础知识就介绍完了。类之间除了组合关系，还有一种非常重要的关系，那就是继承，我们下章来探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/JavaReadingNotes/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/9/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/9/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
