<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/149/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/149/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/149/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-mzjszagu6-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/819e8c93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/819e8c93/" class="post-title-link" itemprop="url">16.5.2 同步代码块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 16:31:20" itemprop="dateCreated datePublished" datetime="2019-07-17T16:31:20+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-26 01:40:32" itemprop="dateModified" datetime="2020-03-26T01:40:32+08:00">2020-03-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" itemprop="url" rel="index"><span itemprop="name">16.5 线程同步</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/819e8c93/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/819e8c93/" data-xid="/JavaReadingNotes/819e8c93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-5-2-同步代码块"><a href="#16-5-2-同步代码块" class="headerlink" title="16.5.2 同步代码块"></a>16.5.2 同步代码块</h1><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p><code>Java</code>的多线程支持引入了<strong>同步监视器</strong>来解决同步问题,**使用<mark>同步监视器</mark>的通用方法就是<mark>同步代码块</mark>**。</p>
<h3 id="同步代码块的语法格式"><a href="#同步代码块的语法格式" class="headerlink" title="同步代码块的语法格式"></a>同步代码块的语法格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 同步代码块的内容...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="什么是同步监视器"><a href="#什么是同步监视器" class="headerlink" title="什么是同步监视器"></a>什么是同步监视器</h3><p><strong><code>synchronized</code>关键字后面的括号里的参数<code>object</code>就是同步监视器</strong></p>
<h3 id="同步代码块的含义"><a href="#同步代码块的含义" class="headerlink" title="同步代码块的含义"></a>同步代码块的含义</h3><p>同步代码块的含义是:<br><strong>线程开始执行同步代码块之前,必须先获得对同步监视器的锁定</strong>。</p>
<p>任何时刻<strong>只能有一个线程可以获得对同步监视器的锁定</strong>,当同步代码块执行完成后,该线程会释放对该同步监视器的锁定。</p>
<h3 id="同步监视器的选择标准"><a href="#同步监视器的选择标准" class="headerlink" title="同步监视器的选择标准"></a>同步监视器的选择标准</h3><p>虽然<code>Java</code>程序允许使用<strong>任何对象</strong>作为同步监视器,但<strong>同步监视器的目的是阻止两个线程对<code>同一个共享资源</code>进行并发访问</strong>,因此<strong>通常推荐使用可能<mark>被并发访问的共享资源</mark>充当同步监视器</strong>。</p>
<h2 id="程序-使用同步代码块-同步取钱"><a href="#程序-使用同步代码块-同步取钱" class="headerlink" title="程序 使用同步代码块 同步取钱"></a>程序 使用同步代码块 同步取钱</h2><p>对于上面的取钱模拟程序,应该考虑<strong>使用账户(<code>account</code>)作为同步监视器</strong>,把程序修改成如下形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟用户账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">// 当前取钱线程所希望取的钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name, Account account, <span class="keyword">double</span> drawAmount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当多条线程修改同一个共享数据时，将涉及数据安全问题。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用account作为同步监视器，任何线程进入下面同步代码块之前，</span></span><br><span class="line">        <span class="comment">// 必须先获得对account账户的锁定——其他线程无法获得锁，也就无法修改它</span></span><br><span class="line">        <span class="comment">// 这种做法符合：“加锁 → 修改 → 释放锁”的逻辑</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="comment">// 账户余额大于取钱数目</span></span><br><span class="line">            <span class="keyword">if</span> (account.getBalance() &gt;= drawAmount) &#123;</span><br><span class="line">                <span class="comment">// 吐出钞票</span></span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱成功！吐出钞票:&quot;</span> + drawAmount);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 修改余额</span></span><br><span class="line">                account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">                System.out.println(<span class="string">&quot;\t余额为: &quot;</span> + account.getBalance());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;取钱失败！余额不足！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 同步代码块结束，该线程释放同步锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序使用<code>synchronized</code>将<code>run()</code>方法里的方法体修改成<code>同步代码块</code>,该同步代码块的<strong>同步监视器是<code>account</code>对象</strong>,这样的做法符合”加锁→修改→释放锁”的逻辑。</p>
<h2 id="加锁-修改-释放锁"><a href="#加锁-修改-释放锁" class="headerlink" title="加锁 修改 释放锁"></a>加锁 修改 释放锁</h2><p>任何线程在修改指定资源之前,</p>
<ul>
<li>首先对该资源加锁,在加锁期间其他线程无法修改该资源,</li>
<li>当该线程修改完成后,</li>
<li>该线程释放对该资源的锁定。</li>
</ul>
<p>通过这种方式就可以保证并发线程在任一时刻只有一个线程可以进入修改共享资源的代码区(也被称为临界区),所以同一时刻最多只有一个线程处于临界区内,从而保证了线程的安全性。</p>
<p>将<code>DrawThread</code>修改为上面所示的情形之后,多次运行该程序,总可以看到如下的运行结果:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">甲取钱成功！吐出钞票:<span class="number">800</span>.<span class="number">0</span></span><br><span class="line">    余额为: <span class="number">200</span>.<span class="number">0</span></span><br><span class="line">乙取钱失败！余额不足！</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8c76ba08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8c76ba08/" class="post-title-link" itemprop="url">16.5 线程同步 16.5.1 线程安全问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 15:49:51" itemprop="dateCreated datePublished" datetime="2019-07-17T15:49:51+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-26 01:30:34" itemprop="dateModified" datetime="2020-03-26T01:30:34+08:00">2020-03-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" itemprop="url" rel="index"><span itemprop="name">16.5 线程同步</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8c76ba08/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8c76ba08/" data-xid="/JavaReadingNotes/8c76ba08/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-5-线程同步"><a href="#16-5-线程同步" class="headerlink" title="16.5 线程同步"></a>16.5 线程同步</h1><p>多线程编程很容易突然出现“错误情况”,这是<strong>由系统的线程调度具有一定的随机性造成的</strong>,不过即使程序偶然出现问题,那也是由于编程不当引起的。<strong>当使用多个线程来访问同一个数据时,很容易“偶然”出现线程安全问题</strong>。</p>
<h1 id="16-5-1-线程安全问题"><a href="#16-5-1-线程安全问题" class="headerlink" title="16.5.1 线程安全问题"></a>16.5.1 线程安全问题</h1><h2 id="银行取钱问题"><a href="#银行取钱问题" class="headerlink" title="银行取钱问题"></a>银行取钱问题</h2><p>关于线程安全问题,有一个经典的问题——银行取钱的问题。银行取钱的基本流程基本上可以分为如下几个步骤</p>
<ol>
<li>用户输入账户、密码,系统判断用户的账户、密码是否匹配。</li>
<li>用户输入取款金额</li>
<li>系统判断账户余额是否大于取款金额<ol>
<li>如果余额大于取款金额,则取款成功;</li>
<li>如果余额小于取款金额,则取款失败</li>
</ol>
</li>
</ol>
<p>乍一看上去,这个流程确实就是日常生活中的取款流程,这个流程没有任何问题。但一旦将这个流程放在多线程并发的场景下,就有可能出现问题。注意此处说的是有可能,并不是说一定。也许你的程序运行了一百万次都没有出现问题,但没有出现问题并不等于没有问题!</p>
<h2 id="程序-银行取钱问题"><a href="#程序-银行取钱问题" class="headerlink" title="程序 银行取钱问题"></a>程序 银行取钱问题</h2><p>按上面的流程去编写取款程序,并使用两个线程来模拟取钱操作,模拟两个人使用同一个账户并发取钱的问题。此处忽略检査账户和密码的操作,仅仅模拟后面三步操作。</p>
<h3 id="账户类"><a href="#账户类" class="headerlink" title="账户类"></a>账户类</h3><p>下面先定义一个账户类,该账户类封装了账户编号和余额两个实例变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 封装账户编号、账户余额的两个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String accountNo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String accountNo , <span class="keyword">double</span> balance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountNo = accountNo;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">    <span class="comment">// 下面两个方法根据accountNo来重写hashCode()和equals()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountNo.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj !=<span class="keyword">null</span></span><br><span class="line">            &amp;&amp; obj.getClass() == Account.class)</span><br><span class="line">        &#123;</span><br><span class="line">            Account target = (Account)obj;</span><br><span class="line">            <span class="keyword">return</span> target.getAccountNo().equals(accountNo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="取钱线程"><a href="#取钱线程" class="headerlink" title="取钱线程"></a>取钱线程</h3><p>接下来提供一个取钱的线程类,该线程类根据执行账户、取钱数量进行取钱操作,取钱的逻辑是当其余额不足时无法提取现金,当余额足够时系统吐出钞票,余额减少。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 模拟用户账户</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="comment">// 当前取钱线程所希望取的钱数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> drawAmount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawThread</span><span class="params">(String name , Account account</span></span></span><br><span class="line"><span class="params"><span class="function">        , <span class="keyword">double</span> drawAmount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">        <span class="keyword">this</span>.drawAmount = drawAmount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当多条线程修改同一个共享数据时，将涉及数据安全问题。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 账户余额大于取钱数目</span></span><br><span class="line">        <span class="keyword">if</span> (account.getBalance() &gt;= drawAmount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 吐出钞票</span></span><br><span class="line">            System.out.println(getName()</span><br><span class="line">                + <span class="string">&quot;取钱成功！吐出钞票:&quot;</span> + drawAmount);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 修改余额</span></span><br><span class="line">            account.setBalance(account.getBalance() - drawAmount);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t余额为: &quot;</span> + account.getBalance());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;取钱失败！余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序是一个非常简单的取钱逻辑,这个取钱逻辑与实际的取钱操作也很相似。</p>
<h3 id="主程序"><a href="#主程序" class="headerlink" title="主程序"></a>主程序</h3><p>程序的主程序非常简单,仅仅是创建一个账户,并启动两个线程从该账户中取钱。如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个账户</span></span><br><span class="line">        Account acct = <span class="keyword">new</span> Account(<span class="string">&quot;1234567&quot;</span> , <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 模拟两个线程对同一个账户取钱</span></span><br><span class="line">        <span class="keyword">new</span> DrawThread(<span class="string">&quot;甲&quot;</span> , acct , <span class="number">800</span>).start();</span><br><span class="line">        <span class="keyword">new</span> DrawThread(<span class="string">&quot;乙&quot;</span> , acct , <span class="number">800</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>多次运行上面程序,很有可能都会看到如下所示的错误结果</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">甲取钱成功！吐出钞票:<span class="number">800</span>.<span class="number">0</span></span><br><span class="line">乙取钱成功！吐出钞票:<span class="number">800</span>.<span class="number">0</span></span><br><span class="line">    余额为: -<span class="number">600</span>.<span class="number">0</span></span><br><span class="line">    余额为: -<span class="number">600</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>账户余额出现了负值,这不是银行希望的结果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d01ed83d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d01ed83d/" class="post-title-link" itemprop="url">16.4.5 改变线程优先级</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 15:35:28" itemprop="dateCreated datePublished" datetime="2019-07-17T15:35:28+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-26 01:18:36" itemprop="dateModified" datetime="2020-03-26T01:18:36+08:00">2020-03-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-4-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">16.4 控制线程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d01ed83d/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d01ed83d/" data-xid="/JavaReadingNotes/d01ed83d/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-4-5-改变线程优先级"><a href="#16-4-5-改变线程优先级" class="headerlink" title="16.4.5 改变线程优先级"></a>16.4.5 改变线程优先级</h1><h2 id="优先级的作用"><a href="#优先级的作用" class="headerlink" title="优先级的作用"></a>优先级的作用</h2><p>每个线程执行时都具有一定的优先级,<strong><code>优先级高</code>的线程获得<code>较多的执行机会</code>,而优先级低的线程则获得较少的执行机会</strong>。</p>
<h2 id="默认优先级"><a href="#默认优先级" class="headerlink" title="默认优先级"></a>默认优先级</h2><p><strong>每个线程默认的优先级都与创建它的父线程的优先级相同</strong>,在默认情况下,<code>main</code>线程具有普通优先级,所以由<code>main</code>线程创建的子线程也具有普通优先级。</p>
<h2 id="优先级方法"><a href="#优先级方法" class="headerlink" title="优先级方法"></a>优先级方法</h2><p><code>Thread</code>类提供了<code>setPriority</code>和<code>getPriority</code>方法来设置和返回指定线程的优先级:</p>
<table>
<thead>
<tr>
<th align="left"><code>Thread</code>类方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void setPriority(int newPriority)</code></td>
<td align="left">Changes the priority of this thread.</td>
</tr>
<tr>
<td align="left"><code>int getPriority()</code></td>
<td align="left">Returns this thread’s priority.</td>
</tr>
</tbody></table>
<p>其中<code>setPriority()</code>方法的参数可以是一个整数,范围是<code>1-10</code>之间,也可以使用<code>Thread</code>类提供的三个静态常量来设置优先级,如下所示:</p>
<ul>
<li><code>MAX_PRIORITY</code>,其值是<code>10</code></li>
<li><code>NORM_PRIORITY</code>,其值是<code>5</code>。</li>
<li><code>MIN_PRIORITY</code>,其值是<code>1</code></li>
</ul>
<h2 id="程序-设置线程优先级"><a href="#程序-设置线程优先级" class="headerlink" title="程序 设置线程优先级"></a>程序 设置线程优先级</h2><p>下面程序使用了<code>setPriority()</code>方法来改变主线程的优先级,并使用该方法改变了两个线程的优先级,从而可以看<strong>到高优先级的线程将会获得更多的执行机会</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个有参数的构造器，用于创建线程时指定name</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityTest</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;,其优先级是：&quot;</span> + getPriority() + <span class="string">&quot;,循环变量的值为:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 改变主线程的优先级</span></span><br><span class="line">        Thread.currentThread().setPriority(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                PriorityTest low = <span class="keyword">new</span> PriorityTest(<span class="string">&quot;低级&quot;</span>);</span><br><span class="line">                low.start();</span><br><span class="line">                System.out.println(<span class="string">&quot;创建之初的优先级:&quot;</span> + low.getPriority());</span><br><span class="line">                <span class="comment">// 设置该线程为最低优先级</span></span><br><span class="line">                low.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">                PriorityTest high = <span class="keyword">new</span> PriorityTest(<span class="string">&quot;高级&quot;</span>);</span><br><span class="line">                high.start();</span><br><span class="line">                System.out.println(<span class="string">&quot;创建之初的优先级:&quot;</span> + high.getPriority());</span><br><span class="line">                <span class="comment">// 设置该线程为最高优先级</span></span><br><span class="line">                high.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中改变了主线程的优先级为6,这样由<code>main</code>线程所创建的子线程的优先级默认都是6,所以程序直接输出<code>low</code>、<code>high</code>两个线程的优先级时应该看到6。<br>接着程序将<code>low</code>线程的优先级设为<code>Priority.MIN_PRIORITY</code>,将<code>high</code>线程的优先级设置为<code>Priority.MAX_PRIORITY</code>。</p>
<h2 id="优先级级别需要操作系统支持"><a href="#优先级级别需要操作系统支持" class="headerlink" title="优先级级别需要操作系统支持"></a>优先级级别需要操作系统支持</h2><p>值得指出的是,虽然<code>Java</code>提供了10个优先级级别,但这些<code>优先级级别需要操作系统的支持</code>。<br>遗憾的是,不同操作系统上的优先级并不相同,而且也不能很好地和<code>Java</code>的10个优先级对应,例如**<code>Windows 2000</code>仅提供了7个优先级**。</p>
<h2 id="应该尽量避免直接为线程指定优先级"><a href="#应该尽量避免直接为线程指定优先级" class="headerlink" title="应该尽量避免直接为线程指定优先级"></a>应该尽量避免直接为线程指定优先级</h2><p>因此<strong>应该尽量避免直接为线程指定优先级</strong>,而应该使用<code>Thread.MAX_PRIORITY</code>、<code>Thread.NORM_PRIORITY</code>、<code>Thread.MIN_PRIORITY</code>三个静态常量来设置优先级,这样才可以保证程序具有最好的可移植性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/eb9364ab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/eb9364ab/" class="post-title-link" itemprop="url">16.4.4 线程让步yield</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 13:10:50" itemprop="dateCreated datePublished" datetime="2019-07-17T13:10:50+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-26 01:07:39" itemprop="dateModified" datetime="2020-03-26T01:07:39+08:00">2020-03-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-4-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">16.4 控制线程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/eb9364ab/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/eb9364ab/" data-xid="/JavaReadingNotes/eb9364ab/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-4-4-线程让步yield"><a href="#16-4-4-线程让步yield" class="headerlink" title="16.4.4 线程让步yield"></a>16.4.4 线程让步yield</h1><h2 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h2><p><code>yield</code>方法是一个和<code>sleep</code>方法有点相似的方法,它也是<code>Thread</code>类提供的一个静态方法,<code>yield</code>也可以让当前正在执行的线程暂停,但<code>yield</code>不会阻塞该线程,<code>yield</code>只是将该线程转入就绪状态。<br><img data-src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/fangkuangJavaJiangYi3/16/1.png" alt="这里有一张图片"></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static void yield()</code></td>
<td align="left">A hint to the scheduler that the current thread is willing to yield its current use of a processor.</td>
</tr>
</tbody></table>
<p><strong><code>yield</code>只是让当前线程暂停一下,让系统的线程调度器重新调度一次</strong>,完全可能的情况是:当某个线程调用了<code>yield</code>方法暂停之后,线程调度器又将其调度出来重新执行。</p>
<h2 id="yield后优先级相同或优先级更高的得到执行机会"><a href="#yield后优先级相同或优先级更高的得到执行机会" class="headerlink" title="yield后优先级相同或优先级更高的得到执行机会"></a>yield后优先级相同或优先级更高的得到执行机会</h2><p>实际上,当某个线程调用了<code>yield</code>方法暂停之后,<strong>只有优先级与当前线程相同,或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。</strong></p>
<h2 id="程序-yield方法"><a href="#程序-yield方法" class="headerlink" title="程序 yield方法"></a>程序 yield方法</h2><p>下面程序使用<code>yield</code>方法来让当前正在执行的线程暂停。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YieldTest</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义run方法作为线程执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">            <span class="comment">// 当i等于20时，使用yield方法让当前线程让步</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.yield();<span class="comment">//代码0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 启动两条并发线程</span></span><br><span class="line">        YieldTest yt1 = <span class="keyword">new</span> YieldTest(<span class="string">&quot;高级&quot;</span>);</span><br><span class="line">        <span class="comment">// 将ty1线程设置成最高优先级</span></span><br><span class="line">        <span class="comment">// yt1.setPriority(Thread.MAX_PRIORITY);//代码1</span></span><br><span class="line">        yt1.start();</span><br><span class="line">        YieldTest yt2 = <span class="keyword">new</span> YieldTest(<span class="string">&quot;低级&quot;</span>);</span><br><span class="line">        <span class="comment">// 将yt2线程设置成最低优先级</span></span><br><span class="line">        <span class="comment">// yt2.setPriority(Thread.MIN_PRIORITY);//代码2</span></span><br><span class="line">        yt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的代码0调用<code>yield</code>静态方法让当前正在执行的线程暂停,让系统线程调度器重新调度。由于程序中代码1、代码2处于注释状态。<br>此时**<code>两个线程的优先级完全一样</code>,所以当一个线程使用<code>yield</code>方法后,另一个线程就会开始执行**。<br>运行结果如下所示:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">高级  <span class="number">20</span></span><br><span class="line">低级  <span class="number">15</span></span><br><span class="line">...</span><br><span class="line">低级  <span class="number">20</span></span><br><span class="line">高级  <span class="number">24</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>如果将程序中<code>代码1</code>和<code>代码2</code>的注释取消,也就是为两个线程分别设置不同的优先级,则程序的运行结果如下所示:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">高级  <span class="number">20</span></span><br><span class="line">低级  <span class="number">10</span></span><br><span class="line">高级  <span class="number">21</span></span><br><span class="line">...</span><br><span class="line">高级  <span class="number">49</span></span><br><span class="line">低级  <span class="number">17</span></span><br><span class="line">低级  <span class="number">18</span></span><br><span class="line">低级  <span class="number">19</span></span><br><span class="line">低级  <span class="number">20</span></span><br><span class="line">低级  <span class="number">21</span></span><br><span class="line">...</span><br><span class="line">低级  <span class="number">49</span></span><br></pre></td></tr></table></figure>
<h2 id="yield后低优先级的线程依然有可能得到执行"><a href="#yield后低优先级的线程依然有可能得到执行" class="headerlink" title="yield后低优先级的线程依然有可能得到执行"></a>yield后低优先级的线程依然有可能得到执行</h2><p>线程让步后,由线程调度器选中<code>就绪状态</code>中的一个线程来执行,优先级高的线程被选中的机会比较大,但也只是机会大而已,<strong>低优先级的线程依然有可能得到运行</strong>。</p>
<h2 id="sleep方法和yield方法的区别"><a href="#sleep方法和yield方法的区别" class="headerlink" title="sleep方法和yield方法的区别"></a>sleep方法和yield方法的区别</h2><p>关于<code>sleep</code>方法和<code>yield</code>方法的区别如下:</p>
<h3 id="yield优先级相关"><a href="#yield优先级相关" class="headerlink" title="yield优先级相关"></a>yield优先级相关</h3><ul>
<li><code>sleep</code>方法暂停当前线程后,会给其他线程执行机会,不会理会其他线程的优先级;<ul>
<li>但<code>yield</code>方法只会给<code>优先级</code>相同,或优先级更高的线程执行机会。</li>
</ul>
</li>
</ul>
<h3 id="sleep先阻塞后就绪-yield直接就绪"><a href="#sleep先阻塞后就绪-yield直接就绪" class="headerlink" title="sleep先阻塞后就绪 yield直接就绪"></a>sleep先阻塞后就绪 yield直接就绪</h3><ul>
<li><code>sleep</code>方法会将线程转入<code>阻塞状态</code>,直到经过阻塞时间才会转入就绪状态;<ul>
<li>而<code>yield</code>不会将线程转入阻塞状态,它只是强制当前线程进入<code>就绪状态</code>。因此完全有可能某个线程调用<code>yield</code>方法暂停之后,立即再次获得处理器资源被执行。</li>
</ul>
</li>
</ul>
<h3 id="sleep抛异常-yield不抛异常"><a href="#sleep抛异常-yield不抛异常" class="headerlink" title="sleep抛异常 yield不抛异常"></a>sleep抛异常 yield不抛异常</h3><ul>
<li><code>sleep</code>方法声明抛出了<code>InterruptedException</code>异常,所以调用<code>sleep</code>方法时要么捕捉该异常,要么显式声明抛出该异常;<ul>
<li>而<code>yiled</code>方法则没有声明抛出任何异常。</li>
</ul>
</li>
<li><code>sleep</code>方法比<code>yiled</code>方法有更好的可移植性,<strong>通常不建议使用<code>yield</code>方法来控制并发线程的执行</strong>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>yiled</code>方法使得线程进入<code>就绪状态</code>,系统线程调度器重新调度处于<code>就绪状态</code>的一个线程来运行,因为调用<code>yiled</code>方法的线程此时也处于<code>就绪状态</code>，所以该线程可能被线程调度器选中得以<code>再次运行</code>.</li>
<li><code>sleep</code>方法使得线程进入<code>阻塞状态</code>,睡眠时间结束后,再进入<code>就绪状态</code>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/e4fe887f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/e4fe887f/" class="post-title-link" itemprop="url">16.4.3 线程睡眠sleep</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 13:09:45" itemprop="dateCreated datePublished" datetime="2019-07-17T13:09:45+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-26 12:53:47" itemprop="dateModified" datetime="2020-03-26T12:53:47+08:00">2020-03-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-4-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">16.4 控制线程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/e4fe887f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/e4fe887f/" data-xid="/JavaReadingNotes/e4fe887f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-4-3-线程睡眠sleep"><a href="#16-4-3-线程睡眠sleep" class="headerlink" title="16.4.3 线程睡眠sleep"></a>16.4.3 线程睡眠sleep</h1><h2 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h2><p>如果需要让当前正在执行的线程暂停一段时间,并进入阻塞状态,则可以通过调用<code>Thread</code>类的静态<code>sleep</code>方法来实现。<br><img data-src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/fangkuangJavaJiangYi3/16/1.png" alt="这里有一张图片"></p>
<p><code>sleep</code>方法有如下两种重载形式</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static void sleep(long millis)</code></td>
<td align="left">让当前正在执行的线程暂停<code>millis</code>毫秒,并进入阻塞状态,该方法受到系统计时器和线程调度器的精度与准确度的影响。</td>
</tr>
<tr>
<td align="left"><code>static void sleep(long millis, int nanos)</code></td>
<td align="left">让当前正在执行的线程暂停 <code>millis</code>毫秒加 <code>nanos</code>毫微秒,并进入阻塞状态,该方法受到系统计时器和线程调度器的精度与准确度的影响。一般很少调用这种形式的<code>sleep</code>方法。</td>
</tr>
</tbody></table>
<p>当一个线程调用<code>sleep</code>方法进入阻塞状态后,在其睡眠时间段内,该线程不会获得执行的机会,即使系统中没有其他可执行的线程,处于<code>sleep()</code>中的线程也不会执行,因此<code>sleep</code>方法常用来暂停程序的执行。</p>
<h2 id="程序示例-线程sleep"><a href="#程序示例-线程sleep" class="headerlink" title="程序示例 线程sleep"></a>程序示例 线程sleep</h2><p>下面程序调用<code>sleep</code>方法来暂停主线程的执行,因为该程序只有一个主线程,当主线程进入睡眠后,系统没有可执行的线程,所以可以看到程序在<code>sleep</code>方法处暂停。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前时间: &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="comment">// 调用sleep方法让当前线程暂停1s。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">24</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">25</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">26</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">27</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">28</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">29</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">30</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">32</span> CST <span class="number">2019</span></span><br><span class="line">当前时间: Wed Jul <span class="number">17</span> <span class="number">13</span>:<span class="number">21</span>:<span class="number">33</span> CST <span class="number">2019</span></span><br></pre></td></tr></table></figure>
<p>运行上面程序,看到程序依次输出10条字符串,输出2条字符串之间的时间间隔为1秒。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/1c771dc8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/1c771dc8/" class="post-title-link" itemprop="url">16.4.2 后台线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-17 12:30:32" itemprop="dateCreated datePublished" datetime="2019-07-17T12:30:32+08:00">2019-07-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-26 12:32:25" itemprop="dateModified" datetime="2020-03-26T12:32:25+08:00">2020-03-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-4-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">16.4 控制线程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/1c771dc8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/1c771dc8/" data-xid="/JavaReadingNotes/1c771dc8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-4-2-后台线程"><a href="#16-4-2-后台线程" class="headerlink" title="16.4.2 后台线程"></a>16.4.2 后台线程</h1><h2 id="什么是后台线程"><a href="#什么是后台线程" class="headerlink" title="什么是后台线程"></a>什么是后台线程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>后台线程(<code>Daemon Thread</code>),是在后台运行的一种线程,</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>后台线程主要用来<strong>向其他的线程提供服务</strong>。<code>JVM</code>的垃圾回收线程就是典型的后台线程。</p>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p><strong>如果所有的前台线程都死亡,后台线程会自动死亡</strong>。</p>
<h2 id="Thread类后台线程方法"><a href="#Thread类后台线程方法" class="headerlink" title="Thread类后台线程方法"></a>Thread类后台线程方法</h2><h3 id="如何把一个线程设置成后台线程"><a href="#如何把一个线程设置成后台线程" class="headerlink" title="如何把一个线程设置成后台线程"></a>如何把一个线程设置成后台线程</h3><p>调用<code>Thread</code>对象的<code>setDaemon(true)</code>方法可将指定线程设置成后台线程。</p>
<h3 id="如何判断一个线程是否是后台线程"><a href="#如何判断一个线程是否是后台线程" class="headerlink" title="如何判断一个线程是否是后台线程"></a>如何判断一个线程是否是后台线程</h3><p><code>Thread</code>类还提供了一个<code>isDaemon()</code>方法,用于判断指定线程是否为后台线程。</p>
<table>
<thead>
<tr>
<th align="left"><code>Thread</code>类方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void setDaemon(boolean on)</code></td>
<td align="left">Marks this thread as either a daemon thread or a user thread.</td>
</tr>
<tr>
<td align="left"><code>boolean isDaemon()</code></td>
<td align="left">Tests if this thread is a daemon thread.</td>
</tr>
</tbody></table>
<h2 id="程序-后台线程示例"><a href="#程序-后台线程示例" class="headerlink" title="程序 后台线程示例"></a>程序 后台线程示例</h2><p>下面程序将执行线程设置成后台线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义后台线程的线程执行体与普通线程没有任何区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;后台线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DaemonThread t = <span class="keyword">new</span> DaemonThread();</span><br><span class="line">        <span class="comment">// 将此线程设置成后台线程</span></span><br><span class="line">        t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 启动后台线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// -----程序执行到此处，前台线程（main线程）结束------</span></span><br><span class="line">        <span class="comment">// 后台线程也应该随之结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前台(main)线程结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">main  0</span><br><span class="line">main  1</span><br><span class="line">......</span><br><span class="line">main  7</span><br><span class="line">main  8</span><br><span class="line">Thread-0  0</span><br><span class="line">main  9</span><br><span class="line">前台(main)线程结束</span><br><span class="line">Thread-0  1</span><br><span class="line">Thread-0  2</span><br><span class="line">......</span><br><span class="line">Thread-0  16</span><br><span class="line">Thread-0  17</span><br></pre></td></tr></table></figure>
<p>上面程序中先将<code>t</code>线程设置成后台线程,然后启动该线程,<strong>本来该线程应该执行到循环变量<code>i</code>等于<code>999</code>时才会结束</strong>,<br>但从运行结果中不难发现<strong>该后台线程无法运行到循环变量<code>i</code>等于<code>999</code>时,因为程序中唯一的前台线程(<code>main</code>线程)运行结束后,<code>JVM</code>会主动退出,因而后台线程也就被结束了</strong>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="前后台的默认情况"><a href="#前后台的默认情况" class="headerlink" title="前后台的默认情况"></a>前后台的默认情况</h3><ul>
<li>主线程默认是前台线程,</li>
<li>前台线程创建的子线程默认是前台线程,</li>
<li>后台线程创建的子线程默认是后台线程。</li>
</ul>
<h3 id="后台线程死亡需要一定时间"><a href="#后台线程死亡需要一定时间" class="headerlink" title="后台线程死亡需要一定时间"></a>后台线程死亡需要一定时间</h3><p>当所有的前台线程死亡后,<code>JVM</code>会给后台线程发出死亡通知,但后台线程从接收死亡通知到真正死亡,需要一定时间。</p>
<h3 id="要先设置为后台线程-再启动线程"><a href="#要先设置为后台线程-再启动线程" class="headerlink" title="要先设置为后台线程 再启动线程"></a>要先设置为后台线程 再启动线程</h3><p>要将某个线程设置为后台线程,必须在该线程启动之前设置,也就是说,<strong><code>setDaemon(true)</code>必须在<code>start()</code>方法之前调用</strong>,否则会引发<code>IllegalThreadStateException</code>异常。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6fdf5d88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6fdf5d88/" class="post-title-link" itemprop="url">16.4 控制线程 16.4.1 join线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-16 10:28:44" itemprop="dateCreated datePublished" datetime="2019-07-16T10:28:44+08:00">2019-07-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-20 11:03:12" itemprop="dateModified" datetime="2020-03-20T11:03:12+08:00">2020-03-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-4-%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">16.4 控制线程</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6fdf5d88/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6fdf5d88/" data-xid="/JavaReadingNotes/6fdf5d88/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-4-控制线程"><a href="#16-4-控制线程" class="headerlink" title="16.4 控制线程"></a>16.4 控制线程</h1><p><code>Java</code>的线程(Thread类)支持提供了一些便捷的工具方法,通过这些便捷的工具方法可以很好地控制线程的执行.</p>
<h1 id="16-4-1-join线程"><a href="#16-4-1-join线程" class="headerlink" title="16.4.1 join线程"></a>16.4.1 join线程</h1><h2 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h2><p>**<code>join</code>方法可以让一个线程<code>等待另一个线程完成</code>**。</p>
<p><code>join()</code>方法有如下三种重载形式</p>
<table>
<thead>
<tr>
<th align="left">Thread类的join方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void join()</code></td>
<td align="left">等待被<code>join</code>的线程执行完成。</td>
</tr>
<tr>
<td align="left"><code>void join(long millis)</code></td>
<td align="left">等待被<code>join</code>的线程的时间最长为<code>millis</code>毫秒。如果在<code>millis</code>毫秒内被<code>join</code>的线程还没有执行结束,则不再等待。</td>
</tr>
<tr>
<td align="left"><code>void join(long millis, int nanos)</code></td>
<td align="left">等待被<code>join</code>的线程的时间最长为<code>millis</code>毫秒加<code>nanos</code>毫微秒。很少使用这种形式,原因有两个:程序对时间的精度无须精确到毫微秒;计算机硬件、操作系统本身也无法精确到毫微秒。</td>
</tr>
</tbody></table>
<h2 id="当前线程-等待-调用join方法的线程"><a href="#当前线程-等待-调用join方法的线程" class="headerlink" title="当前线程 等待 调用join方法的线程"></a>当前线程 等待 调用join方法的线程</h2><p>例如,在<strong>当前线程</strong>中调用如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.join();</span><br></pre></td></tr></table></figure>
<p>则<strong>当前线程</strong>要等待<strong>B线程</strong>运行结束.<br>这个当前线程要看调用join方法的代码位于哪个线程中</p>
<ul>
<li>如果在主线程的代码中调用<code>B.join()</code>,则主线程必须等待B线程执行完毕</li>
<li>如果在A线程的代码中调用<code>B.join()</code>,则线程A必须等待线程B执行完毕</li>
</ul>
<h2 id="join方法的作用"><a href="#join方法的作用" class="headerlink" title="join方法的作用"></a>join方法的作用</h2><p><code>join</code>方法通常由使用线程的程序调用,以将大问题划分成许多小问题,每个小问题分配一个线程。当所有的小问题都得到处理后,再调用主线程来进一步操作。</p>
<h2 id="程序-join方法示例"><a href="#程序-join方法示例" class="headerlink" title="程序 join方法示例"></a>程序 join方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供一个有参数的构造器，用于设置该线程的名字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JoinThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写run()方法，定义线程执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">30</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;================== &quot;</span>+getName()+<span class="string">&quot; 死亡&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 启动子线程</span></span><br><span class="line">        <span class="keyword">new</span> JoinThread(<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                JoinThread jt = <span class="keyword">new</span> JoinThread(<span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">                jt.start();</span><br><span class="line">                <span class="comment">// main线程中调用了jt线程的join()方法</span></span><br><span class="line">                <span class="comment">// main线程必须等jt执行结束才会向下执行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;-----------------主线程 等待 线程B 开始---------------------&quot;</span>);</span><br><span class="line">                jt.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;-----------------主线程 等待 线程B 结束---------------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;================== 主线程 死亡&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">主线程  0</span><br><span class="line">线程A  0</span><br><span class="line">主线程  1</span><br><span class="line">......</span><br><span class="line">主线程  8</span><br><span class="line">线程A  7</span><br><span class="line">主线程  9</span><br><span class="line">线程A  8</span><br><span class="line">-----------------主线程 等待 线程B 开始---------------------</span><br><span class="line">线程B  0</span><br><span class="line">线程A  9</span><br><span class="line">线程B  1</span><br><span class="line">线程A  10</span><br><span class="line">......</span><br><span class="line">线程A  28</span><br><span class="line">线程B  22</span><br><span class="line">线程A  29</span><br><span class="line">线程B  23</span><br><span class="line">线程A  30</span><br><span class="line">线程B  24</span><br><span class="line">================== 线程A 死亡</span><br><span class="line">线程B  25</span><br><span class="line">线程B  26</span><br><span class="line">......</span><br><span class="line">线程B  29</span><br><span class="line">线程B  30</span><br><span class="line">================== 线程B 死亡</span><br><span class="line">-----------------主线程 等待 线程B 结束---------------------</span><br><span class="line">主线程  10</span><br><span class="line">主线程  11</span><br><span class="line">......</span><br><span class="line">主线程  28</span><br><span class="line">主线程  29</span><br><span class="line">================== 主线程 死亡</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上面程序中一共有3个线程：</p>
<ul>
<li><strong>主线程</strong>开始时就启动<strong>线程A</strong>,然后,<strong>线程A</strong>将会和<strong>主线程</strong>并发执行。</li>
<li>当<strong>主线程</strong>的循环变量i等于10时,启动<strong>线程B</strong>,<strong>线程B</strong>不会和主线程并发执行,<strong><mark>主线程</mark>必须等<mark>线程B</mark>执行结束后才可以向下执行</strong>。</li>
<li>在<strong>线程B</strong>的线程执行时,实际上只有<strong>线程A</strong>和<strong>线程B</strong>这2个子线程并发执行,而<strong>主线程</strong>处于等待状态。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/42f33da/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/42f33da/" class="post-title-link" itemprop="url">16.3 线程的生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-16 00:50:35" itemprop="dateCreated datePublished" datetime="2019-07-16T00:50:35+08:00">2019-07-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-20 09:17:27" itemprop="dateModified" datetime="2020-03-20T09:17:27+08:00">2020-03-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" itemprop="url" rel="index"><span itemprop="name">16.3 线程的生命周期</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/42f33da/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/42f33da/" data-xid="/JavaReadingNotes/42f33da/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-3-线程的生命周期"><a href="#16-3-线程的生命周期" class="headerlink" title="16.3 线程的生命周期"></a>16.3 线程的生命周期</h1><p>当线程被创建并启动以后,它既不是一启动就进入了执行状态,也不是一直处于执行状态。</p>
<h2 id="线程的5种状态"><a href="#线程的5种状态" class="headerlink" title="线程的5种状态"></a>线程的5种状态</h2><p>在线程的生命周期中,它要经过:</p>
<ol>
<li>新建(<code>New</code>)、</li>
<li>就绪(<code>Runnable</code>)、</li>
<li>运行(<code>Running</code>)、</li>
<li>阻塞(<code>Blocked</code>)</li>
<li>死亡(<code>Dead</code>)</li>
</ol>
<p>这5种状态。</p>
<p>尤其是当线程启动以后,它不可能一直霸占着<code>CPU</code>独自运行,所以<code>CPU</code>需要在多条线程之间切换,于是线程状态也会多次在<code>运行</code>、<code>阻塞</code>之间切换。</p>
<h1 id="16-3-1-新建状态和就绪状态"><a href="#16-3-1-新建状态和就绪状态" class="headerlink" title="16.3.1 新建状态和就绪状态"></a>16.3.1 新建状态和就绪状态</h1><h2 id="新建状态-new-Thread创建线程后"><a href="#新建状态-new-Thread创建线程后" class="headerlink" title="新建状态 new Thread创建线程后"></a>新建状态 new Thread创建线程后</h2><p><strong>当程序使用<code>new</code>关键字创建了一个线程之后,该线程就处于<code>新建状态</code></strong>,此时它和其他的<code>Java</code>对象一样,仅仅由<code>Java</code>虚拟机为其分配内存,并初始化其成员变量的值。<br>此时的线程对象没有表现出任何线程的动态特征,程序也不会执行线程的线程执行体。</p>
<h2 id="就绪状态-调用Thread对象start方法后"><a href="#就绪状态-调用Thread对象start方法后" class="headerlink" title="就绪状态 调用Thread对象start方法后"></a>就绪状态 调用Thread对象start方法后</h2><p><strong>当线程对象调用了<code>start</code>方法之后,该线程处于<code>就绪状态</code></strong>,<code>Java</code>虚拟机会为其创建<strong>方法调用栈</strong>和<strong>程序计数器</strong>,处于这个状态中的线程并没有开始运行,<strong>只是表示该线程可以运行了</strong>。至于该线程何时开始运行,取决于<code>JVM</code>里线程调度器的调度。</p>
<h2 id="启动线程使用start方法"><a href="#启动线程使用start方法" class="headerlink" title="启动线程使用start方法"></a>启动线程使用start方法</h2><h3 id="永远不要调用线程对象的run方法"><a href="#永远不要调用线程对象的run方法" class="headerlink" title="永远不要调用线程对象的run方法"></a>永远不要调用线程对象的run方法</h3><p><strong>启动线程使用<code>start()</code>方法,而不是<code>run()</code>方法</strong>!永远不要调用线程对象的<code>run()</code>方法!</p>
<ul>
<li>调用<code>start()</code>方法来启动线程,系统会把该<code>run()</code>方法当成<strong>线程执行体</strong>来处理;</li>
<li>如果直接调用线程对象的<code>run()</code>方法,系统把线程对象当成一个普通对象,把<code>run()</code>方法当成一个普通方法,而不是线程执行体,<code>run()</code>方法将立即就会被执行,而且在<code>run()</code>方法返回之前其他线程无法并发执行</li>
</ul>
<h3 id="程序-调用run方法不会启动线程"><a href="#程序-调用run方法不会启动线程" class="headerlink" title="程序 调用run方法不会启动线程"></a>程序 调用run方法不会启动线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeRun</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="comment">// 重写run方法，run方法的方法体就是线程执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 直接调用run方法时，Thread的this.getName返回的是该对象名字，</span></span><br><span class="line">            <span class="comment">// 而不是当前线程的名字。</span></span><br><span class="line">            <span class="comment">// 使用Thread.currentThread().getName()总是获取当前线程名字</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                +  <span class="string">&quot; &quot;</span> + i);   <span class="comment">// ①</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;  i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用Thread的currentThread方法获取当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                +  <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 直接调用线程对象的run方法，</span></span><br><span class="line">                <span class="comment">// 系统会把线程对象当成普通对象，run方法当成普通方法，</span></span><br><span class="line">                <span class="comment">// 所以下面两行代码并不会启动两条线程，而是依次执行两个run方法</span></span><br><span class="line">                <span class="keyword">new</span> InvokeRun().run();</span><br><span class="line">                <span class="keyword">new</span> InvokeRun().run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">main <span class="number">0</span></span><br><span class="line">main <span class="number">1</span></span><br><span class="line">main <span class="number">2</span></span><br><span class="line">main <span class="number">3</span></span><br><span class="line">......</span><br><span class="line">main <span class="number">18</span></span><br><span class="line">main <span class="number">19</span></span><br><span class="line">main <span class="number">20</span></span><br><span class="line">main <span class="number">0</span></span><br><span class="line">main <span class="number">1</span></span><br><span class="line">main <span class="number">2</span></span><br><span class="line">......</span><br><span class="line">main <span class="number">44</span></span><br><span class="line">main <span class="number">45</span></span><br><span class="line">main <span class="number">46</span></span><br><span class="line">main <span class="number">47</span></span><br><span class="line">main <span class="number">48</span></span><br><span class="line">main <span class="number">49</span></span><br><span class="line">main <span class="number">0</span></span><br><span class="line">main <span class="number">1</span></span><br><span class="line">main <span class="number">2</span></span><br><span class="line">main <span class="number">3</span></span><br><span class="line">......</span><br><span class="line">main <span class="number">47</span></span><br><span class="line">main <span class="number">48</span></span><br><span class="line">main <span class="number">49</span></span><br></pre></td></tr></table></figure>
<p>上面程序创建线程对象后**直接调用了线程对象的<code>run()</code>方法,程序运行的结果是整个程序只有一个线程:<code>主线程</code>**。<br>还有一点需要指出,如果直接调用线程对象的<code>run()</code>方法,则<code>run()</code>方法里不能直接通过<code>getName()</code>方法来获得当前执行线程的名字,而是需要使用<code>Thread.currentThread()</code>方法先获得当前线程,再调用线程对象的<code>getName()</code>方法来获得线程的名字。<br>通过上面程序不难看出,<strong>启动线程的正确方法是调用<code>Thread</code>对象的<code>start()</code>方法,而不是直接调用<code>run()</code>方法</strong>,否则就变成单线程程序了</p>
<h3 id="只能对处于新建状态的线程调用start方法"><a href="#只能对处于新建状态的线程调用start方法" class="headerlink" title="只能对处于新建状态的线程调用start方法"></a>只能对处于新建状态的线程调用start方法</h3><p><strong>只能对处于新建状态的线程调用<code>start</code>方法,否则将引发<code>IllegalThreadStateException</code>异常</strong>。调用了线程的<code>run()</code>方法之后,该线程已经不再处于新建状态,不要再次调用线程对象的<code>start()</code>方法。<br>调用线程对象的<code>start</code>方法之后,该线程立即进入就绪状态,就绪状态相当于”等待执行”,但该线程并未真正进入运行状态。</p>
<h3 id="如何让子线程立即执行"><a href="#如何让子线程立即执行" class="headerlink" title="如何让子线程立即执行"></a>如何让子线程立即执行</h3><p>如果希望调用子线程的<code>start</code>方法后子线程立即开始执行,程序可以使用<code>Thread.sleep(1)</code>来让<code>当前运行的线程(主线程)睡眠1毫秒</code>——1毫秒就够了,因为在这1毫秒内<code>CPU</code>不会空闲,它会去执行另一个处于就绪状态的线程,这样就可以让子线程立即开始执行。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><strong>当程序使用<code>new</code>关键字创建了一个线程之后,该线程就处于<code>新建状态</code></strong></li>
<li><strong>当线程对象调用了<code>start</code>方法之后,该线程处于<code>就绪状态</code></strong>,就绪状态相当于”等待执行”状态,此时该线程并未真正进入运行状态。</li>
<li><strong>只能对处于新建状态的线程调用<code>start</code>方法,否则将引发<code>IllegalThreadStateException</code>异常</strong></li>
<li><strong>启动线程的正确方法是调用<code>Thread</code>对象的<code>start()</code>方法,而不是直接调用<code>run()</code>方法</strong>,<strong>直接调用了线程对象的<code>run()</code>方法,程序运行的结果是整个程序只有一个线程:<code>主线程</code></strong></li>
<li>如果希望调用子线程的<code>start</code>方法后子线程立即开始执行,则可以让<code>当前运行的线程(主线程)睡眠1毫秒</code>,这种情况针只有一个子线程的情况,个人觉得用处不大.</li>
</ul>
<h1 id="16-3-2-运行状态和阻塞状态"><a href="#16-3-2-运行状态和阻塞状态" class="headerlink" title="16.3.2 运行状态和阻塞状态"></a>16.3.2 运行状态和阻塞状态</h1><h2 id="运行状态-run方法得到执行"><a href="#运行状态-run方法得到执行" class="headerlink" title="运行状态 run方法得到执行"></a>运行状态 run方法得到执行</h2><p>如果<strong>处于就绪状态的线程获得了<code>CPU</code>,开始执行线程的执行体<code>run()</code>方法,则该线程处于<code>运行状态</code></strong>,如果计算机只有一个<code>CPU</code>,那么在任何时刻只有一个线程处于运行状态。当然,在一个多处理器的机器上,将会有多个线程**<code>并行</code>执行**;不过当线程数大于处理器数时,依然会存在多个线程在同一个<code>CPU</code>上轮换的现象。(注意多处理器的机器上是并行:<code>parallel</code>,单处理器上是<code>并发</code>)<br>当一个线程开始运行后,它不可能一直处于运行状态(除非它的线程执行体足够短,瞬间就执行结束了),<strong>线程在运行过程中需要被中断,目的是使其他线程获得执行的机会</strong>,线程调度的细节取决于底层平台所采用的策略。对于采用<code>抢占式策略</code>的系统而言,系统会给每个可执行的线程一个<code>小时间段</code>来处理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源,让其他线程获得执行的机会。在选择下一个线程时,系统会考虑线程的优先级。<br>所有现代的桌面和服务器操作系统都采用<code>抢占式调度策略</code>,但一些小型设备如<code>手机</code>则可能采用<code>协作式调度策略</code>,在这样的系统中,只有当一个线程调用了它的<code>sleep()</code>或<code>yield()</code>方法后才会放弃所占用的资源,也就是必须由该线程主动放弃所占用的资源。</p>
<h2 id="阻塞状态-sleep-IO阻塞-等待同步锁-等待通知-suspend"><a href="#阻塞状态-sleep-IO阻塞-等待同步锁-等待通知-suspend" class="headerlink" title="阻塞状态 sleep IO阻塞 等待同步锁 等待通知 suspend"></a>阻塞状态 sleep IO阻塞 等待同步锁 等待通知 suspend</h2><p>当发生如下情况时,线程将会进入阻塞状态。</p>
<ol>
<li>线程调用<code>sleep()</code>方法主动放弃所占用的处理器资源。</li>
<li>线程调用了一个<code>阻塞式IO方法</code>,在<code>阻塞式IO方法</code>返回之前,该线程被阻塞。</li>
<li>线程试图获得一个<strong>同步监视器</strong>,但该<code>同步监视器正被其他线程所持有的时候</code>。</li>
<li>线程在等待某个通知(<code>notify</code>)。</li>
<li>程序调用了线程的<code>suspend()</code>方法将该线程挂起。但这个方法容易导致死锁,所以应该尽量避免使用该方法。</li>
</ol>
<h2 id="阻塞结束进入就绪"><a href="#阻塞结束进入就绪" class="headerlink" title="阻塞结束进入就绪"></a>阻塞结束进入就绪</h2><p>当前正在执行的线程被阻塞之后,其他线程就可以获得执行的机会。<strong>被阻塞的线程会在合适的时候重新进入<code>就绪状态</code></strong>,注意是<code>就绪状态</code>而不是<strong>运行状态</strong>。也就是说,<strong>被阻塞线程的阻塞解除后,必须重新等待线程调度器再次调度它</strong>。</p>
<h3 id="阻塞进入就绪-sleep时间到-IO方法返回-获得同步锁-收到通知-resumed"><a href="#阻塞进入就绪-sleep时间到-IO方法返回-获得同步锁-收到通知-resumed" class="headerlink" title="阻塞进入就绪 sleep时间到 IO方法返回 获得同步锁 收到通知 resumed"></a>阻塞进入就绪 sleep时间到 IO方法返回 获得同步锁 收到通知 resumed</h3><p>针对上面几种情况,当发生如下特定的情况时可以解除上面的阻塞,让该线程重新进入就绪状态。</p>
<ol>
<li>调用<code>sleep</code>方法的线程经过了指定时间</li>
<li>线程调用的<code>阻塞式IO方法</code>已经返回。</li>
<li>线程成功地获得了试图取得的同步监视器。</li>
<li>线程正在等待某个通知时,<code>其他线程发出了一个通知</code>。</li>
<li>处于挂起状态的线程被调用了<code>resumed()</code>恢复方法。</li>
</ol>
<h2 id="线程状态转换图"><a href="#线程状态转换图" class="headerlink" title="线程状态转换图"></a>线程状态转换图</h2><p>图16.4显示了线程状态转换图。<br><img data-src="https://image-1257720033.cos.ap-shanghai.myqcloud.com/blog/readbooknote/fangkuangJavaJiangYi3/16/1.png" alt="这里有一张图片"><br>从图16.4中可以看出：</p>
<ul>
<li><strong>线程从<code>阻塞状态</code>只能进入<code>就绪状态</code>,无法直接进入运行状态</strong>。</li>
<li><strong><code>就绪状态</code>和<code>运行状态</code>之间的转换通常不受程序控制,而是由系统线程调度所决定</strong>,<ul>
<li>当处于<code>就绪状态</code>的线程获得处理器资源时,该线程进入<code>运行状态</code>;</li>
<li>当处于<code>运行状态</code>的线程失去处理器资源时,该线程进入<code>就绪状态</code>。<ul>
<li>但有个方法例外,**调用<code>yield()</code>方法可以让<code>运行状态</code>的线程转入<code>就绪状态</code>**。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="16-3-3-线程死亡"><a href="#16-3-3-线程死亡" class="headerlink" title="16.3.3 线程死亡"></a>16.3.3 线程死亡</h1><h2 id="线程死亡-run方法结束-异常-stop"><a href="#线程死亡-run方法结束-异常-stop" class="headerlink" title="线程死亡 run方法结束 异常 stop"></a>线程死亡 run方法结束 异常 stop</h2><p>线程会以如下三种方式结束,结束后就处于死亡状态。</p>
<ul>
<li><code>run()</code>或<code>call()</code>方法执行完成,线程正常结束。</li>
<li>线程抛出一个未捕获的<code>Exception</code>或<code>Error</code>。</li>
<li>直接调用该线程的<code>stop()</code>方法来结束该线程,不过<code>stop()</code>方法容易导致死锁,通常不推荐使用。</li>
</ul>
<h2 id="一个线程结束不会影响其他线程"><a href="#一个线程结束不会影响其他线程" class="headerlink" title="一个线程结束不会影响其他线程"></a>一个线程结束不会影响其他线程</h2><p>当主线程结束时,其他线程不受任何影响,并不会随之结束。一旦子线程启动起来后,它就拥有和主线程相同的地位,它不会受主线程的影响。</p>
<h2 id="isAlive方法"><a href="#isAlive方法" class="headerlink" title="isAlive方法"></a>isAlive方法</h2><p>为了测试某个线程是否已经死亡,可以调用线程对象的<code>isAlive()</code>方法,</p>
<ul>
<li>当线程处于<code>就绪</code>、<code>运行</code>、<code>阻塞</code>三种状态时,<code>isAlive()</code>方法将返回<code>true</code>;</li>
<li>当线程处于<code>新建</code>、<code>死亡</code>两种状态时,<code>isAlive()</code>方法将返回<code>false</code></li>
</ul>
<h2 id="已经死亡的线程无法再次启动"><a href="#已经死亡的线程无法再次启动" class="headerlink" title="已经死亡的线程无法再次启动"></a>已经死亡的线程无法再次启动</h2><p>不要试图对一个已经死亡的线程调用<code>start</code>方法使它重新启动,死亡就是死亡,该线程将不可再次作为线程执行。</p>
<h3 id="程序-死亡的线程无法再次start"><a href="#程序-死亡的线程无法再次start" class="headerlink" title="程序 死亡的线程无法再次start"></a>程序 死亡的线程无法再次start</h3><p>下面程序尝试对处于死亡状态的线程再次调用<code>start</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartDead</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 重写run方法，run方法的方法体就是线程执行体</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(getName() +  <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程对象</span></span><br><span class="line">        StartDead sd = <span class="keyword">new</span> StartDead();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>;  i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用Thread的currentThread方法获取当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                +  <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                <span class="comment">// 判断启动后线程的isAlive()值，输出true</span></span><br><span class="line">                sd.start();</span><br><span class="line">                System.out.println(sd.isAlive());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有当线程处于新建、死亡两种状态时isAlive()方法返回false。</span></span><br><span class="line">            <span class="comment">// 当i &gt; 20，则该线程肯定已经启动过了，</span></span><br><span class="line">            <span class="comment">// 如果sd.isAlive()为假时，那只能是死亡状态了。</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">20</span> &amp;&amp; !sd.isAlive())</span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 试图再次启动该线程</span></span><br><span class="line">                sd.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中试图在线程已死亡的情况下再次调用<code>start</code>方法来启动该线程。<br>运行上面程序,将引发<code>IllegalThreadStateException</code>异常。这表明<strong>处于死亡状态的线程无法再次运行了</strong>。</p>
<h3 id="只能对新建的线程start一次"><a href="#只能对新建的线程start一次" class="headerlink" title="只能对新建的线程start一次"></a>只能对新建的线程start一次</h3><p>不要对处于死亡状态的线程调用<code>start</code>方法,<strong>只能对<code>新建状态</code>的线程调用<code>start</code>方法</strong>,<strong>对<code>新建状态</code>的线程两次调用<code>start</code>方法也是错误的</strong>。这都会引发<code>IllegalThreadStateException</code>异常.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d5151950/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d5151950/" class="post-title-link" itemprop="url">16.2 线程的创建和启动</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-15 21:14:18" itemprop="dateCreated datePublished" datetime="2019-07-15T21:14:18+08:00">2019-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-20 05:29:04" itemprop="dateModified" datetime="2020-03-20T05:29:04+08:00">2020-03-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8/" itemprop="url" rel="index"><span itemprop="name">16.2 线程的创建和启动</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d5151950/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d5151950/" data-xid="/JavaReadingNotes/d5151950/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-2-线程的创建和启动"><a href="#16-2-线程的创建和启动" class="headerlink" title="16.2 线程的创建和启动"></a>16.2 线程的创建和启动</h1><h2 id="线程对象都必须是Thread类的实例"><a href="#线程对象都必须是Thread类的实例" class="headerlink" title="线程对象都必须是Thread类的实例"></a>线程对象都必须是Thread类的实例</h2><p><code>Java</code>使用<code>Thread</code>类代表线程,<strong>所有的线程对象都必须是<code>Thread</code>类或其子类的实例</strong>。<br>每个线程的作用是完成一定的任务,实际上就是执行一段程序流(一段顺序执行的代码)。<code>Java</code>使用线程执行体来代表这段程序流。</p>
<h1 id="16-2-1-继承Thread类创建线程类"><a href="#16-2-1-继承Thread类创建线程类" class="headerlink" title="16.2.1 继承Thread类创建线程类"></a>16.2.1 继承Thread类创建线程类</h1><h2 id="继承Thread来创建并启动多线程的步骤"><a href="#继承Thread来创建并启动多线程的步骤" class="headerlink" title="继承Thread来创建并启动多线程的步骤"></a>继承Thread来创建并启动多线程的步骤</h2><p>通过继承<code>Thread</code>类来创建并启动多线程的步骤如下:</p>
<ol>
<li>定义<code>Thread</code>类的子类,并重写该类的<code>run()</code>方法,该<code>run()</code>方法的方法体就代表了线程需要完成的任务。因此<strong>把<code>run()</code>方法称为线程执行体</strong>。</li>
<li>创建<code>Thread</code>子类的实例,即创建了线程对象</li>
<li>调用线程对象的<code>start()</code>方法来启动该线程。</li>
</ol>
<h2 id="程序-继承Thread类实现多线程"><a href="#程序-继承Thread类实现多线程" class="headerlink" title="程序 继承Thread类实现多线程"></a>程序 继承Thread类实现多线程</h2><p>下面程序示范了通过继承<code>Thread</code>类来创建并启动多线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.通过继承Thread类来创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="comment">// 重写run方法，run方法的方法体就是线程执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当线程类继承Thread类时，直接使用this即可获取当前线程</span></span><br><span class="line">            <span class="comment">// Thread对象的getName()返回当前该线程的名字</span></span><br><span class="line">            <span class="comment">// 因此可以直接调用getName()方法返回当前线程的名</span></span><br><span class="line">            System.out.println(getName() +  <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;  i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 调用Thread的currentThread方法获取当前线程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() +  <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 2.创建、并启动第一条线程</span></span><br><span class="line">                <span class="keyword">new</span> FirstThread().start();</span><br><span class="line">                <span class="comment">// 创建、并启动第二条线程</span></span><br><span class="line">                <span class="keyword">new</span> FirstThread().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 0</span><br><span class="line">Thread-1 0</span><br><span class="line">Thread-0 1</span><br><span class="line">main 25   </span><br><span class="line">Thread-0 2</span><br><span class="line">Thread-1 1</span><br><span class="line">Thread-0 3</span><br><span class="line">Thread-0 4</span><br><span class="line">main 26</span><br><span class="line">main 27</span><br><span class="line">Thread-0 5</span><br><span class="line">Thread-1 2</span><br></pre></td></tr></table></figure>
<p>上面程序中的<code>FirstThread</code>类继承了<code>Thread</code>类,并实现了<code>run()</code>方法,<strong>该<code>run()</code>方法里的代码执行流就是该线程所需要完成的任务</strong>。</p>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>当<code>Java</code>程序开始运行后,<strong>程序至少会创建一个主线程</strong>,<strong><code>main()</code>方法的方法体就是主线程的线程执行体</strong></p>
<h2 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h2><p>除此之外,上面程序还用到了线程的如下两个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static Thread currentThread()</code></td>
<td align="left">返回当前正在执行的线程对象</td>
</tr>
<tr>
<td align="left"><code>String getName()</code></td>
<td align="left">返回调用该方法的线程名字</td>
</tr>
<tr>
<td align="left"><code>void setName(String name)</code></td>
<td align="left">为线程设置名字</td>
</tr>
</tbody></table>
<p>在默认情况下,主线程的名字为<code>main</code>,用户启动的多个线程的名字依次为<code>Thread-0</code>、<code>Thread-1</code>、<code>Thread-2</code>、…、<code>Thread-n</code>等。</p>
<h2 id="继承Thread类创建线程的缺点"><a href="#继承Thread类创建线程的缺点" class="headerlink" title="继承Thread类创建线程的缺点"></a>继承Thread类创建线程的缺点</h2><p>使用继承<code>Thread</code>类的方法来创建线程类时,<strong>多个线程之间无法共享线程类的<code>实例变量</code></strong>.</p>
<h1 id="16-2-2-实现Runnable接口创建线程类"><a href="#16-2-2-实现Runnable接口创建线程类" class="headerlink" title="16.2.2 实现Runnable接口创建线程类"></a>16.2.2 实现Runnable接口创建线程类</h1><h2 id="实现Runnable接口来创建并启动多线程的步骤"><a href="#实现Runnable接口来创建并启动多线程的步骤" class="headerlink" title="实现Runnable接口来创建并启动多线程的步骤"></a>实现Runnable接口来创建并启动多线程的步骤</h2><ol>
<li>定义<code>Runnable</code>接口的实现类,并重写该接口的<code>run()</code>方法,**该<code>run()</code>方法的方法体同样是该线程的<code>线程执行体</code>**。</li>
<li><strong>创建<code>Runnable</code>实现类的实例,并以此实例作为<code>Thread</code>的<code>target</code>来创建<code>Thread</code>对象</strong><ol>
<li><strong>该<code>Thread</code>对象才是真正的线程对象</strong>。</li>
<li>也可以在创建<code>Thread</code>对象时为该<code>Thread</code>对象指定一个名字</li>
</ol>
</li>
<li>调用线程对象的<code>start()</code>方法来启动该线程。</li>
</ol>
<table>
<thead>
<tr>
<th align="left">Thread类构造器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread(Runnable target)</code></td>
<td align="left">Allocates a new Thread object.</td>
</tr>
<tr>
<td align="left"><code>Thread(Runnable target, String name)</code></td>
<td align="left">Allocates a new Thread object.</td>
</tr>
</tbody></table>
<h2 id="程序-实现Runable接口来创建并启动多线程"><a href="#程序-实现Runable接口来创建并启动多线程" class="headerlink" title="程序 实现Runable接口来创建并启动多线程"></a>程序 实现Runable接口来创建并启动多线程</h2><p>下面程序示范了通过实现<code>Runnable</code>接口来创建并启动多线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable接口来创建线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line">    <span class="comment">// run方法同样是线程执行体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当线程类实现Runnable接口时，</span></span><br><span class="line">            <span class="comment">// 如果想获取当前线程，只能用Thread.currentThread()方法。</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;  i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;  &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                SecondThread st = <span class="keyword">new</span> SecondThread();     <span class="comment">// ①</span></span><br><span class="line">                <span class="comment">// 通过new Thread(target , name)方法创建新线程</span></span><br><span class="line">                <span class="keyword">new</span> Thread(st , <span class="string">&quot;新线程1&quot;</span>).start();</span><br><span class="line">                <span class="keyword">new</span> Thread(st , <span class="string">&quot;新线程2&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中实现了<code>run()</code>方法,也就是定义了该线程的线程执行体。</p>
<h2 id="如何获取当前线程对象"><a href="#如何获取当前线程对象" class="headerlink" title="如何获取当前线程对象"></a>如何获取当前线程对象</h2><ul>
<li>通过继承<code>Thread</code>类来<code>获得当前线程对象</code>比较简单,直接使用<code>this</code>关键字就可以了;</li>
<li>但通过实现<code>Runnable</code>接口来获得当前线程对象,则必须使用<code>Thread.currentThread()</code>方法。</li>
</ul>
<h2 id="Runnable接口是函数式接口"><a href="#Runnable接口是函数式接口" class="headerlink" title="Runnable接口是函数式接口"></a>Runnable接口是函数式接口</h2><p><code>Runnable</code>接口中只包含一个抽象方法,从<code>Java 8</code>开始,<code>Runnable</code>接口使用了<code>@FunctionalInterface</code>修饰。也就是说, <strong><code>Runnable</code>接口是函数式接口,可使用<code>Lambda</code>表达式创建<code>Runnable</code>对象</strong>。接下来介绍的<code>Callable</code>接口也是函数式接口。</p>
<h2 id="多个线程共享一个target则可以共享target中的实例变量"><a href="#多个线程共享一个target则可以共享target中的实例变量" class="headerlink" title="多个线程共享一个target则可以共享target中的实例变量"></a>多个线程共享一个target则可以共享target中的实例变量</h2><p>采用<code>Runnable</code>接口的方式创建的<strong>多个线程可以共享线程类的实例变量</strong>。这是因为只创建了一个<code>target</code>实例,而多个线程可以共享这个<code>target</code>实例,因而多个线程中的实例变量也是共享的。</p>
<h3 id="部分运行效果"><a href="#部分运行效果" class="headerlink" title="部分运行效果"></a>部分运行效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">新线程<span class="number">2</span>  <span class="number">82</span></span><br><span class="line">新线程<span class="number">1</span>  <span class="number">81</span></span><br><span class="line">新线程<span class="number">2</span>  <span class="number">83</span></span><br><span class="line">新线程<span class="number">2</span>  <span class="number">85</span></span><br><span class="line">main  <span class="number">54</span></span><br><span class="line">main  <span class="number">55</span></span><br><span class="line">新线程<span class="number">2</span>  <span class="number">86</span></span><br><span class="line">新线程<span class="number">2</span>  <span class="number">87</span></span><br><span class="line">新线程<span class="number">1</span>  <span class="number">84</span></span><br><span class="line">新线程<span class="number">2</span>  <span class="number">88</span></span><br></pre></td></tr></table></figure>
<p>从上面的运行结果可以看出:<strong>两个子线程的i变量是连续的</strong>,也就是采用<code>Runnable</code>接口的方式创建的<strong>多个线程可以共享线程类的实例变量</strong>。这是因为在这种方式下,程序所创建的<code>Runnable</code>对象只是线程的<code>target</code>,而多个线程可以共享同一个<code>target</code>,所以多个线程可以共享同一个线程类(实际上应该是线程的<code>target</code>类)的实例变量。</p>
<h1 id="16-2-3-使用Callable和Future创建线程"><a href="#16-2-3-使用Callable和Future创建线程" class="headerlink" title="16.2.3 使用Callable和Future创建线程"></a>16.2.3 使用Callable和Future创建线程</h1><p>通过实现<code>Runnable</code>接口创建多线程时, <strong><code>Thread</code>类的作用就是把<code>Runnable</code>实例提供的<code>run()</code>方法包装成线程执行体</strong>。<br>那么是否可以直接把任意方法都包装成线程执行体呢?<code>Java</code>目前不行,不过C#可以把任意方法包装成线程执行体,包括有返回值的方法</p>
<h2 id="Callable接口简介"><a href="#Callable接口简介" class="headerlink" title="Callable接口简介"></a>Callable接口简介</h2><p>从<code>Java 5</code>开始,<code>Java</code>提供了<code>Callable</code>接口,可以把该接口看成<code>Runnable</code>接口的<strong>增强版</strong>,<code>Callable</code>接口提供了一个<code>call()</code>方法可以作为线程执行体,但<code>call()</code>方法比<code>run()</code>方法功能更强大,具体表现为:</p>
<ul>
<li><code>call()</code>方法可以有返回值。</li>
<li><code>call()</code>方法可以声明抛出异常。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><code>Callable</code>接口的<code>call</code>方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>V call()</code></td>
<td align="left">Computes a result, or throws an exception if unable to do so.</td>
</tr>
</tbody></table>
<h3 id="Callable接口实例不能作为Thread构造方法的参数"><a href="#Callable接口实例不能作为Thread构造方法的参数" class="headerlink" title="Callable接口实例不能作为Thread构造方法的参数"></a>Callable接口实例不能作为Thread构造方法的参数</h3><p><code>Callable</code>接口是<code>Java 5</code>新增的接口,但<code>Callable</code>接口不是<code>Runnable</code>接口的子接口,所以**<code>Callable</code>接口实例不能直接作为<code>Thread</code>的<code>target</code>**</p>
<h3 id="泛型定义call方法返回值-函数式接口"><a href="#泛型定义call方法返回值-函数式接口" class="headerlink" title="泛型定义call方法返回值 函数式接口"></a>泛型定义call方法返回值 函数式接口</h3><p><code>Callable</code>接口有泛型限制,<strong><code>Callable</code>接口里的泛型形参类型与<code>call()</code>方法返回值类型相同</strong>。<br>并且<code>Callable</code>接口是函数式接口,因此可使用<code>Lambda</code>表达式创建<code>Callable</code>对象。</p>
<h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><h3 id="FutureTask实现类"><a href="#FutureTask实现类" class="headerlink" title="FutureTask实现类"></a>FutureTask实现类</h3><p><strong><code>Java 5</code>提供了<code>Future</code>接口来代表<code>Callable</code>接口里<code>call()</code>方法的返回值</strong>,并为<code>Future</code>接口提供了一个<code>FutureTask</code>实现类,<strong><code>FutureTask</code>即实现了<code>Future</code>接口,又实现了<code>Runnable</code>接口</strong>,所以**<code>FutureTask</code>可以作为<code>Thread</code>类的<code>target</code>**。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>FutureTask(Callable&lt;V&gt; callable)</code></td>
<td align="left">Creates a FutureTask that will, upon running, execute the given Callable.</td>
</tr>
</tbody></table>
<h3 id="Future接口方法"><a href="#Future接口方法" class="headerlink" title="Future接口方法"></a>Future接口方法</h3><p>在<code>Future</code>接口里定义了如下几个公共方法来控制它关联的<code>Callable</code>任务。</p>
<h4 id="获取call方法的返回值-get方法"><a href="#获取call方法的返回值-get方法" class="headerlink" title="获取call方法的返回值 get方法"></a>获取call方法的返回值 get方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>V get()</code></td>
<td align="left"><strong>返回<code>Callable</code>任务里<code>call</code>方法的返回值</strong>。调用该方法将导致程序<code>阻塞</code>,必须<strong>等到子线程结束后才会得到返回值</strong>。</td>
</tr>
<tr>
<td align="left"><code>V get(long timeout, TimeUnit unit)</code></td>
<td align="left">返回<code>Callable</code>任务里<code>call</code>方法的返回值。该方法让程序最多阻塞<code>timeout</code>和<code>unit</code>指定的时间,如果经过指定时间后<code>Callable</code>任务依然没有返回值,将会抛出<code>TimeoutException</code>异常。</td>
</tr>
</tbody></table>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean cancel(boolean mayInterruptIfRunning)</code></td>
<td align="left">试图取消该<code>Future</code>里关联的<code>Callable</code>任务。</td>
</tr>
<tr>
<td align="left"><code>boolean isCancelled()</code></td>
<td align="left">如果在<code>Callable</code>任务正常完成前被取消,则返回<code>true</code>。</td>
</tr>
<tr>
<td align="left"><code>boolean isDone()</code></td>
<td align="left">如果<code>Callable</code>任务已完成,则返回<code>true</code>。</td>
</tr>
</tbody></table>
<h2 id="创建并启动有返回值的线程的步骤"><a href="#创建并启动有返回值的线程的步骤" class="headerlink" title="创建并启动有返回值的线程的步骤"></a>创建并启动有返回值的线程的步骤</h2><p>创建并启动有返回值的线程的步骤如下。</p>
<ol>
<li><strong>创建<code>Callable</code>对象</strong><ol>
<li>先创建<code>Callable</code>接口的实现类,并实现<code>call()</code>方法,该<code>call()</code>方法将作为线程执行体,且该<code>call()</code>方法有返回值,再创建<code>Callable</code>实现类的对象。</li>
<li><strong>直接使用<code>Lambda</code>表达式创建<code>Callable</code>对象</strong>。</li>
</ol>
</li>
<li><strong>创建<code>FutureTask</code>类对象时传入<code>Callable</code>对象作为构造器参数</strong>,<code>FutureTask</code>对象封装了该<code>Callable</code>对象的<code>call()</code>方法的返回值.</li>
<li><strong>创建<code>Thread</code>类对象时传入<code>FutureTask</code>对象作为构造器参数</strong>,然后启动新线程。</li>
<li><strong>调用<code>FutureTask</code>对象的<code>get()</code>方法</strong>来获得子线程执行结束后的返回值。</li>
</ol>
<h2 id="程序-带返回值的线程-Lambda表达式写法"><a href="#程序-带返回值的线程-Lambda表达式写法" class="headerlink" title="程序 带返回值的线程 Lambda表达式写法"></a>程序 带返回值的线程 Lambda表达式写法</h2><p>下面程序通过实现<code>Callable</code>接口来实现线程类,并启动该线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdThread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 1.先使用Lambda表达式创建Callable&lt;Integer&gt;对象</span></span><br><span class="line">        <span class="comment">// 2.使用FutureTask来包装Callable对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;Integer&gt;((Callable&lt;Integer&gt;)() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> ( ; i &lt; <span class="number">100</span> ; i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot; 的循环变量i的值：&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// call()方法可以有返回值</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()</span><br><span class="line">                + <span class="string">&quot; 的循环变量i的值：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 3.实质还是以Callable对象来创建、并启动线程</span></span><br><span class="line">                <span class="keyword">new</span> Thread(task , <span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 4.获取线程返回值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程的返回值：&quot;</span> + task.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中<strong>使用<code>Lambda</code>表达式直接创建了<code>Callable</code>对象,这样就无须先创建<code>Callable</code>实现类,再创建<code>Callable</code>对象了</strong>。</p>
<h3 id="Callable和Runnable的区别"><a href="#Callable和Runnable的区别" class="headerlink" title="Callable和Runnable的区别"></a>Callable和Runnable的区别</h3><p>实现<code>Callable</code>接口与实现<code>Runnable</code>接口并没有太大的差别,只是<code>Callable</code>的<code>call()</code>方法允许声明抛出异常,而且允许带返回值。</p>
<ul>
<li>上面程序先使用<code>Lambda</code>表达式创建一个<code>Callable</code>接口实例,</li>
<li>然后将<code>Callable</code>接口实例包装成一个<code>FutureTask</code>对象。</li>
<li>主线程中当循环变量<code>i</code>等于20时,程序启动以<code>FutureTask</code>对象为<code>target</code>的线程。</li>
<li>程序最后<strong>调用<code>FutureTask</code>对象的<code>get()</code>方法来返回<code>call()</code>方法的返回值,<code>get()</code>方法将导致主线程被阻塞,直到<code>call()</code>方法结束并返回为止</strong>。</li>
</ul>
<p>运行上面程序,将看到主线程和<code>call()</code>方法所代表的线程交替执行的情形,程序最后还会输出<code>call()</code>方法的返回值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main 的循环变量i的值：0</span><br><span class="line">......</span><br><span class="line">main 的循环变量i的值：23</span><br><span class="line">有返回值的线程 的循环变量i的值：0</span><br><span class="line">main 的循环变量i的值：24</span><br><span class="line">有返回值的线程 的循环变量i的值：1</span><br><span class="line">...</span><br><span class="line">main 的循环变量i的值：98</span><br><span class="line">有返回值的线程 的循环变量i的值：72</span><br><span class="line">main 的循环变量i的值：99</span><br><span class="line">有返回值的线程 的循环变量i的值：73</span><br><span class="line">...</span><br><span class="line">有返回值的线程 的循环变量i的值：99</span><br><span class="line">子线程的返回值：100</span><br></pre></td></tr></table></figure>
<h2 id="程序-带返回值的线程-经典写法"><a href="#程序-带返回值的线程-经典写法" class="headerlink" title="程序 带返回值的线程 经典写法"></a>程序 带返回值的线程 经典写法</h2><figure class="highlight java"><figcaption><span>G:\dev2\idea_workspace\MyJavaTools\RunableTools\src\demo\thread\CallableThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">3</span>*<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CallableThread callable = <span class="keyword">new</span> CallableThread();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        System.out.println(<span class="string">&quot;启动线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取线程的返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程返回值：&quot;</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动线程</span><br><span class="line">线程返回值：HelloWorld</span><br><span class="line">main end</span><br></pre></td></tr></table></figure>
<p>打印“启动线程”线程后，主线程阻塞3秒，<br>然后输出“线程返回值：HelloWorld”<br>最后输出“main end”</p>
<h1 id="16-2-4-创建线程的三种方式对比"><a href="#16-2-4-创建线程的三种方式对比" class="headerlink" title="16.2.4 创建线程的三种方式对比"></a>16.2.4 创建线程的三种方式对比</h1><p>通过继承<code>Thread</code>类或实现<code>Runnable</code>、<code>Callable</code>接口都可以实现多线程,不过实现<code>Runnable</code>接口与实现<code>Callable</code>接口的方式基本相同,只是<code>Callable</code>接口里定义的方法有返回值,可以声明抛出异常而已。因此可以将实现<code>Runnable</code>接口和实现<code>Callable</code>接口归为一种方式。这种方式与继承<code>Thread</code>方式之间的主要差别如下:</p>
<h2 id="实现Runnable-Callable接口方式创建多线程的优缺点"><a href="#实现Runnable-Callable接口方式创建多线程的优缺点" class="headerlink" title="实现Runnable,Callable接口方式创建多线程的优缺点"></a>实现Runnable,Callable接口方式创建多线程的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>线程类只是实现了<code>Runnable</code>接口或<code>Callable</code>接口,还可以继承其他类</li>
<li>在这种方式下,多个线程可以共享同一个<code>target</code>对象,所以非常<strong>适合多个相同线程来处理同份资源的情况</strong>,从而可以将<code>CPU</code>、代码和数据分开,形成清晰的模型,较好地体现了面向对象的思想。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li> 编程稍稍复杂,如果需要访问当前线程,则必须使用<code>Thread.currentThread()</code>方法.</li>
</ul>
<h2 id="继承Thread类的方式创建多线程的优缺点"><a href="#继承Thread类的方式创建多线程的优缺点" class="headerlink" title="继承Thread类的方式创建多线程的优缺点"></a>继承Thread类的方式创建多线程的优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>编写简单,如果需要访问当前线程,则无须使用<code>Thread.currentThread()</code>方法,直接使用<code>this</code>关键字即可获得当前线程。</li>
</ul>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>因为线程类已经继承了<code>Thread</code>类,所以不能再继承其他父类。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>一般推荐采用实现<code>Runnable</code>接口、<code>Callable</code>接口的方式来创建多线程</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/11feab9f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/11feab9f/" class="post-title-link" itemprop="url">16.1 线程概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-15 20:45:38" itemprop="dateCreated datePublished" datetime="2019-07-15T20:45:38+08:00">2019-07-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 10:41:13" itemprop="dateModified" datetime="2020-03-15T10:41:13+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0/" itemprop="url" rel="index"><span itemprop="name">16.1 线程概述</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/11feab9f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/11feab9f/" data-xid="/JavaReadingNotes/11feab9f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-1-线程概述"><a href="#16-1-线程概述" class="headerlink" title="16.1 线程概述"></a>16.1 线程概述</h1><p>几乎所有的操作系统都支持同时运行多个任务,一个任务通常就是一个程序,<strong>每个运行中的程序就是一个进程</strong>。<br>当一个程序运行时,内部可能包含了多个顺序执行流,每个顺序执行流就是一个线程。</p>
<h1 id="16-1-1-线程和进程"><a href="#16-1-1-线程和进程" class="headerlink" title="16.1.1 线程和进程"></a>16.1.1 线程和进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>几乎所有的操作系统都支持进程的概念,所有运行中的任务通常对应一个进程(<code>Process</code>)。<br><strong>当一个程序进入内存运行时,即变成一个进程</strong>。<strong>进程是处于运行过程中的程序</strong>,并且具有一定的独立功能,<strong>进程是系统进行资源分配和调度的一个独立单位</strong>。</p>
<h2 id="进程的三个特征"><a href="#进程的三个特征" class="headerlink" title="进程的三个特征"></a>进程的三个特征</h2><p>一般而言,进程包含如下三个特征。</p>
<ul>
<li><strong>独立性</strong>:进程是系统中独立存在的实体,它可以拥有自己独立的资源,每一个进程都拥有自己私有的地址空间。在没有经过进程本身允许的情况下,一个用户进程不可以直接访问其他进程的地址空间。</li>
<li><strong>动态性</strong>:进程与程序的区别在于,<code>程序只是一个静态的指令集合</code>,而进程是一个正在系统中活动的指令集合。在进程中加入了时间的概念。进程具有自己的生命周期和各种不同的状态,这些概念在程序中都是不具备的。</li>
<li><strong>并发性</strong>:多个进程可以在单个处理器上并发执行,多个进程之间不会互相影响。</li>
</ul>
<h2 id="并发性和并行性的区别"><a href="#并发性和并行性的区别" class="headerlink" title="并发性和并行性的区别"></a>并发性和并行性的区别</h2><p>并发性(<code>concurrency</code>)和并行性(<code>parallel</code>)是两个概念,</p>
<ul>
<li><strong>并行</strong>指在<strong>同一时刻,有多条指令在多个处理器上同时执行</strong>;</li>
<li><strong>并发</strong>指在<strong>同一时刻,只能有一条指令执行,但多个进程指令被快速轮换执行</strong>,使得在宏观上具有多个进程同时执行的效果。</li>
</ul>
<h2 id="进程快速轮回执行"><a href="#进程快速轮回执行" class="headerlink" title="进程快速轮回执行"></a>进程快速轮回执行</h2><p>对于一个<code>CPU</code>而言,它在某个时间点只能执行一个程序,也就是说,只能运行一个进程,<code>CPU</code>不断地在这些进程之间轮换执行。不过因为<code>CPU</code>的执行速度相对人的感觉来说实在是太快了,所以虽然<code>CPU</code>在多个进程之间轮换执行,但用户感觉到好像有多个进程在同时执行。不过如果启动的程序足够多,用户依然可以感觉到程序的运行速度下降。</p>
<h2 id="多进程并发策略"><a href="#多进程并发策略" class="headerlink" title="多进程并发策略"></a>多进程并发策略</h2><p>现代的操作系统都支持多进程的并发,但在具体的实现细节上可能因为硬件和操作系统的不同而采用不同的策略。比较常用的方式有:</p>
<ul>
<li><strong>共用式的多任务操作策略</strong>,例如<code>Windows3.1</code>和<code>Mac OS9</code>;</li>
<li><strong>抢占式多任务操作策略</strong>,这种策略效率更高,目前操作系统大多采用这种策略,例如<code>Windows NT</code>、<code>Windows 2000</code>以及<code>UNIX/Linux</code>等操作系统。</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>多线程则扩展了多进程的概念,使得同一个进程可以同时并发处理多个任务。</p>
<h3 id="线程是进程的组成部分"><a href="#线程是进程的组成部分" class="headerlink" title="线程是进程的组成部分"></a>线程是进程的组成部分</h3><p>线程(<code>Thread)</code>也被称作轻量级进程(<code>Lightweight Process</code>),<strong>线程是进程的执行单元</strong>。就像进程在操作系统中的地位一样,<strong>线程在程序中是独立的、并发的执行流</strong>。<br>当进程被初始化后,<strong>主线程</strong>就被创建了。对于绝大多数的应用程序来说,通常仅要求有一个主线程,但也可以在该进程内创建多条顺序执行流,这些顺序执行流就是线程,<strong>每个线程也是互相独立的</strong>。<br><strong>线程是进程的组成部分</strong>,<strong>一个进程可以拥有多个线程,一个线程必须有一个父进程</strong>。</p>
<h3 id="线程拥有的资源"><a href="#线程拥有的资源" class="headerlink" title="线程拥有的资源"></a>线程拥有的资源</h3><p>线程可以拥有自己的<strong>堆栈</strong>、自己的<strong>程序计数器</strong>和自己的<strong>局部变量</strong>。</p>
<h3 id="线程共享父线程的系统资源"><a href="#线程共享父线程的系统资源" class="headerlink" title="线程共享父线程的系统资源"></a>线程共享父线程的系统资源</h3><p>但<strong>线程不拥有系统资源,它与父进程的其他线程共享该进程所拥有的全部资源</strong>。因为多个线程共享父进程里的全部资源,因此编程更加方便;但必须更加小心,因为需要确保线程不会妨碍同一进程里的其他线程。<br>线程可以完成一定的任务,可以与其他线程共享父进程中的共享变量及部分环境,相互之间协同来完成进程所要完成的任务。</p>
<h3 id="线程独立运行"><a href="#线程独立运行" class="headerlink" title="线程独立运行"></a>线程独立运行</h3><p>线程是独立运行的,它并不知道进程中是否还有其他线程存在。<strong>线程的执行是抢占式的</strong>,也就是说,当前运行的线程在任何时候都可能被挂起,以便另外一个线程可以运行。<br><strong>一个线程可以创建和撤销另一个线程</strong>,同一个进程中的多个线程之间可以并发执行。<br>从逻辑角度来看,多线程存在于一个应用程序中,让一个应用程序中可以有多个执行部分同时执行,但操作系统无须将多个线程看作多个独立的应用,对多线程实现调度和管理以及资源分配。<strong>线程的调度和管理由进程本身负责完成</strong>。</p>
<h3 id="一个程序至少有一个进程-一个进程至少有一个线程"><a href="#一个程序至少有一个进程-一个进程至少有一个线程" class="headerlink" title="一个程序至少有一个进程 一个进程至少有一个线程"></a>一个程序至少有一个进程 一个进程至少有一个线程</h3><p><strong>简而言之,一个程序运行后至少有一个进程,一个进程里可以包含多个线程,但至少要包含一个线程</strong></p>
<p><strong>归纳起来可以这样说:操作系统可以同时执行多个任务,每个任务就是进程;进程可以同时执行多个任务,每个任务就是线程。</strong></p>
<h1 id="16-1-2-多线程的优势"><a href="#16-1-2-多线程的优势" class="headerlink" title="16.1.2 多线程的优势"></a>16.1.2 多线程的优势</h1><p>线程在程序中是独立的、并发的执行流,与分隔的进程相比,进程中线程之间的隔离程度要小。它们共享内存、文件句柄和其他每个进程应有的状态。<br>因为线程的划分尺度小于进程,使得多线程程序的并发性高。进程在执行过程中拥有独立的内存单元,而多个线程共享内存,从而极大地提高了程序的运行效率。</p>
<h2 id="线程共享的环境"><a href="#线程共享的环境" class="headerlink" title="线程共享的环境"></a>线程共享的环境</h2><p>线程比进程具有更高的性能,这是由于同一个进程中的线程都有共性:一多个线程共享同一个进程虚拟空间。<strong>线程共享的环境包括:<mark>进程代码段</mark>、<mark>进程的公有数据</mark>等</strong>。利用这些共享的数据,线程很容易实现相互之间的<strong>通信</strong>。</p>
<p>当操作系统创建一个进程时,必须为该进程分配独立的内存空间,并分配大量的相关资源;但创建一个线程则简单得多,因此使用多线程来实现并发比使用多进程实现并发的性能要高得多。</p>
<h2 id="多线程编程优点"><a href="#多线程编程优点" class="headerlink" title="多线程编程优点"></a>多线程编程优点</h2><p>总结起来,使用多线程编程具有如下几个优点。</p>
<ul>
<li>进程之间不能共享内存,但线程之间共享内存非常容易</li>
<li>系统创建进程时需要为该进程重新分配系统资源,但创建线程则代价小得多,因此使用多线程来实现多任务并发比多进程的效率高</li>
<li><code>Java</code>语言内置了多线程功能支持,而不是单纯地作为底层操作系统的调度方式,从而简化了<code>Java</code>的多线程编程。</li>
</ul>
<h2 id="线程常见用途"><a href="#线程常见用途" class="headerlink" title="线程常见用途"></a>线程常见用途</h2><p>在实际应用中,多线程是非常有用的:</p>
<ul>
<li>一个浏览器必须能同时下载多个图片;</li>
<li>一个<code>Web</code>服务器必须能同时响应多个用户请求;</li>
<li><code>Java</code>虚拟机本身就在后台提供了一个超级线程来进行垃圾回收;</li>
<li>图形用户界面(<code>GUI</code>)应用也需要启动单独的线程从主机环境收集用户界面事件…</li>
</ul>
<p>总之,多线程在实际编程中的应用是非常广泛的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/148/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/148/">148</a><span class="page-number current">149</span><a class="page-number" href="/JavaReadingNotes/page/150/">150</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/150/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/149/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-mzjszagu6-lanlan2017.vercel.app","placeholder":"填写您的邮箱以便接收回复提醒,填写您个人网站地址以便为您增加访问量","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/149/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
