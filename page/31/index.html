<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/31/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/31/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/31/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/b7ce3fce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/b7ce3fce/" class="post-title-link" itemprop="url">15.1 理解断路器模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-21 18:24:08" itemprop="dateCreated datePublished" datetime="2021-10-21T18:24:08+08:00">2021-10-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-23 21:24:52" itemprop="dateModified" datetime="2021-10-23T21:24:52+08:00">2021-10-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC15%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E5%92%8C%E5%BB%B6%E8%BF%9F/" itemprop="url" rel="index"><span itemprop="name">第15章 处理失败和延迟</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/b7ce3fce/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/b7ce3fce/" data-xid="/JavaReadingNotes/b7ce3fce/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-1-理解断路器模式"><a href="#15-1-理解断路器模式" class="headerlink" title="15.1 理解断路器模式"></a>15.1 理解断路器模式</h1><p>断路器模式是随着Michael Nygard的Release It!（第2版，PragmaticBookshelf，2018）一书流行起来的，解决了我们所编写的代码可能会失败的问题。很重要的一点在于，即便是失败，它也能够优雅地失败。这个强大的模式在微服务环境中会更加关键，因为在这种环境下避免跨调用堆栈产生级联失败非常重要。</p>
<p>相对来讲，断路器模式的理念很简单，非常类似于现实世界中的电路断路器，这也是它得名的由来。在电路断路器中，当开关处于闭合位置时，电流能够流过断路器，为房间中的电灯、电视、电脑和其他设备供电。如果线路中出现故障，比如功率骤增，断路器就会打开，在电流损坏电子设备或房屋失火之前切断电流。</p>
<p>与之类似，软件中的断路器起初会处于关闭状态，允许进行方法的调用。如果因为某种原因，方法调用失败了（比如时间超出了定义的阈值），断路器就会打开，就不会对失败的方法再执行调用了。软件断路器的区别在于它提供了后备（fallback）行为和自校正功能。</p>
<p>如果被保护的方法在给定的失败阈值内发生了失败，那么可以调用一个后备方法代替它的位置。在断路器处于打开状态之后，几乎始终都会调用后备方法。处于打开状态的断路器偶尔会进入半开状态，并尝试调用发生失败的方法：如果依然失败，断路器就恢复为打开状态；如果调用成功，它会认为问题已经解决，断路器会回到闭合状态。图15.1阐述了软件断路器的流程。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211023212429.png" alt="image-20211023212429519"></p>
<center>图15.1 断路器模式能够实现优雅的失败处理</center>

<p>按照我的阐述，断路器是应用到方法上的。这样，在给定的一个微服务中，很容易就能达到数十个（甚至更多）断路器。决定在代码的什么地方声明断路器其实就是识别哪些方法易于出现失败。如下的几类方法肯定是添加断路器的首选。</p>
<ul>
<li>调用REST的方法：这些方法可能会因为远程服务不可用或者返回HTTP 500响应而失败。</li>
<li>执行数据库查询的方法：这些方法可能会因为数据库不响应或者模式变更破坏了应用而导致失败。</li>
<li>可能会比较慢的方法：它们不一定会失败，但是如果耗费太长时间才能完成工作就可能会被视为失败。</li>
</ul>
<p>最后一项强调了除处理故障之外断路器的另一项收益。在微服务中，延迟也是非常重要的，某个执行缓慢的微服务不能拖慢整个微服务的性能，避免上游的服务产生级联延迟是非常重要的。</p>
<p>我们可以看到，断路器模式是在代码中优雅处理故障和延迟的强大方法。那么该如何将断路器用到我们的代码中呢？幸运的是，Netflix开源项目通过Hystrix为我们提供了答案。</p>
<p>Netflix Hystrix是断路器模式的Java实现。简而言之，Hystrix断路器实现为一个切面，会在目标方法发生失败的时候触发后备方法。为了实现断路器模式，这个切面还会跟踪目标方法失败的频率；如果失败率超过了某个阈值，那么所有的请求都会转发至后备方法。</p>
<h3 id="关于Hystrix名称的一点逸事"><a href="#关于Hystrix名称的一点逸事" class="headerlink" title="关于Hystrix名称的一点逸事"></a>关于Hystrix名称的一点逸事</h3><p>当Netflix的开发人员为他们的断路器实现起名字的时候，他们想要这个名字能够体现出需要提供的弹性、防御能力和容错能力。最终，他们选择了Hystrix（Hystrix是古代豪猪的一种，豪猪是一种能够使用长刺进行自卫的动物）。此外，正如Hystrix FAQ中所解释的，这是一个听起来很酷的名称。当我们在15.3.1小节中查看Hystrix dashboard时，我们就会在项目的Logo位置处看到一个豪猪的图案。</p>
<p>Spring Cloud Netflix包含对Hystrix的支持，提供了一个简单的编程模型。Spring和Spring Boot开发人员都应该很熟悉这个模型。为方法添加@HystrixCommand注解并提供一个后备方法，就可以为该方法声明断路器。下面让我们看看如何在Taco Cloud代码中声明断路器，从而优雅地使用Hystrix来处理失败。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/39ba282d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/39ba282d/" class="post-title-link" itemprop="url">15.0 第15章 处理失败和延迟</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 18:22:09 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T18:22:09+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC15%E7%AB%A0-%E5%A4%84%E7%90%86%E5%A4%B1%E8%B4%A5%E5%92%8C%E5%BB%B6%E8%BF%9F/" itemprop="url" rel="index"><span itemprop="name">第15章 处理失败和延迟</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/39ba282d/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/39ba282d/" data-xid="/JavaReadingNotes/39ba282d/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>52</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第15章-处理失败和延迟"><a href="#第15章-处理失败和延迟" class="headerlink" title="第15章 处理失败和延迟"></a>第15章 处理失败和延迟</h1><div style="border:1px solid;"><strong>本章内容：</strong><ul><li>断路器模式简介</li><li>使用Hystrix处理失败和延迟</li><li>监控断路器</li><li>聚合断路器的指标</li></ul></div>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/72d681d2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/72d681d2/" class="post-title-link" itemprop="url">14.7 小结_第14章 管理配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 18:12:35 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T18:12:35+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/72d681d2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/72d681d2/" data-xid="/JavaReadingNotes/72d681d2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>304</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-7-小结"><a href="#14-7-小结" class="headerlink" title="14.7 小结"></a>14.7 小结</h1><ul>
<li>Spring Cloud Config Server提供了中心化的配置数据源，能够用于微服务架构应用中的所有微服务。</li>
<li>Config Server提供的属性是通过后端的Git或Vault仓库维护的。</li>
<li>除了暴露给所有Config Server客户端的全局属性，Config Server还能提供特定profile和特定应用的配置。</li>
<li>敏感数据能够保持私密，这可以在后端Git仓库中通过对其进行加密来实现，也可以通过在Vault后端存储私密信息来实现。</li>
<li>Config Server客户端能够借助手动或自动刷新得到新的属性，前者通过Actuator端点来实现，后者通过Spring Cloud Bus和Git webhooks来实现。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/9311c105/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/9311c105/" class="post-title-link" itemprop="url">14.6 在运行时刷新配置属性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-21 18:11:39" itemprop="dateCreated datePublished" datetime="2021-10-21T18:11:39+08:00">2021-10-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-23 22:25:12" itemprop="dateModified" datetime="2021-10-23T22:25:12+08:00">2021-10-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/9311c105/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/9311c105/" data-xid="/JavaReadingNotes/9311c105/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-6-在运行时刷新配置属性"><a href="#14-6-在运行时刷新配置属性" class="headerlink" title="14.6 在运行时刷新配置属性"></a>14.6 在运行时刷新配置属性</h1><p>在编写本章的时候，我正在一架飞机上，因为维护问题，飞机被重新拉回了登机口。情况并不严重，你正在读本章的内容，就说明机械工程师的工作完成得还是很令人满意的。即便如此，关于飞机维护，最有意思的事情是它要求飞机必须要在地面上。如果飞机正在飞行，那么能做的事情就太少了。</p>
<p>相比之下，在《星球大战》（Star Wars）电影中，如果Luke Skywalker或PoeDameron的X翼战机需要维护，舰载机械机器人（mech droid）就可以派上用场了，即使X翼战机正在作战，它也可以开展工作。</p>
<p>传统上，应用程序维护，包括配置更改，都需要重新部署或至少重新启动应用。可以说，由于缺少一个“机械机器人”来调整哪怕是最小的配置属性，因此我们每次都需要将应用程序拉回“登机口”。这对云原生应用来说是不可接受的。我们希望能够动态地更改配置属性，而不需要关闭应用程序。</p>
<p>幸运的是，Spring Cloud Config Server能够刷新正在运行的应用程序的配置属性，而不需要停机。一旦变更推送到支撑的Git仓库或Vault私密仓库，应用中的每个微服务就都可以立即通过以下两种方式的某一种进行刷新。</p>
<ul>
<li>手动刷新：Config Server客户端启用一个特殊的“/actuator/refresh”端点，对每个服务的这个端点发送HTTP POST请求将会强制配置客户端从Config Server的后端检索最新的配置。</li>
<li>自动刷新：Git仓库上的提交hook会触发所有Config Server客户端服务的刷新操作。这涉及Spring Cloud的另一个项目，名为Spring Cloud Bus，它能够用于Config Server及其客户端之间的通信。</li>
</ul>
<p>每种方案都有其优点和缺点。手动刷新能够更精确地控制服务何时更新最新配置，但是它需要向每个微服务实例发送一个HTTP请求。自动更新能够让应用中的每个微服务即时使用最新的配置，但它是由配置仓库的提交自动触发的，对于有些项目来说过于危险。</p>
<p>我们接下来看一下这两种方案，然后你就可以自行选择哪种方式更适合你的项目了。</p>
<h2 id="14-6-1-手动刷新配置属性"><a href="#14-6-1-手动刷新配置属性" class="headerlink" title="14.6.1 手动刷新配置属性"></a>14.6.1 手动刷新配置属性</h2><p>在第16章中，我们将会介绍Spring Boot Actuator。它是Spring Boot的基本元素之一，能够探查应用运行时的状况并且允许对运行时进行一些有限的操作，比如修改日志级别。现在先看一个特殊的Actuator特性，只有配置为Spring CloudConfig Server客户端的应用，这个特性才有效。</p>
<p>当我们将应用设置为Config Server客户端的时候，自动配置功能会配置一个特殊的Actuator端点，用来刷新配置属性。为了使用该端点，在项目的构建文件中除了Config Client依赖，我们还需要添加Actuator starter依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以猜到，这项依赖也可以在Spring Initializr中通过选中Actuator复选框添加进来。</p>
<p>在Config Server客户端应用中添加Actuator之后，我们可以在任意时间发送HTTPPOST请求到“/actuator/refresh”，通知它从后端仓库刷新配置属性。</p>
<p>我们看一下它是如何实现的。假设我们有一个带有<code>@ConfigurationProperties</code>注解的类，名为GreetingProps：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;greeting&quot;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingProps</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String message;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，我们可以编写一个控制器类。GreetingProps会注入其中，当它在处理GET请求时，返回message属性的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetingController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GreetingProps props;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GreetingController</span><span class="params">(GreetingProps props)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> props.getMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的Git配置仓库中有一个application.yml文件，含有如下的属性设置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">greeting:</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">Hello</span> <span class="string">World!</span></span><br></pre></td></tr></table></figure>

<p>Config Server和这个简单的hello-world配置客户端运行起来之后，我们对“/hello”发送HTTP GET请求，将会产生如下的响应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/hello</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>现在，我们对Config Server和hello-world都不进行重启，而是修改application.yml文件并推送至后端Git仓库，这样greeting.message属性将会变成如下形式：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">greeting:</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">Hiya</span> <span class="string">folks!</span></span><br></pre></td></tr></table></figure>

<p>即便在Git中配置已经发生变化，如果我们发送GET请求到hello-world应用，得到的结果依然是“Hello World!”响应。但是，我们可以对刷新端点发送一个POST请求，强制使其刷新：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:53419/actuator/refresh -X POST</span><br><span class="line">[&quot;config.client.version&quot;,&quot;greeting.message&quot;]</span><br></pre></td></tr></table></figure>

<p>注意，响应中包含一个JSON数组，列出了发生变更的属性名。这个数组包含greeting.message属性，还包含config.client.version属性（当前配置对应的Git提交的哈希值）的变化。因为现在的配置基于一个新的Git提交，所以每当后端的配置仓库有变化时，这个值都会跟着变化。</p>
<p>POST请求的响应告诉我们greeting.message已经发生变化了。但是，真正的证据还是要靠再次向“/hello”路径发送GET请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/hello</span><br><span class="line">Hiya folks!</span><br></pre></td></tr></table></figure>

<p>无须重启应用，甚至无须重启Config Server，应用现在就能向我们提供greeting.message属性的全新值。</p>
<p>如果我们能够完全控制何时对配置属性进行更新，那么“/actuator/refresh”端点是很不错的选择。如果我们的应用由多个微服务组成（可能每个服务都有多个实例），那么将配置传播到所有服务可能是一项非常乏味的工作。接下来，我们看一下如何一次性地将配置变更自动用到所有服务上。</p>
<h2 id="14-6-2-自动刷新配置属性"><a href="#14-6-2-自动刷新配置属性" class="headerlink" title="14.6.2 自动刷新配置属性"></a>14.6.2 自动刷新配置属性</h2><p>Config Server能够借助名为Spring Cloud Bus的Spring Cloud项目将配置变更自动通知到每个客户端，作为手动刷新应用中每个Config Server客户端属性的替代方案。图14.7阐述了它是如何运行的。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211023215219.png" alt="image-20211023215219588"></p>
<center>图14.7 Config Server与Spring Cloud Bus能够对应用广播变更（应用会在属性发生变化的时候，自动刷新它们的属性）</center>

<p>可以简要概括图14.7中的属性刷新流程。</p>
<ul>
<li>在配置Git仓库上创建一个webhook，当Git仓库有任何变化（比如所有的推送）时，都会通知Config Server。很多的Git实现都支持webhook，比如GitHub、GitLab、Bitbucket和Gogs。</li>
<li>Config Server会对webhook POST请求做出响应，借助某种消息代理以消息的方式广播该变更。</li>
<li>每个Config Server客户端应用订阅该通知，对通知消息做出响应，也就是会使用Config Server中的新属性值刷新它们的环境。</li>
</ul>
<p>这样做的结果就是，在配置属性变更推送到后端的Git仓库之后，所有的ConfigServer客户端应用能够立即获取最新的配置属性值。</p>
<p>在使用Config Server的自动属性刷新功能时，会有多个部件在发挥作用。我们回顾一下要做的变更，这样对需要做的事情会有一个整体的了解。</p>
<ul>
<li>我们需要有一个消息代理，用来处理Config Server及其客户端之间的消息传递，可以选择RabbitMQ或Kafka。</li>
<li>在后端Git仓库上需要创建一个webhook，将各种变更通知给ConfigServer。</li>
<li>Config Server需要启用Config Server监控依赖（提供了处理Git仓库webhook请求的端点）以及RabbitMQ或Kafka的Spring Cloud Stream依赖（用于发布属性变更消息给代理）。</li>
<li>除非消息代理在本地按照默认设置运行，否则，我们要在Config Server及其所有的客户端上配置连接至代理的详细信息。</li>
<li>每个Config Server的客户端应用需要Spring Cloud Bus依赖。</li>
</ul>
<p>假设预先需要的消息代理（不管是RabbitMQ、Kafka，还是你选择的其他方案）已经处于运行状态，并且为传送属性变更消息做好了准备，我们首先从将属性变更应用于Config Server开始，让它处理webhook的更新请求。</p>
<h3 id="创建webhook"><a href="#创建webhook" class="headerlink" title="创建webhook"></a>创建webhook</h3><p>很多Git服务都支持创建webhook，从而能够将Git仓库的变更信息通知给应用，这些变更包括推送。不同实现之间创建webhook的操作有所差异，我们很难对它们一一描述。在这里，我会介绍如何为Gogs仓库创建webhook。</p>
<p>我选择Gogs的原因在于它非常易于在本地运行，并且支持将webhook POST用到本地运行的应用上（对于GitHub来说，这非常难以实现）。同时，在Gogs上创建webhook的过程与GitHub几乎完全相同，因此描述Gogs的过程能够间接让你知道为GitHub创建webhook都需要哪些步骤。</p>
<p>首先，在Web浏览器中访问配置仓库并点击Settings链接，如图14.8所示。（GitHub上Settings链接的位置略有差异，但是它们的外观很相似。）</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211023215249.png" alt="image-20211023215249586"></p>
<center>图14.8 在Gogs或GitHub上点击Settings开始创建webhook</center>

<p>这会将我们带到仓库的设置页面，在左侧包含了一个设置分类的菜单。在菜单中选择Webhooks，将会出现如图14.9所示的页面。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211023215304.png" alt="image-20211023215304730"></p>
<center>图14.9 Webhooks页面中的Add Webhook按钮会打开创建webhook的表单</center>

<p>在Webhooks设置页面，点击Add Webhook按钮，在Gogs中会生成一个下拉列表，用来选择不同类型的webhook。选择Gogs选项，如图14.9所示。这样，我们会看到一个创建新webhook的表单，如图14.10所示[^1]。</p>
<p>Add Webhook表单有多个输入域，重要的是Payload URL和Content Type。我们马上将会配置Config Server来处理webhook的POST请求。在实现该功能的时候，Config Server将会在“/monitor”路径下处理webhook请求。因此，我们需要将Payload URL输入域设置成引用Config Server的“/monitor”端点的URL。因为我是在一个Docker容器中运行Gogs的，所以在图14.10中将URL设置成<a target="_blank" rel="noopener" href="http://host.docker.internal:8888/monitor%EF%BC%8C%E5%AE%83%E7%9A%84%E5%9F%9F%E5%90%8D%E4%B8%BAhost.docker.internal%E3%80%82%E8%BF%99%E4%B8%AA%E5%9F%9F%E5%90%8D%E8%AE%A9Gog%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%83%BD%E5%A4%9F%E8%B7%A8%E8%B6%8A%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BE%B9%E7%95%8C%E8%AE%BF%E9%97%AE%E5%AE%BF%E4%B8%BB%E6%9C%BA%E5%99%A8%E4%B8%8A%E7%9A%84Config">http://host.docker.internal:8888/monitor，它的域名为host.docker.internal。这个域名让Gog服务器能够跨越容器的边界访问宿主机器上的Config</a> Server[^2]。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211023215423.png" alt="image-20211023215423231"></p>
<center>图14.10 创建webhook时需要指定Config Server的“/monitor”URL和JSON载荷</center>

<p>我还将Content Type输入域设置成了application/json。这一点非常重要，因为Config Server的“/monitor”端点并不支持Content Type的另一个选项application/x-www- form-urlencoded。</p>
<p>如果设置Secret输入域，就可以在webhook POST请求中新增一个名为X-Gogs-Signature（在GitHub中名为X-Hub-Signature）的头信息，包含给定私密信息的HMAC-SHA256摘要（在GitHub中是HMAC-SHA1）。此时，Config Server的“/monitor”端点并不识别这个签名头信息，因此我们可以将这个输入域设置为空。</p>
<p>最后，我们只关心配置仓库的推送请求，另外，我们当然希望这个webhook处于活跃状态，所以需要确保Just the push event单选框和Active复选框处于选中状态。点击表单底部的Add Webhook按钮，webhook就创建完成了。每当仓库有推送的时候，就会向Config Server发送POST请求。</p>
<p>现在，我们必须要启用Config Server的“/monitor”端点来处理这些请求。</p>
<h3 id="在Config-Server中处理webhook更新"><a href="#在Config-Server中处理webhook更新" class="headerlink" title="在Config Server中处理webhook更新"></a>在Config Server中处理webhook更新</h3><p>要启用Config Server的“/monitor”端点非常简单，我们只需添加spring-cloud-config-monitor依赖到Config Server的配置文件即可。在Maven的pom.xml文件中，如下的依赖就会完成该项工作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-monitor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这项依赖添加完成之后，自动配置功能会发挥作用，从而启用“/monitor”端点。但是，除非Config Server本身有广播变更通知的方法，否则不会带来任何好处。为了实现这一点，我们需要添加对Spring Cloud Stream的依赖。</p>
<p>Spring Cloud Stream是另一个Spring Cloud项目。借助它，我们能够创建通过底层绑定机制通信的服务，这种通信机制可能是RabbitMQ或Kafka。服务在编写的时候并不会关心如何使用这些通信机制，只是接受流中的数据，对其进行处理，并返回到流中，由下游的服务继续处理。</p>
<p>“/monitor”端点使用Spring Cloud Stream发布通知消息给参与的ConfigServer客户端。为了避免硬编码特定的消息实现，监控器会作为Spring CloudStream的源，发布消息到流中并让底层的绑定机制处理消息发送的特定功能。</p>
<p>如果使用RabbitMQ，就需要将Spring Cloud Stream RabbitMQ绑定依赖添加到Config Server的构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你更喜欢Kafka，那么需要添加如下的Spring Cloud Stream Kafka依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-stream-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>依赖准备就绪之后，Config Server几乎就可以参与属性自动刷新功能了。实际上，如果RabbitMQ或Kafka在本地运行并且使用默认配置，Config Server就已经可以运行了。如果消息代理在其他地方运行，而不是在localhost，或者使用了非默认端口，又或者我们修改了访问代理的凭证信息，就需要在Config Server本身的配置中添加一些属性了。</p>
<p>如果采用RabbitMQ绑定，那么application.yml中的如下条目可以用来重写默认值：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">rabbit.tacocloud.com</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">tacocloud</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">s3cr3t</span></span><br></pre></td></tr></table></figure>

<p>虽然我们在这里设置了所有的属性，但是在你的RabbitMQ代理中只需要设置与默认值不同的属性即可。</p>
<p>如果使用Kafka，可以使用类似的属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kafka.tacocloud.com:9092</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kafka.tacocloud.com:9093</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kafka.tacocloud.com:9094</span></span><br></pre></td></tr></table></figure>

<p>你会发现，这些属性来源于第8章我们学习Kafka消息时的配置。实际上，配置自动刷新功能的RabbitMQ和Kafka后端与在Spring中使用代理的其他场景非常相似。</p>
<h3 id="创建Gogs的通知提取器"><a href="#创建Gogs的通知提取器" class="headerlink" title="创建Gogs的通知提取器"></a>创建Gogs的通知提取器</h3><p>对于每个Git实现来说，webhook POST请求所携带的内容会有所不同。所以，对于“/monitor”端点来说，很重要的一点就是在处理webhook POST请求时能够理解不同的数据格式。在幕后，“/monitor”端点会有一组组件来检查POST请求，试图弄清楚请求来自哪种Git服务器，然后将请求数据映射为通用的通知类型，并发送至每个客户端。</p>
<p>Config Server对多个流行的Git实现提供了开箱即用的支持，比如GitHub、GitLab和Bitbucket。如果你使用其中的某一个实现，那么不需要任何额外的操作。在我编写本书的时候，Gogs还没有得到官方支持[^3]。因此，使用Gogs作为Git实现的话，我们需要在项目中提供一个Gogs的通知提取器。</p>
<p>程序清单14.1为Taco Cloud集成Gogs时我所使用的通知提取器。</p>
<p>程序清单14.1 Gogs的通知提取器实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.gogs;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.monitor.PropertyPathNotification;</span><br><span class="line"><span class="keyword">import</span></span><br><span class="line">     org.springframework.cloud.config.monitor.PropertyPathNotificationExtractor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.MultiValueMap;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(Ordered.LOWEST_PRECEDENCE - 300)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GogsPropertyPathNotificationExtractor</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">PropertyPathNotificationExtractor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyPathNotification <span class="title">extract</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MultiValueMap&lt;String, String&gt; headers,</span></span></span><br><span class="line"><span class="params"><span class="function">    Map&lt;String, Object&gt; request)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;push&quot;</span>.equals(headers.getFirst(<span class="string">&quot;X-Gogs-Event&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.get(<span class="string">&quot;commits&quot;</span>) <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">      Set&lt;String&gt; paths = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      Collection&lt;Map&lt;String, Object&gt;&gt; commits =</span><br><span class="line">          (Collection&lt;Map&lt;String, Object&gt;&gt;) request</span><br><span class="line">          .get(<span class="string">&quot;commits&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map&lt;String, Object&gt; commit : commits) &#123;</span><br><span class="line">          addAllPaths(paths, commit, <span class="string">&quot;added&quot;</span>);</span><br><span class="line">          addAllPaths(paths, commit, <span class="string">&quot;removed&quot;</span>);</span><br><span class="line">          addAllPaths(paths, commit, <span class="string">&quot;modified&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!paths.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> PropertyPathNotification(</span><br><span class="line">              paths.toArray(<span class="keyword">new</span> String[^<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addAllPaths</span><span class="params">(Set&lt;String&gt; paths,</span></span></span><br><span class="line"><span class="params"><span class="function">                           Map&lt;String, Object&gt; commit,</span></span></span><br><span class="line"><span class="params"><span class="function">                           String name)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Collection&lt;String&gt; files =</span><br><span class="line">            (Collection&lt;String&gt;) commit.get(name);</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">      paths.addAll(files);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GogsPropertyPathNotificationExtractor如何运行的细节与我们的讨论没有太大关系，并且在Spring Cloud Config Server内置对Gogs的支持之后，就更加无关紧要了。所以，我不会对它进行过多的介绍，将它放在这里只是为了让你在使用Gogs的时候，可以作为参考。</p>
<h3 id="在Config-Server的客户端中启用自动刷新"><a href="#在Config-Server的客户端中启用自动刷新" class="headerlink" title="在Config Server的客户端中启用自动刷新"></a>在Config Server的客户端中启用自动刷新</h3><p>在Config Server客户端启用属性的自动刷新比Config Server本身会更加简单。我们需要添加一项依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样会添加AMQP（如RabbitMQ）Spring Cloud Bus starter到构建文件中。</p>
<p>如果使用Kafka，就需要添加如下的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应的Spring Cloud Bus starter准备就绪之后，启动应用的时候，自动配置功能就会发挥作用，应用会自动将自己绑定到本地运行的RabbitMQ代理或Kafka集群上。如果你的RabbitMQ或Kafka在其他地方运行，那么我们需要在每个客户端应用上像Config Server本身那样配置它们的详细信息。</p>
<p>Config Server及其客户端都配置成了支持自动刷新。将它们启动起来，并对application.yml做一下修改（任意修改都可以），当将该文件提交至Git仓库的时候，我们会立即看到它在客户端应用中生效。</p>
<p>[^1]: GitHub没有可选webhook的下拉列表。在点击Add Webhook按钮之后，会直接出现创建webhook的表单。<br>[^2]: 在Docker容器中。localhost指的是容器本身，而不是Docker宿主机。<br>[^3]: 作者给Config Server项目提交了一个支持Gogs的pull request。在它合并进去之后，本书的这个章节就没有必要关注了。目前，作者的这个pull request经修改后，已经合并到了Config Server中。——译者注</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/442a9225/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/442a9225/" class="post-title-link" itemprop="url">14.5 保持配置属性的私密性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 18:03:10 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T18:03:10+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/442a9225/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/442a9225/" data-xid="/JavaReadingNotes/442a9225/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-5-保持配置属性的私密性"><a href="#14-5-保持配置属性的私密性" class="headerlink" title="14.5 保持配置属性的私密性"></a>14.5 保持配置属性的私密性</h1><p>Config Server提供的大多数配置可能并不是私密的。但是，我们可能需要ConfigServer提供一些包含敏感信息的属性，比如密码或安全token，在后端仓库中，它们最好保持私密。</p>
<p>Config Server提供了两种方式来支持私密的配置属性。</p>
<ul>
<li>在Git存储的属性文件中使用加密后的值。</li>
<li>使用HashiCorp Vault作为Config Server的后端存储，补充（或替代）Git。</li>
</ul>
<p>我们将会依次看一下这两种方案是如何与Config Server组合使用保证配置属性私密性的。首先，我们看一下如何在Git后端中写入加密的属性。</p>
<h2 id="14-5-1-在Git中加密属性"><a href="#14-5-1-在Git中加密属性" class="headerlink" title="14.5.1 在Git中加密属性"></a>14.5.1 在Git中加密属性</h2><p>除了提供非加密值以外，Config Server也可以借助存储在Git中的属性文件提供加密值。处理存储在Git中的加密数据的关键在于一个秘钥（key），即加密秘钥（encryption key）。</p>
<p>为了启用加密属性功能，我们使用一个加密秘钥来配置Config Server，在将属性值提供给客户端应用之前，Config Server要使用这个秘钥对属性值进行解密。Config Server支持对称秘钥和非对称秘钥。要设置对称秘钥，我们可以在ConfigServer自己的配置中将encrypt.key属性设置为加密和解密秘钥的值：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">s3cr3t</span></span><br></pre></td></tr></table></figure>

<p>很重要的一点需要注意，这个属性要设置到bootstrap配置中（例如，bootstrap.properties或bootstrap.yml）。这样的话，在自动配置功能启用Config Server之前，这个属性就会加载和启用。</p>
<p>为了更加安全一些，我们可以让Config Server使用非对称的RSA秘钥对或引用一个keystore。要创建这样的秘钥，我们可以使用keytool命令行工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias tacokey -keyalg RSA \</span><br><span class="line">-dname &quot;CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US&quot; \</span><br><span class="line">-keypass s3cr3t -keystore keystore.jks -storepass l3tm31n</span><br></pre></td></tr></table></figure>

<p>这样形成的keystore会写入到名为keystore.jks的文件中。我们可以将这个keystore.jks文件放到文件系统中或者放到应用本身。不管使用哪种方式，我们都需要在Config Server的bootstrap.yml文件中配置keystore的位置和凭证信息。</p>
<div style="border:1px solid;">注意：为了在Config Server中使用加密功能，我们需要要安装JavaCryptography Extensions Unlimited Strength策略文件。参见Oracle的JavaSE页面了解详细信息。</div>

<p>例如，假设我们要将keystore打包到应用本身，将其放到类路径的根目录下，那么我们可以配置如下的属性，让Config Server使用该keystore：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">key-store:</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">tacokey</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:/keystore.jks</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">l3tm31n</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">s3cr3t</span></span><br></pre></td></tr></table></figure>

<p>秘钥和keystore就绪之后，我们需要对某些数据进行加密。Config Server暴露了一个“/encrypt”端口会帮助我们实现该功能。我们需要做的就是提交一个POST请求到“/encrypt”端点，其中包括要加密的数据。例如，我们要加密连接至MongoDB数据库的密码。借助curl，我们可以按照如下的方式加密密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/encrypt -d &quot;s3cr3tP455w0rd&quot;</span><br><span class="line">93912a660a7f3c04e811b5df9a3cf6e1f63850cdcd4aa092cf5a3f7e1662fab7</span><br></pre></td></tr></table></figure>

<p>在提交POST请求之后，我们会接收到一个加密的值作为响应。接下来，需要做的就是复制这个值并粘贴到Git仓库托管的配置文件中。</p>
<p>为了设置MongoDB，在Git仓库的application.yml文件中添加spring.data.mongodb. password属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;&#123;cipher&#125;93912a660a7f3c04e811b5df9a3cf6e1f63850...&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要注意，spring.data.mongodb.password被一个单括号（’）括了起来，并且带有{cipher}前缀。这样就会告诉Config Server，这是一个加密的值，而不是简单的未加密值。</p>
<p>在将这个变更提交并推送到Git仓库中的application.yml文件之后，Config Server就可以对外提供加密的属性了。如果要实际看一下，就使用curl命令伪装成ConfigServer的客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default | jq</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;app&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;prof&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: null,</span><br><span class="line">  &quot;version&quot;: &quot;464adfd43485182e4e0af08c2aaaa64d2f78c4cf&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;http://localhost:10080/tacocloud/tacocloudconfig/</span><br><span class="line">     application.yml&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;spring.data.mongodb.password&quot;: &quot;s3cr3tP455w0rd&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，spring.data.mongodb.password的值是以解密后的形式提供的。默认情况下，Config Server提供的所有加密值只是在后端Git仓库中处于加密的状态，它们在对外提供之前会解密。这意味着，消费这个配置的客户端应用并不需要任何特殊的代码和配置就能接收Git中已加密的属性。</p>
<p>如果你想要让Config Server以未解密的形式对外提供加密属性，那么可以将spring.cloud.config.server.encrypt.enabled属性设置为false：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">        <span class="attr">encrypt:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这样导致的结果就是Config Server在提供所有的属性值的时候完全按照Git仓库设置的样子进行发送，包括已加密的属性值。我们再次伪装成一个客户端，利用curl命令展示禁用解密的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default | jq</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;http://localhost:10080/tacocloud/tacocloudconfig/</span><br><span class="line">     application.yml&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;spring.data.mongodb.password&quot;: &quot;&#123;cipher&#125;AQA4JeVhf2cRXW...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果客户端接收到了未解密的属性值，那么客户端需要自行解密。</p>
<p>尽管可以通过Config Server在Git中保存已加密的私密信息，但是我们可以看到加密并不是Git的原生特性。它需要我们自己对写入Git仓库的数据进行加密。另外，除非将解密的任务推给Config Server的客户端应用，否则对于任何请求配置的客户端，Config Server API对外提供的私密信息都是解密之后的形式。我们接下来看一下另一个Config Server后端方案，它能够只向已授权的用户提供私密信息。</p>
<h2 id="14-5-2-在Vault中存储私密信息"><a href="#14-5-2-在Vault中存储私密信息" class="headerlink" title="14.5.2 在Vault中存储私密信息"></a>14.5.2 在Vault中存储私密信息</h2><p>HashiCorp Vault是一个私密管理工具。这意味着与Git相比，Vault的核心特性就是原生地处理私密信息。对于敏感的配置数据，Vault是一个更有吸引力的ConfigServer后端支撑方案。</p>
<p>为了开始使用Vault，我们需要参考Vault Web站点的安装指南下载并安装vault命令行工具。在本小节中，我们将会使用vault命令管理私密信息和启动Vault服务器。</p>
<h3 id="启动Vault服务器"><a href="#启动Vault服务器" class="headerlink" title="启动Vault服务器"></a>启动Vault服务器</h3><p>在使用Config Server写入和对外提供私密信息之前，我们需要启动一个Vault服务器。对于我们来讲，最简单的方式就是在开发模式下使用如下的命令启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vault server -dev -dev-root-token-id=roottoken</span><br><span class="line">$ export VAULT_ADDR=&#x27;http://127.0.0.1:8200&#x27;</span><br><span class="line">$ vault status</span><br></pre></td></tr></table></figure>

<p>第一条命令会在开发模式下启动一个Vault服务器，其中根token（root token）的ID为roottoken。顾名思义，开发模式意味着它是一个更简单但并不完全安全的Vault运行时。它不应该在生产环境中使用，但是在开发的工作流程中，这种使用Vault的方式会非常便利。</p>
<div style="border:1px solid;">注意：Vault是一个功能完备且健壮的私密管理工具。除了开发模式下的简单使用之外，本章没有足够的篇幅完整介绍Vault服务器的运行。我强烈建议你在尝试生产环境中使用Vault之前，通过阅读Vaul文档来更详细地了解Vault。</div>

<p>对Vault服务器的所有访问都需要向服务器提供一个token。根token是一个管理token，这意味着除了其他功能之外，它允许我们创建其他的token。它还能够用于读取和写入私密信息。如果在开发模式启动服务器的时候未指定根token，那么Vault服务器会为我们创建一个token并在启动的时候写入日志中。为了便于使用，建议将根token设置成一个易于记忆的值，比如roottoken。</p>
<p>开发模式的服务器启动之后，它将会监听本地机器的8200端口。所以，要让vault命令行知道Vault服务器在什么地方，设置VAULT_ADDR环境变量是非常重要的，这也是上述代码片段第二行所做的事情。</p>
<p>最后，vault status命令会校验之前的两条命令是否已经按照预期运行。你大致会看到描述Vault服务器的6个属性，包括Vault是否密闭（在开发模式下，它不应该处于密闭状态）。</p>
<p>使用Vault 0.10.0或之后的版本的话，Vault与Config Server协作使用之前还有其他的两条命令需要执行。Vault运行方式的一些变更会导致一个标准的私密后端与Config Server不兼容。以下两个命令会重新创建名为secret的后端，以兼容Config Server：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vault secrets disable secret</span><br><span class="line">$ vault secrets enable -path=secret kv</span><br></pre></td></tr></table></figure>

<p>如果使用更早版本的Vault，就不需要这些步骤。</p>
<h3 id="写入私密信息到Vault中"><a href="#写入私密信息到Vault中" class="headerlink" title="写入私密信息到Vault中"></a>写入私密信息到Vault中</h3><p>借助vault命令，可以很容易将私密信息写入Vault中。例如，假设我们想要将访问MongoDB的密码（也就是spring.data.mongodb.password）存储到Vault中，而不是存储到Git里面，就可以通过vault命令完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vault write secret/application spring.data.mongodb.password=s3cr3t</span><br></pre></td></tr></table></figure>

<p>图14.6拆分了vault write命令，阐述每个组成部分在将私密信息写入Vault的过程中扮演了什么角色。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021180046.png" alt="image-20211021180046275"></p>
<center>图14.6 通过vault命令将私密信息写入Vault</center>

<p>现在，我们最需要关注的就是私密信息的路径、key和值。私密信息的路径就像文件系统中的路径那样，允许我们将相关的私密信息放到一个给定的路径中，而将其他的私密信息放到不同的路径中。路径的前缀“secret/”用来识别Vault后端，在这里使用了一个key-value的后端，名为“secret”。</p>
<p>私密信息的key和值是我们实际要写入Vault的内容。当Config Server要对外提供已写入的私密信息时，很重要的一点在于私密信息的key要和配置属性保持一致。</p>
<p>我们可以使用vault read命令校验私密信息是否已经写入Vault中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vault read secret/application</span><br><span class="line">Key                             Value</span><br><span class="line">---                             -----</span><br><span class="line">refresh_interval                768h</span><br><span class="line">spring.data.mongodb.password    s3cr3t</span><br></pre></td></tr></table></figure>

<p>在将私密信息写入到指定路径的时候，需要注意每次往给定路径中写入时都会覆盖之前在该路径下写入的私密信息。例如，假设我们还想要往Vault的上述路径中写入MongoDB用户名，我们不能简单地写入spring.data.mongodb.usernamesecret私密信息本身，如果这样做就会导致spring.data.mongodb.password私密信息丢失。我们需要同时将这两个属性写进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% vault write secret/application \</span><br><span class="line">              spring.data.mongodb.password=s3cr3t \</span><br><span class="line">              spring.data.mongodb.username=tacocloud</span><br></pre></td></tr></table></figure>

<p>现在，我们已经往Vault中写入了一些私密信息。接下来，我们看一下如何让Vault作为Config Server的后端属性源。</p>
<h3 id="在Config-Server中启用Vault后端"><a href="#在Config-Server中启用Vault后端" class="headerlink" title="在Config Server中启用Vault后端"></a>在Config Server中启用Vault后端</h3><p>为了将Vault添加为Config Server的后端，我们至少需要将Vault添加为激活的profile。在Config Server的application.yml文件中，将会如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vault</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span></span><br></pre></td></tr></table></figure>

<p>如上所示，vault和git profile均处于激活状态，允许Config Server同时从Vault和Git获取配置。一般而言，我们会将敏感的配置属性写入Vault，对于不需要私密性的属性则继续使用Git作为后端。如果你希望将所有配置都写到Vault中或者没有必要使用Git后端，那么可以将spring.profiles.active设置为vault，完全放弃Git后端。</p>
<p>默认情况下，Config Server会假定Vault运行在localhost并监听8200端口。但是，我们可以在Config Server的配置中修改这种默认行为，如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">vault:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">vault.tacocloud.com</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8200</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Config Server对Vault的默认假定都可以通过spring.cloud.config.server.vault.*相关的属性重写。在这里，我们告诉Config Server，Vault的API可以通过<a target="_blank" rel="noopener" href="https://vault.tacocloud.com:8200/">https://vault.tacocloud.com:8200</a> 来访问。</p>
<p>注意，我们保留了Git配置，假定Vault和Git分担了提供配置相关的职责。order属性表明Vault提供的私密属性要优先于Git提供的属性。</p>
<p>在配置完Config Server使用Vault作为后端之后，我们可以使用curl命令伪装成一个客户端尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[habuma:habuma]% curl localhost:8888/application/default | jq</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2018-04-29T23:33:22.275+0000&quot;,</span><br><span class="line">  &quot;status&quot;: 400,</span><br><span class="line">  &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;Missing required header: X-Config-Token&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;/application/default&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>噢，不！似乎出现问题了。实际上，这个错误表明Config Server提供来自Vault的私密信息，但是请求中没有包含Vault token。</p>
<p>很重要的一点需要注意，对Vault的所有请求都要包含一个X-Vault-Token头信息。我们不会在Config Server本身中配置这个token，而是让每个Config Server客户端在向Config Server发送请求的时候在请求中包含X-Config-Token头信息。Config Server会接收到X-Config-Token头信息，然后将其转换成发送给Vault的X-Vault-Token头信息。</p>
<p>我们可以看到，因为在请求中缺少这个token，所以Config Server拒绝提供任何属性，甚至连Git中的属性都不可用了，因为在暴露私密的信息之前需要一个token。这是组合使用Vault和Git的一个有趣的副作用，除非提供一个合法的token，否则连Git属性都会被Config Server间接隐藏。</p>
<p>我们可以再尝试一下，在请求中添加一个X-Config-Token头信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default</span><br><span class="line">        -H&quot;X-Config-Token: roottoken&quot; | jq</span><br></pre></td></tr></table></figure>

<p>请求中的这个X-Config-Token头信息应该会产生更好的结果，响应中将会包含我们写入到Vault中的私密信息。这里给出的token是在我们以开发模式启动Vault的时候设置的根token，但实际上Vault服务器创建的所有合法、未过期且具有访问Vault私密后端的token都是可以的。</p>
<h3 id="在Config-Server客户端设置Vault-token"><a href="#在Config-Server客户端设置Vault-token" class="headerlink" title="在Config Server客户端设置Vault token"></a>在Config Server客户端设置Vault token</h3><p>显然，在每个微服务中，我们不能使用curl来指定消费Config Server属性的token。相反，我们应该在服务应用的本地配置中添加一点配置信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">token:</span> <span class="string">roottoken</span></span><br></pre></td></tr></table></figure>

<p>spring.cloud.config.token属性会告诉Config Server客户端在每次向ConfigServer发送请求的时候都要带上给定的token。这个属性必须设置到应用的本地配置中（而不能存放到Config Server的Git或Vault中），Config Server才能够将其传递到Vault上，从而访问私密属性。</p>
<h3 id="写入特定应用和特定profile的私密信息"><a href="#写入特定应用和特定profile的私密信息" class="headerlink" title="写入特定应用和特定profile的私密信息"></a>写入特定应用和特定profile的私密信息</h3><p>在为Config Server提供服务的时候，写入application路径的属性适用于所有的应用，不管它们的名字是什么。如果我们想要写入针对给定应用的私密属性，就需要将路径中的application部分改成应用的名称。例如，如下的vault write命令会为名为ingredient-service的应用（通过其spring.application.name属性指定）写入专有的私密信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vault write secret/ingredient-service \</span><br><span class="line">              spring.data.mongodb.password=s3cr3t</span><br></pre></td></tr></table></figure>

<p>类似的，如果我们不指定profile，写入Vault的私密信息就会成为默认profile属性的一部分。也就是说，不管哪个profile处于激活状态，客户端都能收到这些私密信息。我们可能想要将私密信息写入到特定的profile中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% vault write secret/application,production \</span><br><span class="line">              spring.data.mongodb.password=s3cr3t \</span><br><span class="line">              spring.data.mongodb.username=tacocloud</span><br></pre></td></tr></table></figure>

<p>这种方式写入的私密信息只对激活profile为production的应用有效。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/7bab10e2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/7bab10e2/" class="post-title-link" itemprop="url">14.4 提供特定应用和profile的属性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 17:29:07 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T17:29:07+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/7bab10e2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/7bab10e2/" data-xid="/JavaReadingNotes/7bab10e2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-4-提供特定应用和profile的属性"><a href="#14-4-提供特定应用和profile的属性" class="headerlink" title="14.4 提供特定应用和profile的属性"></a>14.4 提供特定应用和profile的属性</h1><p>我们可以回忆一下，当Config Server客户端启动的时候，它会发送一个请求到Config Server中，这个请求的路径中会包含应用的名称和激活profile的名称。在提供配置数据的时候，Config Server会考虑这些值，并为客户端返回特定应用和特定profile的配置数据。</p>
<p>从客户端的角度来讲，消费特定应用和特定profile的配置属性与之前没有ConfigServer时并没有太大的差别。应用的名称可以通过spring.application.name属性（这与Eureka识别应用的属性名是相同的）来指定应用的名称。激活的profile可以通过spring.profiles.active属性进行设置（通常会通过名为SPRING_PROFILES_ACTIVE的环境变量进行设置）。</p>
<p>类似的，要提供面向特定应用和profile的属性，Config Server本身也没有太多需要做的。真正比较重要的是，这些属性在支撑Git仓库中该如何进行存储。</p>
<h2 id="14-4-1-提供特定应用的属性"><a href="#14-4-1-提供特定应用的属性" class="headerlink" title="14.4.1 提供特定应用的属性"></a>14.4.1 提供特定应用的属性</h2><p>按照我们之前的讨论，使用Config Server的好处之一就是我们可以让应用中的所有微服务共享通用的配置属性。尽管如此，有些属性可能是某个服务特有的，不需要（或者不应该）与所有的服务共享。</p>
<p>除了共享配置之外，Config Server还能管理面向特定应用的配置属性。要实现这一点，需要将配置文件的名称命名为该应用spring.application.name属性的值。</p>
<p>在第13章中，我们使用spring.application.name属性为微服务提供了一个名称，将会注册到Eureka中。相同的属性也可以被配置客户端用来在Config Server中识别自身，这样Config Server就能提供该应用特有的配置。</p>
<p>例如，在Taco Cloud应用中，我们将应用拆分成了多个微服务，分别是ingredient-service、order-service、taco-service和user-service，我们可以在每个服务的spring.application.name属性中指定它的名称。然后，我们就可以根据各个服务的名称在Config Server的Git后端创建对应的配置YAML文件，比如ingredient-service.yml、order-service.yml、taco-service.yml和user-service.yml。图14.3为Gogs Web应用中配置仓库的文件截图。</p>
<p>不管服务应用的名称是什么，所有的应用都会接收来自application.yml文件的配置。但是，在向Config Server发起请求的时候，每个服务应用的spring.application.name的属性值会一同发送（作为请求路径的第一部分），如果存在匹配的属性文件，那么该文件中的属性将会一并返回。如果application.yml中通用的属性与特定应用配置文件中的属性出现重复，那么特定应用的属性会优先生效。</p>
<p>需要注意的是，尽管图14.3显示的是YAML配置文件，实际上，如果在Git仓库中存放properties文件，同样的规则依然有效。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021172704.png" alt="image-20211021172703981"></p>
<center>图14.3 应用特定的配置文件会根据每个应用的spring.application.name属性进行命名</center>

<h2 id="14-4-2-提供来自profile的属性"><a href="#14-4-2-提供来自profile的属性" class="headerlink" title="14.4.2 提供来自profile的属性"></a>14.4.2 提供来自profile的属性</h2><p>在第5章中，在编写配置属性时，我们曾经看到过利用Spring profile实现特定的属性只有在给定profile处于激活状态时才生效。Spring Cloud Config Server采用与单个Spring Boot应用完全相同的方式，提供了对特定profile属性的支持，包括：</p>
<ul>
<li>提供特定profile的“.properties”或YAML文件，比如名为application-production.yml的配置文件；</li>
<li>在一个YAML文件中提供多个profile配置组，它们之间以“—”和spring.profiles分割开。</li>
</ul>
<p>假设我们要通过Config Server为应用所有的微服务共享Eureka配置，现在它只引用了一个Eureka开发实例，对于开发环境来说是很不错的。如果服务要在生产环境运行，那么我们可能想要将它配置成引用多个Eureka节点。</p>
<p>另外，尽管我们在开发环境的配置中将server.port属性设置成了0，但是服务在部署到生产环境的时候，每个服务可能会运行到独立的容器中，容器将8080端口映射到外部的端口，这样就需要所有的应用都监听8080端口。</p>
<p>借助profile，我们可以声明多个配置。除了已经推送到Config Server Git后端的默认application.yml文件之外，我们还可以推送另外一个名为application-production.yml的YAML文件，如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">service-url:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://eureka1:8761/eureka/,http://eureka2:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>在应用从Config Server获取配置信息的时候，Config Server会识别哪个profile处于激活状态（位于请求路径的第二部分）。如果活跃profile是production，那么两个属性集（application.yml和application-production.yml）都将会返回，并且application- production.yml中的属性会优先于application.yml中的默认属性。图14.4为后端Git仓库的显示效果。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021172817.png" alt="image-20211021172817385"></p>
<center>图14.4 特定profile的配置文件在命名时后缀与激活profile的名称相同</center>

<p>我们还可以使用同样的命名约定指定适用于特定应用且特定profile的属性，也就是将属性文件命名为应用名加中划线再加profile名的形式。</p>
<p>例如，我们想要为名为ingredient-service的应用设置属性，而且这些属性只有当production profile处于激活状态时才有效。在这种场景下，名为ingredient-service-production.yml的文件可以包含特定应用且特定profile的属性，如图14.5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021172834.png" alt="image-20211021172834285"></p>
<center>图14.5 配置文件可以适用于特定应用且特定profile的属性</center>

<p>对于特定profile的属性，在后端Git仓库中，我们也可以使用相同命名约定的properties文件来代替YAML。在YAML文件中，我们可以将特定profile的属性和默认profile的属性放到同一个文件中，中间使用3个中划线和spring.profiles进行分割，相关内容我们在第5章已经学习过了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/77785ddb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/77785ddb/" class="post-title-link" itemprop="url">14.3 消费共享配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 16:19:43 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T16:19:43+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/77785ddb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/77785ddb/" data-xid="/JavaReadingNotes/77785ddb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-3-消费共享配置"><a href="#14-3-消费共享配置" class="headerlink" title="14.3 消费共享配置"></a>14.3 消费共享配置</h1><p>除了提供中心化的配置服务器，Spring Cloud Config Server还提供了一个客户端库，它会包含在Spring Boot应用的构建文件中，允许应用成为Config Server的客户端。</p>
<p>将Spring Boot应用变成Config Server客户端的最简单方式就是添加如下的依赖到项目的Maven构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相同的依赖也可以在Spring Initializr中通过选择标签为Config Client的复选框添加进来。</p>
<p>当应用启动的时候，自动配置功能将会自动化地注册一个属性源，该属性源将会从Config Server中拉取属性。默认情况下，它会假定Config Server运行在localhost并监听8888端口。如果情况并非如此，我们可以通过设置spring.cloud.config.uri配置Config Server的位置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://config.tacocloud.com:8888</span></span><br></pre></td></tr></table></figure>

<p>需要清楚一点，这些属性必须要放到Config Server客户端应用的本地，比如随每个微服务打包和部署的application.yml或application.properties文件中。</p>
<p>现在，我们有了一个中心化的配置服务器，几乎所有的配置都将会由它来提供，每个微服务都不需要携带很多自己的配置了。正常情况下，我们只需要设置spring.cloud.config.uri属性来指定配置服务器的地址并设置spring.application.name属性为配置服务器指明当前应用即可。</p>
<div style="border:1px solid;"><strong>哪个优先：Config Server还是服务注册中心？</strong><p>我们正在设置微服务，让它们通过Config Server了解Eureka服务注册中心在什么地方。这是一种通用的方式，能够避免在应用的每个微服务中重复服务注册中心的细节信息。</p><p>同时，我们还可能会将Config Server本身注册到Eureka中，并让每个微服务像发现其他服务那样去查找Config Server。如果你喜欢这种模式，就需要将Config Server变成服务发现的客户端，并将spring.cloud.config.discovery.enabled属性设置为false。这样的话，ConfigServer会将自身以“configserver”名称注册到Eureka中。</p><p>这种方式的缺点在于，每个服务在启动的时候都要调用两次外部的服务：第一次调用Eureka发现Config Server的位置，第二次调用Config Server获取配置数据。</p></div>

<p>当应用启动的时候，Config Server客户端提供的属性源将会对Config Server发送请求。它所接收到的属性将会放到应用的环境之中。除此之外，这些属性实际上还会被缓存起来，即便Config Server停机，它们依然是可用的（我们将会在14.6节看一下在属性发生变更的时候，刷新它们的几种方式）。</p>
<p>到目前为止，Config Server提供的配置都非常简单，面向所有的应用和所有的profile。但有时候，我们需要提供特定应用专有的配置，或者提供当应用在特定profile处于激活状态时才可用的配置。我们看一下Config Server的另一面，看看使用它的几种方式，包括提供特定应用和特定profile的属性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/e0f1d067/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/e0f1d067/" class="post-title-link" itemprop="url">14.2 运行配置服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 16:18:48 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T16:18:48+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/e0f1d067/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/e0f1d067/" data-xid="/JavaReadingNotes/e0f1d067/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-2-运行配置服务器"><a href="#14-2-运行配置服务器" class="headerlink" title="14.2 运行配置服务器"></a>14.2 运行配置服务器</h1><p>Spring Cloud Config Server为配置数据提供了中心化的数据源。与Eureka类似，我们可以将Config Server视为另一个微服务，在更大的应用中，它的角色就是为应用中的其他服务提供配置数据。</p>
<p>Config Server暴露了REST API，客户端（也就是其他的服务）可以通过它来消费配置属性。通过Config Server提供的配置来源于Config Server之外，通常来源于一个像Git这样的源码控制系统。图14.1阐述了它是如何运行的。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021155947.png" alt="image-20211021155947793"></p>
<center>图14.1 Spring Cloud Config Server通过支撑的Git仓库或Vault私密存储来为其他服务提供配置属性</center>

<p>注意，在图14.1中，我使用的是Git的图标，而不是GitHub的图标。这是很重要的，我们可以使用任意的Git实现来存储配置信息，包括但不限于GitHub。GitLab、微软的Team Foundation Server和Gogs都是合法的Config Server后端可选方案。</p>
<div style="border:1px solid;">注意：不管使用哪个Git服务器，Config Server几乎没有什么差异。在这里，我选择使用Gogs，这是一个轻量级、易于搭建的Git服务器。更具体来讲，我在开发使用的机器运行Gogs时完全遵循了Docker中运行Gogs的指南。</div>

<p>将配置信息存储在像Git这样的源码控制系统中，配置可以像应用源码那样实现版本化、使用分支、添加标签、恢复和指摘（blame）。但是，为了让配置信息与使用它们的源码分离，这些配置可以独立于应用演化和版本化。</p>
<p>你可能注意到了，在图14.1中还包含了HashiCorp Vault。如果想要保持配置属性完全私密，并且要将它们锁起来直到需要的时候才取出，那么Vault非常有用。我们将会在14.5节中讨论如何组合使用Config Server和Vault。</p>
<h2 id="14-2-1-启用配置服务器"><a href="#14-2-1-启用配置服务器" class="headerlink" title="14.2.1 启用配置服务器"></a>14.2.1 启用配置服务器</h2><p>作为更大应用系统中的一个微服务，Config Server会作为一个独立的应用进行开发和部署。所以，我们需要为Config Server创建一个全新的项目。要实现这一点，最简单的方式就是使用Spring Initializr或它的某个客户端（比如Spring ToolSuite中的New Spring Starter Project向导）。</p>
<div style="border:1px solid;"><strong>配置：重载的术语</strong><p>当我们讨论Spring Cloud Config Server的时候，会经常用到“配置（configuration）”这个术语，但是它所指的并不总是同一件事。我们将会编写配置属性来配置Config Server本身。同时，Config Server还会为应用提供配置属性。Config Server的名字中还有“Config”这个单词，这会导致一定的混乱。</p><p>在使用“configuration”这个单词的时候，我都会尽力表达清楚到底指的是哪个配置，而在代指Config Server的时候，我都会使用“Config”这个缩写形式。</p></div>

<p>我一般会将项目命名为“config-server”，但是你可以选取任何你喜欢的名称。最重要的是要选中Config Server复选框，这样就能声明对Config Server的依赖。这样做的结果就是会在所生成项目的pom.xml文件中添加如下的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Config Server的版本是根据选择的Spring Cloud release train确定的。在pom.xml文件中，必须要配置Spring Cloud release train。在我编写本书的时候，最新的Spring Cloud发布版本是Finchley.SR1。所以，在pom.xml文件中将会发现如下的属性和<code>&lt;dependencyManagement&gt;</code>代码块：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>尽管Config Server依赖将Spring Cloud添加到了项目的类路径下，但是这里并没有自动配置启动它，所以我们需要为某个配置类添加<code>@EnableConfigServer</code>。顾名思义，这个注解会在应用运行的时候启用一个Config Server。通常，我会将<code>@EnableConfigServer</code>放到主类中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们想要启动应用并查看Config Server如何运行之前，必须还要做另外一件事情：我们必须要告诉它，它要对外提供的配置属性都位于何处。作为开始，我们将会使用来自Git仓库的配置，所以我们需要将spring.cloud.config.server.git.uri属性设置为配置仓库的URL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在14.2.2小节，我们将会看到如何为Git仓库填充属性。</p>
<p>为了在本地开发环境运行，我们可能还要配置另一个属性。在测试本地服务的时候，我们最终会有多个服务一直运行并且它们要监听localhost的不同端口。作为典型的Spring Boot Web应用，Config Server默认会监听8080端口。为了避免端口冲突，我们可以通过设置server.port属性指定一个唯一的端口号：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们将server.port设置为8888，是因为在14.3节中我们将会看到这是Config客户端试图获取配置信息时默认使用的端口。可以将其设置成任意值，但是在配置客户端服务中必须要与其匹配。</p>
<p>很重要的一点需要注意，我们此时所编写的配置是针对Config Server本身的。它与Config Server对外提供的配置是不同的。Config Server会对外提供从Git或Vault获取到的配置信息。</p>
<p>此时，如果启动应用，就会有一个监听8888端口的Config Server，它还不能提供任何的配置属性。我们目前还没有任何Config Server客户端，但是可以通过curl命令行（或者提供同样功能的HTTP客户端）模拟一个客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;application&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;default&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: null,</span><br><span class="line">  &quot;version&quot;: &quot;ca791b15df07ce41d30c24937eece4ec4b208f4d&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会向Config Server的“/application/default”路径发送HTTP GET请求。这个请求可以由两部分或3部分组成，如图14.2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021160334.png" alt="image-20211021160333988"></p>
<center>图14.2 Config Server对外暴露了一个REST API（通过它可以消费配置属性）</center>

<p>路径的第一部分，即“application”，指的是发送请求的应用的名称。在14.4.1小节中将会看到，Config Server是如何利用请求路径中这部分的内容为我们提供特定应用配置的。现在，我们没有特定应用的配置，所以任意值都是可以的。</p>
<p>路径的第二部分指的是发送请求的应用中处于激活状态的Spring profile。在14.4.2小节中，我们将会看到Config Server是如何利用请求路径中的profile值提供激活active特定配置的。我们目前没有特定profile的配置，所以任意的profile值都是可以的。</p>
<p>路径的第三部分是可选的，指定了提供配置信息的后端Git仓库的标签或分支。如果没有指定，那么默认会使用“master”分支。</p>
<p>请求的响应为我们提供了一些关于Config Server的基本信息，包括为我们提供配置信息的Git提交的版本和标签。但是，这里明显缺少的就是真正的实际配置信息。正常情况下，我们会在propertySources属性下看到它们，但是在这个响应中，它是空的。这是因为我们需要为Git仓库填充Config Server要对外提供的属性。现在，我们看一下该如何实现。</p>
<h2 id="14-2-2-填充配置仓库"><a href="#14-2-2-填充配置仓库" class="headerlink" title="14.2.2 填充配置仓库"></a>14.2.2 填充配置仓库</h2><p>我们有多种办法为Config Server提供属性，最基本、最直接的方案是提交application.properties或application.yml文件到Git仓库的根路径下。</p>
<p>假设我们已经推送了一个名为application.yml的文件到前面章节所配置的Git仓库下。这个配置文件与前面章节的配置是不同的，它是Config Server将要对外提供的配置。假设在这个application.yml文件中我们配置了如下的属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>尽管这个application.yml文件的内容并不多，但是它所定义的配置是相当重要的。它会告诉应用中的每个服务都选择任意可用的端口并且告诉它们进行服务注册的Eureka在哪里。这意味着，在14.3节中，当我们将服务变成Config Server客户端的时候，我们可以从服务中移除显式的Eureka配置。</p>
<p>作为Config Server的客户端，我们可以使用curl命令行查看Config Server提供的新配置数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/someapp/someconfig</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;someapp&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;someconfig&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: null,</span><br><span class="line">  &quot;version&quot;: &quot;95df0cbc3bca106199bd804b27a1de7c3ef5c35e&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;http://localhost:10080/habuma/tacocloudconfig/</span><br><span class="line">     application.yml&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;server.port&quot;: 0,</span><br><span class="line">        &quot;eureka.client.service-url.defaultZone&quot;:</span><br><span class="line">     &quot;http://eureka1:8761/eureka/&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前对Config Server的请求不同，这个响应的propertySources属性中有了内容。具体来讲，它包含了一个属性源，属性源的name属性指向了Git仓库的引用，source则包含了我们推送至Git仓库中的属性。</p>
<h2 id="从Git子路径下提供配置"><a href="#从Git子路径下提供配置" class="headerlink" title="从Git子路径下提供配置"></a>从Git子路径下提供配置</h2><p>按照代码的组织风格，你可能想要将配置信息存储到Git仓库的子目录下，而不是放到根路径下。例如，我们想要将配置放到相对于Git仓库根目录名为“config”的子目录下，就可以按照如下方式设置spring.cloud.config.server.git.search-paths属性，让Config Server不再从根目录而是从“/config”目录下提供配置信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config</span></span><br></pre></td></tr></table></figure>

<p>注意，spring.cloud.config.server.git.search-paths属性是一个复数形式，这意味着我们可以让Config Server提供来自多个路径的配置，只需将它们列出来以逗号分隔即可：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config,moreConfig</span></span><br></pre></td></tr></table></figure>

<p>这样的话，Config Server会提供Git仓库下来自“/config”和“/moreConfig”路径的配置。</p>
<p>我们还可以使用通配符指定搜索路径：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config,more*</span></span><br></pre></td></tr></table></figure>

<p>这里，Config Server会提供来自“/config”和所有以“more”开头的子目录的配置。</p>
<h2 id="从Git分支或标签下提供配置"><a href="#从Git分支或标签下提供配置" class="headerlink" title="从Git分支或标签下提供配置"></a>从Git分支或标签下提供配置</h2><p>默认情况下，Config Server会提供Git中master分支下的配置。在客户端，我们可以将特定分支或标签设置为请求Config Server路径的第三个成员，如图14.2所示。但是，我们可能会发现让Config Server默认请求Git下特定的标签或分支会非常有用，而不是默认使用master。spring.cloud.config.server.git.default-label属性可以重写默认的标签或分支。</p>
<p>例如，考虑如下的配置，它会让Config Server提供名为“sidework”的分支（或标签）下的配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">sidework</span></span><br></pre></td></tr></table></figure>

<p>按照这个配置形式，除非Config Server客户端指定，否则将会提供“sidework”分支下的配置。</p>
<h2 id="为Git后端提供认证"><a href="#为Git后端提供认证" class="headerlink" title="为Git后端提供认证"></a>为Git后端提供认证</h2><p>Config Server检索配置信息的后端Git仓库很可能会使用用户名和密码进行保护。如果是这样，我们就必须为Config Server提供Git仓库的凭证信息。</p>
<p>spring.cloud.config.server.username和spring.cloud.config.server.password属性可以为后端仓库设置用户名和密码。如下的Config Server配置将设置这些属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">tacocloud</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">s3cr3tP455w0rd</span></span><br></pre></td></tr></table></figure>

<p>在这里，分别将用户名和密码设置成了tacocloud和s3cr3tP455w0rd。</p>
<p>使用curl作为Config Server的客户端能够帮助我们体验一下Config Server是怎样运行的。实际上，Config Server所能做的远远不止于此。但是，我们所编写的微服务并不会使用curl来获取配置数据。所以在查看Config Server提供配置的其他方式之前，我们将关注点转移到微服务上，看一下如何将它们变成Config Server的客户端。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/fba1438e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/fba1438e/" class="post-title-link" itemprop="url">14.1 共享配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 15:48:04 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T15:48:04+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/fba1438e/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/fba1438e/" data-xid="/JavaReadingNotes/fba1438e/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-1-共享配置"><a href="#14-1-共享配置" class="headerlink" title="14.1 共享配置"></a>14.1 共享配置</h1><p>就像我们在第5章所看到的那样，我们可以通过多种属性源设置属性来对Spring应用进行配置。如果某个配置属性可能会更改或者只针对运行时环境有效，那么Java系统属性或操作系统环境变量是一个合适的可选方案。对于不太可能发生变化或者应用特定的属性，将它们放到application.yml或application.properties中，随着打包的应用一起部署是一种很好的方案。</p>
<p>这些方案对于简单的应用来说都很不错。但是，当在环境变量或Java系统属性中设置配置属性的时候，我们必须要接受这样一个现实，那就是修改这些属性需要应用重启。如果我们选择将属性打包到要部署的JAR或WAR文件中，那么在属性变更时，我们必须要完全重新构建和重新部署应用。如果我们想要回滚配置变更，那么同样的约束依然有效。</p>
<p>这些约束在有些应用程序中是可以接受的。但是，在有些情况下，如果仅仅是为了修改一个属性就重启应用，往好了说是不太方便，往坏了说则具有破坏性。除此之外，在基于微服务架构的应用中，属性管理会跨越多个代码库和部署实例，因此将相同变更用到应用中多个服务的每个实例中是不现实的。</p>
<p>有些属性是敏感的，比如数据库密码和其他类型的私密信息。尽管这些值作为应用的属性在写入的时候可以进行加密，但是应用在使用它们之前必须要先解密。即便如此，有些属性甚至可能需要对应用开发人员保密。这样的话，将它们设置成环境变量或者将它们与应用的其他代码一起通过源码控制系统进行管理就是不可取的了。</p>
<p>相反，我们可以考虑一下这些场景在集中式的配置管理下会是什么样子。</p>
<ul>
<li>配置不再需要和应用程序代码一起打包和部署。这样的话，配置的变更或回滚就都不需要重新构建和重新部署应用了。配置甚至可以在运行时进行变更，无须重新启动应用。</li>
<li>共享通用配置的微服务不需要管理自己的属性设置副本，并且能够管理共享的相同属性。如果需要对属性进行变更，那么这些变更只需在一个地方执行一次就可以应用到所有的微服务上。</li>
<li>敏感配置可以进行加密，并且能够与应用代码分开进行维护。应用可以按需获取未加密的值，而不需要应用程序提供解密信息相关的代码。</li>
</ul>
<p>Spring Cloud Config Server提供了中心化的配置功能，应用中的所有微服务均可以依赖该服务器来获取配置。因为它是中心化的，所以是一个一站式的配置商店，所有的服务都可以使用它，另外它还能够为特定服务提供专门的配置。</p>
<p>使用Config Server的第一步就是创建并运行该服务器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/dc8a54a4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/dc8a54a4/" class="post-title-link" itemprop="url">14.0 第14章 管理配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 15:46:56 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T15:46:56+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/dc8a54a4/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/dc8a54a4/" data-xid="/JavaReadingNotes/dc8a54a4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>677</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第14章-管理配置"><a href="#第14章-管理配置" class="headerlink" title="第14章 管理配置"></a>第14章 管理配置</h1><div style="border:1px solid;"><strong>本章内容：</strong><ul><li>运行Spring Cloud Config Server</li><li>创建Config Server的客户端</li><li>存储敏感配置</li><li>自动化刷新配置</li></ul></div>

<p>买过房子或汽车的人可能都会面临厚厚的一叠纸。购买大宗商品时要签署的合同往往会对无纸化社会的承诺不屑一顾。每当我与汽车经销商或代理人坐到一起的时候，都感觉我应该提前准备好一叠绷带，为这个过程中几乎总能出现的纸划伤手的情况做好准备。</p>
<p>近年来，尽管我必须要签署的总页数几乎没有什么变化，但是我不必像以前那样填写那么多的字段了。对于表格中那些曾经手动填写的地方，现代化的表格在打印之前通常就基于收集到的数据预先填充好了。这样的话，不但会加快处理速度，而且能够减少在多个表格间手动填写重复数据所导致的错误。</p>
<p>与之类似，很多应用程序都存在某种形式的配置。在第5章中，我们讨论了通过配置属性来设置Spring Boot应用。通常，我们设置的属性是该应用特有的，所以可以通过application.properties或application.yml文件声明这些属性，并将它们打包到应用的部署文件中。</p>
<p>按照微服务的方式来组织架构的话，多个服务之间的配置属性是通用的。就像手工填写带有重复数据的表单非常乏味而且易于出错一样，跨多个应用服务重复进行配置可能也会存在问题。</p>
<p>在本章中，我们将会研究Spring Cloud的Config Server，这是为指定应用中所有服务提供集中式配置的一个服务。借助配置服务器，我们可以在一个地方管理所有的应用配置，避免任何重复。</p>
<p>但是在开始之前，我们简单思考一下单独配置微服务的问题，以及中心化的配置为何能够更好。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/30/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/JavaReadingNotes/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/32/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/31/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/31/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
