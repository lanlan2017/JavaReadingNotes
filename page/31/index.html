<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/31/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/31/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/31/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1875</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">630</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/442a9225/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/442a9225/" class="post-title-link" itemprop="url">14.5 保持配置属性的私密性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 18:03:10 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T18:03:10+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/442a9225/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/442a9225/" data-xid="/JavaReadingNotes/442a9225/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-5-保持配置属性的私密性"><a href="#14-5-保持配置属性的私密性" class="headerlink" title="14.5 保持配置属性的私密性"></a>14.5 保持配置属性的私密性</h1><p>Config Server提供的大多数配置可能并不是私密的。但是，我们可能需要ConfigServer提供一些包含敏感信息的属性，比如密码或安全token，在后端仓库中，它们最好保持私密。</p>
<p>Config Server提供了两种方式来支持私密的配置属性。</p>
<ul>
<li>在Git存储的属性文件中使用加密后的值。</li>
<li>使用HashiCorp Vault作为Config Server的后端存储，补充（或替代）Git。</li>
</ul>
<p>我们将会依次看一下这两种方案是如何与Config Server组合使用保证配置属性私密性的。首先，我们看一下如何在Git后端中写入加密的属性。</p>
<h2 id="14-5-1-在Git中加密属性"><a href="#14-5-1-在Git中加密属性" class="headerlink" title="14.5.1 在Git中加密属性"></a>14.5.1 在Git中加密属性</h2><p>除了提供非加密值以外，Config Server也可以借助存储在Git中的属性文件提供加密值。处理存储在Git中的加密数据的关键在于一个秘钥（key），即加密秘钥（encryption key）。</p>
<p>为了启用加密属性功能，我们使用一个加密秘钥来配置Config Server，在将属性值提供给客户端应用之前，Config Server要使用这个秘钥对属性值进行解密。Config Server支持对称秘钥和非对称秘钥。要设置对称秘钥，我们可以在ConfigServer自己的配置中将encrypt.key属性设置为加密和解密秘钥的值：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">s3cr3t</span></span><br></pre></td></tr></table></figure>

<p>很重要的一点需要注意，这个属性要设置到bootstrap配置中（例如，bootstrap.properties或bootstrap.yml）。这样的话，在自动配置功能启用Config Server之前，这个属性就会加载和启用。</p>
<p>为了更加安全一些，我们可以让Config Server使用非对称的RSA秘钥对或引用一个keystore。要创建这样的秘钥，我们可以使用keytool命令行工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkeypair -alias tacokey -keyalg RSA \</span><br><span class="line">-dname &quot;CN=Web Server,OU=Unit,O=Organization,L=City,S=State,C=US&quot; \</span><br><span class="line">-keypass s3cr3t -keystore keystore.jks -storepass l3tm31n</span><br></pre></td></tr></table></figure>

<p>这样形成的keystore会写入到名为keystore.jks的文件中。我们可以将这个keystore.jks文件放到文件系统中或者放到应用本身。不管使用哪种方式，我们都需要在Config Server的bootstrap.yml文件中配置keystore的位置和凭证信息。</p>
<div style="border:1px solid;">注意：为了在Config Server中使用加密功能，我们需要要安装JavaCryptography Extensions Unlimited Strength策略文件。参见Oracle的JavaSE页面了解详细信息。</div>

<p>例如，假设我们要将keystore打包到应用本身，将其放到类路径的根目录下，那么我们可以配置如下的属性，让Config Server使用该keystore：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line">  <span class="attr">key-store:</span></span><br><span class="line">    <span class="attr">alias:</span> <span class="string">tacokey</span></span><br><span class="line">    <span class="attr">location:</span> <span class="string">classpath:/keystore.jks</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">l3tm31n</span></span><br><span class="line">    <span class="attr">secret:</span> <span class="string">s3cr3t</span></span><br></pre></td></tr></table></figure>

<p>秘钥和keystore就绪之后，我们需要对某些数据进行加密。Config Server暴露了一个“&#x2F;encrypt”端口会帮助我们实现该功能。我们需要做的就是提交一个POST请求到“&#x2F;encrypt”端点，其中包括要加密的数据。例如，我们要加密连接至MongoDB数据库的密码。借助curl，我们可以按照如下的方式加密密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/encrypt -d &quot;s3cr3tP455w0rd&quot;</span><br><span class="line">93912a660a7f3c04e811b5df9a3cf6e1f63850cdcd4aa092cf5a3f7e1662fab7</span><br></pre></td></tr></table></figure>

<p>在提交POST请求之后，我们会接收到一个加密的值作为响应。接下来，需要做的就是复制这个值并粘贴到Git仓库托管的配置文件中。</p>
<p>为了设置MongoDB，在Git仓库的application.yml文件中添加spring.data.mongodb. password属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&#x27;&#123;cipher&#125;93912a660a7f3c04e811b5df9a3cf6e1f63850...&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要注意，spring.data.mongodb.password被一个单括号（’）括了起来，并且带有{cipher}前缀。这样就会告诉Config Server，这是一个加密的值，而不是简单的未加密值。</p>
<p>在将这个变更提交并推送到Git仓库中的application.yml文件之后，Config Server就可以对外提供加密的属性了。如果要实际看一下，就使用curl命令伪装成ConfigServer的客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default | jq</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;app&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;prof&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: null,</span><br><span class="line">  &quot;version&quot;: &quot;464adfd43485182e4e0af08c2aaaa64d2f78c4cf&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;http://localhost:10080/tacocloud/tacocloudconfig/</span><br><span class="line">     application.yml&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;spring.data.mongodb.password&quot;: &quot;s3cr3tP455w0rd&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，spring.data.mongodb.password的值是以解密后的形式提供的。默认情况下，Config Server提供的所有加密值只是在后端Git仓库中处于加密的状态，它们在对外提供之前会解密。这意味着，消费这个配置的客户端应用并不需要任何特殊的代码和配置就能接收Git中已加密的属性。</p>
<p>如果你想要让Config Server以未解密的形式对外提供加密属性，那么可以将spring.cloud.config.server.encrypt.enabled属性设置为false：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">        <span class="attr">encrypt:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这样导致的结果就是Config Server在提供所有的属性值的时候完全按照Git仓库设置的样子进行发送，包括已加密的属性值。我们再次伪装成一个客户端，利用curl命令展示禁用解密的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default | jq</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;http://localhost:10080/tacocloud/tacocloudconfig/</span><br><span class="line">     application.yml&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;spring.data.mongodb.password&quot;: &quot;&#123;cipher&#125;AQA4JeVhf2cRXW...&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，如果客户端接收到了未解密的属性值，那么客户端需要自行解密。</p>
<p>尽管可以通过Config Server在Git中保存已加密的私密信息，但是我们可以看到加密并不是Git的原生特性。它需要我们自己对写入Git仓库的数据进行加密。另外，除非将解密的任务推给Config Server的客户端应用，否则对于任何请求配置的客户端，Config Server API对外提供的私密信息都是解密之后的形式。我们接下来看一下另一个Config Server后端方案，它能够只向已授权的用户提供私密信息。</p>
<h2 id="14-5-2-在Vault中存储私密信息"><a href="#14-5-2-在Vault中存储私密信息" class="headerlink" title="14.5.2 在Vault中存储私密信息"></a>14.5.2 在Vault中存储私密信息</h2><p>HashiCorp Vault是一个私密管理工具。这意味着与Git相比，Vault的核心特性就是原生地处理私密信息。对于敏感的配置数据，Vault是一个更有吸引力的ConfigServer后端支撑方案。</p>
<p>为了开始使用Vault，我们需要参考Vault Web站点的安装指南下载并安装vault命令行工具。在本小节中，我们将会使用vault命令管理私密信息和启动Vault服务器。</p>
<h3 id="启动Vault服务器"><a href="#启动Vault服务器" class="headerlink" title="启动Vault服务器"></a>启动Vault服务器</h3><p>在使用Config Server写入和对外提供私密信息之前，我们需要启动一个Vault服务器。对于我们来讲，最简单的方式就是在开发模式下使用如下的命令启动服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vault server -dev -dev-root-token-id=roottoken</span><br><span class="line">$ export VAULT_ADDR=&#x27;http://127.0.0.1:8200&#x27;</span><br><span class="line">$ vault status</span><br></pre></td></tr></table></figure>

<p>第一条命令会在开发模式下启动一个Vault服务器，其中根token（root token）的ID为roottoken。顾名思义，开发模式意味着它是一个更简单但并不完全安全的Vault运行时。它不应该在生产环境中使用，但是在开发的工作流程中，这种使用Vault的方式会非常便利。</p>
<div style="border:1px solid;">注意：Vault是一个功能完备且健壮的私密管理工具。除了开发模式下的简单使用之外，本章没有足够的篇幅完整介绍Vault服务器的运行。我强烈建议你在尝试生产环境中使用Vault之前，通过阅读Vaul文档来更详细地了解Vault。</div>

<p>对Vault服务器的所有访问都需要向服务器提供一个token。根token是一个管理token，这意味着除了其他功能之外，它允许我们创建其他的token。它还能够用于读取和写入私密信息。如果在开发模式启动服务器的时候未指定根token，那么Vault服务器会为我们创建一个token并在启动的时候写入日志中。为了便于使用，建议将根token设置成一个易于记忆的值，比如roottoken。</p>
<p>开发模式的服务器启动之后，它将会监听本地机器的8200端口。所以，要让vault命令行知道Vault服务器在什么地方，设置VAULT_ADDR环境变量是非常重要的，这也是上述代码片段第二行所做的事情。</p>
<p>最后，vault status命令会校验之前的两条命令是否已经按照预期运行。你大致会看到描述Vault服务器的6个属性，包括Vault是否密闭（在开发模式下，它不应该处于密闭状态）。</p>
<p>使用Vault 0.10.0或之后的版本的话，Vault与Config Server协作使用之前还有其他的两条命令需要执行。Vault运行方式的一些变更会导致一个标准的私密后端与Config Server不兼容。以下两个命令会重新创建名为secret的后端，以兼容Config Server：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vault secrets disable secret</span><br><span class="line">$ vault secrets enable -path=secret kv</span><br></pre></td></tr></table></figure>

<p>如果使用更早版本的Vault，就不需要这些步骤。</p>
<h3 id="写入私密信息到Vault中"><a href="#写入私密信息到Vault中" class="headerlink" title="写入私密信息到Vault中"></a>写入私密信息到Vault中</h3><p>借助vault命令，可以很容易将私密信息写入Vault中。例如，假设我们想要将访问MongoDB的密码（也就是spring.data.mongodb.password）存储到Vault中，而不是存储到Git里面，就可以通过vault命令完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vault write secret/application spring.data.mongodb.password=s3cr3t</span><br></pre></td></tr></table></figure>

<p>图14.6拆分了vault write命令，阐述每个组成部分在将私密信息写入Vault的过程中扮演了什么角色。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021180046.png" alt="image-20211021180046275"></p>
<center>图14.6 通过vault命令将私密信息写入Vault</center>

<p>现在，我们最需要关注的就是私密信息的路径、key和值。私密信息的路径就像文件系统中的路径那样，允许我们将相关的私密信息放到一个给定的路径中，而将其他的私密信息放到不同的路径中。路径的前缀“secret&#x2F;”用来识别Vault后端，在这里使用了一个key-value的后端，名为“secret”。</p>
<p>私密信息的key和值是我们实际要写入Vault的内容。当Config Server要对外提供已写入的私密信息时，很重要的一点在于私密信息的key要和配置属性保持一致。</p>
<p>我们可以使用vault read命令校验私密信息是否已经写入Vault中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vault read secret/application</span><br><span class="line">Key                             Value</span><br><span class="line">---                             -----</span><br><span class="line">refresh_interval                768h</span><br><span class="line">spring.data.mongodb.password    s3cr3t</span><br></pre></td></tr></table></figure>

<p>在将私密信息写入到指定路径的时候，需要注意每次往给定路径中写入时都会覆盖之前在该路径下写入的私密信息。例如，假设我们还想要往Vault的上述路径中写入MongoDB用户名，我们不能简单地写入spring.data.mongodb.usernamesecret私密信息本身，如果这样做就会导致spring.data.mongodb.password私密信息丢失。我们需要同时将这两个属性写进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% vault write secret/application \</span><br><span class="line">              spring.data.mongodb.password=s3cr3t \</span><br><span class="line">              spring.data.mongodb.username=tacocloud</span><br></pre></td></tr></table></figure>

<p>现在，我们已经往Vault中写入了一些私密信息。接下来，我们看一下如何让Vault作为Config Server的后端属性源。</p>
<h3 id="在Config-Server中启用Vault后端"><a href="#在Config-Server中启用Vault后端" class="headerlink" title="在Config Server中启用Vault后端"></a>在Config Server中启用Vault后端</h3><p>为了将Vault添加为Config Server的后端，我们至少需要将Vault添加为激活的profile。在Config Server的application.yml文件中，将会如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vault</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">git</span></span><br></pre></td></tr></table></figure>

<p>如上所示，vault和git profile均处于激活状态，允许Config Server同时从Vault和Git获取配置。一般而言，我们会将敏感的配置属性写入Vault，对于不需要私密性的属性则继续使用Git作为后端。如果你希望将所有配置都写到Vault中或者没有必要使用Git后端，那么可以将spring.profiles.active设置为vault，完全放弃Git后端。</p>
<p>默认情况下，Config Server会假定Vault运行在localhost并监听8200端口。但是，我们可以在Config Server的配置中修改这种默认行为，如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">vault:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">vault.tacocloud.com</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">8200</span></span><br><span class="line">          <span class="attr">scheme:</span> <span class="string">https</span></span><br><span class="line">          <span class="attr">order:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>Config Server对Vault的默认假定都可以通过spring.cloud.config.server.vault.*相关的属性重写。在这里，我们告诉Config Server，Vault的API可以通过<a target="_blank" rel="noopener" href="https://vault.tacocloud.com:8200/">https://vault.tacocloud.com:8200</a> 来访问。</p>
<p>注意，我们保留了Git配置，假定Vault和Git分担了提供配置相关的职责。order属性表明Vault提供的私密属性要优先于Git提供的属性。</p>
<p>在配置完Config Server使用Vault作为后端之后，我们可以使用curl命令伪装成一个客户端尝试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[habuma:habuma]% curl localhost:8888/application/default | jq</span><br><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2018-04-29T23:33:22.275+0000&quot;,</span><br><span class="line">  &quot;status&quot;: 400,</span><br><span class="line">  &quot;error&quot;: &quot;Bad Request&quot;,</span><br><span class="line">  &quot;message&quot;: &quot;Missing required header: X-Config-Token&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;/application/default&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>噢，不！似乎出现问题了。实际上，这个错误表明Config Server提供来自Vault的私密信息，但是请求中没有包含Vault token。</p>
<p>很重要的一点需要注意，对Vault的所有请求都要包含一个X-Vault-Token头信息。我们不会在Config Server本身中配置这个token，而是让每个Config Server客户端在向Config Server发送请求的时候在请求中包含X-Config-Token头信息。Config Server会接收到X-Config-Token头信息，然后将其转换成发送给Vault的X-Vault-Token头信息。</p>
<p>我们可以看到，因为在请求中缺少这个token，所以Config Server拒绝提供任何属性，甚至连Git中的属性都不可用了，因为在暴露私密的信息之前需要一个token。这是组合使用Vault和Git的一个有趣的副作用，除非提供一个合法的token，否则连Git属性都会被Config Server间接隐藏。</p>
<p>我们可以再尝试一下，在请求中添加一个X-Config-Token头信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default</span><br><span class="line">        -H&quot;X-Config-Token: roottoken&quot; | jq</span><br></pre></td></tr></table></figure>

<p>请求中的这个X-Config-Token头信息应该会产生更好的结果，响应中将会包含我们写入到Vault中的私密信息。这里给出的token是在我们以开发模式启动Vault的时候设置的根token，但实际上Vault服务器创建的所有合法、未过期且具有访问Vault私密后端的token都是可以的。</p>
<h3 id="在Config-Server客户端设置Vault-token"><a href="#在Config-Server客户端设置Vault-token" class="headerlink" title="在Config Server客户端设置Vault token"></a>在Config Server客户端设置Vault token</h3><p>显然，在每个微服务中，我们不能使用curl来指定消费Config Server属性的token。相反，我们应该在服务应用的本地配置中添加一点配置信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">token:</span> <span class="string">roottoken</span></span><br></pre></td></tr></table></figure>

<p>spring.cloud.config.token属性会告诉Config Server客户端在每次向ConfigServer发送请求的时候都要带上给定的token。这个属性必须设置到应用的本地配置中（而不能存放到Config Server的Git或Vault中），Config Server才能够将其传递到Vault上，从而访问私密属性。</p>
<h3 id="写入特定应用和特定profile的私密信息"><a href="#写入特定应用和特定profile的私密信息" class="headerlink" title="写入特定应用和特定profile的私密信息"></a>写入特定应用和特定profile的私密信息</h3><p>在为Config Server提供服务的时候，写入application路径的属性适用于所有的应用，不管它们的名字是什么。如果我们想要写入针对给定应用的私密属性，就需要将路径中的application部分改成应用的名称。例如，如下的vault write命令会为名为ingredient-service的应用（通过其spring.application.name属性指定）写入专有的私密信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vault write secret/ingredient-service \</span><br><span class="line">              spring.data.mongodb.password=s3cr3t</span><br></pre></td></tr></table></figure>

<p>类似的，如果我们不指定profile，写入Vault的私密信息就会成为默认profile属性的一部分。也就是说，不管哪个profile处于激活状态，客户端都能收到这些私密信息。我们可能想要将私密信息写入到特定的profile中，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% vault write secret/application,production \</span><br><span class="line">              spring.data.mongodb.password=s3cr3t \</span><br><span class="line">              spring.data.mongodb.username=tacocloud</span><br></pre></td></tr></table></figure>

<p>这种方式写入的私密信息只对激活profile为production的应用有效。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/7bab10e2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/7bab10e2/" class="post-title-link" itemprop="url">14.4 提供特定应用和profile的属性</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 17:29:07 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T17:29:07+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/7bab10e2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/7bab10e2/" data-xid="/JavaReadingNotes/7bab10e2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-4-提供特定应用和profile的属性"><a href="#14-4-提供特定应用和profile的属性" class="headerlink" title="14.4 提供特定应用和profile的属性"></a>14.4 提供特定应用和profile的属性</h1><p>我们可以回忆一下，当Config Server客户端启动的时候，它会发送一个请求到Config Server中，这个请求的路径中会包含应用的名称和激活profile的名称。在提供配置数据的时候，Config Server会考虑这些值，并为客户端返回特定应用和特定profile的配置数据。</p>
<p>从客户端的角度来讲，消费特定应用和特定profile的配置属性与之前没有ConfigServer时并没有太大的差别。应用的名称可以通过spring.application.name属性（这与Eureka识别应用的属性名是相同的）来指定应用的名称。激活的profile可以通过spring.profiles.active属性进行设置（通常会通过名为SPRING_PROFILES_ACTIVE的环境变量进行设置）。</p>
<p>类似的，要提供面向特定应用和profile的属性，Config Server本身也没有太多需要做的。真正比较重要的是，这些属性在支撑Git仓库中该如何进行存储。</p>
<h2 id="14-4-1-提供特定应用的属性"><a href="#14-4-1-提供特定应用的属性" class="headerlink" title="14.4.1 提供特定应用的属性"></a>14.4.1 提供特定应用的属性</h2><p>按照我们之前的讨论，使用Config Server的好处之一就是我们可以让应用中的所有微服务共享通用的配置属性。尽管如此，有些属性可能是某个服务特有的，不需要（或者不应该）与所有的服务共享。</p>
<p>除了共享配置之外，Config Server还能管理面向特定应用的配置属性。要实现这一点，需要将配置文件的名称命名为该应用spring.application.name属性的值。</p>
<p>在第13章中，我们使用spring.application.name属性为微服务提供了一个名称，将会注册到Eureka中。相同的属性也可以被配置客户端用来在Config Server中识别自身，这样Config Server就能提供该应用特有的配置。</p>
<p>例如，在Taco Cloud应用中，我们将应用拆分成了多个微服务，分别是ingredient-service、order-service、taco-service和user-service，我们可以在每个服务的spring.application.name属性中指定它的名称。然后，我们就可以根据各个服务的名称在Config Server的Git后端创建对应的配置YAML文件，比如ingredient-service.yml、order-service.yml、taco-service.yml和user-service.yml。图14.3为Gogs Web应用中配置仓库的文件截图。</p>
<p>不管服务应用的名称是什么，所有的应用都会接收来自application.yml文件的配置。但是，在向Config Server发起请求的时候，每个服务应用的spring.application.name的属性值会一同发送（作为请求路径的第一部分），如果存在匹配的属性文件，那么该文件中的属性将会一并返回。如果application.yml中通用的属性与特定应用配置文件中的属性出现重复，那么特定应用的属性会优先生效。</p>
<p>需要注意的是，尽管图14.3显示的是YAML配置文件，实际上，如果在Git仓库中存放properties文件，同样的规则依然有效。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021172704.png" alt="image-20211021172703981"></p>
<center>图14.3 应用特定的配置文件会根据每个应用的spring.application.name属性进行命名</center>

<h2 id="14-4-2-提供来自profile的属性"><a href="#14-4-2-提供来自profile的属性" class="headerlink" title="14.4.2 提供来自profile的属性"></a>14.4.2 提供来自profile的属性</h2><p>在第5章中，在编写配置属性时，我们曾经看到过利用Spring profile实现特定的属性只有在给定profile处于激活状态时才生效。Spring Cloud Config Server采用与单个Spring Boot应用完全相同的方式，提供了对特定profile属性的支持，包括：</p>
<ul>
<li>提供特定profile的“.properties”或YAML文件，比如名为application-production.yml的配置文件；</li>
<li>在一个YAML文件中提供多个profile配置组，它们之间以“—”和spring.profiles分割开。</li>
</ul>
<p>假设我们要通过Config Server为应用所有的微服务共享Eureka配置，现在它只引用了一个Eureka开发实例，对于开发环境来说是很不错的。如果服务要在生产环境运行，那么我们可能想要将它配置成引用多个Eureka节点。</p>
<p>另外，尽管我们在开发环境的配置中将server.port属性设置成了0，但是服务在部署到生产环境的时候，每个服务可能会运行到独立的容器中，容器将8080端口映射到外部的端口，这样就需要所有的应用都监听8080端口。</p>
<p>借助profile，我们可以声明多个配置。除了已经推送到Config Server Git后端的默认application.yml文件之外，我们还可以推送另外一个名为application-production.yml的YAML文件，如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">service-url:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://eureka1:8761/eureka/,http://eureka2:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>在应用从Config Server获取配置信息的时候，Config Server会识别哪个profile处于激活状态（位于请求路径的第二部分）。如果活跃profile是production，那么两个属性集（application.yml和application-production.yml）都将会返回，并且application- production.yml中的属性会优先于application.yml中的默认属性。图14.4为后端Git仓库的显示效果。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021172817.png" alt="image-20211021172817385"></p>
<center>图14.4 特定profile的配置文件在命名时后缀与激活profile的名称相同</center>

<p>我们还可以使用同样的命名约定指定适用于特定应用且特定profile的属性，也就是将属性文件命名为应用名加中划线再加profile名的形式。</p>
<p>例如，我们想要为名为ingredient-service的应用设置属性，而且这些属性只有当production profile处于激活状态时才有效。在这种场景下，名为ingredient-service-production.yml的文件可以包含特定应用且特定profile的属性，如图14.5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021172834.png" alt="image-20211021172834285"></p>
<center>图14.5 配置文件可以适用于特定应用且特定profile的属性</center>

<p>对于特定profile的属性，在后端Git仓库中，我们也可以使用相同命名约定的properties文件来代替YAML。在YAML文件中，我们可以将特定profile的属性和默认profile的属性放到同一个文件中，中间使用3个中划线和spring.profiles进行分割，相关内容我们在第5章已经学习过了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/77785ddb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/77785ddb/" class="post-title-link" itemprop="url">14.3 消费共享配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 16:19:43 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T16:19:43+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/77785ddb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/77785ddb/" data-xid="/JavaReadingNotes/77785ddb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-3-消费共享配置"><a href="#14-3-消费共享配置" class="headerlink" title="14.3 消费共享配置"></a>14.3 消费共享配置</h1><p>除了提供中心化的配置服务器，Spring Cloud Config Server还提供了一个客户端库，它会包含在Spring Boot应用的构建文件中，允许应用成为Config Server的客户端。</p>
<p>将Spring Boot应用变成Config Server客户端的最简单方式就是添加如下的依赖到项目的Maven构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相同的依赖也可以在Spring Initializr中通过选择标签为Config Client的复选框添加进来。</p>
<p>当应用启动的时候，自动配置功能将会自动化地注册一个属性源，该属性源将会从Config Server中拉取属性。默认情况下，它会假定Config Server运行在localhost并监听8888端口。如果情况并非如此，我们可以通过设置spring.cloud.config.uri配置Config Server的位置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://config.tacocloud.com:8888</span></span><br></pre></td></tr></table></figure>

<p>需要清楚一点，这些属性必须要放到Config Server客户端应用的本地，比如随每个微服务打包和部署的application.yml或application.properties文件中。</p>
<p>现在，我们有了一个中心化的配置服务器，几乎所有的配置都将会由它来提供，每个微服务都不需要携带很多自己的配置了。正常情况下，我们只需要设置spring.cloud.config.uri属性来指定配置服务器的地址并设置spring.application.name属性为配置服务器指明当前应用即可。</p>
<div style="border:1px solid;"><strong>哪个优先：Config Server还是服务注册中心？</strong><p>我们正在设置微服务，让它们通过Config Server了解Eureka服务注册中心在什么地方。这是一种通用的方式，能够避免在应用的每个微服务中重复服务注册中心的细节信息。</p><p>同时，我们还可能会将Config Server本身注册到Eureka中，并让每个微服务像发现其他服务那样去查找Config Server。如果你喜欢这种模式，就需要将Config Server变成服务发现的客户端，并将spring.cloud.config.discovery.enabled属性设置为false。这样的话，ConfigServer会将自身以“configserver”名称注册到Eureka中。</p><p>这种方式的缺点在于，每个服务在启动的时候都要调用两次外部的服务：第一次调用Eureka发现Config Server的位置，第二次调用Config Server获取配置数据。</p></div>

<p>当应用启动的时候，Config Server客户端提供的属性源将会对Config Server发送请求。它所接收到的属性将会放到应用的环境之中。除此之外，这些属性实际上还会被缓存起来，即便Config Server停机，它们依然是可用的（我们将会在14.6节看一下在属性发生变更的时候，刷新它们的几种方式）。</p>
<p>到目前为止，Config Server提供的配置都非常简单，面向所有的应用和所有的profile。但有时候，我们需要提供特定应用专有的配置，或者提供当应用在特定profile处于激活状态时才可用的配置。我们看一下Config Server的另一面，看看使用它的几种方式，包括提供特定应用和特定profile的属性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/e0f1d067/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/e0f1d067/" class="post-title-link" itemprop="url">14.2 运行配置服务器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 16:18:48 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T16:18:48+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/e0f1d067/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/e0f1d067/" data-xid="/JavaReadingNotes/e0f1d067/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-2-运行配置服务器"><a href="#14-2-运行配置服务器" class="headerlink" title="14.2 运行配置服务器"></a>14.2 运行配置服务器</h1><p>Spring Cloud Config Server为配置数据提供了中心化的数据源。与Eureka类似，我们可以将Config Server视为另一个微服务，在更大的应用中，它的角色就是为应用中的其他服务提供配置数据。</p>
<p>Config Server暴露了REST API，客户端（也就是其他的服务）可以通过它来消费配置属性。通过Config Server提供的配置来源于Config Server之外，通常来源于一个像Git这样的源码控制系统。图14.1阐述了它是如何运行的。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021155947.png" alt="image-20211021155947793"></p>
<center>图14.1 Spring Cloud Config Server通过支撑的Git仓库或Vault私密存储来为其他服务提供配置属性</center>

<p>注意，在图14.1中，我使用的是Git的图标，而不是GitHub的图标。这是很重要的，我们可以使用任意的Git实现来存储配置信息，包括但不限于GitHub。GitLab、微软的Team Foundation Server和Gogs都是合法的Config Server后端可选方案。</p>
<div style="border:1px solid;">注意：不管使用哪个Git服务器，Config Server几乎没有什么差异。在这里，我选择使用Gogs，这是一个轻量级、易于搭建的Git服务器。更具体来讲，我在开发使用的机器运行Gogs时完全遵循了Docker中运行Gogs的指南。</div>

<p>将配置信息存储在像Git这样的源码控制系统中，配置可以像应用源码那样实现版本化、使用分支、添加标签、恢复和指摘（blame）。但是，为了让配置信息与使用它们的源码分离，这些配置可以独立于应用演化和版本化。</p>
<p>你可能注意到了，在图14.1中还包含了HashiCorp Vault。如果想要保持配置属性完全私密，并且要将它们锁起来直到需要的时候才取出，那么Vault非常有用。我们将会在14.5节中讨论如何组合使用Config Server和Vault。</p>
<h2 id="14-2-1-启用配置服务器"><a href="#14-2-1-启用配置服务器" class="headerlink" title="14.2.1 启用配置服务器"></a>14.2.1 启用配置服务器</h2><p>作为更大应用系统中的一个微服务，Config Server会作为一个独立的应用进行开发和部署。所以，我们需要为Config Server创建一个全新的项目。要实现这一点，最简单的方式就是使用Spring Initializr或它的某个客户端（比如Spring ToolSuite中的New Spring Starter Project向导）。</p>
<div style="border:1px solid;"><strong>配置：重载的术语</strong><p>当我们讨论Spring Cloud Config Server的时候，会经常用到“配置（configuration）”这个术语，但是它所指的并不总是同一件事。我们将会编写配置属性来配置Config Server本身。同时，Config Server还会为应用提供配置属性。Config Server的名字中还有“Config”这个单词，这会导致一定的混乱。</p><p>在使用“configuration”这个单词的时候，我都会尽力表达清楚到底指的是哪个配置，而在代指Config Server的时候，我都会使用“Config”这个缩写形式。</p></div>

<p>我一般会将项目命名为“config-server”，但是你可以选取任何你喜欢的名称。最重要的是要选中Config Server复选框，这样就能声明对Config Server的依赖。这样做的结果就是会在所生成项目的pom.xml文件中添加如下的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Config Server的版本是根据选择的Spring Cloud release train确定的。在pom.xml文件中，必须要配置Spring Cloud release train。在我编写本书的时候，最新的Spring Cloud发布版本是Finchley.SR1。所以，在pom.xml文件中将会发现如下的属性和<code>&lt;dependencyManagement&gt;</code>代码块：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>尽管Config Server依赖将Spring Cloud添加到了项目的类路径下，但是这里并没有自动配置启动它，所以我们需要为某个配置类添加<code>@EnableConfigServer</code>。顾名思义，这个注解会在应用运行的时候启用一个Config Server。通常，我会将<code>@EnableConfigServer</code>放到主类中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigServerApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们想要启动应用并查看Config Server如何运行之前，必须还要做另外一件事情：我们必须要告诉它，它要对外提供的配置属性都位于何处。作为开始，我们将会使用来自Git仓库的配置，所以我们需要将spring.cloud.config.server.git.uri属性设置为配置仓库的URL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigServerApplication</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在14.2.2小节，我们将会看到如何为Git仓库填充属性。</p>
<p>为了在本地开发环境运行，我们可能还要配置另一个属性。在测试本地服务的时候，我们最终会有多个服务一直运行并且它们要监听localhost的不同端口。作为典型的Spring Boot Web应用，Config Server默认会监听8080端口。为了避免端口冲突，我们可以通过设置server.port属性指定一个唯一的端口号：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们将server.port设置为8888，是因为在14.3节中我们将会看到这是Config客户端试图获取配置信息时默认使用的端口。可以将其设置成任意值，但是在配置客户端服务中必须要与其匹配。</p>
<p>很重要的一点需要注意，我们此时所编写的配置是针对Config Server本身的。它与Config Server对外提供的配置是不同的。Config Server会对外提供从Git或Vault获取到的配置信息。</p>
<p>此时，如果启动应用，就会有一个监听8888端口的Config Server，它还不能提供任何的配置属性。我们目前还没有任何Config Server客户端，但是可以通过curl命令行（或者提供同样功能的HTTP客户端）模拟一个客户端：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/application/default</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;application&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;default&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: null,</span><br><span class="line">  &quot;version&quot;: &quot;ca791b15df07ce41d30c24937eece4ec4b208f4d&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它会向Config Server的“&#x2F;application&#x2F;default”路径发送HTTP GET请求。这个请求可以由两部分或3部分组成，如图14.2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211021160334.png" alt="image-20211021160333988"></p>
<center>图14.2 Config Server对外暴露了一个REST API（通过它可以消费配置属性）</center>

<p>路径的第一部分，即“application”，指的是发送请求的应用的名称。在14.4.1小节中将会看到，Config Server是如何利用请求路径中这部分的内容为我们提供特定应用配置的。现在，我们没有特定应用的配置，所以任意值都是可以的。</p>
<p>路径的第二部分指的是发送请求的应用中处于激活状态的Spring profile。在14.4.2小节中，我们将会看到Config Server是如何利用请求路径中的profile值提供激活active特定配置的。我们目前没有特定profile的配置，所以任意的profile值都是可以的。</p>
<p>路径的第三部分是可选的，指定了提供配置信息的后端Git仓库的标签或分支。如果没有指定，那么默认会使用“master”分支。</p>
<p>请求的响应为我们提供了一些关于Config Server的基本信息，包括为我们提供配置信息的Git提交的版本和标签。但是，这里明显缺少的就是真正的实际配置信息。正常情况下，我们会在propertySources属性下看到它们，但是在这个响应中，它是空的。这是因为我们需要为Git仓库填充Config Server要对外提供的属性。现在，我们看一下该如何实现。</p>
<h2 id="14-2-2-填充配置仓库"><a href="#14-2-2-填充配置仓库" class="headerlink" title="14.2.2 填充配置仓库"></a>14.2.2 填充配置仓库</h2><p>我们有多种办法为Config Server提供属性，最基本、最直接的方案是提交application.properties或application.yml文件到Git仓库的根路径下。</p>
<p>假设我们已经推送了一个名为application.yml的文件到前面章节所配置的Git仓库下。这个配置文件与前面章节的配置是不同的，它是Config Server将要对外提供的配置。假设在这个application.yml文件中我们配置了如下的属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka1:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>尽管这个application.yml文件的内容并不多，但是它所定义的配置是相当重要的。它会告诉应用中的每个服务都选择任意可用的端口并且告诉它们进行服务注册的Eureka在哪里。这意味着，在14.3节中，当我们将服务变成Config Server客户端的时候，我们可以从服务中移除显式的Eureka配置。</p>
<p>作为Config Server的客户端，我们可以使用curl命令行查看Config Server提供的新配置数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8888/someapp/someconfig</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;someapp&quot;,</span><br><span class="line">  &quot;profiles&quot;: [</span><br><span class="line">    &quot;someconfig&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;label&quot;: null,</span><br><span class="line">  &quot;version&quot;: &quot;95df0cbc3bca106199bd804b27a1de7c3ef5c35e&quot;,</span><br><span class="line">  &quot;state&quot;: null,</span><br><span class="line">  &quot;propertySources&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;http://localhost:10080/habuma/tacocloudconfig/</span><br><span class="line">     application.yml&quot;,</span><br><span class="line">      &quot;source&quot;: &#123;</span><br><span class="line">        &quot;server.port&quot;: 0,</span><br><span class="line">        &quot;eureka.client.service-url.defaultZone&quot;:</span><br><span class="line">     &quot;http://eureka1:8761/eureka/&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前对Config Server的请求不同，这个响应的propertySources属性中有了内容。具体来讲，它包含了一个属性源，属性源的name属性指向了Git仓库的引用，source则包含了我们推送至Git仓库中的属性。</p>
<h2 id="从Git子路径下提供配置"><a href="#从Git子路径下提供配置" class="headerlink" title="从Git子路径下提供配置"></a>从Git子路径下提供配置</h2><p>按照代码的组织风格，你可能想要将配置信息存储到Git仓库的子目录下，而不是放到根路径下。例如，我们想要将配置放到相对于Git仓库根目录名为“config”的子目录下，就可以按照如下方式设置spring.cloud.config.server.git.search-paths属性，让Config Server不再从根目录而是从“&#x2F;config”目录下提供配置信息：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config</span></span><br></pre></td></tr></table></figure>

<p>注意，spring.cloud.config.server.git.search-paths属性是一个复数形式，这意味着我们可以让Config Server提供来自多个路径的配置，只需将它们列出来以逗号分隔即可：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config,moreConfig</span></span><br></pre></td></tr></table></figure>

<p>这样的话，Config Server会提供Git仓库下来自“&#x2F;config”和“&#x2F;moreConfig”路径的配置。</p>
<p>我们还可以使用通配符指定搜索路径：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">search-paths:</span> <span class="string">config,more*</span></span><br></pre></td></tr></table></figure>

<p>这里，Config Server会提供来自“&#x2F;config”和所有以“more”开头的子目录的配置。</p>
<h2 id="从Git分支或标签下提供配置"><a href="#从Git分支或标签下提供配置" class="headerlink" title="从Git分支或标签下提供配置"></a>从Git分支或标签下提供配置</h2><p>默认情况下，Config Server会提供Git中master分支下的配置。在客户端，我们可以将特定分支或标签设置为请求Config Server路径的第三个成员，如图14.2所示。但是，我们可能会发现让Config Server默认请求Git下特定的标签或分支会非常有用，而不是默认使用master。spring.cloud.config.server.git.default-label属性可以重写默认的标签或分支。</p>
<p>例如，考虑如下的配置，它会让Config Server提供名为“sidework”的分支（或标签）下的配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">default-label:</span> <span class="string">sidework</span></span><br></pre></td></tr></table></figure>

<p>按照这个配置形式，除非Config Server客户端指定，否则将会提供“sidework”分支下的配置。</p>
<h2 id="为Git后端提供认证"><a href="#为Git后端提供认证" class="headerlink" title="为Git后端提供认证"></a>为Git后端提供认证</h2><p>Config Server检索配置信息的后端Git仓库很可能会使用用户名和密码进行保护。如果是这样，我们就必须为Config Server提供Git仓库的凭证信息。</p>
<p>spring.cloud.config.server.username和spring.cloud.config.server.password属性可以为后端仓库设置用户名和密码。如下的Config Server配置将设置这些属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:10080/tacocloud/tacocloud-config</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">tacocloud</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">s3cr3tP455w0rd</span></span><br></pre></td></tr></table></figure>

<p>在这里，分别将用户名和密码设置成了tacocloud和s3cr3tP455w0rd。</p>
<p>使用curl作为Config Server的客户端能够帮助我们体验一下Config Server是怎样运行的。实际上，Config Server所能做的远远不止于此。但是，我们所编写的微服务并不会使用curl来获取配置数据。所以在查看Config Server提供配置的其他方式之前，我们将关注点转移到微服务上，看一下如何将它们变成Config Server的客户端。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/fba1438e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/fba1438e/" class="post-title-link" itemprop="url">14.1 共享配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 15:48:04 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T15:48:04+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/fba1438e/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/fba1438e/" data-xid="/JavaReadingNotes/fba1438e/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="14-1-共享配置"><a href="#14-1-共享配置" class="headerlink" title="14.1 共享配置"></a>14.1 共享配置</h1><p>就像我们在第5章所看到的那样，我们可以通过多种属性源设置属性来对Spring应用进行配置。如果某个配置属性可能会更改或者只针对运行时环境有效，那么Java系统属性或操作系统环境变量是一个合适的可选方案。对于不太可能发生变化或者应用特定的属性，将它们放到application.yml或application.properties中，随着打包的应用一起部署是一种很好的方案。</p>
<p>这些方案对于简单的应用来说都很不错。但是，当在环境变量或Java系统属性中设置配置属性的时候，我们必须要接受这样一个现实，那就是修改这些属性需要应用重启。如果我们选择将属性打包到要部署的JAR或WAR文件中，那么在属性变更时，我们必须要完全重新构建和重新部署应用。如果我们想要回滚配置变更，那么同样的约束依然有效。</p>
<p>这些约束在有些应用程序中是可以接受的。但是，在有些情况下，如果仅仅是为了修改一个属性就重启应用，往好了说是不太方便，往坏了说则具有破坏性。除此之外，在基于微服务架构的应用中，属性管理会跨越多个代码库和部署实例，因此将相同变更用到应用中多个服务的每个实例中是不现实的。</p>
<p>有些属性是敏感的，比如数据库密码和其他类型的私密信息。尽管这些值作为应用的属性在写入的时候可以进行加密，但是应用在使用它们之前必须要先解密。即便如此，有些属性甚至可能需要对应用开发人员保密。这样的话，将它们设置成环境变量或者将它们与应用的其他代码一起通过源码控制系统进行管理就是不可取的了。</p>
<p>相反，我们可以考虑一下这些场景在集中式的配置管理下会是什么样子。</p>
<ul>
<li>配置不再需要和应用程序代码一起打包和部署。这样的话，配置的变更或回滚就都不需要重新构建和重新部署应用了。配置甚至可以在运行时进行变更，无须重新启动应用。</li>
<li>共享通用配置的微服务不需要管理自己的属性设置副本，并且能够管理共享的相同属性。如果需要对属性进行变更，那么这些变更只需在一个地方执行一次就可以应用到所有的微服务上。</li>
<li>敏感配置可以进行加密，并且能够与应用代码分开进行维护。应用可以按需获取未加密的值，而不需要应用程序提供解密信息相关的代码。</li>
</ul>
<p>Spring Cloud Config Server提供了中心化的配置功能，应用中的所有微服务均可以依赖该服务器来获取配置。因为它是中心化的，所以是一个一站式的配置商店，所有的服务都可以使用它，另外它还能够为特定服务提供专门的配置。</p>
<p>使用Config Server的第一步就是创建并运行该服务器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/dc8a54a4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/dc8a54a4/" class="post-title-link" itemprop="url">14.0 第14章 管理配置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 15:46:56 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T15:46:56+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC14%E7%AB%A0-%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE/" itemprop="url" rel="index"><span itemprop="name">第14章 管理配置</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/dc8a54a4/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/dc8a54a4/" data-xid="/JavaReadingNotes/dc8a54a4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>677</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第14章-管理配置"><a href="#第14章-管理配置" class="headerlink" title="第14章 管理配置"></a>第14章 管理配置</h1><div style="border:1px solid;"><strong>本章内容：</strong><ul><li>运行Spring Cloud Config Server</li><li>创建Config Server的客户端</li><li>存储敏感配置</li><li>自动化刷新配置</li></ul></div>

<p>买过房子或汽车的人可能都会面临厚厚的一叠纸。购买大宗商品时要签署的合同往往会对无纸化社会的承诺不屑一顾。每当我与汽车经销商或代理人坐到一起的时候，都感觉我应该提前准备好一叠绷带，为这个过程中几乎总能出现的纸划伤手的情况做好准备。</p>
<p>近年来，尽管我必须要签署的总页数几乎没有什么变化，但是我不必像以前那样填写那么多的字段了。对于表格中那些曾经手动填写的地方，现代化的表格在打印之前通常就基于收集到的数据预先填充好了。这样的话，不但会加快处理速度，而且能够减少在多个表格间手动填写重复数据所导致的错误。</p>
<p>与之类似，很多应用程序都存在某种形式的配置。在第5章中，我们讨论了通过配置属性来设置Spring Boot应用。通常，我们设置的属性是该应用特有的，所以可以通过application.properties或application.yml文件声明这些属性，并将它们打包到应用的部署文件中。</p>
<p>按照微服务的方式来组织架构的话，多个服务之间的配置属性是通用的。就像手工填写带有重复数据的表单非常乏味而且易于出错一样，跨多个应用服务重复进行配置可能也会存在问题。</p>
<p>在本章中，我们将会研究Spring Cloud的Config Server，这是为指定应用中所有服务提供集中式配置的一个服务。借助配置服务器，我们可以在一个地方管理所有的应用配置，避免任何重复。</p>
<p>但是在开始之前，我们简单思考一下单独配置微服务的问题，以及中心化的配置为何能够更好。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/c7377a44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/c7377a44/" class="post-title-link" itemprop="url">13.4 小结_第13章 注册和发现服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 15:43:49 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T15:43:49+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/c7377a44/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/c7377a44/" data-xid="/JavaReadingNotes/c7377a44/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>261</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-4-小结"><a href="#13-4-小结" class="headerlink" title="13.4 小结"></a>13.4 小结</h1><ul>
<li>借助自动配置和<code>@EnableEurekaServer</code>注解，Spring Cloud Netflix能够让我们很容易地创建Netflix Eureka服务注册中心。</li>
<li>微服务可以使用名字将它们自身注册到Eureka中，这样可以被其他服务发现。</li>
<li>在客户端，作为客户端负载均衡器，Ribbon能够根据名称查找服务并选择实例。</li>
<li>客户端代码可以使用RestTemplate，利用Ribbon进行负载均衡；也可以将REST客户端定义为接口，由Feign在运行期自动实现。</li>
<li>不管采用哪种方案，客户端代码都不需要硬编码它们所消费的服务的地址。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/91bd6a00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/91bd6a00/" class="post-title-link" itemprop="url">13.3 注册和发现服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:58" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:58+08:00">2021-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-21 18:13:34" itemprop="dateModified" datetime="2021-10-21T18:13:34+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/91bd6a00/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/91bd6a00/" data-xid="/JavaReadingNotes/91bd6a00/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-3-注册和发现服务"><a href="#13-3-注册和发现服务" class="headerlink" title="13.3 注册和发现服务"></a>13.3 注册和发现服务</h1><p>没有服务注册的话，Eureka服务注册中心没有任何用处。如果你的服务想要被其他服务发现和消费，就需要将它们作为服务注册中心的客户端。为了让应用（任何应用，但很可能是微服务）成为服务注册中心的客户端，我们至少需要将Eureka客户端依赖添加到服务应用的构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与Eureka服务器starter依赖类似，我们还需要为Spring Cloud的依赖管理设置Spring Cloud的版本属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以手动添加这些条目到服务应用的pom.xml文件中，但是更简单的方式是在Spring Initializr的复选框中选中Eureka Discovery依赖。</p>
<p>Eureka client starter依赖会添加通过Eureka发现服务所需的所有内容，包括Eureka的客户端库以及Ribbon负载均衡器。我们只需要将这个依赖添加进来，就能将应用变成Eureka服务注册中心的客户端。当应用启动的时候，它会尝试联系在本地运行并且端口为8761的Eureka服务器，并将自身基于UNKNOWN名称进行注册。</p>
<h2 id="13-3-1-配置Eureka客户端属性"><a href="#13-3-1-配置Eureka客户端属性" class="headerlink" title="13.3.1 配置Eureka客户端属性"></a>13.3.1 配置Eureka客户端属性</h2><p>对于开发阶段来说，默认位置的Eureka服务器是可以接受的，如果我们要将服务部署到localhost之外，就需要覆盖它的值。另外，默认的服务名为UNKNOWN，这是一个非常糟糕的选择……但是，坦白来讲，任何形式的默认方案都会很糟糕，因为如果采用默认方案，那么所有服务都会具有相同的名称。</p>
<p>更改服务在Eureka中的注册名称非常简单，我们只需要设置spring.application.name属性就可以了。例如，如果想要注册一个处理taco配料相关操作的服务，那么我们可以将其注册为ingredient-service。在application.yml中，将会如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ingredient-service</span></span><br></pre></td></tr></table></figure>

<p>设置完这个属性之后，我们就可以按照ingredient-service名称来查找服务了。另外，如果我们为配料服务添加多个实例，它们就会以相同的名称出现在注册中心，实际上，服务会扩展到多个实例，并假定它们是完全相同的，服务的消费者可以从中选择。此时，我们查看Eureka dashboard的话，服务将会如图13.5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211021153854.png" alt="image-20211021153847278"></p>
<center>图13.5 Eureka dashboard上的配料服务</center>

<p>在继续使用Spring Cloud的过程中，你会发现spring.application.name是我们要设置的最重要的属性之一。它决定了Eureka中的注册名。在第14章中我们将会看到，这个属性会帮助配置服务识别该应用，用来管理特定应用的配置。其他的Spring Cloud项目，如Spring Cloud Task（短暂存活的微服务）和Spring CloudSleuth（分布式跟踪），同样依赖spring.application.name属性来识别服务。</p>
<p>正如我们在第1章所学到的，默认情况下，所有的Spring MVC和Spring WebFlux应用都会监听8080端口。因为这些服务现在只会通过Eureka进行查找，所以它们监听什么端口也就无所谓了，Eureka能够知道它们使用的是什么端口。为了避免本地运行时潜在的端口冲突，我们可以将端口设置为0：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<div style="border:1px solid;">注意：将端口设置成0的话，应用会选择任意一个可用端口来启动。</div>

<p>现在，我们要考虑Eureka服务器的位置。默认情况下，Eureka客户端会假定Eureka服务器在本地运行（8761端口）。对于开发期来说，这种方式很不错，但是在生产环境中，大多数情况并非如此。因此，我们需要指定Eureka服务器的位置。这与Eureka服务器本身的实现方式完全相同，都是要使用eureka.client.service-url属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">service-url:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://eureka1.tacocloud.com:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>通过这样的配置，客户端会使用eureka1.tacocloud.com主机（端口8761）上的Eureka服务器进行注册。只要Eureka服务器在运行，这种方式就是没有问题的，但是一旦Eureka服务器因为某种原因而停机，服务注册就会失败。为了避免注册失败，最好是为服务配置两个或更多的Eureka实例：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">service-url:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://eureka1.tacocloud.com:8761/eureka/,</span></span><br><span class="line">                  <span class="string">http://eureka2.tacocloud.com:8762/eureka/</span></span><br></pre></td></tr></table></figure>

<p>当服务启动的时候，它会尝试使用zone中的第一个服务器进行注册。如果因为某种原因失败，它将会使用列表中的下一个服务器来进行注册。最终，如果出现故障的服务器重新恢复在线状态，它将会从对等的端上复制注册信息，这样就能将该服务的注册条目包含进来。</p>
<p>在Eureka中注册服务只完成整个任务的一半。服务在Eureka注册之后，其他的服务就可以发现和消费它们了。接下来，我们看一下如何消费Eureka中注册的服务。</p>
<h2 id="13-3-2-消费服务"><a href="#13-3-2-消费服务" class="headerlink" title="13.3.2 消费服务"></a>13.3.2 消费服务</h2><p>在消费者代码中，硬编码任何服务实例的URL都是错误的做法。这不仅会让消费者与服务的特定实例耦合在一起，而且一旦服务的主机和&#x2F;或端口改变，消费者就会出问题。</p>
<p>对于消费者应用来说，在从Eureka中查找服务时，它要承担很多责任。Eureka可能会基于查找结果返回同一个服务的多个实例。如果消费者请求ingredient-service服务时得到了多个服务实例，那么它该如何选择正确的服务呢？</p>
<p>好消息是消费者应用根本不需要从中进行选择，甚至都不需要自己显式地进行服务查找。借助Spring Cloud的Eureka客户端支持和Ribbon客户端负载均衡器，我们可以很容易地查找、选择和消费服务实例。我们有两种方式可以消费从Eureka中查找到的服务：</p>
<ul>
<li>支持负载均衡的RestTemplate；</li>
<li>Feign生成的客户端接口。</li>
</ul>
<p>选择哪种方式在很大程度上取决于个人喜好。下面我们将会看一下这两种方案（首先会介绍支持负载均衡的RestTemplate），然后你就可以从中选择最喜欢的方式了。</p>
<h3 id="使用RestTemplate消费服务"><a href="#使用RestTemplate消费服务" class="headerlink" title="使用RestTemplate消费服务"></a>使用RestTemplate消费服务</h3><p>你对Spring RestTemplate客户端的第一印象可能来源于第7章。我们快速回忆一下它的运行原理，在创建或注入RestTemplate之后，我们就可以发送HTTP调用并将响应绑定到领域类型上。例如，为了发送根据ID获取配料的HTTP GET请求，我们可以使用如下的RestTemplate代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">getIngredientById</span><span class="params">(String ingredientId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> rest.getForObject(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">                           Ingredient.class, ingredientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，唯一的问题在于getForObject()的URL硬编码了特定的主机和端口。我想，你可能会将细节信息提取到一个属性中，但是如果我们将请求的目的地设置成配料服务众多实例中的某一个，那么我们所配置的URL会始终都指向同一个特定实例，这样就没有负载均衡器将请求分散到多个服务实例中了。</p>
<p>如果我们将应用变成Eureka客户端，就可以声明支持负载均衡的RestTemplatebean了。我们需要做的就是声明一个常规的RestTemplate bean，并为带有<code>@Bean</code>注解的方法再添加上<code>@LoadBalanced</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@LoadBalanced</code>注解有两个目的。首先，也是最重要的，它会告诉SpringCloud，这个RestTemplate要能够通过Ribbon来查找服务。其次，它会作为一个注入限定符（qualifier），所以有两个或更多RestTemplate bean的话，我们可以在注入的地方声明此处想要支持负载均衡的RestTemplate。</p>
<p>例如，就像上面的代码那样，我们想要使用支持负载均衡的RestTemplate来查找配料。首先，我们将支持负载均衡的RestTemplate注入需要它的bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IngredientServiceClient</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> RestTemplate rest;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IngredientServiceClient</span><span class="params">(<span class="meta">@LoadBalanced</span> RestTemplate rest)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.rest = rest;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后，我们稍微修改一下getIngredientById()方法，使用服务的注册名，而不再明确使用主机和端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Ingredient <span class="title function_">getIngredientById</span><span class="params">(String ingredientId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> rest.getForObject(</span><br><span class="line">              <span class="string">&quot;http://ingredient-service/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">              Ingredient.class, ingredientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现区别了吗？getForObject()的URL不再使用特定的主机名或端口。在主机名和端口的位置上，我们使用了服务名ingredient-service。在内部, RestTemplate会要求Ribbon根据名称查找服务并从中选择一个实例。Ribbon非常乐于效力，它会将URL重写为选定服务实例的主机和端口，然后让RestTemplate像以往那样进行处理。</p>
<p>我们可以看到，使用支持负载均衡的RestTemplate与标准RestTemplate并没有太大的差异。关键的不同点在于客户端需要使用服务名，而不是显式的主机名和端口。如果你想使用WebClient来替代RestTemplate该怎么办呢？WebClient也能够和Ribbon组合使用根据名称来消费服务吗？</p>
<h3 id="使用WebClient消费服务"><a href="#使用WebClient消费服务" class="headerlink" title="使用WebClient消费服务"></a>使用WebClient消费服务</h3><p>在第11章中，我们看到WebClient提供了与RestTemplate类似的HTTP客户端，但是它使用的是像Flux和Mono这样的反应式类型。如果你曾经被反应式编程的bug所困扰，那么你可能倾向于直接使用WebClient，而不是使用RestTemplate。好消息是，我们可以按照与RestTemplate类似的方式将WebClient作为支持负载均衡的客户端。我们需要做的第一件事就是声明一个返回WebClient.Builder bean的方法，该方法要添加<code>@LoadBalanced</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> WebClient.Builder <span class="title function_">webClientBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明完WebClient.Builder之后，我们就可以将支持负载均衡的WebClient.Builder注入任何需要它的地方。例如，我们可以将它注入IngredientServiceClient的构造器中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IngredientServiceClient</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> WebClient.Builder wcBuilder;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IngredientServiceClient</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="meta">@LoadBalanced</span> WebClient.Builder webclientBuilder wcBuilder)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.wcBuilder = wcBuilder;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在我们需要使用它的时候，可以利用WebClient.Builder构建一个WebClient，然后就能够使用Eureka注册的服务名来发送请求了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Mono&lt;Ingredient&gt; <span class="title function_">getIngredientById</span><span class="params">(String ingredientId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> wcBuilder.build()</span><br><span class="line">    .get()</span><br><span class="line">      .uri(<span class="string">&quot;http://ingredient-service/ingredients/&#123;id&#125;&quot;</span>, ingredientId)</span><br><span class="line">    .retrieve().bodyToMono(Ingredient.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与支持负载均衡的RestTemplate类似，在发送请求的时候，这里不需要明确指定主机和端口。系统会从给定的URL中抽取出服务名，通过这个名称在Eureka中查询服务。Ribbon会选择服务的一个实例，在真正发送请求之前，会根据所选实例的主机和端口重写URL。</p>
<p>这种编程模型非常容易掌握，若你已经熟悉RestTemplate或WebClient则更是如此。Spring Cloud还有一个技巧，接下来我们看一下如何使用Feign创建基于接口的服务客户端。</p>
<h3 id="定义Feign客户端接口"><a href="#定义Feign客户端接口" class="headerlink" title="定义Feign客户端接口"></a>定义Feign客户端接口</h3><p>Feign是一个REST客户端库，使用一种特殊的、接口驱动的方式来定义REST客户端。简而言之，如果你喜欢Spring Data自动实现repository接口的方式，那么你肯定会喜欢Feign的。</p>
<p>Feign最初是Netflix的一个项目，后来变成了独立的开源项目，名为OpenFeign。单词feign的意思是“伪装”，稍后我们将会看到对于假装成REST客户端的项目，这是一个很合适的名称。</p>
<p>要使用Feign，我们首先需要将依赖添加到项目的构建文件中。在pom.xml文件中，如下的<code>&lt;dependency&gt;</code>就可以完成该任务：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在使用Spring Initializr的时候，我们可以通过选中Feign复选框自动添加该starter依赖。令人遗憾的是，目前不会根据已有的依赖启用自动配置功能。所以，我们需要将<code>@EnableFeignClients</code>添加到某个配置类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> RestClientConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，到了有意思的部分。假设我们想要通过注册在Eureka中名为ingredient-service的服务获取一个Ingredient，需要做的就是定义如下的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.ingredientclient.feign;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> tacos.ingredientclient.Ingredient;</span><br><span class="line"><span class="meta">@FeignClient(&quot;ingredient-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IngredientClient</span> &#123;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/ingredients/&#123;id&#125;&quot;)</span></span><br><span class="line">  Ingredient <span class="title function_">getIngredient</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简单的接口，并没有实现类。在运行期，当Feign发现它的时候，这一切就都不重要了，Feign会自动创建一个实现类并将其暴露为Spring应用上下文中的bean。</p>
<p>仔细观察一下，我们会发现其中有一些注解在发挥作用，并将所有功能组合在了一起。接口上的@FeignClient注解会指定该接口上的所有方法都会对名为ingredient-service的服务发送请求。在内部，服务将会通过Ribbon进行查找，这与支持负载均衡的RestTemplate运行方式是一样的。</p>
<p>随后就是getIngredient()方法，它使用了@GetMapping注解。你会发现，这个注解来源于Spring MVC。确实，就是同一个注解。现在它用在了客户端，而不是用在控制器上。它表明，任何对getIngredient()的调用都会对“&#x2F;ingredients&#x2F;{id}”路径发起GET请求，其中的主机和端口是通过Ribbon选定的。@PathVariable注解同样来自Spring MVC，会将方法参数映射到给定路径的占位符上。</p>
<p>现在，我们需要做的就是将Feign实现的接口注入需要的地方并开始使用它。例如，要在控制器中使用它，我们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ingredients&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IngredientController</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> IngredientClient client;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">IngredientController</span><span class="params">(IngredientClient client)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">ingredientDetailPage</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id,</span></span><br><span class="line"><span class="params">                                     Model model)</span> &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;ingredient&quot;</span>, client.getIngredient(id));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ingredientDetail&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我不知道你的观点如何，但是我觉得这非常流畅！很难说我最喜欢哪种方式：支持负载均衡的RestTemplate、WebClient，还是具有魔力的Feign客户端接口。不管选择哪种方式，我们的REST客户端都能根据名称消费在Eureka注册的服务，避免硬编码特定的主机名和端口。</p>
<p>值得一提的是，Feign提供了自己的注解。@RequestLine和@Param非常类似于Spring MVC中的@RequestMapping和@PathVariable，但是它们的使用方式略有差异。能够在客户端使用我们已经非常熟悉的Spring MVC注解是非常棒的，而且它们很可能与我们在定义服务控制器时所使用的注解是一样的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/949eb7b7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/949eb7b7/" class="post-title-link" itemprop="url">第4部分 云原生Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:57" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:57+08:00">2021-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-22 13:37:58" itemprop="dateModified" datetime="2021-10-22T13:37:58+08:00">2021-10-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/949eb7b7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/949eb7b7/" data-xid="/JavaReadingNotes/949eb7b7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>257</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第4部分-云原生Spring"><a href="#第4部分-云原生Spring" class="headerlink" title="第4部分 云原生Spring"></a>第4部分 云原生Spring</h1><p>第4部分将会拆分单体应用模型，我们会介绍Spring Cloud和微服务的开发。在第13章中，简单介绍微服务之后，我们将会深入介绍服务发现，这里会使用Spring和Netflix的Eureka服务注册中心实现基于Spring的微服务的注册和发现。第14章通过Spring Cloud的Config Server探讨中心化的配置，Config Server服务能够为应用中的所有微服务提供中心化的配置。在第15章中，我们将会借助NetflixHystrix实现断路器模式，让服务面对失败时更具弹性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8126bbbc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8126bbbc/" class="post-title-link" itemprop="url">13.1 思考微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:57" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:57+08:00">2021-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-21 18:13:34" itemprop="dateModified" datetime="2021-10-21T18:13:34+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8126bbbc/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8126bbbc/" data-xid="/JavaReadingNotes/8126bbbc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-1-思考微服务"><a href="#13-1-思考微服务" class="headerlink" title="13.1 思考微服务"></a>13.1 思考微服务</h1><p>到目前为止，我们都是将Taco Cloud开发为单个应用程序，它会构建为一个可部署的JAR或WAR。单个可部署的文件似乎是一种很自然的选择。毕竟，几十年来，大多数的应用程序都是这样部署的。即便可能会将应用程序拆分为多个模块进行构建，但最终我们还是形成一个JAR或WAR，并将其投入到生产环境之中。</p>
<p>在构建小型、简单应用程序的时候，这当然是显而易见的方式。有意思的是，小型应用程序往往会不断增长。当需要新特性的时候，我们能够轻而易举地向项目中添加更多的代码。在我们发觉之前，它已经变成了一个复杂的单体应用，甚至有自己的思想。就像电影《小鬼怪》（Gremlins）里的Mogwai一样，如果你一直喂它，它最终会变成一个与你作对的怪物<a href="%E6%98%AF%E7%9A%84%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%83%A8%E7%94%B5%E5%BD%B1%E4%B8%AD%EF%BC%8C%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%E5%96%82Mogwai%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8D%88%E5%A4%9C%E6%97%B6%E5%88%86%E3%80%82%E6%B2%A1%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%AF%94%E6%98%AF%E5%AE%8C%E7%BE%8E%E7%9A%84%E3%80%82">^1</a>。</p>
<p>单体应用看似简单，但是它会面临各种挑战，如下所示。</p>
<ul>
<li>单体应用难以理解：代码库越大，理解每个组件在整个应用程序中所担任的角色就越困难。</li>
<li>单体应用难以测试：随着应用的不断增长，全面的集成和验收测试会变得更加复杂。</li>
<li>单体应用更容易出现库冲突：实现某个特性所需要的依赖可能会与其他特定的依赖不兼容。</li>
<li>单体应用的扩展较为低效：如果处于扩展的目的要将应用程序部署到更多的硬件上，那么我们必须要将整个应用部署到更多的服务器上，即便应用程序中很小的一部分需要扩展也同样如此。</li>
<li>单体应用中的技术决策是针对整个单体应用的：当为应用程序选择语言、运行时平台、框架和库的时候，整个应用程序都会遵循我们的选择，即便我们所做的选择只是为了支持某个单独的用户场景时同样如此。</li>
<li>单体应用需要大量的操作过程才能投入生产环境：当应用程序只有一个部署单元时，似乎更容易将其投入生产环境。事实上并非如此，单体应用程序的规模和复杂性通常需要更严格的开发过程和更周全的测试周期，这样才能保证所部署的应用程序是高质量的，才能避免引入bug。</li>
</ul>
<p>在过去的几年间，微服务架构的出现致力于解决这些挑战。简而言之，微服务架构是将应用程序分解为可独立开发和部署的小规模、微型应用的一种方式。这些微服务之间互相协作，以实现更大的应用程序的功能。与单体应用程序架构相比，微服务架构有以下特点。</p>
<ul>
<li>微服务易于理解：每个微服务与应用程序的其他微服务之间有一个很小且有限的契约。因此，微服务更加专注于目标，作为一个单元，微服务更易于理解。</li>
<li>微服务易于测试：事情越小，就越便于测试。当你思考单元测试、集成测试和验收测试的时候，这一点非常明显。它也适用于微服务与单体应用之间的测试。</li>
<li>微服务较少受到库不兼容的影响：因为每个微服务都有自己的构建依赖项的集合，而这些依赖项不会与其他的微服务共享，所以不太可能会出现库冲突的现象。</li>
<li>微服务能够独立扩展：如果指定的微服务需要更多的处理能力，那么内存分配和&#x2F;或实例数量可以按比例增加，而不会影响整体应用中其他微服务的内存和实例数量。</li>
<li>每个微服务可以选择不同的技术：每个微服务可以选择完全不同的语言、平台、框架和库。实际上，某个使用Java编写的微服务与另一个使用C#编写的微服务进行协作是完全合理的[^2]。</li>
<li>微服务可以更加频繁地发布到生产环境中：尽管微服务架构的应用是由许多微服务组成的，但是部署每个微服务的时候，并不需要其他的微服务都已经部署就绪。而且，因为它们更小、更集中、更易于测试，所以将微服务投入到生产环境不需要那么多的繁文缛节。从产生想法到将其投入生产的耗时可以用分钟和小时计量，而不是用周和月。</li>
</ul>
<p>显然，微服务能够让事情变得更简单。但是公平地讲，微服务架构并不是免费的午餐。微服务架构是一种分布式架构，有自己需要应对的挑战，包括网络延迟。在迁移至微服务架构时，我们需要记住这一点，因为很多的远程调用会累积并降低应用的速度。</p>
<p>你还要考虑是否应该将应用构建为微服务，因为并不是所有的应用程序都需要这种架构，或者说能从这种架构中受益。如果你的应用相对比较小或者比较简单，那么最初最好依然采用单体架构。随着它的不断发展，再考虑将其拆分为微服务。</p>
<p>在开发云原生、微服务架构的应用时，要考虑很多因素。本章和接下来的几章主要关注Spring Cloud所提供的技术，以开发由微服务组成的应用程序。如果你对深入研究云原生应用程序的设计和思想过程感兴趣，那么建议阅读Cornelia Davis的Cloud Native（Manning，2019）。</p>
<p>微服务架构所面临的另外一个常见挑战就是每个服务该如何知道它要协作的其他服务在哪里。这恰好是本章的主题。事不宜迟，我们马上看一下如何使用SpringCloud搭建一个服务注册中心。</p>
<p>[^2]: 在这里，我们会关注如何使用Java和Spring编写微服务。如果你对如何使用.NET编写微服务并与Spring Cloud服务交互感兴趣，那么可以参考一下Steeltoe。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/30/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/30/">30</a><span class="page-number current">31</span><a class="page-number" href="/JavaReadingNotes/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/32/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
  <!--博客朗读功能开始-->
  <script>
const java_generic_descriptor_regexp = new RegExp('\\<[a-zA-Z?& ,]+\\>');
const modifierRegExp = '([a-z]+)';
const returnValueRegExp = '([a-zA-Z0-9<>,&? \\[\\]]+)';
const methodNameRegExp = '([a-zA-Z0-9]+)';
const parameterRegExp = '([a-zA-Z0-9<>,&? ]+)';
const constructorRegExp = '([A-Z][a-zA-Z0-9_]+)';
const constructor_parameterless_regexp = new RegExp('^' + constructorRegExp + '\\(\\)$');
const constructor_parameterless_replace = '$1无参数构造方法';
const constructor_parameter_regexp = new RegExp('^' + constructorRegExp + '\\(' + parameterRegExp + '\\)$');
const constructor_parameter_replace = '$1构造方法，参数列表$2。';
const return_name_parameterless_regexp = new RegExp('^' + returnValueRegExp + ' ' + methodNameRegExp + '\\(\\)$');
const return_name_parameterless_replace = '$2方法，无参数，返回值$1。';
const modifier_return_name_parameterless_regexp = new RegExp('^' + modifierRegExp + ' ' + returnValueRegExp + ' ' + methodNameRegExp + '\\(\\)$');
const modifier_return_name_parameterless_replace = '$3方法，无参数，返回值$2，修饰符$1。';
const return_name_parameter_regexp = new RegExp('^' + returnValueRegExp + ' ' + methodNameRegExp + '\\(' + parameterRegExp + '\\)' + '$');
const return_name_parameter_replace = '$2方法，参数列表：$3，返回值：$1。';
const modifier_return_name_parameter_regexp = new RegExp('^' + modifierRegExp + ' ' + returnValueRegExp + ' ' + methodNameRegExp + '\\(' + parameterRegExp + '\\)' + '$');
const modifier_return_name_parameter_replace = '$3方法，参数列表：$4，返回值：$2，修饰符：$1。';
function fixTuoFengSplit(javaMethodCode, code) {
    var wrongCode = code.replace(/(?<=[A-Z])(?=[A-Z])/g, " ");
    if (javaMethodCode.search(wrongCode) > -1) {
        javaMethodCode = javaMethodCode.replaceAll(wrongCode, code);
    }
    return javaMethodCode;
}
function javaTuoFengLangDu(javaMethodCode) {
    javaMethodCode = javaMethodCode.replace(/(?<=[a-zA-Z])(?=[A-Z])/g, " ");
    var wrongSplit = ['UNIX', 'WEST', 'NORTH', 'SOUTH', 'EAST', 'RIGHT', 'CENTER', 'LEFT', 'CLASSPATH', 'PATH'];
    wrongSplit = wrongSplit.sort(function (a, b) {
        return b.length - a.length;
    })
    for (var i = 0, len = wrongSplit.length; i < len; i++) {
        javaMethodCode = fixTuoFengSplit(javaMethodCode, wrongSplit[i]);
    }
    return javaMethodCode;
}
function readPunctuation(text) {
    text = text.replaceAll("<", "");
    text = text.replaceAll(">", "");
    text = text.replaceAll(".", "点");
    text = text.replaceAll(":", "冒号");
    text = text.replaceAll("?", "问号");
    return text.replaceAll("**", "");
}
function readKeywords(text) {
    text = text.replaceAll("instanceof", "instance of");
    text = text.replaceAll("C#", "C sharp");
    text = text.replaceAll("javac", "java c");
    return text;
}
function remove_colon_Period_AtTheEndOfTheLine(text) {
    if (text.endsWith(".") || text.endsWith(":")) {
        text = text.substring(0, text.length - 1);
    }
    return text;
}
function readJavaStaticConstants(text) {
    const regexp = /(\.[A-Z_]+)/g;
    const matches = text.matchAll(regexp);
    for (const match of matches) {
        const goup1 = RegExp.$1;
        const goup1Lower = goup1.toLowerCase();
        text = text.replace(goup1, goup1Lower);
    }
    return text;
}
function removeReadingBtnTag(text) {
    text = text.replace(/\n朗读\n/g, '');
    text = text.replace(/^\d+$\n/mg, '');
    text = text.replace(/朗读$/mg, '');
    return text;
}
function preprocessingText(text) {
    text = remove_colon_Period_AtTheEndOfTheLine(text);
    text = readJavaStaticConstants(text);
    text = readPunctuation(text);
    text = readKeywords(text);
    text = javaTuoFengLangDu(text);
    text = removeReadingBtnTag(text);
    return text;
}
function methondReading(text) {
    while (java_generic_descriptor_regexp.test(text)) {
        text = text.replace(java_generic_descriptor_regexp, '');
    }
    console.log("     删除泛型后：" + text);
    text = text.replace('[]', '数组');
    text = text.replace(/\, ?/g, " 和 ");
    text = text.replace(/([a-zA-Z<>]+) ([a-zA-Z]+)/g, "$1类型的参数$2")
    text = javaTuoFengLangDu(text);
    return text;
}
function speak(text, parentElement) {
    const to_speak = new window.SpeechSynthesisUtterance();
    to_speak.text = text;
    to_speak.rate = 7.0;
    const oldColor = parentElement.style.backgroundColor;
    window.speechSynthesis.speak(to_speak);
    parentElement.style.backgroundColor = 'LightCyan';
    to_speak.onstart = function () {
        parentElement.style.backgroundColor = 'LightSkyBlue';
        parentElement.scrollIntoView({
            behavior: "smooth"
        });
    }
    to_speak.onend = function () {
        parentElement.style.backgroundColor = oldColor;
    }
}
function isMethod(text) {
    const modifierCode = 2;
    const returnCode = 3;
    const methodNameCode = 5;
    const parameterCode = 7;
    const constructorCode = 11;
    if (modifier_return_name_parameter_regexp.test(text)) {
        return modifierCode * returnCode * methodNameCode * parameterCode;
    }
    else if (return_name_parameter_regexp.test(text)) {
        return returnCode * methodNameCode * parameterCode;
    } else if (modifier_return_name_parameterless_regexp.test(text)) {
        return modifierCode * returnCode * methodNameCode;
    }
    else if (return_name_parameterless_regexp.test(text)) {
        return returnCode * methodNameCode;
    }
    else if (constructor_parameter_regexp.test(text)) {
        return constructorCode * methodNameCode;
    }
    else if (constructor_parameterless_regexp.test(text)) {
        return constructorCode;
    }
    return -1;
}
function addSpeckBtn(element, number) {
    let i = 0;
    for (; i < element.length; i++) {
        let speakBtn = document.createElement('button');
        speakBtn.innerText = "朗读";
        setButtonStyle(speakBtn);
        speakBtn.id = "speak_btn_" + (i + number);
        speakBtn.className = "speak_btn";
        speakBtn.onclick = function (e) {
            e.target.style.backgroundColor = '#979696';
            const btn = document.getElementById(e.target.id);
            parentElement = btn.parentElement;
            let text = parentElement.innerText;
            text = text.substring(0, text.lastIndexOf(e.target.innerText));
            text = text.replaceAll('​', '');
            console.log(text);
            const methodCode = isMethod(text);
            if (methodCode > 0) {
                console.log("是方法！编号:" + methodCode);
                if (methodCode === 210) {
                    console.log("    修饰符 返回值 方法名 参数列表")
                    text = text.replace(modifier_return_name_parameter_regexp, modifier_return_name_parameter_replace);
                } else if (methodCode === 105) {
                    console.log("    返回值 方法名 参数列表");
                    text = text.replace(return_name_parameter_regexp, return_name_parameter_replace);
                } else if (methodCode === 15) {
                    console.log("    返回值 方法名 没有参数列表")
                    text = text.replace(return_name_parameterless_regexp, return_name_parameterless_replace);
                } else if (methodCode === 30) {
                    console.log("    修饰符 返回值 方法名 没有参数列表");
                    text = text.replace(modifier_return_name_parameterless_regexp, modifier_return_name_parameterless_replace);
                } else if (methodCode === 55) {
                    console.log("    构造器 参数列表");
                    text = text.replace(constructor_parameter_regexp, constructor_parameter_replace);
                } else if (methodCode === 11) {
                    console.log("    构造器 无参数");
                    text = text.replace(constructor_parameterless_regexp, constructor_parameterless_replace);
                }
                text = methondReading(text);
            } else {
                console.log("不是方法")
                text = preprocessingText(text);
            }
            console.log(text + '\n');
            speak(text, parentElement);
        }
        element[i].append(speakBtn);
    }
    return (i + number);
}
function setButtonStyle(button) {
    if (button.innerText.startsWith('朗读')) {
        button.style.fontSize = '12px';
        button.style.backgroundColor = '#008CBA';
    } else {
        button.style.fontSize = '0.8em';
        if (button.innerText == '显示' || button.innerText == '隐藏') {
            button.style.backgroundColor = '#d54b4b';
        } else {
            button.style.backgroundColor = '#25d37c';
        }
        button.style.display = 'block';
    }
    button.style.border = 'none';
    button.style.marginTop = '0.5em';
    button.style.borderRadius = '2px';
}
window.onload = function () {
    const article_div = document.querySelector('body > main > div> div> article');
    const p_ul_ol_h = article_div.querySelectorAll('p:not(.image-caption,:has(img)),div:not(.post-copyright)>ul,div>ol,div>pre,h1:not(.post-title),h2,h3,h4,h5,h6');
    let number = addSpeckBtn(p_ul_ol_h, 0);
    const table_td = article_div.querySelectorAll('div > table tr > th,td:not(.code,.gutter)');
    addSpeckBtn(table_td, number);
    const readAllBtn = document.createElement('button');
    readAllBtn.innerText = "开始";
    setButtonStyle(readAllBtn);
    readAllBtn.onclick = function () {
        const sttButtonS = document.querySelectorAll('button.speak_btn');
        console.log(sttButtonS);
        for (let i = 0; i < sttButtonS.length; i++) {
            sttButtonS[i].click();
        }
    }
    const reloadBtn = document.createElement('button');
    reloadBtn.innerText = "刷新";
    setButtonStyle(reloadBtn);
    reloadBtn.onclick = function () {
        location.reload();
        window.scrollTo(0, 0);
    }
    const pauseBtn = document.createElement('button');
    pauseBtn.innerText = "暂停";
    setButtonStyle(pauseBtn);
    pauseBtn.onclick = function () {
        if (pauseBtn.innerText === "暂停") {
            window.speechSynthesis.pause();
            pauseBtn.innerText = "继续";
        } else if (pauseBtn.innerText === "继续") {
            window.speechSynthesis.resume();
            pauseBtn.innerText = "暂停";
        }
    }
    const readStopBtn = document.createElement('button');
    readStopBtn.innerText = "停止";
    setButtonStyle(readStopBtn);
    readStopBtn.onclick = function () {
        window.speechSynthesis.cancel()
        const sttButtonS = document.querySelectorAll('button.speak_btn');
        for (let i = 0; i < sttButtonS.length; i++) {
            sttButtonS[i].parentElement.style.backgroundColor = '#fff';
        }
    }
    const divTop = document.createElement('div');
    divTop.id = 'blog_reading_control_div';
    divTop.style.position = 'fixed';
    divTop.style.zIndex = '9999';
    divTop.style.textAlign = 'center';
    divTop.style.bottom = '1em';
    divTop.style.left = '0em';
    divTop.style.lineHeight = '1.15';
    const controlDiv = document.createElement('div');
    const showHideBtn = document.createElement('button');
    showHideBtn.innerText = '隐藏';
    showHideBtn.onclick = function (ev) {
        if (showHideBtn.innerText === '隐藏') {
            controlDiv.style.display = 'none';
            showHideBtn.innerText = '显示';
        } else if (showHideBtn.innerText === '显示') {
            controlDiv.style.display = 'block';
            showHideBtn.innerText = '隐藏';
        }
    }
    setButtonStyle(showHideBtn);
    controlDiv.append(reloadBtn);
    controlDiv.append(readAllBtn);
    controlDiv.append(pauseBtn);
    controlDiv.append(readStopBtn);
    divTop.append(controlDiv);
    divTop.append(showHideBtn);
    document.body.appendChild(divTop);
}
  </script>
  <!--博客朗读功能结束-->
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.9m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:42</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/31/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/31/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
