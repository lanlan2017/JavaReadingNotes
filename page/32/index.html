<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/32/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/32/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/32/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-mzjszagu6-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/c7377a44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/c7377a44/" class="post-title-link" itemprop="url">13.4 小结_第13章 注册和发现服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-21 15:43:49 / 修改时间：22:31:45" itemprop="dateCreated datePublished" datetime="2021-10-21T15:43:49+08:00">2021-10-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/c7377a44/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/c7377a44/" data-xid="/JavaReadingNotes/c7377a44/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>261</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-4-小结"><a href="#13-4-小结" class="headerlink" title="13.4 小结"></a>13.4 小结</h1><ul>
<li>借助自动配置和<code>@EnableEurekaServer</code>注解，Spring Cloud Netflix能够让我们很容易地创建Netflix Eureka服务注册中心。</li>
<li>微服务可以使用名字将它们自身注册到Eureka中，这样可以被其他服务发现。</li>
<li>在客户端，作为客户端负载均衡器，Ribbon能够根据名称查找服务并选择实例。</li>
<li>客户端代码可以使用RestTemplate，利用Ribbon进行负载均衡；也可以将REST客户端定义为接口，由Feign在运行期自动实现。</li>
<li>不管采用哪种方案，客户端代码都不需要硬编码它们所消费的服务的地址。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/91bd6a00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/91bd6a00/" class="post-title-link" itemprop="url">13.3 注册和发现服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:58" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:58+08:00">2021-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 18:13:34" itemprop="dateModified" datetime="2021-10-21T18:13:34+08:00">2021-10-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/91bd6a00/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/91bd6a00/" data-xid="/JavaReadingNotes/91bd6a00/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-3-注册和发现服务"><a href="#13-3-注册和发现服务" class="headerlink" title="13.3 注册和发现服务"></a>13.3 注册和发现服务</h1><p>没有服务注册的话，Eureka服务注册中心没有任何用处。如果你的服务想要被其他服务发现和消费，就需要将它们作为服务注册中心的客户端。为了让应用（任何应用，但很可能是微服务）成为服务注册中心的客户端，我们至少需要将Eureka客户端依赖添加到服务应用的构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与Eureka服务器starter依赖类似，我们还需要为Spring Cloud的依赖管理设置Spring Cloud的版本属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以手动添加这些条目到服务应用的pom.xml文件中，但是更简单的方式是在Spring Initializr的复选框中选中Eureka Discovery依赖。</p>
<p>Eureka client starter依赖会添加通过Eureka发现服务所需的所有内容，包括Eureka的客户端库以及Ribbon负载均衡器。我们只需要将这个依赖添加进来，就能将应用变成Eureka服务注册中心的客户端。当应用启动的时候，它会尝试联系在本地运行并且端口为8761的Eureka服务器，并将自身基于UNKNOWN名称进行注册。</p>
<h2 id="13-3-1-配置Eureka客户端属性"><a href="#13-3-1-配置Eureka客户端属性" class="headerlink" title="13.3.1 配置Eureka客户端属性"></a>13.3.1 配置Eureka客户端属性</h2><p>对于开发阶段来说，默认位置的Eureka服务器是可以接受的，如果我们要将服务部署到localhost之外，就需要覆盖它的值。另外，默认的服务名为UNKNOWN，这是一个非常糟糕的选择……但是，坦白来讲，任何形式的默认方案都会很糟糕，因为如果采用默认方案，那么所有服务都会具有相同的名称。</p>
<p>更改服务在Eureka中的注册名称非常简单，我们只需要设置spring.application.name属性就可以了。例如，如果想要注册一个处理taco配料相关操作的服务，那么我们可以将其注册为ingredient-service。在application.yml中，将会如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">ingredient-service</span></span><br></pre></td></tr></table></figure>

<p>设置完这个属性之后，我们就可以按照ingredient-service名称来查找服务了。另外，如果我们为配料服务添加多个实例，它们就会以相同的名称出现在注册中心，实际上，服务会扩展到多个实例，并假定它们是完全相同的，服务的消费者可以从中选择。此时，我们查看Eureka dashboard的话，服务将会如图13.5所示。</p>
<p><img data-src="https://gitee.com/XiaoLan223/images/raw/master/Blog/Sum/20211021153854.png" alt="image-20211021153847278"></p>
<center>图13.5 Eureka dashboard上的配料服务</center>

<p>在继续使用Spring Cloud的过程中，你会发现spring.application.name是我们要设置的最重要的属性之一。它决定了Eureka中的注册名。在第14章中我们将会看到，这个属性会帮助配置服务识别该应用，用来管理特定应用的配置。其他的Spring Cloud项目，如Spring Cloud Task（短暂存活的微服务）和Spring CloudSleuth（分布式跟踪），同样依赖spring.application.name属性来识别服务。</p>
<p>正如我们在第1章所学到的，默认情况下，所有的Spring MVC和Spring WebFlux应用都会监听8080端口。因为这些服务现在只会通过Eureka进行查找，所以它们监听什么端口也就无所谓了，Eureka能够知道它们使用的是什么端口。为了避免本地运行时潜在的端口冲突，我们可以将端口设置为0：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<div style="border:1px solid;">注意：将端口设置成0的话，应用会选择任意一个可用端口来启动。</div>

<p>现在，我们要考虑Eureka服务器的位置。默认情况下，Eureka客户端会假定Eureka服务器在本地运行（8761端口）。对于开发期来说，这种方式很不错，但是在生产环境中，大多数情况并非如此。因此，我们需要指定Eureka服务器的位置。这与Eureka服务器本身的实现方式完全相同，都是要使用eureka.client.service-url属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">service-url:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://eureka1.tacocloud.com:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>通过这样的配置，客户端会使用eureka1.tacocloud.com主机（端口8761）上的Eureka服务器进行注册。只要Eureka服务器在运行，这种方式就是没有问题的，但是一旦Eureka服务器因为某种原因而停机，服务注册就会失败。为了避免注册失败，最好是为服务配置两个或更多的Eureka实例：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"> <span class="attr">client:</span></span><br><span class="line">   <span class="attr">service-url:</span></span><br><span class="line">     <span class="attr">defaultZone:</span> <span class="string">http://eureka1.tacocloud.com:8761/eureka/,</span></span><br><span class="line">                  <span class="string">http://eureka2.tacocloud.com:8762/eureka/</span></span><br></pre></td></tr></table></figure>

<p>当服务启动的时候，它会尝试使用zone中的第一个服务器进行注册。如果因为某种原因失败，它将会使用列表中的下一个服务器来进行注册。最终，如果出现故障的服务器重新恢复在线状态，它将会从对等的端上复制注册信息，这样就能将该服务的注册条目包含进来。</p>
<p>在Eureka中注册服务只完成整个任务的一半。服务在Eureka注册之后，其他的服务就可以发现和消费它们了。接下来，我们看一下如何消费Eureka中注册的服务。</p>
<h2 id="13-3-2-消费服务"><a href="#13-3-2-消费服务" class="headerlink" title="13.3.2 消费服务"></a>13.3.2 消费服务</h2><p>在消费者代码中，硬编码任何服务实例的URL都是错误的做法。这不仅会让消费者与服务的特定实例耦合在一起，而且一旦服务的主机和/或端口改变，消费者就会出问题。</p>
<p>对于消费者应用来说，在从Eureka中查找服务时，它要承担很多责任。Eureka可能会基于查找结果返回同一个服务的多个实例。如果消费者请求ingredient-service服务时得到了多个服务实例，那么它该如何选择正确的服务呢？</p>
<p>好消息是消费者应用根本不需要从中进行选择，甚至都不需要自己显式地进行服务查找。借助Spring Cloud的Eureka客户端支持和Ribbon客户端负载均衡器，我们可以很容易地查找、选择和消费服务实例。我们有两种方式可以消费从Eureka中查找到的服务：</p>
<ul>
<li>支持负载均衡的RestTemplate；</li>
<li>Feign生成的客户端接口。</li>
</ul>
<p>选择哪种方式在很大程度上取决于个人喜好。下面我们将会看一下这两种方案（首先会介绍支持负载均衡的RestTemplate），然后你就可以从中选择最喜欢的方式了。</p>
<h3 id="使用RestTemplate消费服务"><a href="#使用RestTemplate消费服务" class="headerlink" title="使用RestTemplate消费服务"></a>使用RestTemplate消费服务</h3><p>你对Spring RestTemplate客户端的第一印象可能来源于第7章。我们快速回忆一下它的运行原理，在创建或注入RestTemplate之后，我们就可以发送HTTP调用并将响应绑定到领域类型上。例如，为了发送根据ID获取配料的HTTP GET请求，我们可以使用如下的RestTemplate代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rest.getForObject(<span class="string">&quot;http://localhost:8080/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">                           Ingredient.class, ingredientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，唯一的问题在于getForObject()的URL硬编码了特定的主机和端口。我想，你可能会将细节信息提取到一个属性中，但是如果我们将请求的目的地设置成配料服务众多实例中的某一个，那么我们所配置的URL会始终都指向同一个特定实例，这样就没有负载均衡器将请求分散到多个服务实例中了。</p>
<p>如果我们将应用变成Eureka客户端，就可以声明支持负载均衡的RestTemplatebean了。我们需要做的就是声明一个常规的RestTemplate bean，并为带有<code>@Bean</code>注解的方法再添加上<code>@LoadBalanced</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@LoadBalanced</code>注解有两个目的。首先，也是最重要的，它会告诉SpringCloud，这个RestTemplate要能够通过Ribbon来查找服务。其次，它会作为一个注入限定符（qualifier），所以有两个或更多RestTemplate bean的话，我们可以在注入的地方声明此处想要支持负载均衡的RestTemplate。</p>
<p>例如，就像上面的代码那样，我们想要使用支持负载均衡的RestTemplate来查找配料。首先，我们将支持负载均衡的RestTemplate注入需要它的bean中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientServiceClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> RestTemplate rest;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IngredientServiceClient</span><span class="params">(<span class="meta">@LoadBalanced</span> RestTemplate rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.rest = rest;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随后，我们稍微修改一下getIngredientById()方法，使用服务的注册名，而不再明确使用主机和端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Ingredient <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rest.getForObject(</span><br><span class="line">              <span class="string">&quot;http://ingredient-service/ingredients/&#123;id&#125;&quot;</span>,</span><br><span class="line">              Ingredient.class, ingredientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现区别了吗？getForObject()的URL不再使用特定的主机名或端口。在主机名和端口的位置上，我们使用了服务名ingredient-service。在内部, RestTemplate会要求Ribbon根据名称查找服务并从中选择一个实例。Ribbon非常乐于效力，它会将URL重写为选定服务实例的主机和端口，然后让RestTemplate像以往那样进行处理。</p>
<p>我们可以看到，使用支持负载均衡的RestTemplate与标准RestTemplate并没有太大的差异。关键的不同点在于客户端需要使用服务名，而不是显式的主机名和端口。如果你想使用WebClient来替代RestTemplate该怎么办呢？WebClient也能够和Ribbon组合使用根据名称来消费服务吗？</p>
<h3 id="使用WebClient消费服务"><a href="#使用WebClient消费服务" class="headerlink" title="使用WebClient消费服务"></a>使用WebClient消费服务</h3><p>在第11章中，我们看到WebClient提供了与RestTemplate类似的HTTP客户端，但是它使用的是像Flux和Mono这样的反应式类型。如果你曾经被反应式编程的bug所困扰，那么你可能倾向于直接使用WebClient，而不是使用RestTemplate。好消息是，我们可以按照与RestTemplate类似的方式将WebClient作为支持负载均衡的客户端。我们需要做的第一件事就是声明一个返回WebClient.Builder bean的方法，该方法要添加<code>@LoadBalanced</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> WebClient.<span class="function">Builder <span class="title">webClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> WebClient.builder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在声明完WebClient.Builder之后，我们就可以将支持负载均衡的WebClient.Builder注入任何需要它的地方。例如，我们可以将它注入IngredientServiceClient的构造器中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientServiceClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> WebClient.Builder wcBuilder;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IngredientServiceClient</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="meta">@LoadBalanced</span> WebClient.Builder webclientBuilder wcBuilder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.wcBuilder = wcBuilder;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在我们需要使用它的时候，可以利用WebClient.Builder构建一个WebClient，然后就能够使用Eureka注册的服务名来发送请求了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;Ingredient&gt; <span class="title">getIngredientById</span><span class="params">(String ingredientId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wcBuilder.build()</span><br><span class="line">    .get()</span><br><span class="line">      .uri(<span class="string">&quot;http://ingredient-service/ingredients/&#123;id&#125;&quot;</span>, ingredientId)</span><br><span class="line">    .retrieve().bodyToMono(Ingredient.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与支持负载均衡的RestTemplate类似，在发送请求的时候，这里不需要明确指定主机和端口。系统会从给定的URL中抽取出服务名，通过这个名称在Eureka中查询服务。Ribbon会选择服务的一个实例，在真正发送请求之前，会根据所选实例的主机和端口重写URL。</p>
<p>这种编程模型非常容易掌握，若你已经熟悉RestTemplate或WebClient则更是如此。Spring Cloud还有一个技巧，接下来我们看一下如何使用Feign创建基于接口的服务客户端。</p>
<h3 id="定义Feign客户端接口"><a href="#定义Feign客户端接口" class="headerlink" title="定义Feign客户端接口"></a>定义Feign客户端接口</h3><p>Feign是一个REST客户端库，使用一种特殊的、接口驱动的方式来定义REST客户端。简而言之，如果你喜欢Spring Data自动实现repository接口的方式，那么你肯定会喜欢Feign的。</p>
<p>Feign最初是Netflix的一个项目，后来变成了独立的开源项目，名为OpenFeign。单词feign的意思是“伪装”，稍后我们将会看到对于假装成REST客户端的项目，这是一个很合适的名称。</p>
<p>要使用Feign，我们首先需要将依赖添加到项目的构建文件中。在pom.xml文件中，如下的<code>&lt;dependency&gt;</code>就可以完成该任务：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在使用Spring Initializr的时候，我们可以通过选中Feign复选框自动添加该starter依赖。令人遗憾的是，目前不会根据已有的依赖启用自动配置功能。所以，我们需要将<code>@EnableFeignClients</code>添加到某个配置类上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> RestClientConfiguration &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，到了有意思的部分。假设我们想要通过注册在Eureka中名为ingredient-service的服务获取一个Ingredient，需要做的就是定义如下的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.ingredientclient.feign;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> tacos.ingredientclient.Ingredient;</span><br><span class="line"><span class="meta">@FeignClient(&quot;ingredient-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientClient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/ingredients/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">Ingredient <span class="title">getIngredient</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个很简单的接口，并没有实现类。在运行期，当Feign发现它的时候，这一切就都不重要了，Feign会自动创建一个实现类并将其暴露为Spring应用上下文中的bean。</p>
<p>仔细观察一下，我们会发现其中有一些注解在发挥作用，并将所有功能组合在了一起。接口上的@FeignClient注解会指定该接口上的所有方法都会对名为ingredient-service的服务发送请求。在内部，服务将会通过Ribbon进行查找，这与支持负载均衡的RestTemplate运行方式是一样的。</p>
<p>随后就是getIngredient()方法，它使用了@GetMapping注解。你会发现，这个注解来源于Spring MVC。确实，就是同一个注解。现在它用在了客户端，而不是用在控制器上。它表明，任何对getIngredient()的调用都会对“/ingredients/{id}”路径发起GET请求，其中的主机和端口是通过Ribbon选定的。@PathVariable注解同样来自Spring MVC，会将方法参数映射到给定路径的占位符上。</p>
<p>现在，我们需要做的就是将Feign实现的接口注入需要的地方并开始使用它。例如，要在控制器中使用它，我们可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/ingredients&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> IngredientClient client;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">IngredientController</span><span class="params">(IngredientClient client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">ingredientDetailPage</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;ingredient&quot;</span>, client.getIngredient(id));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ingredientDetail&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我不知道你的观点如何，但是我觉得这非常流畅！很难说我最喜欢哪种方式：支持负载均衡的RestTemplate、WebClient，还是具有魔力的Feign客户端接口。不管选择哪种方式，我们的REST客户端都能根据名称消费在Eureka注册的服务，避免硬编码特定的主机名和端口。</p>
<p>值得一提的是，Feign提供了自己的注解。@RequestLine和@Param非常类似于Spring MVC中的@RequestMapping和@PathVariable，但是它们的使用方式略有差异。能够在客户端使用我们已经非常熟悉的Spring MVC注解是非常棒的，而且它们很可能与我们在定义服务控制器时所使用的注解是一样的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/949eb7b7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/949eb7b7/" class="post-title-link" itemprop="url">第4部分 云原生Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:57" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:57+08:00">2021-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-22 13:37:58" itemprop="dateModified" datetime="2021-10-22T13:37:58+08:00">2021-10-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/949eb7b7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/949eb7b7/" data-xid="/JavaReadingNotes/949eb7b7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>257</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第4部分-云原生Spring"><a href="#第4部分-云原生Spring" class="headerlink" title="第4部分 云原生Spring"></a>第4部分 云原生Spring</h1><p>第4部分将会拆分单体应用模型，我们会介绍Spring Cloud和微服务的开发。在第13章中，简单介绍微服务之后，我们将会深入介绍服务发现，这里会使用Spring和Netflix的Eureka服务注册中心实现基于Spring的微服务的注册和发现。第14章通过Spring Cloud的Config Server探讨中心化的配置，Config Server服务能够为应用中的所有微服务提供中心化的配置。在第15章中，我们将会借助NetflixHystrix实现断路器模式，让服务面对失败时更具弹性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8126bbbc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8126bbbc/" class="post-title-link" itemprop="url">13.1 思考微服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:57" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:57+08:00">2021-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 18:13:34" itemprop="dateModified" datetime="2021-10-21T18:13:34+08:00">2021-10-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8126bbbc/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8126bbbc/" data-xid="/JavaReadingNotes/8126bbbc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-1-思考微服务"><a href="#13-1-思考微服务" class="headerlink" title="13.1 思考微服务"></a>13.1 思考微服务</h1><p>到目前为止，我们都是将Taco Cloud开发为单个应用程序，它会构建为一个可部署的JAR或WAR。单个可部署的文件似乎是一种很自然的选择。毕竟，几十年来，大多数的应用程序都是这样部署的。即便可能会将应用程序拆分为多个模块进行构建，但最终我们还是形成一个JAR或WAR，并将其投入到生产环境之中。</p>
<p>在构建小型、简单应用程序的时候，这当然是显而易见的方式。有意思的是，小型应用程序往往会不断增长。当需要新特性的时候，我们能够轻而易举地向项目中添加更多的代码。在我们发觉之前，它已经变成了一个复杂的单体应用，甚至有自己的思想。就像电影《小鬼怪》（Gremlins）里的Mogwai一样，如果你一直喂它，它最终会变成一个与你作对的怪物<a href="%E6%98%AF%E7%9A%84%EF%BC%8C%E5%9C%A8%E8%BF%99%E9%83%A8%E7%94%B5%E5%BD%B1%E4%B8%AD%EF%BC%8C%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%97%AE%E9%A2%98%E6%98%AF%E5%96%82Mogwai%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8D%88%E5%A4%9C%E6%97%B6%E5%88%86%E3%80%82%E6%B2%A1%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%AF%94%E6%98%AF%E5%AE%8C%E7%BE%8E%E7%9A%84%E3%80%82">^1</a>。</p>
<p>单体应用看似简单，但是它会面临各种挑战，如下所示。</p>
<ul>
<li>单体应用难以理解：代码库越大，理解每个组件在整个应用程序中所担任的角色就越困难。</li>
<li>单体应用难以测试：随着应用的不断增长，全面的集成和验收测试会变得更加复杂。</li>
<li>单体应用更容易出现库冲突：实现某个特性所需要的依赖可能会与其他特定的依赖不兼容。</li>
<li>单体应用的扩展较为低效：如果处于扩展的目的要将应用程序部署到更多的硬件上，那么我们必须要将整个应用部署到更多的服务器上，即便应用程序中很小的一部分需要扩展也同样如此。</li>
<li>单体应用中的技术决策是针对整个单体应用的：当为应用程序选择语言、运行时平台、框架和库的时候，整个应用程序都会遵循我们的选择，即便我们所做的选择只是为了支持某个单独的用户场景时同样如此。</li>
<li>单体应用需要大量的操作过程才能投入生产环境：当应用程序只有一个部署单元时，似乎更容易将其投入生产环境。事实上并非如此，单体应用程序的规模和复杂性通常需要更严格的开发过程和更周全的测试周期，这样才能保证所部署的应用程序是高质量的，才能避免引入bug。</li>
</ul>
<p>在过去的几年间，微服务架构的出现致力于解决这些挑战。简而言之，微服务架构是将应用程序分解为可独立开发和部署的小规模、微型应用的一种方式。这些微服务之间互相协作，以实现更大的应用程序的功能。与单体应用程序架构相比，微服务架构有以下特点。</p>
<ul>
<li>微服务易于理解：每个微服务与应用程序的其他微服务之间有一个很小且有限的契约。因此，微服务更加专注于目标，作为一个单元，微服务更易于理解。</li>
<li>微服务易于测试：事情越小，就越便于测试。当你思考单元测试、集成测试和验收测试的时候，这一点非常明显。它也适用于微服务与单体应用之间的测试。</li>
<li>微服务较少受到库不兼容的影响：因为每个微服务都有自己的构建依赖项的集合，而这些依赖项不会与其他的微服务共享，所以不太可能会出现库冲突的现象。</li>
<li>微服务能够独立扩展：如果指定的微服务需要更多的处理能力，那么内存分配和/或实例数量可以按比例增加，而不会影响整体应用中其他微服务的内存和实例数量。</li>
<li>每个微服务可以选择不同的技术：每个微服务可以选择完全不同的语言、平台、框架和库。实际上，某个使用Java编写的微服务与另一个使用C#编写的微服务进行协作是完全合理的[^2]。</li>
<li>微服务可以更加频繁地发布到生产环境中：尽管微服务架构的应用是由许多微服务组成的，但是部署每个微服务的时候，并不需要其他的微服务都已经部署就绪。而且，因为它们更小、更集中、更易于测试，所以将微服务投入到生产环境不需要那么多的繁文缛节。从产生想法到将其投入生产的耗时可以用分钟和小时计量，而不是用周和月。</li>
</ul>
<p>显然，微服务能够让事情变得更简单。但是公平地讲，微服务架构并不是免费的午餐。微服务架构是一种分布式架构，有自己需要应对的挑战，包括网络延迟。在迁移至微服务架构时，我们需要记住这一点，因为很多的远程调用会累积并降低应用的速度。</p>
<p>你还要考虑是否应该将应用构建为微服务，因为并不是所有的应用程序都需要这种架构，或者说能从这种架构中受益。如果你的应用相对比较小或者比较简单，那么最初最好依然采用单体架构。随着它的不断发展，再考虑将其拆分为微服务。</p>
<p>在开发云原生、微服务架构的应用时，要考虑很多因素。本章和接下来的几章主要关注Spring Cloud所提供的技术，以开发由微服务组成的应用程序。如果你对深入研究云原生应用程序的设计和思想过程感兴趣，那么建议阅读Cornelia Davis的Cloud Native（Manning，2019）。</p>
<p>微服务架构所面临的另外一个常见挑战就是每个服务该如何知道它要协作的其他服务在哪里。这恰好是本章的主题。事不宜迟，我们马上看一下如何使用SpringCloud搭建一个服务注册中心。</p>
<p>[^2]: 在这里，我们会关注如何使用Java和Spring编写微服务。如果你对如何使用.NET编写微服务并与Spring Cloud服务交互感兴趣，那么可以参考一下Steeltoe。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/43e8f9eb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/43e8f9eb/" class="post-title-link" itemprop="url">3.0 第13章 注册和发现服务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 21:00:57" itemprop="dateCreated datePublished" datetime="2021-10-20T21:00:57+08:00">2021-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 18:13:34" itemprop="dateModified" datetime="2021-10-21T18:13:34+08:00">2021-10-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/43e8f9eb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/43e8f9eb/" data-xid="/JavaReadingNotes/43e8f9eb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>541</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第13章-注册和发现服务"><a href="#第13章-注册和发现服务" class="headerlink" title="第13章 注册和发现服务"></a>第13章 注册和发现服务</h1><div style="border:1px solid;"><strong>本章内容：</strong><ul><li></li><li>- 思考微服务</li><li>- 创建服务注册中心</li><li>- 注册和发现服务</li></ul></div>

<p>你看过《海底总动员》（Finding Nemo）吗？在这部电影中，马林（小丑鱼）和多莉（蓝唐王鱼）试图去澳大利亚悉尼寻找马林失踪的儿子尼莫。在路上，它们遇到了一群翻车鱼。为了好玩儿，这些翻车鱼把自己摆成了很多种形状——剑鱼、八眼鱼，它们甚至还摆成马林的样子来模仿它。当多莉问它们是否知道如何到达悉尼时，它们组成了悉尼歌剧院的形状，然后变成了一个指向东澳大利亚洋流的箭头。</p>
<p>虽然这部电影没有深入介绍每条翻车鱼的生活，但是我们可以假定每条鱼都是独立于其他翻车鱼的个体。它们都有自己的鳞片、鳍、鳃、眼睛、内脏，据我们所知，它们还有各自的希望和梦想。尽管如此，它们还是一起努力形成这些有趣的形状，帮助马林和多莉前往澳大利亚。</p>
<p>本章我们将会讨论如何开发翻车鱼所组成的应用程序，这是一系列章节中的第一章。也就是说，你将会看到如何使用微服务（一些小的、独立的应用程序，它们协同工作以提供完整应用的功能）进行开发。</p>
<p>更具体地讲，我们将会看到如何使用Spring Cloud套件中一些最有用的组件，包括配置管理、容错以及本章的主题即服务发现。但是，在此之前，我们快速、整体地了解一下使用微服务开发意味着什么以及它们能够提供哪些收益。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/b37b1963/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/b37b1963/" class="post-title-link" itemprop="url">13.2 搭建服务注册中心</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-20 20:51:03" itemprop="dateCreated datePublished" datetime="2021-10-20T20:51:03+08:00">2021-10-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-21 18:13:34" itemprop="dateModified" datetime="2021-10-21T18:13:34+08:00">2021-10-21</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/" itemprop="url" rel="index"><span itemprop="name">第4部分 云原生Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC4%E9%83%A8%E5%88%86-%E4%BA%91%E5%8E%9F%E7%94%9FSpring/%E7%AC%AC13%E7%AB%A0-%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">第13章 注册和发现服务</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/b37b1963/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/b37b1963/" data-xid="/JavaReadingNotes/b37b1963/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="13-2-搭建服务注册中心"><a href="#13-2-搭建服务注册中心" class="headerlink" title="13.2 搭建服务注册中心"></a>13.2 搭建服务注册中心</h1><p>Spring Cloud是一个非常大的伞形项目，由多个独立的子项目组成，每个子项目都以某种形式支撑着微服务的开发。其中有一个子项目叫作Spring Cloud Netflix，它按照Spring的编码风格重新提供了Netflix的多个组件。在这些组件中包括了Netflix的服务注册中心Eureka。</p>
<h2 id="Eureka赤裸裸的历史真相"><a href="#Eureka赤裸裸的历史真相" class="headerlink" title="Eureka赤裸裸的历史真相"></a>Eureka赤裸裸的历史真相</h2><p>Eureka这个词最初的含义是当人们找到或发现某件事情时所发出的欢呼。这使得Eureka非常适合用作服务注册中心的名称，微服务要借助注册中心实现彼此发现的功能。</p>
<p>据传说，Eureka最早是由希腊物理学家阿基米德发明的，他坐在浴缸里的时候发现了浮力的原理，于是他跳出浴缸，赤裸裸地跑回家，嘴里喊着“Eureka！”。</p>
<p>关于阿基米德是否真的光着身子跑回家并大喊“Eureka！”还有一些争论，但无论如何，这个故事非常有意思。话说回来，我们倒是可以衣冠整洁地使用Eureka服务注册中心。</p>
<p>在微服务应用中，Eureka会担当所有服务的注册中心。Eureka本身也可以视为一个微服务，只不过在整体应用中它的目的是让其他的服务能够互相发现。</p>
<p>鉴于它在微服务应用中的角色，在创建需要注册的服务之前，我们最好搭建一个Eureka服务注册中心。为了理解Eureka的运行原理，我们可以参见图13.1所述的流动过程。</p>
<p>当服务实例启动的时候，它会按照名称将自己注册到Eureka中。在图13.1中，服务的名称为“some-service”。“some-service”可能会有多个完全等价的实例，但是在Eureka注册时，它们的名称是相同的。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211020204019.png" alt="image-20211020204011914"></p>
<center>图13.1 服务使用Eureka服务注册中心进行注册（这样其他的服务就能发现并消费它们了）</center>

<p>在某个时间点，另一个服务（图13.1中名为“other-service”）需要使用“some-service”的端点。在这里，“other-service”没有使用特定的主机和端口信息对“some-service”进行硬编码，而是根据名字从Eureka查找“some-service”。Eureka的回应中将会包含它所知道的“some-service”的所有实例。</p>
<p>现在，“other-service”需要做决策了。它该使用“some-service”的哪个实例呢？如果它们都是完全等同的，其实就没什么关系了。为了避免每次都选择同一个实例，最好用一些客户端负载平衡算法来分散请求。这就是Netflix的另一个项目Ribbon的用武之地了。</p>
<p>虽然“other-service”完全可以自行查找和选择“some-service”的实例，但在这里我们让它依赖Ribbon。Ribbon是一个客户端负载平衡器，会帮助“other-service”做出选择。Ribbon做完选择之后，剩下的就是让“other-service”向Ribbon选择的实例发出请求。</p>
<h2 id="为何要使用客户端负载均衡器"><a href="#为何要使用客户端负载均衡器" class="headerlink" title="为何要使用客户端负载均衡器"></a>为何要使用客户端负载均衡器</h2><p>通常，我们会认为负载均衡器是一个中心化的服务，它处理所有的请求并将请求分发到多个目标实例中。与之不同，Ribbon是一个客户端负载均衡器，它会在每个客户端上发起请求。</p>
<p>相对于中心化的负载均衡器，Ribbon作为客户端的负载均衡器会有很多额外的收益。因为有一个在客户端本地的负载均衡器，所以负载均衡器能够很自然地按照客户端的数量成比例伸缩。此外，每个负载均衡器都可以配置成最适合对应客户端的负载平衡算法，而不必对所有的服务都使用相同的配置。</p>
<p>如果你觉得它看上去有些复杂，那么不用担心，随后我们就会看到大多数功能都会以自动化、透明的方式来进行处理。在注册和消费服务之前，我们需要先启用Eureka服务器。</p>
<p>要开始使用Spring Cloud和Eureka，我们需要首先为Eureka本身创建一个全新的项目。最简单的方式是使用Spring Initializr，该项目可以使用任何名称，但是我一般会将其称为service-registry。在选择starter依赖的时候，我们只需要一项依赖：带有Eureka Server标签的复选框。在创建完新项目之后，在Initializr为我们生成的项目中，pom.xml将会包含如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在pom.xml文件中，我们还可以看到名为spring-cloud.version的属性以及一个<code>&lt;dependencyManagement&gt;</code>区域，它们指定了Spring Cloud的发布版本。当我创建service-registry的时候，它引用的是Finchley train的第一个服务发布版本（SR1）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你想要使用不同版本的Spring Cloud，只需要将spring-cloud.version属性修改为想要的版本即可。</p>
<p>在构建文件中添加完Eureka starter依赖之后，要启用Eureka服务器，我们还需要做一件事情，那就是打开应用的主引导类并为其添加<code>@EnableEurekaServer</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRegistryApplication</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(ServiceRegistryApplication.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好的，这样就可以了！如果此时启动应用，Eureka服务注册中心就会运行起来并监听8080端口。如果此时在浏览器上访问<a target="_blank" rel="noopener" href="http://localhost:8080/">http://localhost:8080</a> ，将会看到如图13.2所示的Web界面。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211020204747.png" alt="image-20211020204747659"></p>
<center>图13.2 Eureka基于Web的dashboard</center>

<p>Eureka还对外暴露了REST API，借助它们服务可以自行进行注册，也可以发现其他的服务。你可能不会直接使用REST API，但是你会发现“/eureka/apps”端点非常有意思。它会列出注册中心所有服务实例的细节。此时，我们没有注册任何服务，它的响应如下所示。在注册完服务之后，我们还会研究这个端点：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">applications</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">versions__delta</span>&gt;</span>1<span class="tag">&lt;/<span class="name">versions__delta</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">apps__hashcode</span>&gt;</span><span class="tag">&lt;/<span class="name">apps__hashcode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">applications</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你会发现，在Eureka的日志中，每隔大约30秒就会打印出一些异常。不用担心，Eureka正在运行，而且完全符合我们的预期。但是，这些异常表明我们还没有完全配置好服务注册中心。接下来，我们添加一些配置属性来消除这些异常。</p>
<h2 id="13-2-1-配置Eureka"><a href="#13-2-1-配置Eureka" class="headerlink" title="13.2.1 配置Eureka"></a>13.2.1 配置Eureka</h2><p>Eureka不喜欢独自工作，并相信数量多会更安全的理念，希望能够成为Eureka服务器集群的一部分。如果有多个Eureka服务器，其中有一个遇到问题，就不会出现单点故障。因此，Eureka的默认行为是与其他Eureka服务器建立关联，尝试获取其他Eureka服务器的服务注册中心，甚至还会将自身注册为其他Eureka服务器的服务。</p>
<p>在生产环境中，Eureka的高可用是非常有价值的。但是，对于开发阶段来说，启动多个Eureka服务器既不方便也没有必要。为了达到开发的目的，有一个单独的Eureka服务器就足够了。除非我们正确配置了Eureka服务器，否则它会以日志文件中异常的形式每隔30秒就抱怨孤独状态。这是因为，每隔30秒，Eureka服务器就会尝试与另外的Eureka服务器建立关联，以注册自己并共享其注册中心中的信息。</p>
<p>我们需要做的就是配置Eureka使其接受当前的孤独状态。为了实现这一点，我们需要在application.yml中设置一些属性，代码片段如下所示：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>

<p>首先，我们将eureka.instance.hostname属性设置为localhost。这会告诉Eureka它正运行在哪个主机（host）上。这个属性是可选的，如果我们不指定它，那么Eureka会尝试通过环境变量确定它的主机。明确设置这个属性能够让我们更加确定它的值。</p>
<p>接下来的两个属性是eureka.client.fetch-registry和eureka.client.register-with-eureka。在其他的微服务中，我们可能会通过这两个属性告诉它们该如何与Eureka服务器进行交互。但是，不要忘了，Eureka也是一个微服务，所以这些属性也可以用到Eureka服务器上，以便于告诉它该如何与其他Eureka服务器进行交互。</p>
<p>这两个属性的默认值都是true，表明Eureka应该从其他的Eureka实例获取注册信息，并且应该将自身注册为其他Eureka服务器中的服务。因为在开发模式下并没有其他的Eureka服务器，所以我们将它们设置为false，这样Eureka将不会尝试与其他的Eureka服务器建立关联。</p>
<p>最后，我们还设置了eureka.client.service-url属性。这个属性包含了zone名称与该zone下一个或多个Eureka服务器之间的映射关系。defaultZone是一个特殊的key，如果客户端（在本例中，也就是Eureka本身）没有指定所需的zone，就将会使用这个zone。因为我们只有一个Eureka，映射到默认zone的URL就是Eureka服务器本身，所以这里使用了占位符变量，由其他属性填充它的值。</p>
<h3 id="指定Eureka的服务器端口"><a href="#指定Eureka的服务器端口" class="headerlink" title="指定Eureka的服务器端口"></a>指定Eureka的服务器端口</h3><p>尽管不一定是强制要求，但是我们可能想要修改默认的服务器端口。虽然Eureka非常乐意监听8080端口，但是在开发代码的时候我们可能会在本地机器同时运行多个应用（微服务），也就无法让所有的应用均监听8080端口。因此，在本地开发的时候，设置server.port属性通常是一个比较好的做法：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们将端口设置成了8761，这是Eureka客户端（我们将会在13.3节中进行讨论）默认监听的端口。</p>
<h3 id="禁用自我保护模式"><a href="#禁用自我保护模式" class="headerlink" title="禁用自我保护模式"></a>禁用自我保护模式</h3><p>另外一个我们需要考虑设置的属性是eureka.server.enable-self-preservation。如果我们启动Eureka服务器并让它空闲一分钟以上，可能就会在Eureka UI上看到一个非常吓人的错误信息，如图13.3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211020205004.png" alt="image-20211020205004645"></p>
<center>图13.3 在自我保护模式下，Eureka会在dashboard显示信息</center>

<p>尽管这里使用了红色字体和大写字母，但是这条信息并不像看上去那么严重。Eureka希望服务实例能够注册上来，并且每隔30秒向它发送一次注册更新的请求。通常，如果Eureka在3个更新周期（或者说90秒）内没有收到服务的更新请求，就会将该服务注销。在本例中，Eureka假定出现了网络问题，进入自我保护模式，所以不会注销服务实例。</p>
<p>在生产环境中，自我保护模式是很好的，可以防止在出现网络故障时更新请求无法发送至Eureka所导致的活跃服务被注销。但是，在我们第一次启动Eureka并且还没有注册任何服务时候，出现这样的告警会让人产生疑虑。我们可以将eureka.server.enable-self- preservation属性设置为false，从而禁用自我保护模式：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="string">...</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这个属性在开发环境中是非常有用的。在开发环境中，基于各种原因，Eureka可能会收不到更新请求。在这种环境下，我们可能会频繁地启动或关闭服务实例，自我保护模式会将已停止服务的注册项保留下来，另一个服务访问已经不可用的服务时就会产生问题。禁用自动保护模式将会防止这种诡异的问题。然而，我们付出的代价就是会看到另一条恐怖的红色信息（见图13.4）。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211020205040.png" alt="image-20211020205040204"></p>
<center>图13.4 禁用自我保护模式时，提示自我保护模式已禁用</center>

<p>虽然我们在开发环境可以禁用自我保护模式，但是在投入生产环境时需要将其启用。</p>
<h2 id="13-2-2-扩展Eureka"><a href="#13-2-2-扩展Eureka" class="headerlink" title="13.2.2 扩展Eureka"></a>13.2.2 扩展Eureka</h2><p>在开发环境中，单个Eureka实例会更加便利；但是在将应用投入生产环境时，我们可能至少需要两个Eureka实例，以实现高可用性。</p>
<h3 id="生产环境可用的Spring-Cloud-Services"><a href="#生产环境可用的Spring-Cloud-Services" class="headerlink" title="生产环境可用的Spring Cloud Services"></a>生产环境可用的Spring Cloud Services</h3><p>在将微服务部署到生产环境时，有许多需要考虑的因素。Eureka的高可用性和安全性在开发阶段可能并不太重要，但是在生产环境中就非常关键了。如果你是PivotalCloud Foundry或Pivotal Web Services的客户，就可以让他们来关心这些事情了。</p>
<p>Spring Cloud Services提供了一个Eureka实现，同时还包含了配置服务器和断路器dashboard。我们所需要做的就是从marketplace请求一个p-service-registry服务，然后将自己的微服务绑定到该服务上。在marketplace中，配置服务器和断路器dashboard（我们将会在接下来的两章中讨论它们）的名称分别为p-config-server和p-circuit-breaker-dashboard。</p>
<p>配置两个（或更多）Eureka实例最简单直接的方式就是在application.yml中使用Spring profile，然后针对两个profile各启动一次。例如，程序清单13.1中的配置项会将两个Eureka服务器设置为彼此对等的端。</p>
<p>配置两个（或更多）Eureka实例最简单直接的方式就是在application.yml中使用Spring profile，然后针对两个profile各启动一次。例如，程序清单13.1中的配置项会将两个Eureka服务器设置为彼此对等的端。</p>
<p>程序清单13.1 使用Spring profile将Eureka配置成两个对等的端</p>
<pre>
eureka:
  client:
    service-url:
      defaultZone: http://${other.eureka.host}:${other.eureka.port}/eureka
&#45;&#45;&#45;
spring:
  profiles: eureka-1
  application:
    name: eureka-1
server:
  port: 8761
eureka:
  instance:
    hostname: eureka1.tacocloud.com
other:
  eureka:
    host: eureka2.tacocloud.com
    port: 8761
&#45;&#45;&#45;
spring:
  profiles: eureka-2
  application:
    name: eureka-2
server:
  port: 8762
eureka:
  instance:
    hostname: eureka2.tacocloud.com
other:
  eureka:
    host: eureka1.tacocloud.com
    port: 8762
</pre>

<p>在默认的profile中（位于程序清单13.1顶部），我们用占位符变量来设置eureka.client. service-url.defaultZone属性，这些占位符都是在每个profile特定的配置中设置的。</p>
<p>在默认的profile之后，我们配置了两个profile，分别为eureka-1和eureka-2。每个profile都按照自己的配置需要指定了端口和eureka.instance.hostname。随后，我们设置了两个略显牵强的other.eureka.host和other.eureka.port属性，在每个profile中它们都指向了其他的Eureka实例。这两个属性与框架本身是没有关系的，但是在默认profile的占位符中会引用它们。</p>
<p>注意，我们在这里没有设置eureka.client.fetch-registry或eureka.client.register-with-eureka。它们的默认值为true，因此能够确保每个Eureka服务器都会向对方进行注册，并且能够从其他Eureka服务器上获取注册信息。</p>
<p>目前，Eureka服务注册中心已经启动并处于运行状态了。但是，它现在就像一个没有人查阅的空电话本。只有让服务开始在注册中心注册，并让其他服务查找和调用它们才行，否则我们的工作都是徒劳的。接下来，我们看一下如何让微服务成为Eureka的客户端。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/de067c2f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/de067c2f/" class="post-title-link" itemprop="url">12.4 小结_第12章 反应式持久化数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-19 21:30:56" itemprop="dateCreated datePublished" datetime="2021-10-19T21:30:56+08:00">2021-10-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-20 21:00:55" itemprop="dateModified" datetime="2021-10-20T21:00:55+08:00">2021-10-20</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/" itemprop="url" rel="index"><span itemprop="name">第3部分 反应式Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/%E7%AC%AC12%E7%AB%A0-%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">第12章 反应式持久化数据</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/de067c2f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/de067c2f/" data-xid="/JavaReadingNotes/de067c2f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>263</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="12-4-小结"><a href="#12-4-小结" class="headerlink" title="12.4 小结"></a>12.4 小结</h1><ul>
<li>Spring Data支持为Cassandra、MongoDB、Couchbase和Redis数据库创建反应式repository。</li>
<li>Spring Data的反应式repository遵循与非反应式repository相同的编程模型，只不过它们所处理的是反应式发布者，如Flux和Mono。</li>
<li>非反应式repository（比如JPA repository）可以调整为使用Mono和Flux，但是在保存和获取数据时它们依然是阻塞的。</li>
<li>在使用非关系数据库时，需要理解如何恰当地为数据建模，这个建模过程决定了数据库最终如何存储数据。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/e654098e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/e654098e/" class="post-title-link" itemprop="url">12.3 编写反应式的MongoDB repository</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-19 21:30:17" itemprop="dateCreated datePublished" datetime="2021-10-19T21:30:17+08:00">2021-10-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-04-13 01:32:08" itemprop="dateModified" datetime="2022-04-13T01:32:08+08:00">2022-04-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/" itemprop="url" rel="index"><span itemprop="name">第3部分 反应式Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/%E7%AC%AC12%E7%AB%A0-%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">第12章 反应式持久化数据</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/e654098e/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/e654098e/" data-xid="/JavaReadingNotes/e654098e/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>与Cassandra一样，必须要明确知道MongoDB不是关系数据库。管理MongoDB服务器集群和数据建模的方式与处理其他类型数据库时的思维方式是不一样的。</p>
<p>不过，使用MongoDB和Spring Data与使用Spring Data处理JPA或Cassandra并没有太大的差异。我们会在领域类上使用注解，将领域类型映射为文档结构。我们还会编写repository接口，这遵循与JPA和Cassandra一样的编程模型。但是在进行任何操作之前，我们必须在项目中启用Spring Data MongoDB。</p>
<h2 id="12-3-1-启用Spring-Data-MongoDB"><a href="#12-3-1-启用Spring-Data-MongoDB" class="headerlink" title="12.3.1 启用Spring Data MongoDB"></a>12.3.1 启用Spring Data MongoDB</h2><p>要启用Spring Data MongoDB，我们需要将Spring Data MongoDB starter添加到项目的构建文件中。Spring Data MongoDB有两个独立的可选starter。</p>
<p>如果你使用非反应式的MongoDB，那么需要将如下的依赖添加到构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    spring-boot-starter-data-mongodb</span><br><span class="line">  <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这项依赖也可以在Spring Initializr中通过选中名为MongoDB的复选框添加进来。但是，本章主要关注的是编写反应式repository，所以我们要选择反应式SpringData MongoDB starter依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    spring-boot-starter-data-mongodb-reactive</span><br><span class="line">  <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Initializr中，我们可以通过选中Reactive MongoDB复选框将反应式SpringData MongoDB starter添加进来。将这个starter添加到构建文件中之后，自动配置功能将会触发，启用Spring Data对自动化repository接口的支持，这一点与第3章的JPA和第11章的Cassandra类似。</p>
<p>默认情况下，Spring Data MongoDB会假定MongoDB在本地运行并监听27017端口。为了测试和开发的便利性，我们可以选择使用嵌入式的Mongo数据库。为了实现这一点，我们需要将Flapdoodle Embedded MongoDB依赖添加到构建文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.flapdoodle.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>de.flapdoodle.embed.mongo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与我们在关系型数据库中使用H2类似，Flapdoodle嵌入式数据库带来了使用内存Mongo数据库的便利性。也就是说，我们不需要运行单独的数据库，但是所有的数据会在应用重启的时候丢掉。</p>
<p>嵌入式数据库对于开发和测试是很不错的，一旦我们将应用部署到生产环境，就需要设置几个属性，让Spring Data MongoDB知道访问何处的Mongo数据库以及该如何进行访问：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">mongodb:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">mongodb.tacocloud.com</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">27018</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">tacocloud</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">s3cr3tp455w0rd</span></span><br><span class="line">      <span class="attr">database:</span> <span class="string">tacoclouddb</span></span><br></pre></td></tr></table></figure>

<p>在这里，并不是所有的属性都是必需的。如果Mongo数据库不在本地运行，那么这些属性能够为Spring Data MongoDB指明正确的方向。拆分一下上面的配置，如下就是要设置的每个属性。</p>
<ul>
<li>spring.data.mongodb.host：Mongo运行的主机名（默认为localhost）。</li>
<li>spring.data.mongodb.port：Mongo服务器监听的端口（默认为27017）。</li>
<li>spring.data.mongodb.username：访问安全Mongo数据库的用户名。</li>
<li>spring.data.mongodb.password：访问安全Mongo数据库的密码。</li>
<li>spring.data.mongodb.database：数据库名（默认为test）。</li>
</ul>
<p>在我们的项目中，已经启用了Spring Data MongoDB，所以接下来我们需要为领域对象添加注解，以便于将它们持久化为MongoDB中的文档。</p>
<h2 id="12-3-2-将领域对象映射为文档"><a href="#12-3-2-将领域对象映射为文档" class="headerlink" title="12.3.2 将领域对象映射为文档"></a>12.3.2 将领域对象映射为文档</h2><p>Spring Data MongoDB提供了多个注解。在将领域对象映射为要持久化到MongoDB中的文档结构时，这些注解是非常有用的。尽管Spring DataMongoDB提供了多个用于映射的注解，但是其中的3个是最常用的。</p>
<ul>
<li><code>@Id</code>：将某个属性指明为文档的ID（来自Spring Data Commons）。</li>
<li><code>@Document</code>：将领域类型声明为要持久化到MongoDB中的文档。</li>
<li><code>@Field</code>：指定某个属性持久化到文档中的字段名称（以及可选的顺序配置）。</li>
</ul>
<p>在这3个注解中，@Id和@Document是严格需要的。除非显式指定，否则没有使用@Field注解的属性将假定字段名与属性名相同。</p>
<p>将这些注解应用到Ingredient类上的效果如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;</span><br><span class="line">    spring-boot-starter-data-mongodb</span><br><span class="line">  &lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;</span><br><span class="line">    spring-boot-starter-data-mongodb-reactive</span><br><span class="line">  &lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;de.flapdoodle.embed&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;de.flapdoodle.embed.mongo&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">spring:</span><br><span class="line">  data:</span><br><span class="line">    mongodb:</span><br><span class="line">      host: mongodb.tacocloud.com</span><br><span class="line">      port: <span class="number">27018</span></span><br><span class="line">      username: tacocloud</span><br><span class="line">      password: s3cr3tp455w0rd</span><br><span class="line">      database: tacoclouddb</span><br><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在类级别使用了<code>@Document</code>注解，表明Ingredient是一个文档实体，可以在Mongo数据库中执行读取和写入操作。默认情况下，集合名（这是Mongo中与关系型数据库的表对等的概念）是基于类名的，只不过第一个字母会变成小写。因为我们没有特别指定，所以Ingredient对象将会持久化到名为ingredient的集合中。但是，我们可以通过设置<code>@Document</code>的collection属性改变这种行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@Document(collection=&quot;ingredients&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还会看到，id属性使用了<code>@Id</code>注解。这表明该属性将会作为要持久化的文档的ID。我们可以将<code>@Id</code>注解用到任意Serializable类型的字段上，包括String和Long。在本例中，我们已经使用String定义的id属性作为自然标识符，因此不需要将其更改为其他类型。</p>
<p>到目前为止，一切都很顺利。但是，不要忘了，在本章前面的内容中，我们曾说过Ingredient是进行Cassandra映射时最简单的一个领域类型。其他的类型，比如Taco，就稍微困难一些了。接下来，我们看一下如何映射Taco类，看看它会有哪些惊喜。</p>
<p>在将领域类型映射为MongoDB文档时，我们肯定需要为Taco添加<code>@Document</code>注解。同时，我们还需要通过<code>@Id</code>注解指定ID属性。在添加完支持MongoDB持久化的注解后，我们就会得到如下的Taco类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RestResource(rel=&quot;tacos&quot;, path=&quot;tacos&quot;)</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="meta">@NotNull</span></span><br><span class="line">  <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> Date createdAt = <span class="keyword">new</span> Date();</span><br><span class="line">  <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Ingredient&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管你是否相信，这就是所有的内容。在Cassandra中，我们还需要处理两个不同的主键字段并且要引用用户定义类型，但这是Cassandra特有的。对于MongoDB来说，Taco的映射要简单得多。</p>
<p>即便如此，在Taco中还是有一些有意思的事情值得关注。首先，我们要注意，id属性变成了String类型（而不是JPA版本中的Long类型或Cassandra版本中的UUID类型）。正如我在前文所述，@Id注解可以用到任意Serializable类型上。如果选择使用String属性作为ID，我们就可以在保存的时候让Mongo自动设置一个值给它。将其设置为String类型之后，我们就得到了一个数据库管理赋值的ID，而不用再担心如何手动设置该属性。</p>
<p>我们再看一下ingredients属性。它是一个<code>List&lt;Ingredient&gt;</code>，与第3章中的JPA版本非常类似。与JPA版本不同的是，这个列表不会存储到单独的MongoDB集合中。与Cassandra对应的功能类似，配料列表会直接、以非规范化的形式存储到taco文档中。不过，与Cassandra不同，我们不需要创建用户定义类型，MongoDB非常乐意使用任何类型，不管它是带有<code>@Document</code>注解的另一个类型还是简单的POJO，都是可以的。</p>
<p>看到将Taco映射为文档持久化非常容易，我们可以松口气了。这种映射的便利性会延续到Order领域类吗？你可以自行看一下带有MongoDB注解的Order类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> Date placedAt = <span class="keyword">new</span> Date();</span><br><span class="line">  <span class="meta">@Field(&quot;customer&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  <span class="comment">// other properties omitted for brevity&#x27;s sake</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Taco&gt; tacos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDesign</span><span class="params">(Taco design)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tacos.add(design);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单起见，我删除了投递和信用卡相关的各种字段。从剩下的部分可以清楚地看出，与其他领域类型一样，我们只需要<code>@Document</code>和<code>@Id</code>注解。即便如此，我们也为user属性使用了<code>@Field</code>，指定在持久化文档中它将会存储为customer。</p>
<p>User领域类的MongoDB持久化映射依然非常简单，看到这里，相信你并不会对此感到意外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String password;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String fullname;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String street;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String city;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String state;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String zip;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String phoneNumber;</span><br><span class="line">  <span class="comment">// UserDetails method omitted for brevity&#x27;s sake</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然有一些更高级和不常见的场景需要额外的映射，但是我们会发现，对于大多数情况，<code>@Document</code>、<code>@Id</code>以及偶尔用到的<code>@Field</code>对于MongoDB映射来说已经足够了。对于Taco Cloud的领域类型，它们完全可以胜任。</p>
<p>剩下的事情就是编写repository接口了。</p>
<h2 id="12-3-3-编写反应式的MongoDB-repository接口"><a href="#12-3-3-编写反应式的MongoDB-repository接口" class="headerlink" title="12.3.3 编写反应式的MongoDB repository接口"></a>12.3.3 编写反应式的MongoDB repository接口</h2><p>Spring Data MongoDB提供的自动化repository功能与Spring Data JPA和Spring Data Cassandra类似。在为MongoDB编写反应式repository的时候，我们可以在ReactiveCrudRepository和ReactiveMongoRepository之间进行选择。核心的差异在于，ReactiveMongoRepository提供多个特殊的insert()方法，它们针对新文档的持久化进行了优化，而ReactiveCrudRepository依赖save()方法来保存新文档和已有的文档。</p>
<div style="border:1px solid;"><strong>如何编写非反应式的MongoDB repository？</strong><p>本章主要关注如何使用Spring Data编写反应式的repository。如果出于某种原因，你希望使用非反应式的repository，那么可以通过让repository接口扩展CrudRepository或MongoRepository来实现，而不是选择扩展ReactiveCrudRepository或ReactiveMongo Repository。这样，我们就可以让repository返回带有Mongo注解的领域类型或这些领域类型的集合。</p><p>尽管不是严格要求的，但是你可以将spring-boot-starter-data-mongodb-reactive依赖替换为spring-boot-starter- data-mongodb。</p></div>

<p>首先，我们来定义将Ingredient对象持久化为文档的repository。在数据库初始化完成之后，我们不会频繁地创建配料的文档，甚至有可能永远不会这样做。因此，ReactiveMongoRepository提供的优化没有太多的用处，我们可以让IngredientRepository扩展ReactiveCrudRepository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.reactive.ReactiveCrudRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> tacos.Ingredient;</span><br><span class="line"><span class="meta">@CrossOrigin(origins=&quot;*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveCrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍等片刻！它看起来与我们在12.2.4小节中为Cassandra编写的IngredientRepository接口是完全一样的！实际上，这是同一个接口，没有任何变化。这凸显了扩展ReactiveCrudRepository的一个好处，也就是它在各种数据库类型之间具有更强的可移植性，并且针对MongoDB和Cassandra都可以很好地运行。</p>
<p>因为它是一个反应式repository，所以它的方法处理的是Flux和Mono，而不是原始领域类型或这些领域类型的集合。例如，findAll()方法将返回<code>Flux&lt;Ingredient&gt;</code>，而不是<code>Iterable&lt;Ingredient&gt;</code>。同样，findById()将返回<code>Mono&lt;Ingredient&gt;</code>，而不是<code>Optional&lt;Ingredient&gt;</code>。因此，这个反应式repository可以作为端到端反应式流的一部分。</p>
<p>现在，为了将Taco持久化为MongoDB中的文档，我们定义另一个repository。与配料文档不同，我们会频繁创建taco文档。因此，ReactiveMongoRepository优化过的insert()方法就很有价值了。如下的代码片段展现了支持MongoDB的TacoRepository接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> tacos.Taco;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TacoRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">Taco</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Flux&lt;Taco&gt; <span class="title">findByOrderByCreatedAtDesc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对于ReactiveCrudRepository，使用ReactiveMongoRepository唯一的缺点在于它是专属于MongoDB的，不能迁移至其他数据库。在你的项目中，你需要确定这种代价是否值得。如果你预计不会在某个时刻切换到不同的数据库，那么尽可以选择ReactiveMongoRepository并充分利用它针对数据插入操作所带来的优化。</p>
<p>注意，在TacoRepository中，我们引入了一个新的方法。这个方法支持显示最近创建的taco。在JPA版本的repository中，我们需要通过扩展PagingAndSortingRepository实现该功能。但是，在反应式repository中，PagingAndSortingRepository并没有太大的用处（尤其是分页功能）。在Cassandra版本中，排序是通过表定义中的集群键实现的，所以在repository中获取最近创建的taco时，我们并不需要特殊的处理。</p>
<p>对于MongoDB来说，我们想要获取最近创建的taco。尽管名字看上去有些奇怪，但是findByOrderByCreatedAtDesc()方法遵循自定义查询方法命名约定。它说明我们想要查找Taco对象，没有任何查询条件，我们在这里没有设置任何必须匹配的属性。然后，我们告诉它将结果按照createdAt属性降序排列。</p>
<p>在这里，命名中使用空By子句的原因在于方法名称中还有另一个By，这样做可以避免方法名称出现误解。如果将其命名为findAllOrderByCreatedAtDesc()，那么名称中的AllOrder部分将被忽略，Spring Data将尝试通过匹配createdAtDesc属性来查找taco。因为不存在该属性，所以应用将会报错，无法正常启动。</p>
<p>因为findByOrderByCreatedAtDesc()返回的是一个<code>Flux&lt;Taco&gt;</code>，所以我们不用担心分页的事情。相反，我们只需要使用take操作获取Flux发布的前12个Taco即可。例如，在显示最近创建的taco的控制器中，我们可以按照如下方式调用findByOrderBy CreatedAtDesc()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Taco&gt; recents = repo.findByOrderByCreatedAtDesc()</span><br><span class="line">                         .take(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>

<p>最终得到的Flux所发布的Taco条目不会超过12个。</p>
<p>再看OrderRepository接口，它非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Flux;</span><br><span class="line"><span class="keyword">import</span> tacos.Order;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">Order</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们会频繁创建Order文档，所以OrderRepository扩展了ReactiveMongoRepository，从而充分利用其insert()方法所带来的优化。除此之外，相对于我们已经定义的repository，它并没有什么新奇之处。</p>
<p>最后，我们看一下将User对象持久化为文档的repository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos.data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.ReactiveMongoRepository;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="keyword">import</span> tacos.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveMongoRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲解到现在，你对这个repository接口应该没有丝毫感到惊讶的地方了。与其他repository类似，它扩展了ReactiveMongoRepository（当然，它也可以扩展ReactiveCrudRepository）。唯一的与众不同之处在于，它有一个findByUsername()方式，这是在第4章中我们为了支持认证功能添加上去的。在这里，将它修改为返回<code>Mono&lt;User&gt;</code>，而不是原始的User对象。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/30ffda3b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/30ffda3b/" class="post-title-link" itemprop="url">12.2 使用反应式的Cassandra repository</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-17 21:46:41" itemprop="dateCreated datePublished" datetime="2021-10-17T21:46:41+08:00">2021-10-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-19 21:31:10" itemprop="dateModified" datetime="2021-10-19T21:31:10+08:00">2021-10-19</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/" itemprop="url" rel="index"><span itemprop="name">第3部分 反应式Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/%E7%AC%AC12%E7%AB%A0-%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">第12章 反应式持久化数据</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/30ffda3b/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/30ffda3b/" data-xid="/JavaReadingNotes/30ffda3b/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="12-2-使用反应式的Cassandra-repository"><a href="#12-2-使用反应式的Cassandra-repository" class="headerlink" title="12.2 使用反应式的Cassandra repository"></a>12.2 使用反应式的Cassandra repository</h1><p>Cassandra是一个分布式、高性能、始终可用、最终一致、分区行存储的NoSQL数据库。</p>
<p>描述该数据库的形容词是非常冗长的，但每一个词都准确说明了Cassandra的威力。简而言之，Cassandra处理的是数据行（row of data），这些数据行会在多个分布式节点中分区。不会有任何节点保存所有的数据，但是任何给定的行都会跨多个节点保存副本，从而消除了单点故障。</p>
<p>Spring Data Cassandra为Cassandra数据库提供了自动化repository的支持，这与Spring Data JPA为关系数据库提供的支持非常相似，但又有着明显的差异。此外，Spring Data Cassandra还提供了映射注解，用于将应用的领域类型映射到支撑的数据库结构之上。</p>
<p>在我们进一步探讨Cassandra之前，有一点很重要，那就是尽管Cassandra与关系数据库（如Oracle和SQL Server）有许多相似的概念，但Cassandra并不是关系数据库，在很多方面与关系数据库截然不同。我将尝试解释Cassandra的独特之处，因为这与如何使用Spring Data有关。我鼓励你阅读Cassandra自己的文档，以全面了解Cassandra的工作原理。</p>
<p>下面我们从在Taco Cloud项目中启用Spring Data Cassandra开始。</p>
<h2 id="12-2-1-启用Spring-Data-Cassandra"><a href="#12-2-1-启用Spring-Data-Cassandra" class="headerlink" title="12.2.1 启用Spring Data Cassandra"></a>12.2.1 启用Spring Data Cassandra</h2><p>要开始使用Spring Data Cassandra的反应式repository功能，我们需要添加反应式Spring Data Cassandra的Spring Boot starter依赖。实际上，我们可以从两个Spring Data Cassandra starter依赖间进行选择。</p>
<p>如果不打算为Cassandra编写反应式repository，那么我们可以在构建文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-cassandra<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个依赖也可以在Initializr中通过选中Cassandra复选框添加进来。</p>
<p>在本章中，我们主要关注编写反应式repository，所以需要使用另外一个支持反应式Cassandra repository的starter依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    spring-boot-starter-data-cassandra-reactive</span><br><span class="line">  <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果使用Spring Initializr创建项目，我们可以通过选中Reactive Cassandra复选框将这个依赖添加到构建文件中。</p>
<p>很重要的一点在于，我们使用这个依赖替代了Spring Data JPA starter依赖。此时我们不再通过JPA将数据持久化到关系型数据库中，而是使用Spring Data将数据持久化到Cassandra数据库中。因此，我们可能想要从构建文件中移除SpringData JPA starter依赖和关系型数据库的依赖（如JDBC驱动和H2依赖）。</p>
<p>Spring Data Reactive Cassandra starter依赖会为项目引入多个依赖项，其中包括Spring Data Cassandra库和Reactor。由于这些库位于运行时类路径中，因此将会触发创建反应式Cassandra库的自动配置。这意味着我们马上就能开始编写反应式Cassandra repository，而无须太多显式配置。</p>
<p>不过，少量的配置还是需要的，至少需要配置键空间（key space）的名称，我们的repository要在该键空间中进行操作。为了做到这一点，我们先创建一个键空间。</p>
<div style="border:1px solid;">**注意**：在Cassandra中，键空间是Cassandra节点中的一组表。这与关系数据库中表、视图和约束的分组方式大致类似。</div>

<p>尽管我们可以配置Spring Data Cassandra自动创建键空间，但是手动创建（或使用现有的键空间）通常要容易得多。借助Cassandra CQL （Cassandra QueryLanguage，Cassandra查询语言） shell，我们可以使用如下的create keyspace命令为Taco Cloud应用创建键空间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cqlsh&gt; create keyspace tacocloud</span><br><span class="line">   ... with replication=&#123;&#x27;class&#x27;:&#x27;SimpleStrategy&#x27;, &#x27;replication_factor&#x27;:1&#125;</span><br><span class="line">   ... and durable_writes=true;</span><br></pre></td></tr></table></figure>

<p>简而言之，这里创建了一个名为tacocloud的键空间，并且使用简单策略的复制（replication）和持久性写入（durable writes）。通过将复制因子设置为1，我们希望为每行数据保留一个副本。复制策略决定了该如何处理复制操作。SimpleStrategy复制策略对于单数据中心（和样例）使用来说是不错的选择，但是如果你的Cassandra集群跨多个数据中心，那就应该考虑使用NetworkTopologyStrategy。推荐你阅读一下Cassandra的文档，了解复制策略的更多细节以及创建键空间的其他可选项。</p>
<p>现在，我们已经创建了键空间，接下来应该配置spring.data.cassandra.keyspace-name属性，告诉Spring Data Cassandra该如何使用该键空间：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">cassandra:</span></span><br><span class="line">      <span class="attr">keyspace-name:</span> <span class="string">tacocloud</span></span><br><span class="line">      <span class="attr">schema-action:</span> <span class="string">recreate-drop-unused</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们将spring.data.cassandra.schema-action属性设置为recreate-drop-unused。这项配置在开发阶段非常有用，因为它会保证应用在每次重新启动的时候，所有的表和用户定义类型都将会删除并重建。它的默认值为none，不会对已有模式采取任何操作，在生产环境中，这种设置是非常有用的，因为我们并不想在应用启动的时候删除所有生产环境中的表。</p>
<p>在本地运行Cassandra数据库时，我们只需要设置这两个属性。不过，除了这两个属性之外，你可能还想要设置其他的属性，这取决于你如何配置Cassandra集群。</p>
<p>默认情况下，Spring Data Cassandra会假定Cassandra在本地运行并监听9092端口。如果事实并非如此，那么在生产环境的配置中我们可能还要配置spring.data.cassandra.contact- points和spring.data.cassandra.port属性：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">cassandra:</span></span><br><span class="line">      <span class="attr">keyspace-name:</span> <span class="string">tacocloud</span></span><br><span class="line">      <span class="attr">contact-points:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">casshost-1.tacocloud.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">casshost-2.tacocloud.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">casshost-3.tacocloud.com</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9043</span></span><br></pre></td></tr></table></figure>

<p>注意，spring.data.cassandra.contact-points属性是我们识别Cassandra主机名的地方。每个联系点（contact point）代表了运行Cassandra节点的主机。默认情况下，它会被设置为localhost，但是我们可以将其设置为主机名的一个列表。应用会尝试连接每个连接点，直到能够连接上其中的一个为止。这样能够确保在Cassandra集群中不会出现单点故障，应用能够通过给定的连接点与集群建立连接。</p>
<p>我们可能还需要设置Cassandra集群的用户名和密码。这可以通过设置spring.data.cassandra.username和spring.data.cassandra.password属性来实现：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">cassandra:</span></span><br><span class="line">       <span class="string">...</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">tacocloud</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">s3cr3tP455w0rd</span></span><br></pre></td></tr></table></figure>

<p>现在，在我们的项目中已经启用和配置好了Spring Data Cassandra，接下来就应该将领域模型与Cassandra表进行映射并编写repository了。在此之前，我们回过头来看一些Cassandra数据模型的基本要点。</p>
<h2 id="12-2-2-理解Cassandra的数据模型"><a href="#12-2-2-理解Cassandra的数据模型" class="headerlink" title="12.2.2 理解Cassandra的数据模型"></a>12.2.2 理解Cassandra的数据模型</h2><p>正如前文所述，Cassandra与关系型数据库有很大的不同。在将领域类型映射为Cassandra表之前，理解Cassandra数据模型与关系型数据库数据持久化建模的差异是非常重要的。</p>
<p>关于Cassandra数据模型，有几项很重要的事情需要理解。</p>
<ul>
<li>Cassandra表可能有任意数量的列，但是并不是所有的行都会用到这些列。</li>
<li>Cassandra数据库被分割为多个分区。给定表中的任何一行都可以由一个或多个分区管理，但是不太可能每个分区都拥有所有的行。</li>
<li>Cassandra表有两种键：分区键（partition key）和集群键（clusteringkey）。Cassandra会对每一行的分区键执行哈希操作，以确定由哪个分区管理该行。集群键决定了行在分区中维护的顺序（不一定是它们在查询结果中出现的顺序）。</li>
<li>Cassandra对读操作进行了极大的优化。因此，较为常见和推荐的做法是让表实现高度非规范化，并让数据跨多个表进行复制（比如，客户信息可能会保存在customer表中，同时也会复制到客户所创建的订单表中）。</li>
</ul>
<p>需要说明一点，将Taco Cloud领域类型调整为使用Cassandra，并不是简单地将几个JPA注解替换为Cassandra注解就可以了。我们必须重新考虑如何对数据进行建模。</p>
<h2 id="12-2-3-将领域对象映射为Cassandra持久化"><a href="#12-2-3-将领域对象映射为Cassandra持久化" class="headerlink" title="12.2.3 将领域对象映射为Cassandra持久化"></a>12.2.3 将领域对象映射为Cassandra持久化</h2><p>在第3章中，我们为领域类型（Taco、Ingredient、Order等）添加了JPA规范提供的注解。这些注解会将领域类型映射为要持久化到关系型数据库中的实体。尽管这些注解无法用于Cassandra的持久化，但是Spring Data Cassandra提供了自己的映射注解以达到同样的目的。</p>
<p>我们首先从Ingredient开始，它可以非常容易地映射到Cassandra上。如下是支持Cassandra的新Ingredient类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.mapping.PrimaryKey;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.mapping.Table;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@Table(&quot;ingredients&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ingredient</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PrimaryKey</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Type type;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去，Ingredient类与我前面所说的只需替换几个注解就可以的说法相矛盾。在这里，我们不再使用JPA持久化中的<code>@Entity</code>注解，而是使用了<code>@Table</code>注解，这表明配料将会持久化到名为ingredients的表中。另外，我们不再为id属性使用<code>@Id</code>，而是使用<code>@PrimaryKey</code>。到现在为止，我们似乎只是替换了几个注解而已。</p>
<p>但是，不要让Ingredient的映射欺骗了你。Ingredient是最简单的领域类型之一。如果我们将Taco类进行Cassandra持久化映射（如程序清单12.1所示），那就更有意思了。</p>
<p>程序清单12.1 为Taco类添加注解实现Cassandra持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.Size;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.cql.Ordering;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.cql.PrimaryKeyType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.mapping.Column;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.mapping.Table;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.rest.core.annotation.RestResource;</span><br><span class="line"><span class="keyword">import</span> com.datastax.driver.core.utils.UUIDs;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RestResource(rel=&quot;tacos&quot;, path=&quot;tacos&quot;)</span></span><br><span class="line"><span class="meta">@Table(&quot;tacos&quot;)</span>                                ⇽--- 持久化到tacos表</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taco</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PrimaryKeyColumn(type=PrimaryKeyType.PARTITIONED)</span>        ⇽--- 定义分区键</span><br><span class="line">  <span class="keyword">private</span> UUID id = UUIDs.timeBased();</span><br><span class="line">  <span class="meta">@NotNull</span></span><br><span class="line">  <span class="meta">@Size(min=5, message=&quot;Name must be at least 5 characters long&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@PrimaryKeyColumn(type=PrimaryKeyType.CLUSTERED,       ⇽--- 定义集群键</span></span><br><span class="line"><span class="meta">                    ordering=Ordering.DESCENDING)</span></span><br><span class="line">  <span class="keyword">private</span> Date createdAt = <span class="keyword">new</span> Date();</span><br><span class="line">  <span class="meta">@Size(min=1, message=&quot;You must choose at least 1 ingredient&quot;)</span></span><br><span class="line">  <span class="meta">@Column(&quot;ingredients&quot;)</span>                               ⇽--- 将列表映射到ingredients列</span><br><span class="line">  <span class="keyword">private</span> List&lt;IngredientUDT&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Taco类的映射会更加复杂。与Ingredient类似，它也使用<code>@Table</code>注解声明taco应该写入到名为tacos的表中。但是，这是它与Ingredient唯一的相似之处。</p>
<p>id属性依然是主键，但它只是两个主键列中的一个而已。具体来讲，id属性使用了@PrimaryKeyColumn注解，并且type的值为PrimaryKeyType.PARTITIONED。这表明id属性要作为分区键，用来确定taco数据的每一行要写入到哪个分区中。</p>
<p>你可能也会发现，id属性现在是UUID类型，而不是Long类型。虽然不是强制要求，但是保存系统生成的ID值的属性通常是UUID类型的。此外，针对新Taco对象，这里的UUID会使用基于时间的UUID进行初始化（但是，从数据库中读取已有Taco时，它可能会被覆盖）。</p>
<p>我们继续往下看，createdAt属性映射到了另外一个主键列。但是，在本例中，@PrimaryKeyColumn的type属性设置成了PrimaryKeyType.CLUSTERED，这意味着createdAt会作为集群键。按照前文所述，集群键用来确定行在集群中的顺序。更具体来讲，我们将顺序设置为降序，所以，在给定的分区中，较新的行会优先出现在taco表中。</p>
<p>最后，ingredients属性是一个IngredientUDT对象的List，而不再是Ingredient对象的List。Cassandra表是高度非规范化的，因此可能会包含与其他表重复的数据。尽管ingredient表代表了所有可用配料的记录，但是taco所选择的配料会重复保存到ingredients列中。我们不会简单地引用ingredients表中的一行或多行，而是会让ingredients属性包含所有已选配料的完整数据。</p>
<p>但是，我们为什么会引入新的IngredientUDT类呢？为何不重用Ingredient类呢？简而言之，包含数据集合的列，比如ingredients列，必须是原生类型（整型、字符串等）的集合或用户定义类型（user-defined type）的集合。</p>
<p>在Cassandra中，用户定义类型能够让我们声明比原生类型更丰富的表的列。通常，它们会作为关系型结构中外键的非规范化模拟形式。但是，外键只是引用另外一张表中的一行数据，与之不同，用户定义类型实际上会持有其他表中某行数据的副本。在tacos表的ingredients列中，它将会包含配料定义的数据结构集合。</p>
<p>我们不能将Ingredient用作用户定义类型，因为<code>@Table</code>注解已经将其映射成了Cassandra中的一个持久化实体。所以，我们必须创建一个新的类，定义该如何将配料信息存储到taco表的ingredients列上。IngredientUDT类（其中UDT代表了用户定义类型，即user-defined type）就是完成这项工作的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tacos;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.cassandra.core.mapping.UserDefinedType;</span><br><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)</span></span><br><span class="line"><span class="meta">@UserDefinedType(&quot;ingredient&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IngredientUDT</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Ingredient.Type type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管IngredientUDT和Ingredient看上去非常相似，但是它的映射需求要简单得多。它使用了<code>@UserDefinedType</code>注解，表明这是Cassandra中的用户定义类型。但是就其他方面来讲，它就是有几个属性的简单类。</p>
<p>我们会发现，IngredientUDT类没有包含id属性。尽管它也可以包含源Ingredient中id属性的副本，但是这样没有太大必要。实际上，用户定义类型可以包含任何想要的属性，它没有必要与表定义一一对应。</p>
<p>我发现，可视化用户定义类型与表中的持久化数据之间的关联关系是很困难的。图12.1展现了整个Taco Cloud数据库的数据模型，包含了用户定义类型。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/Sum/20211017213044.png" alt="image-20211017213043765"></p>
<center>图12.1 在这里不再使用外键和连接，Cassandra表是非规范化的，用户定义类型包含从关联表复制的数据</center>

<p>具体到我们刚刚创建的用户定义类型，需要注意Taco有一个IngredientUDT列表，其中包含了从Ingredient复制而来的数据。当Taco持久化的时候，Taco对象以及IngredientUDT列表都会持久化到tacos表中。IngredientUDT列表会完整地持久化到ingredients列中。</p>
<p>另外一种帮助我们理解用户定义类型如何使用的办法就是从数据库中查询tacos表的各个行。借助Cassandra提供的CQL和cqlsh工具，我们可以看到如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cqlsh:tacocloud&gt; select id, name, createdAt, ingredients from tacos;</span><br><span class="line">id        | name      | createdat | ingredients</span><br><span class="line">----------+-----------+-----------+---------------------------------------</span><br><span class="line"> 827390...| Carnivore | 2018-04...| [&#123;name: &#x27;Flour Tortilla&#x27;, type: &#x27;WRAP&#x27;&#125;,</span><br><span class="line">                                     &#123;name: &#x27;Carnitas&#x27;, type: &#x27;PROTEIN&#x27;&#125;,</span><br><span class="line">                                     &#123;name: &#x27;Sour Cream&#x27;, type: &#x27;SAUCE&#x27;&#125;,</span><br><span class="line">                                     &#123;name: &#x27;Salsa&#x27;, type: &#x27;SAUCE&#x27;&#125;,</span><br><span class="line">                                     &#123;name: &#x27;Cheddar&#x27;, type: &#x27;CHEESE&#x27;&#125;]</span><br><span class="line">(1 rows)</span><br></pre></td></tr></table></figure>

<p>从中可以看到，id、name和createdat列包含的都是简单的值。在这方面，它们与关系数据库的类似查询差别不大。ingredients列就不一样了，按照定义，它包含用户定义的ingredient类型（由IngredientUDT所定义）的集合，所以它的值显示为一个JSON数组，数组中则是JSON对象。</p>
<p>你可能也注意到了在图12.1中还有其他的用户定义类型。在继续将领域对象映射为Cassandra的过程中，我们肯定要创建更多的用户定义类型，其中包括Order类所用到的类型。程序清单12.2显示的Order类，针对Cassandra持久化进行了修改。</p>
<p>程序清单12.2 将Order类映射为Cassandra tacoorders表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table(&quot;tacoorders&quot;)</span>                             ⇽--- 映射到tacoorders表</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="meta">@PrimaryKey</span>                                ⇽--- 声明主键</span><br><span class="line">  <span class="keyword">private</span> UUID id = UUIDs.timeBased();</span><br><span class="line">  <span class="keyword">private</span> Date placedAt = <span class="keyword">new</span> Date();</span><br><span class="line">  <span class="meta">@Column(&quot;user&quot;)</span>                     ⇽--- 映射到user列</span><br><span class="line">  <span class="keyword">private</span> UserUDT user;</span><br><span class="line">  <span class="comment">// delivery and credit card properties omitted for brevity&#x27;s sake</span></span><br><span class="line">  <span class="meta">@Column(&quot;tacos&quot;)</span>                                      ⇽--- 将一个列表映射到tacos列</span><br><span class="line">  <span class="keyword">private</span> List&lt;TacoUDT&gt; tacos = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDesign</span><span class="params">(TacoUTD design)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tacos.add(design);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序清单12.2有意省略了Order的许多属性，这些属性不适合Cassandra数据建模的讨论。剩下的属性和映射方式类似于Taco的定义。就像以前使用<code>@Table</code>一样，在这里<code>@Table</code>用于将Order映射到tacoorders表。在本例中，我们不关注顺序，因此id属性只使用了<code>@PrimaryKey</code>注解，将其同时作为分区键和集群键，并采用了默认的排序。</p>
<p>tacos属性比较有趣，因为它是<code>List&lt;TacoUDT&gt;</code>，而不是Taco对象的列表。在这里，Order和Taco/TacoUDT之间的关系类似于前文中Taco和Ingredient/IngredientUDT之间的关系。也就是说，我们不是通过外键将不同表中的多行数据关联在一起，而是让Order表包含所有的taco数据，以便于优化表的快速读取。</p>
<p>类似的，user属性引用了UserUDT对象，它会持久化到user列中。同样，这与关系型数据库中连接另外一张表的策略是不同的。</p>
<p>至于TacoUDT，它与IngredientUDT类非常相似，不过它里面包含了对另外一个用户定义类型的引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@UserDefinedType(&quot;taco&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TacoUDT</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;IngredientUDT&gt; ingredients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UserUDT更有趣一点，因为它包含了3个属性，而不是两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UserDefinedType(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserUDT</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String fullname;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String phoneNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能够重用第3章定义的领域类或者仅仅将JPA注解替换为Cassandra注解，那当然很好，但是Cassandra持久化的本质特点是要求我们重新思考数据该如何建模。现在，我们已经映射好了领域模型，接下来该编写repository了。</p>
<h2 id="12-2-4-编写反应式Cassandra-repository"><a href="#12-2-4-编写反应式Cassandra-repository" class="headerlink" title="12.2.4 编写反应式Cassandra repository"></a>12.2.4 编写反应式Cassandra repository</h2><p>正如我们在第3章所看到的，使用Spring Data编写repository只需声明一个接口，让它扩展Spring Data的基础repository，并有选择性地声明用于自定义查询的方法即可。实际上，编写反应式repository并没有太大的不同。主要区别在于，我们需要扩展一个不同的基础repository接口，而且我们的方法将会处理反应式发布者，如Mono和Flux，而不再是领域类型和集合。</p>
<p>在编写反应式Cassandra repository时，我们有两个基础接口可选：ReactiveCassandraRepository和ReactiveCrudRepository。选择哪个接口很大程度上取决于该如何使用repository。ReactiveCassandraRepository扩展了ReactiveCrudRepository，提供了insert()方法的一些变种，如果要保存的对象是新建的，这些变种进行了优化。除此之外，ReactiveCassandraRepository提供了与ReactiveCrudRepository相同的操作。如果我们想要插入很多数据，那么可能需要选择ReactiveCassandraRepository；否则，最好选择ReactiveCrudRepository，因为在不同数据库类型之间它更具可移植性。</p>
<div style="border:1px solid;"><strong>Cassandra repository必须是反应式的吗？</strong><p>尽管我们本章主要关注如何使用Spring Data编写反应式repository，但是你可能想知道该如何为Cassandra编写非反应式的repository。如果是这样，那么我们需要让repository接口扩展非反应式的CrudRepository或CassandraRepository接口，而不是扩展ReactiveCrud Repository或ReactiveCassandraRepository。我们的repository方法就可以返回带有Cassandra相关注解的领域类型或这些领域类型的集合，而不再是Flux和Mono。</p><p>如果你准备采用非反应式的repository，那么可以将starter依赖从spring-boot-starter-data-cassandra-reactive修改为spring-boot-starter-data-cassandra，不过这并不是严格要求的。</p></div>

<p>重新看一下我们为Taco Cloud编写的repository，要使它们变成反应式的，我们首先让它们扩展ReactiveCrudRepository或ReactiveCassandraRepository，而不再是CrudRepository。我们首先看一下IngredientRepository。除了使用配料数据初始化数据库之外，我们不会插入很多的新配料数据。所以，IngredientRepository可以扩展ReactiveCrudRepository，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IngredientRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveCrudRepository</span>&lt;<span class="title">Ingredient</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不需要在IngredientRepository中定义任何的自定义查询，所以要将IngredientRepository变成反应式repository，并不需要额外的工作。现在，它扩展了ReactiveCrud Repository，所以它的方法处理的都是Flux和Mono。例如，findAll()方法现在返回的是<code>Flux&lt;Ingredient&gt;</code>，而不是<code>Iterable&lt;Ingredient&gt;</code>。所以，在使用它的时候，要按照正确的方式来使用。比如，IngredientController需要重写为返回<code>Flux&lt;Ingredient&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Flux&lt;Ingredient&gt; <span class="title">allIngredients</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> repo.findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TacoRepository的变更要稍微复杂一些。我们不用像非反应式repository那样扩展PagingAndSortingRepository，而是可以扩展ReactiveCassandraRepository。在参数化Taco对象的时候，不能使用Long类型的ID属性，在与Taco对象协作的时候，要使用UUID类型的ID：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TacoRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveCrudRepository</span>&lt;<span class="title">Taco</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这个新TacoRepository的findAll()方法会返回<code>Flux&lt;Ingredient&gt;</code>，所以我们不用让它扩展PagingAndSortingRepository，也不用操作分页的数据。相反，在DesignTacoController的recentTacos()方法中，我们只需要调用返回的Flux的take()方法来限制要消费的Taco对象的数量即可（实际上，在11.1.2节中，我们已经修改了DesignTacoController和它的recentTacos()方法）。</p>
<p>OrderRepository所需的变更也很简单。我们不再扩展CrudRepository，而是让它扩展ReactiveCassandraRepository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveCassandraRepository</span>&lt;<span class="title">Order</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们来看一下UserRepository。我们可能还记得，UserRepository有一个自定义的查询方法，即findByUsername()。这个方法让定义Cassandra持久化repository有了一些变化。支持Cassandra的UserRepository代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span></span></span><br><span class="line"><span class="class">         <span class="keyword">extends</span> <span class="title">ReactiveCassandraRepository</span>&lt;<span class="title">User</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@AllowFiltering</span></span><br><span class="line">  <span class="function">Mono&lt;User&gt; <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与其他的repository接口（除了IngredientRepository）类似，UserRepository也扩展了ReactiveCassandraRepository。到目前为止，没有感到惊讶的地方。但是，它的findByUsername()方法我们需要注意一下。</p>
<p>首先，因为这是一个反应式repository，所以findByUsername()不会再简单地返回User对象。我们对其进行了重新定义，让它返回<code>Mono&lt;User&gt;</code>。一般而言，在反应式repository中，我们自定义的查询方法应该要么返回Mono（要返回的值不超过一个），要么返回Flux（会有多个返回值）。</p>
<p>同时，按照Cassandra的特点，在查询表的时候，我们不能像在关系型数据库的SQL中那样简单地使用where子句。Cassandra对读取进行了优化，但是使用where子句进行过滤可能会拖慢其他快速查询的速度。即便如此，根据一个或多个列对表进行查询还是非常有用的。因此，@AllowFiltering注解使结果的过滤变成了现实，它可以作为这些场景的可用方案。</p>
<p>在findByUsername()中，我们预期的CQL查询如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;some username&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>同样，Cassandra是不允许这样做的。但是，在将<code>@AllowFiltering</code>注解放到findByUsername()方法上之后，所形成的CQL查询如下所示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> username<span class="operator">=</span><span class="string">&#x27;some username&#x27;</span> allow filtering;</span><br></pre></td></tr></table></figure>

<p>查询末尾的allow filtering子句提醒Cassandra，我们已经意识到查询性能的潜在影响，并且无论如何都需要它。在这种情况下，Cassandra将允许使用where子句并按需过滤结果。</p>
<p>Cassandra中有很多强大功能，当它与Spring Data和Reactor结合使用时，我们可以在Spring应用中充分使用这些功能。但是，让我们把注意力转移到支持反应式repository的另一个数据库上来，那就是MongoDB。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/Infinity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/Infinity/" class="post-title-link" itemprop="url">12.0 第12章 反应式持久化数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-17 11:59:29" itemprop="dateCreated datePublished" datetime="2021-10-17T11:59:29+08:00">2021-10-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-04-03 01:21:18" itemprop="dateModified" datetime="2022-04-03T01:21:18+08:00">2022-04-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">6 Spring实战(第5版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/" itemprop="url" rel="index"><span itemprop="name">第3部分 反应式Spring</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/6-Spring%E5%AE%9E%E6%88%98-%E7%AC%AC5%E7%89%88/%E7%AC%AC3%E9%83%A8%E5%88%86-%E5%8F%8D%E5%BA%94%E5%BC%8FSpring/%E7%AC%AC12%E7%AB%A0-%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">第12章 反应式持久化数据</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/Infinity/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/Infinity/" data-xid="/JavaReadingNotes/Infinity/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>658</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第12章-反应式持久化数据"><a href="#第12章-反应式持久化数据" class="headerlink" title="第12章 反应式持久化数据"></a>第12章 反应式持久化数据</h1><div style="border:1px solid;"><strong>本章内容</strong>：<ul><li></li><li>- Spring Data的反应式repository</li><li>- 为Cassandra和MongoDB编写反应式repository</li><li>- 以反应式的方式使用非反应式的repository</li><li>- Cassandra的数据模型</li></ul></div>

<p>在思考非阻塞的反应式代码和阻塞的命令式代码时，我经常会想到上下班的高峰时刻（rush hour）。高峰时刻是一个很奇怪的名字。每个人都急着去他们想到的地方，但是我们通常只能几乎一动不动地坐在车流之中。如果路上没有其他人，我们能够轻而易举地到达目的地。</p>
<p>即便我非常希望到达某个地方（我没有阻塞），但是这并不意味着路上没有其他人挡着我。前面可能有其他司机发生了剐蹭事故，阻塞了其他车辆的通行。所以即使我本可以畅通无阻地回到家中，但此刻我也只能阻塞在这里等待事故清理完成。</p>
<p>在前面的章节中，我们看到了如何使用Spring WebFlux创建反应式、非阻塞的控制器。这样能够帮助我们提升Web层的可扩展性。但是，只有当与这些控制器协作的其他组件都是非阻塞的时候，它们本身才能是非阻塞的。如果我们编写的SpringWebFlux控制器依赖于阻塞的repository，那么反应式控制器需要阻塞等待它们生成数据。</p>
<p>因此，很重要的一点在于，要让整个数据流变成反应式和非阻塞的，也就是从控制器直到数据库。在本章中，我们将会看到如何使用Spring Data编写反应式的repository，这些repository与我们在第3章看到的编程模型非常类似。我们首先从整体上了解一下Spring Data对反应式的支持。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/31/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/31/">31</a><span class="page-number current">32</span><a class="page-number" href="/JavaReadingNotes/page/33/">33</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/33/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/32/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-mzjszagu6-lanlan2017.vercel.app","placeholder":"填写您的邮箱以便接收回复提醒,填写您个人网站地址以便为您增加访问量","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/32/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
