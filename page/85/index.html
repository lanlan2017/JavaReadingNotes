<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/85/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/85/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/85/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/94bed61f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/94bed61f/" class="post-title-link" itemprop="url">17.2 Java的基本网络支持 17.2.1 使用InetAddress</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-14 05:09:53" itemprop="dateCreated datePublished" datetime="2020-01-14T05:09:53+08:00">2020-01-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-02-07 01:34:56" itemprop="dateModified" datetime="2020-02-07T01:34:56+08:00">2020-02-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第17章 网络编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17-2-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BD%91%E7%BB%9C%E6%94%AF%E6%8C%81/" itemprop="url" rel="index"><span itemprop="name">17.2 Java的基本网络支持</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/94bed61f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/94bed61f/" data-xid="/JavaReadingNotes/94bed61f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="17-2-Java的基本网络支持"><a href="#17-2-Java的基本网络支持" class="headerlink" title="17.2 Java的基本网络支持"></a>17.2 Java的基本网络支持</h1><p><code>Java</code>为网络支持提供了<code>java.net</code>包,该包下的</p>
<ul>
<li><code>URL</code>和<code>URLConnection</code>等类提供了以编程方式访问<code>Web</code>服务的功能,</li>
<li>而<code>URLDecoder</code>和<code>URLEncoder</code>则提供了普通字符串和<code>application/x-www-form-urlencoded MIME</code>字符串相互转换的静态方法.</li>
</ul>
<h1 id="17-2-1-使用InetAddress"><a href="#17-2-1-使用InetAddress" class="headerlink" title="17.2.1 使用InetAddress"></a>17.2.1 使用InetAddress</h1><p><code>Java</code>提供了<code>InetAddress</code>类来代表<code>IP</code>地址,<code>InetAddress</code>下还有两个子类:<code>Inet4Address</code>、<code>Inet6Adress</code>它们分别代表<code>Internet Protocol version 4(IPv4)</code>地址和<code>Internet Protocol version 6(IP6)</code>地址。</p>
<h2 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a><code>InetAddress</code>类</h2><h3 id="获取InetAddress类对象"><a href="#获取InetAddress类对象" class="headerlink" title="获取InetAddress类对象"></a>获取<code>InetAddress</code>类对象</h3><p><code>InetAddress</code>类没有提供构造器,而是提供了如下两个静态方法来获取<code>InetAddress</code>实例</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static InetAddress getByName(String host)</code></td>
<td align="left">根据主机获取对应的<code>InetAddress</code>对象</td>
</tr>
<tr>
<td align="left"><code>static InetAddress getByAddress(byte[] addr)</code></td>
<td align="left">根据原始<code>IP</code>地址来获取对应的<code>InetAddress</code>对象</td>
</tr>
</tbody></table>
<p>除此之外,<code>InetAddress</code>类还提供了一个<code>getLocalHost()</code>方法来获取<strong>本机<code>IP</code>地址对应的<code>InetAddress</code>实例</strong>。</p>
<h3 id="读取InetAddress对象的IP地址和主机名"><a href="#读取InetAddress对象的IP地址和主机名" class="headerlink" title="读取InetAddress对象的IP地址和主机名"></a>读取<code>InetAddress</code>对象的IP地址和主机名</h3><p><code>InetAddress</code>还提供了如下三个方法来获取<code>InetAddress</code>实例对应的<code>IP</code>地址和主机名。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>String getCanonicalHostName()</code></td>
<td align="left">获取此<code>IP</code>地址的全限定域名。</td>
</tr>
<tr>
<td align="left"><code>String getHostAddress()</code></td>
<td align="left">返回该<code>InetAddress</code>实例对应的<code>IP</code>地址字符串(以字符串形式)。</td>
</tr>
<tr>
<td align="left"><code>String getHostName()</code></td>
<td align="left">获取此<code>IP</code>地址的主机名</td>
</tr>
</tbody></table>
<h3 id="判断IP地址是否可达"><a href="#判断IP地址是否可达" class="headerlink" title="判断IP地址是否可达"></a>判断IP地址是否可达</h3><p><code>Inetaddress</code>类还提供了一个<code>isReachable()</code>方法,用于测试是否可以到达该地址。该方法将尽最大努力试图到达主机,但防火墙和服务器配置可能阻塞请求,使得它在访问某些特定的端口时处于不可达状态。如果可以获得权限,典型的实现将使用<code>ICMP ECHO REQUEST</code>；否则它将试图在目标主机的<strong>端口7</strong>(<code>Echo</code>)上建立<code>TCP</code>连接。</p>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>下面程序测试了<code>InetAddress</code>类的简单用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 根据主机名来获取对应的InetAddress实例</span></span><br><span class="line">        InetAddress ip = InetAddress.getByName(<span class="string">&quot;lanlan2017.github.io&quot;</span>);</span><br><span class="line">        <span class="comment">// 判断是否可达</span></span><br><span class="line">        System.out.println(<span class="string">&quot;lanlan2017.github.io是否可达：&quot;</span> + ip.isReachable(<span class="number">2000</span>));</span><br><span class="line">        <span class="comment">// 获取该InetAddress实例的IP字符串</span></span><br><span class="line">        System.out.println(ip.getHostAddress());</span><br><span class="line">        <span class="comment">// 根据原始IP地址来获取对应的InetAddress实例</span></span><br><span class="line">        InetAddress local = InetAddress.getByAddress(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;本机是否可达：&quot;</span> + local.isReachable(<span class="number">5000</span>));</span><br><span class="line">        <span class="comment">// 获取该InetAddress实例对应的全限定域名</span></span><br><span class="line">        System.out.println(local.getCanonicalHostName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序简单地示范了<code>Inetaddress</code>类的几个方法的用法,<code>InetAddress</code>类本身并没有提供太多功能,它代表一个<strong>IP地址对象</strong>,是网络通信的基础,在后面介绍中将大量使用该类</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/64a8da7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/64a8da7/" class="post-title-link" itemprop="url">17.1 网络编程的基础知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-13 08:37:50" itemprop="dateCreated datePublished" datetime="2020-01-13T08:37:50+08:00">2020-01-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-02-07 01:34:56" itemprop="dateModified" datetime="2020-02-07T01:34:56+08:00">2020-02-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第17章 网络编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">17.1 网络编程的基础知识</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/64a8da7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/64a8da7/" data-xid="/JavaReadingNotes/64a8da7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="17-1-1-网络基础知识"><a href="#17-1-1-网络基础知识" class="headerlink" title="17.1.1 网络基础知识"></a>17.1.1 网络基础知识</h1><p>所谓计算机网络,就是把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统,从而使众多的计算机可以方便地互相传递信息,共享硬件、软件、数据信息等资源<br>计算机网络是现代通信技术与计算机技术相结合的产物,计算机网络可以提供以下一些主要功能。</p>
<ul>
<li>资源共享。</li>
<li>信息传输与集中处理。</li>
<li>均衡负荷与分布处理</li>
<li>综合信息服务。</li>
</ul>
<p>通过计算机网络可以向全社会提供各种经济信息、科研情报和咨询服务。其中,国际互联网<code>Internet</code>上的全球信息网(<code>WWW,World Wide Web</code>)服务就是一个最典型也是最成功的例子。实际上,今天的网络承载绝大部分大型企业的运转,一个大型的、全球性的企业或组织的日常工作流程都是建立在互联网基础之上的。</p>
<h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>计算机网络的品种很多,根据各种不同的分类原则,可以得到各种不同类型的计算机网络。</p>
<p>计算机网络通常是<strong>按照规模大小和延伸范围来分类</strong>的,常见的划分为:局域网(<code>LAN</code>)、城域网(<code>MAN</code>)、厂域网(<code>WAN</code>)。<code>Internet</code>可以视为世界上最大的广域网。<br>如果按照网络的拓扑结构来划分,可以分为<strong>星型网络</strong>、<strong>总线型网络</strong>、<strong>环型网络</strong>、<strong>树型网络</strong>、星型环型网络等;</p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>如果<strong>按照网络的传输介质来划分</strong>,可以分为双绞线网、同轴电缆网、光纤网和卫星网等。<br>计算机网络中实现通信必须有一些约定,这些约定被称为通信协议。通信协议负责对传输速率、传输代码、代码结构、传输控制步骤、岀错控制等制定处理标准。为了让两个节点之间能进行对话,必须在它们之间建立通信工具,使彼此之间能进行信息交换。</p>
<h3 id="通信协议组成"><a href="#通信协议组成" class="headerlink" title="通信协议组成"></a>通信协议组成</h3><p><strong>通信协议</strong>通常由三部分组成:</p>
<ul>
<li>一是<strong>语义</strong>部分,用于决定双方对话的类型;</li>
<li>二是<strong>语法</strong>部分,用于决定双方对话的格式;</li>
<li>三是<strong>变换规则</strong>,用于决定通信双方的应答关系。</li>
</ul>
<h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>国际标准化组织<code>ISO</code>于1978年提出“开放系统互连参考模型”,即著名的<code>OSI(Open System Interconnection)</code>。</p>
<p>开放系统互连参考模型力求将网络简化,并以模块化的方式来设计网络。<br>开放系统互连参考模型把计算机网络分成</p>
<ul>
<li><strong>物理层</strong>、</li>
<li><strong>数据链路层</strong>、</li>
<li><strong>网络层</strong>、</li>
<li><strong>传输层</strong>、</li>
<li><strong>会话层</strong>、</li>
<li><strong>表示层</strong>、</li>
<li><strong>应用层</strong></li>
</ul>
<p>这七层</p>
<p>通过十多年的发展和推进,<code>OSI</code>模式已成为各种计算机网络结构的参考标准<br>图17.1显示了<code>OSI</code>参考模型的推荐分层。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter17/17.1.1/2.png" alt="这里有一张图片"></p>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>前面介绍过通信协议是网络通信的基础,<code>IP</code>协议则是一种非常重要的通信协议。<code>IP(Internet Protocol)</code>协议又称<strong>互联网协议</strong>,是支持网间互联的数据报协议。它提供网间连接的完善功能,包括<code>IP</code>数据报规定互联网络范围内的地址格式</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>经常与<code>IP</code>协议放在一起的还有<code>TCP(Transmission Control protocol)</code>协议,即<strong>传输控制协议</strong>,它规定一种可靠的数据信息传递服务。虽然<code>IP</code>和<code>TCP</code>这两个协议功能不尽相同,也可以分开单独使用,但它们是在同一个时期作为一个协议来设计的,并且在功能上也是互补的。因此实际使用中常常把这两个协议统称为<code>TCP/IP</code>协议,<code>TCP/IP</code>协议最早出现在<code>UNIX</code>操作系统中,现在几乎所有的操作系统都支持<code>TCPP</code>协议,因此<code>TCP/IP</code>协议也是<code>Internet</code>中最常用的基础协议。</p>
<h2 id="TCP-IP和OSI分层的关系"><a href="#TCP-IP和OSI分层的关系" class="headerlink" title="TCP/IP和OSI分层的关系"></a>TCP/IP和OSI分层的关系</h2><p>按<code>TCP/IP</code>协议模型,网络通常被分为一个四层模型,这个四层模型和前面的<code>OSI</code>七层模型有大致的对应关系,图17.2显示了<code>TCPP</code>分层模型和<code>OSI</code>分层模型之间的对应关系。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter17/17.1.1/1.png" alt="这里有一张图片"></p>
<h1 id="17-1-2-IP地址和端口号"><a href="#17-1-2-IP地址和端口号" class="headerlink" title="17.1.2 IP地址和端口号"></a>17.1.2 IP地址和端口号</h1><p><code>IP</code>地址用于唯一地标识网络中的一个通信实体,这个通信实体既可以是一台主机,也可以是一台打印机,或者是路由器的某一个端口。而在基于<code>IP</code>协议网络中传输的数据包,都必须使用P地址来进行标识。<br>就像写一封信,要标明收信人的通信地址和发信人的地址,而邮政工作人员则通过该地址来决定邮件的去向。类似的过程也发生在计算机网络里,每个<strong>被传输的数据包也要包括一个<code>源IP地址</code>和一个<code>目的IP地址</code></strong>,当该数据包在网络中进行传输时,这两个地址要保持不变,以确保网络设备总能根据确定的P地址,将数据包从源通信实体送往指定的目的通信实体。</p>
<p><code>IP</code>地址是数字型的,IP地址是一个32位(32 bit)整数,但通常为了便于记忆,通常把它分成4个8位的二进制数,每8位之间用圆点隔开,每个8位整数可以转换成一个0~255的<strong>十进制整数</strong>,因此日常看到的<code>IP</code>地址常常是这种形式:<code>202.9.128.88</code>。</p>
<p><code>NIC</code>(<code>Internet Network Information Center</code>)统一负责全球<code>Internet IP</code>地址的规划、管理,而<code>Inter NIC</code>、 <code>APNIC</code>、<code>RIPE</code>三大网络信息中心具体负责美国及其他地区的<code>IP</code>地址分配。其中<code>APNIC</code>负责亚太地区的IP管理,我国申请<code>IP</code>地址也要通过<code>APNIC</code>,<code>APNIC</code>的总部设在日本东京大学。</p>
<h2 id="五类IP地址"><a href="#五类IP地址" class="headerlink" title="五类IP地址"></a>五类IP地址</h2><p><code>IP</code>地址被分成了A、B、C、D、E五类,每个类别的网络标识和主机标识各有规则。</p>
<ul>
<li>A类:10.0.0.0~10.255.255.255</li>
<li>B类:172.16.0.0~172.31.255.255</li>
<li>C类:192.168.0.0~192.168.255.255</li>
</ul>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p><code>IP</code>地址用于唯一地标识网络上的一个通信实体,但<strong>一个通信实体可以有多个通信程序同时提供网络服务,此时还需要使用端口</strong>。<br>端口是一个<strong>16位的整数</strong>,用于表示数据交给哪个通信程序处理。因此,<strong>端口就是应用程序与外界交流的出入口</strong>,它是一种抽象的软件结构,包括一些数据结构和<code>IO</code>(基本输入输出)缓冲区。<br>不同的应用程序处理不同端口上的数据,<strong>同一台机器上不能有两个程序使用同一个端口</strong>,<strong>端口号可以从0到65535</strong>。</p>
<h3 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a>端口分类</h3><p>通常将端口分为如下三类:</p>
<ul>
<li>公认端口(<code>Well Known Ports</code>):<strong>从0到1023</strong>,它们紧密绑定(<code>Binding</code>)一些特定的服务</li>
<li>注册端口(<code>Registered Ports</code>):<strong>从1024到49151</strong>,它们松散地绑定一些服务。应用程序通常应该使用这个范围内的端口.</li>
<li>动态和或私有端口(<code>Dynamic And/or Private Ports</code>):从49152到65535,这些端口是应用程序使用的动态端口,应用程序一般不会主动使用这些端口</li>
</ul>
<p>如果把<code>IP</code>地址理解为某个人所在地方的地址(包括街道和门牌号),但仅有地址还是找不到这个人,还需要知道他所在的房号才可以找到这个人。因此如果把应用程序当作人,把计算机网络当作类似邮递员的角色,当一个程序需要发送数据时,需要指定目的地的<code>IP</code>地址和端口,如果指定了正确的<code>IP</code>地址和端口号,计算机网络就可以将数据送给该<code>IP</code>地址和端口所对应的程序。</p>
<!-- CrazyJavaHandout4/Chapter17/17.1.1/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6e1b7e8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6e1b7e8f/" class="post-title-link" itemprop="url">17.0 第17章 前言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-13 01:44:19" itemprop="dateCreated datePublished" datetime="2020-01-13T01:44:19+08:00">2020-01-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-02-07 01:34:56" itemprop="dateModified" datetime="2020-02-07T01:34:56+08:00">2020-02-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第17章 网络编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17-0-%E5%89%8D%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">17.0 前言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6e1b7e8f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6e1b7e8f/" data-xid="/JavaReadingNotes/6e1b7e8f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>935</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第17章-网络编程-前言"><a href="#第17章-网络编程-前言" class="headerlink" title="第17章 网络编程 前言"></a>第17章 网络编程 前言</h1><h2 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h2><ul>
<li>计算机网络基础</li>
<li><code>IP</code>地址和端口</li>
<li>使用<code>InetAddress</code>包装<code>IP</code>地址</li>
<li>使用<code>URLEncoder</code>和<code>URLDecoder</code>工具类</li>
<li>使用<code>URLConnection</code>访问远程资源</li>
<li><code>TCP</code>协议基础</li>
<li>使用<code>ServerSocket</code>和<code>Socket</code></li>
<li>使用<code>NIO</code>实现非阻塞式网络通信</li>
<li>使用<code>AIO</code>实现异步网络通信</li>
<li><code>UDP</code>协议基础</li>
<li>使用<code>DatagramSocket</code>发送/接收数据报(<code>DatagramPacket</code>)</li>
<li>使用<code>MulticastSocket</code>实现多点广播</li>
<li>通过<code>Proxy</code>使用代理服务器</li>
<li>通过<code>ProxySelector</code>使用代理服务器</li>
</ul>
<p>本章将主要介绍<code>Java</code>网络通信的支持,通过这些网络支持类,<code>Java</code>程序可以非常方便地访问互联网上的<code>HTTP</code>服务、<code>FTP</code>服务等,并可以直接取得互联网上的远程资源,还可以向远程资源发送<code>GET</code>、<code>POST</code>请求</p>
<h2 id="介绍网络工具类"><a href="#介绍网络工具类" class="headerlink" title="介绍网络工具类"></a>介绍网络工具类</h2><p>本章先简要介绍计算机网络的基础知识,包括酽地址和端口等概念,这些知识是网络编程的基础。本章会详细介绍<code>InetAddress</code>、<code>URLDecoder</code>、<code>URLEncoder</code>、<code>URL</code>和<code>URLConnection</code>等网络工具类,并会深入介绍通过<code>URLConnection</code>发送请求、访问远程资源等操作。</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>本章将重点介绍<code>Java</code>提供的<code>TCP</code>网络通信支持,包括如何利用<code>ServerSocket</code>建立<code>TCP</code>服务器,利用<code>Socket</code>建立<code>TCP</code>客户端。实际上<code>Java</code>的网络通信非常简单,服务器端通过<code>ServerSocket</code>建立监听,客户端通过<code>Socket</code>连接到指定服务器后,通信双方就可以通过IO流进行通信。本章将以采用逐步迭代的方式开发一个C/S结构多人网络聊天工具为例,向读者介绍基于<code>TCP</code>协议的网络编程。</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>本章还将重点介绍<code>Java</code>提供的<code>UDP</code>网络通信支持,主要介绍如何使用<code>DatagramSocket</code>来发送、接收数据报(<code>DatagramPacket</code>),并讲解如何使用<code>MulticastSocket</code>来实现多点广播通信。本章也将以开发局域网通信程序为例来介绍<code>MulticastSocket</code>和<code>DatagramSocket</code>的实际用法</p>
<h2 id="代理服务器访问远程资源"><a href="#代理服务器访问远程资源" class="headerlink" title="代理服务器访问远程资源"></a>代理服务器访问远程资源</h2><p>本章最后还会介绍利用<code>Proxy</code>和<code>ProxySelector</code>在<code>Java</code>程序中通过代理服务器访问远程资源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/37d7c517/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/37d7c517/" class="post-title-link" itemprop="url">16.10 本章小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 05:11:57" itemprop="dateCreated datePublished" datetime="2020-01-11T05:11:57+08:00">2020-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-28 03:14:50" itemprop="dateModified" datetime="2020-03-28T03:14:50+08:00">2020-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-10-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">16.10 本章小结</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/37d7c517/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/37d7c517/" data-xid="/JavaReadingNotes/37d7c517/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>554</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-10-本章小结"><a href="#16-10-本章小结" class="headerlink" title="16.10 本章小结"></a>16.10 本章小结</h1><p>本章主要介绍了<code>Java</code>的多线程编程支持:</p>
<ul>
<li>简要介绍了线程的基本概念,并讲解了线程和进程之间的区别与联系。</li>
<li>本章详细讲解了如何创建、启动多线程,并对比了三种创建多线程方式之间的优势和劣势,也详细介绍了线程的生命周期。</li>
<li>本章通过示例程序示范了控制线程的几个方法,</li>
<li>还详细讲解了线程同步的意义和必要性,并介绍了三种不同的线程同步方法:<ul>
<li>同步方法、</li>
<li>同步代码块，</li>
<li>显式使用<code>Lock</code>控制线程同步。</li>
</ul>
</li>
<li>本章也介绍了三种实现线程通信的方式:<ul>
<li>使用同步监视器的方法实现通信、</li>
<li>显式使用<code>Condition</code>对象实现线程通信，</li>
<li>使用阻塞对象实现线程通信。</li>
</ul>
</li>
</ul>
<p>此外,本章还介绍了线程组和线程池,由于线程属于创建成本较大的对象,因此程序应该考虑复用线程,线程池是在实际开发中不错的选择.<br>本章最后介绍了线程相关的工具类,比如<code>ThreadLocal</code>，线程安全的集合类，以及如果使用<code>Collections</code>包装线程不安全的集合类.</p>
<h1 id="本章练习"><a href="#本章练习" class="headerlink" title="本章练习"></a>本章练习</h1><ol>
<li>写2个线程,其中一个线程打印<code>1~52</code>,另一个线程打印<code>A~Z</code>,<strong>每两个数字后打印一个字母</strong>,也就是打印顺序应该是<code>12A34B56C...5152Z</code>。该习题需要利用多线程通信的知识。</li>
<li>假设车库有3个车位(可以用<code>boolean</code>口数组来表示车库)可以停车,写一个程序模拟多个用户开车离开、停车入库的效果。注意:车位有车时不能停车</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/b58c8736/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/b58c8736/" class="post-title-link" itemprop="url">16.9.4 Java9新增的发布-订阅框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 04:15:24" itemprop="dateCreated datePublished" datetime="2020-01-11T04:15:24+08:00">2020-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-28 03:12:04" itemprop="dateModified" datetime="2020-03-28T03:12:04+08:00">2020-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/b58c8736/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/b58c8736/" data-xid="/JavaReadingNotes/b58c8736/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-4-Java9新增的发布-订阅框架"><a href="#16-9-4-Java9新增的发布-订阅框架" class="headerlink" title="16.9.4 Java9新增的发布-订阅框架"></a>16.9.4 Java9新增的发布-订阅框架</h1><p><code>Java9</code>新增了一个发布-订阅框架,该框架是基于<code>异步响应流</code>的。这个发布-订阅框架可以非常方便地处理异步线程之间的<code>流数据交换</code>(比如两个线程之间需要交换数据)。而且这个发布-订阅框架不需要使用数据中心来缓冲数据,同时具有非常高效的性能。</p>
<h2 id="Flow类静态内部接口"><a href="#Flow类静态内部接口" class="headerlink" title="Flow类静态内部接口"></a>Flow类静态内部接口</h2><p>这个发布订阅框架使用<code>Flow</code>类的4个静态内部接口作为核心<code>API</code></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static interface Flow.Publisher&lt;T&gt;</code></td>
<td align="left">代表数据发布者、生产者</td>
</tr>
<tr>
<td align="left"><code>static interface Flow.Subscriber&lt;T&gt;</code></td>
<td align="left">代表数据订阅者、消费者</td>
</tr>
<tr>
<td align="left"><code>static interface Flow.Subscription</code></td>
<td align="left">代表发布者和订阅者之间的链接纽带。<br>订阅者既可通过调用该对象的<code>request()</code>方法来获取数据项,<br>也可通过调用对象的<code>cancel()</code>方法来取消订阅。</td>
</tr>
<tr>
<td align="left"><code>static interface Flow.Processor&lt;T,​R&gt;</code></td>
<td align="left">数据处理器,它可同时作为发布者和订阅者使用</td>
</tr>
</tbody></table>
<h2 id="Flow-Publisher接口方法"><a href="#Flow-Publisher接口方法" class="headerlink" title="Flow.Publisher接口方法"></a><code>Flow.Publisher</code>接口方法</h2><p><code>Flow.Publisher</code>作为<strong>生产者</strong>,负责发布数据项,并注册订阅者。<code>Flow.Publisher</code>接口定义了如下方法来注册订阅者。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)</code></td>
<td align="left">程序调用此方法注册订阅者时,会触发订阅者的<code>onSubscribe()</code>方法,将<code>Flow.Subscription</code>对象作为参数传给该方法;<br>如果注册失败,将会触发订阅者的<code>onError()</code>方法。</td>
</tr>
</tbody></table>
<h2 id="Flow-Subscriber接口方法"><a href="#Flow-Subscriber接口方法" class="headerlink" title="Flow.Subscriber接口方法"></a><code>Flow.Subscriber</code>接口方法</h2><p><code>Flow.Subscriber</code>接口定义了如下方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void onSubscribe(Flow.Subscription subscription)</code></td>
<td align="left">订阅者注册时自动触发该方法</td>
</tr>
<tr>
<td align="left"><code>void onComplete()</code></td>
<td align="left">当订阅结束时触发该方法</td>
</tr>
<tr>
<td align="left"><code>void onError(Throwable throwable)</code></td>
<td align="left">当订阅失败时触发该方法</td>
</tr>
<tr>
<td align="left"><code>void onNext(T item)</code></td>
<td align="left">订阅者从发布者处获取数据项时触发该方法,订阅者可通过该方法获取数据项</td>
</tr>
</tbody></table>
<h2 id="Flow-Publisher的SubmissionPublisher实现类"><a href="#Flow-Publisher的SubmissionPublisher实现类" class="headerlink" title="Flow.Publisher的SubmissionPublisher实现类"></a><code>Flow.Publisher</code>的<code>SubmissionPublisher</code>实现类</h2><p>为了处理一些通用发布者的场景,<code>Java9</code>为<code>Flow.Publisher</code>提供了一个<code>SubmissionPublisher</code>实现类,它可向当前订阅者异步提交非空的数据项,直到它被关闭。每个订阅者都能以相同的顺序接收到新提交的数据项。<br>程序创建<code>SubmissionPublisher</code>对象时,需要传入一个线程池作为底层支撑;该类也提供了一个无参数的构造器,该构造器使用<code>ForkJoinPool.commonPool()</code>方法来提交发布者,以此实现发布者向订阅者提供数据项的异步特性。</p>
<h2 id="程序示例-使用SubmissionPublisher作为发布者"><a href="#程序示例-使用SubmissionPublisher作为发布者" class="headerlink" title="程序示例 使用SubmissionPublisher作为发布者"></a>程序示例 使用<code>SubmissionPublisher</code>作为发布者</h2><p>下面程序示范了使用<code>SubmissionPublisher</code>作为发布者的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Flow.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PubSubTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个SubmissionPublisher作为发布者</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> SubmissionPublisher&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建订阅者</span></span><br><span class="line">        MySubscriber&lt;String&gt; subscriber = <span class="keyword">new</span> MySubscriber&lt;&gt;();</span><br><span class="line">        <span class="comment">// 注册订阅者</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line">        <span class="comment">// 发布几个数据项</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开发发布数据...&quot;</span>);</span><br><span class="line">        List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Erlang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;Lua&quot;</span>).forEach(im -&gt; &#123;</span><br><span class="line">            <span class="comment">// 提交数据</span></span><br><span class="line">            publisher.submit(im);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 发布结束</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="comment">// 发布结束后，为了让发布者线程不会死亡，暂停线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;fkjava&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="string">&quot;fkjava&quot;</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建订阅者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 发布者与订阅者之间的纽带</span></span><br><span class="line">    <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 订阅时触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Subscription subscription)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">        <span class="comment">// 开始请求数据</span></span><br><span class="line">        subscription.request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 接收到数据时触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到数据: &quot;</span> + item);</span><br><span class="line">        <span class="comment">// 请求下一条数据</span></span><br><span class="line">        subscription.request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 订阅出错时触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;fkjava&quot;</span>) &#123;</span><br><span class="line">            <span class="string">&quot;fkjava&quot;</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 订阅结束时触发该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅结束&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;fkjava&quot;</span>) &#123;</span><br><span class="line">            <span class="string">&quot;fkjava&quot;</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中先创建<code>SubmissionPublisher</code>对象,该对象可作为发布者;然后创建订阅者对象,该订阅者类是一个自定义类;接着注册订阅者。<br>完成上面步骤之后,程序即可<strong>调用<code>SubmissionPublisher</code>对象的<code>submit()</code>方法来发布数据项,发布者通过该方法发布数据项</strong>。<br>上面程序实现了一个自定义的订阅者,该<strong>订阅者实现了<code>Subscriber</code>接口的4个方法,重点就是实现<code>onNext()</code>方法,当订阅者获取到数据时就会触发这个<code>onNext()</code>方法,订阅者通过该方法接收数据</strong>。<br>至于订阅者接收到数据项之后的处理,则取决于程序的业务需求<br>运行该程序,可以看到订阅者逐项获得数据的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开发发布数据...</span><br><span class="line">获取到数据: Java</span><br><span class="line">获取到数据: Kotlin</span><br><span class="line">获取到数据: Go</span><br><span class="line">获取到数据: Erlang</span><br><span class="line">获取到数据: Swift</span><br><span class="line">获取到数据: Lua</span><br><span class="line">订阅结束</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31ba8933/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/31ba8933/" class="post-title-link" itemprop="url">16.9.3 线程安全的集合类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 04:14:35" itemprop="dateCreated datePublished" datetime="2020-01-11T04:14:35+08:00">2020-01-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-28 03:03:09" itemprop="dateModified" datetime="2020-03-28T03:03:09+08:00">2020-03-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31ba8933/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31ba8933/" data-xid="/JavaReadingNotes/31ba8933/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-3-线程安全的集合类"><a href="#16-9-3-线程安全的集合类" class="headerlink" title="16.9.3 线程安全的集合类"></a>16.9.3 线程安全的集合类</h1><p>实际上从<code>Java5</code>开始,在<code>java.util.concurrent</code>包下提供了大量支持高效并发访问的集合接口和实现类,如图16.7所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter16/19.6/1.png" alt="这里有一张图片"></p>
<h2 id="线程安全集合分类"><a href="#线程安全集合分类" class="headerlink" title="线程安全集合分类"></a>线程安全集合分类</h2><p>从图16.17所示的类图可以看出,这些线程安全的集合类可分为如下两类</p>
<ul>
<li>以<code>Concurrent</code>开头的集合类,如<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、<code>ConcurrentLinkedQueue</code>,<code>ConcurrentLinkedDeque</code>.</li>
<li>以<code>CopyOnWrite</code>开头的集合类,如<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code></li>
</ul>
<h2 id="Concurrent开头的集合类"><a href="#Concurrent开头的集合类" class="headerlink" title="Concurrent开头的集合类"></a>Concurrent开头的集合类</h2><p>其中<strong>以<code>Concurrent</code>开头的集合类代表了支持并发访问的集合,它们可以支持多个线程并发<code>写入</code>访问</strong>,这些<strong>写入线程的所有操作都是线程安全的</strong>,但读取操作不必锁定。以<code>Concurrent</code>开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合,因此在并发写入时有较好的性能。</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>当多个线程共享访问一个公共集合时,<code>ConcurrentLinkedQueue</code>是一个恰当的选择。<code>ConcurrentLinkedQueue</code>不允许使用<code>null</code>元素。<code>ConcurrentLinkedQueue</code>实现了多线程的高效访问,多个线程访问<code>ConcurrentLinkedQueue</code>集合时无须等待。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>在默认情况下,<code>ConcurrentHashMap</code>支持<strong>16</strong>个线程并发写入,当有超过16个线程并发向该<code>Map</code>中写入数据时,可能有一些线程需要等待。实际上,程序通过设置<code>concurrencyLevel</code>构造参数(默认值为16)来支持更多的并发写入线程</p>
<h3 id="java-util-concurrent包下的集合和java-util包的集合在迭代时的区别"><a href="#java-util-concurrent包下的集合和java-util包的集合在迭代时的区别" class="headerlink" title="java.util.concurrent包下的集合和java.util包的集合在迭代时的区别"></a>java.util.concurrent包下的集合和java.util包的集合在迭代时的区别</h3><p>使用<code>java.util</code>包下的<code>Collection</code>作为集合对象时,<strong>如果该集合对象创建迭代器后集合元素发生改变,则会引发<code>ConcurrentModificationException</code>异常</strong>。<br>与前面介绍的<code>HashMap</code>和普通集合不同的是,因为<code>ConcurrentLinkedQueue</code>和<code>ConcurrentHashMap</code>支持多线程并发访问,所以<strong>当使用迭代器来遍历集合元素时,该迭代器可能无法反映出创建迭代器之后所做的修改,并且程序不会抛出任何异常</strong>。</p>
<h3 id="java8对ConcurrentHashMap的扩展"><a href="#java8对ConcurrentHashMap的扩展" class="headerlink" title="java8对ConcurrentHashMap的扩展"></a>java8对ConcurrentHashMap的扩展</h3><p><code>Java8</code>扩展了<code>ConcurrentHashMap</code>的功能,<code>Java8</code>为该类新增了30多个新方法,这些方法可借助于<code>Stream</code>和<code>Lambda</code>表达式支持执行聚集操作。</p>
<h3 id="Java8的ConcurrentHashMap新的的方法"><a href="#Java8的ConcurrentHashMap新的的方法" class="headerlink" title="Java8的ConcurrentHashMap新的的方法"></a>Java8的ConcurrentHashMap新的的方法</h3><p><code>ConcurrentHashMap</code>新增的方法大致可分为如下三类。</p>
<ul>
<li><code>forEach</code>系列(<code>forEach</code>,<code>ForEachKey</code>,<code>ForEachValue</code>,<code>ForEachEntry</code>)</li>
<li><code>search</code>系列(<code>search</code>,<code>SearchKeys</code>,<code>SearchValues</code>,<code>SearchEntries</code>)</li>
<li><code>reduce</code>系列(<code>reduce</code>,<code>reduceToDouble</code>,<code>reduceToLong</code>,<code>reduceKeys</code>,<code>reduceValues</code>)</li>
</ul>
<p>除此之外,<code>ConcurrentHashMap</code>还新增了<code>mappingCount()</code>、<code>newKeySet()</code>等方法,增强后的<code>ConcurrentHashMap</code>更适合作为缓存实现类使用。</p>
<h2 id="CopyOn开头的集合"><a href="#CopyOn开头的集合" class="headerlink" title="CopyOn开头的集合"></a>CopyOn开头的集合</h2><p>由于<code>CopyOnWriteArraySet</code>的底层封装了<code>CopyOnWriteArrayList</code>,因此它的实现机制完全类似于<code>CopyOnWriteArrayList</code>集合。<br>对于<code>CopyOnWriteArrayList</code>集合,正如它的名字所暗示的,它<strong>釆用复制底层数组的方式来实现写操作</strong></p>
<ul>
<li>当线程对<code>CopyOnWriteArrayList</code>集合执行读取操作时,线程将会直接读取集合本身,无须加锁与阻塞。</li>
<li>当线程对<code>CopyOnWriteArraylist</code>集合执行写入操作时(包括调用<code>add()</code>、<code>remove()</code>、<code>set()</code>等方法),该集合会在底层复制一份新的数组,接下来对新的数组执行写入操作。<ul>
<li>由于对**<code>CopyOnWriteArrayList</code>集合的写入操作都是对数组的副本执行操作,因此它是线程安全的**</li>
</ul>
</li>
</ul>
<p>需要指出的是,由于<code>CopyOnWriteArrayList</code>执行写入操作时需要频繁地复制数组,性能比较差,但由于读操作与写操作不是操作同一个数组,而且读操作也不需要加锁,因此<strong>读操作就很快、很安全</strong>。<br>由此可见,<strong><code>CopyOnWriteArrayList</code>适合用在读取操作远远大于写入操作的场景中,例如缓存等</strong>。</p>
<!-- CrazyJavaHandout4/Chapter16/19.6/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8df965bc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8df965bc/" class="post-title-link" itemprop="url">16.9.2 包装线程不安全的集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 07:04:24" itemprop="dateCreated datePublished" datetime="2020-01-10T07:04:24+08:00">2020-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-27 10:36:08" itemprop="dateModified" datetime="2020-03-27T10:36:08+08:00">2020-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8df965bc/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8df965bc/" data-xid="/JavaReadingNotes/8df965bc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-2-包装线程不安全的集合"><a href="#16-9-2-包装线程不安全的集合" class="headerlink" title="16.9.2 包装线程不安全的集合"></a>16.9.2 包装线程不安全的集合</h1><p>前面介绍<code>Java</code>集合时所讲的<code>ArrayList</code>、<code>Linkedlist</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>HashMap</code>、<code>TreeMap</code>等都是线程不安全的,也就是说,当多个并发线程向这些集合中存、取元素时,就可能会破坏这些集合的数据完整性。</p>
<h2 id="Collections的synchronizedXxx方法"><a href="#Collections的synchronizedXxx方法" class="headerlink" title="Collections的synchronizedXxx方法"></a>Collections的synchronizedXxx方法</h2><p>如果程序中有多个线程可能访问以上这些集合,就可以<strong>使用<code>Collections</code>提供的类方法把这些集合包装成线程安全的集合</strong>。<br><code>Collections</code>提供了如下几个静态方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code></td>
<td align="left">返回指定<code>collection</code>对应的线程安全的<code>collection</code></td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></td>
<td align="left">返回指定<code>List</code>对象对应的线程安全的<code>List</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;K,​V&gt; Map&lt;K,​V&gt; synchronizedMap(Map&lt;K,​V&gt; m)</code></td>
<td align="left">返回指定<code>Map</code>对象对应的线程安全的<code>Map</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></td>
<td align="left">返回指定<code>Set</code>对象对应的线程安全的<code>Set</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;K,​V&gt; SortedMap&lt;K,​V&gt; synchronizedSortedMap(SortedMap&lt;K,​V&gt; m)</code></td>
<td align="left">返回指定<code>SortedMap</code>对象对应的线程安全的<code>SortedMap</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></td>
<td align="left">返回指定<code>SortedSet</code>对象对应的线程安全的<code>SortedSet</code>对象</td>
</tr>
</tbody></table>
<h2 id="代码-使用线程安全的HashMap"><a href="#代码-使用线程安全的HashMap" class="headerlink" title="代码 使用线程安全的HashMap"></a>代码 使用线程安全的HashMap</h2><p>例如需要在多线程中使用线程安全的<code>HashMap</code>对象,则可以采用如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Collectionss的synchronizedMap方法将一个普通的HashMap包装成线程安全的类</span></span><br><span class="line">HashMap m=Collections.synchronizedMap(<span class="keyword">new</span> HashMap());</span><br></pre></td></tr></table></figure>
<h2 id="创建后就包装"><a href="#创建后就包装" class="headerlink" title="创建后就包装"></a>创建后就包装</h2><p>如果需要把某个集合包装成线程安全的集合,则<strong>应该在创建之后立即包装</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a8a61bd3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a8a61bd3/" class="post-title-link" itemprop="url">16.9 线程相关类 16.9.1 Threadlocal类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 05:37:52" itemprop="dateCreated datePublished" datetime="2020-01-10T05:37:52+08:00">2020-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-27 10:30:54" itemprop="dateModified" datetime="2020-03-27T10:30:54+08:00">2020-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a8a61bd3/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a8a61bd3/" data-xid="/JavaReadingNotes/a8a61bd3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-线程相关类"><a href="#16-9-线程相关类" class="headerlink" title="16.9 线程相关类"></a>16.9 线程相关类</h1><p><code>Java</code>还为线程安全提供了一些工具类,如<code>ThreadLocal</code>类,它代表一个<strong>线程局部变量</strong>,<strong>通过把数据放在<code>ThreadLocal</code>中就可以<mark>让每个线程创建一个该变量的副本</mark>,从而避免并发访问的线程安全问题</strong>。除此之外,<code>Java5</code>还新增了大量的线程安全类。</p>
<h1 id="16-9-1-Threadlocal类"><a href="#16-9-1-Threadlocal类" class="headerlink" title="16.9.1 Threadlocal类"></a>16.9.1 Threadlocal类</h1><p>早在<code>JDK1.2</code>推出之时,<code>Java</code>就为多线程编程提供了一个<code>ThreadLocal</code>类;从<code>Java5.0</code>以后,<code>Java</code>引入了泛型支持,<code>Java</code>为该<code>ThreadLocal</code>类增加了泛型支持,即:<code>ThreadLocal&lt;T&gt;</code>。<strong>通过使用<code>ThreadLocal</code>类可以简化多线程编程时的并发访问,使用这个<code>ThreadLocal</code>类可以很简捷地隔离多线程程序的竞争资源</strong>.<br><code>ThreadLocal</code>,是<code>ThreadLocalVariable</code>(线程局部变量)的意思,也许将它命名为<code>ThreadLocalVar</code>更加合适。</p>
<h2 id="线程局部变量的作用"><a href="#线程局部变量的作用" class="headerlink" title="线程局部变量的作用"></a>线程局部变量的作用</h2><p>线程局部变量(<code>ThreadLocal</code>)的功用其实非常简单,就是<strong>为每一个使用该变量的线程都提供一个变量值的副本,使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突</strong>。从线程的角度看,<strong>就好像每一个线程都完全拥有该变量一样</strong>。</p>
<h2 id="ThreadLocal常用方法"><a href="#ThreadLocal常用方法" class="headerlink" title="ThreadLocal常用方法"></a>ThreadLocal常用方法</h2><p><code>ThreadLocal</code>类的用法非常简单,它只提供了如下三个<code>public</code>方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>T get()</code></td>
<td align="left">返回此线程局部变量中当前线程副本中的值。</td>
</tr>
<tr>
<td align="left"><code>void remove()</code></td>
<td align="left">删除此线程局部变量中当前线程的值。</td>
</tr>
<tr>
<td align="left"><code>void set(T value)</code></td>
<td align="left">设置此线程局部变量中当前线程副本中的值</td>
</tr>
<tr>
<td align="left"><code>protected T initialValue()</code></td>
<td align="left">Returns the current thread’s “initial value” for this thread-local variable.</td>
</tr>
<tr>
<td align="left"><code>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code></td>
<td align="left">Creates a thread local variable.</td>
</tr>
</tbody></table>
<h2 id="程序-ThreadLocal示例"><a href="#程序-ThreadLocal示例" class="headerlink" title="程序 ThreadLocal示例"></a>程序 ThreadLocal示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个ThreadLocal类型的变量，该变量将是一个线程局部变量 每个线程都会保留该变量的一个副本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个初始化name成员变量的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name.set(str);</span><br><span class="line">        <span class="comment">// 下面代码用于访问当前线程的name副本的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + <span class="keyword">this</span>.name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name.set(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个Account类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest</span><span class="params">(Account account, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 循环10次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当i == 6时输出将账户名替换成当前线程名</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span><br><span class="line">                account.setName(getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出同一个账户的账户名和循环变量</span></span><br><span class="line">            System.out.println(account.getName() + <span class="string">&quot; 账户的i值：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动两条线程，两条线程共享同一个Account</span></span><br><span class="line">        Account at = <span class="keyword">new</span> Account(<span class="string">&quot;初始名&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 虽然两条线程共享同一个账户，即只有一个账户名</span></span><br><span class="line"><span class="comment">         * 但由于账户名是ThreadLocal类型的，所以每条线程 都完全拥有各自的账户名副本，</span></span><br><span class="line"><span class="comment">         * 所以从i == 6之后，将看到两条 线程访问同一个账户时看到不同的账户名。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> MyTest(at, <span class="string">&quot;线程甲&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> MyTest(at, <span class="string">&quot;线程乙&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于程序中的账户名是一个<code>ThreadLocal</code>变量,所以虽然程序中只有一个<code>Account</code>对象,但两个子线程将会产生两个账户名(主线程也持有一个账户名的副本)。两个线程进行循环时都会在<code>i==6</code>时<strong>将账户名 改为 线程名</strong>,这样就可以看到两个线程拥有两个账户名的情形:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---初始名</span><br><span class="line">null 账户的i值：0</span><br><span class="line">null 账户的i值：0</span><br><span class="line">null 账户的i值：1</span><br><span class="line">null 账户的i值：1</span><br><span class="line">null 账户的i值：2</span><br><span class="line">null 账户的i值：2</span><br><span class="line">null 账户的i值：3</span><br><span class="line">null 账户的i值：3</span><br><span class="line">null 账户的i值：4</span><br><span class="line">null 账户的i值：5</span><br><span class="line">null 账户的i值：4</span><br><span class="line">线程乙 账户的i值：6</span><br><span class="line">null 账户的i值：5</span><br><span class="line">线程乙 账户的i值：7</span><br><span class="line">线程甲 账户的i值：6</span><br><span class="line">线程乙 账户的i值：8</span><br><span class="line">线程甲 账户的i值：7</span><br><span class="line">线程乙 账户的i值：9</span><br><span class="line">线程甲 账户的i值：8</span><br><span class="line">线程甲 账户的i值：9</span><br></pre></td></tr></table></figure>
<p>从上面程序可以看出,实际上账户名有三个副本,主线程一个,另外启动的两个线程各一个,它们的值互不干扰,<strong>每个线程完全拥有自己的<code>ThreadLocal</code>变量,这就是<code>ThreadLocal</code>的用途</strong>。</p>
<h2 id="ThreadLocal和加锁同步的区别"><a href="#ThreadLocal和加锁同步的区别" class="headerlink" title="ThreadLocal和加锁同步的区别"></a>ThreadLocal和加锁同步的区别</h2><p><code>ThreadLocal</code>和其他所有的同步机制一样,<strong>都是为了解决多线程中对同一变量的访问冲突</strong>.</p>
<ul>
<li>在普通的同步机制中,<strong>是通过对象加锁来实现多个线程对同一变量的安全访问的。该<mark>变量是多个线程共享的</mark></strong>,所以要使用这种同步机制,需要很细致地分析在什么时候对变量进行读写,什么时候需要锁定某个对象,什么时候释放该对象的锁等。在这种情况下,系统并没有将这份资源复制多份,只是采用了安全机制来控制对这份资源的访问而已。</li>
<li><code>ThreadLocal</code>从另一个角度来解决多线程的并发访问,<code>ThreadLocal</code>将需要并发访问的资源复制多份,<strong>每个线程拥有一份资源</strong>,每个线程都拥有自己的资源副本,从而也就没有必要对该变量进行同步了,<code>ThreadLocal</code>提供了线程安全的共享对象,在编写多线程代码时,可以把不安全的整个变量封装进<code>ThreadLocal</code>,或者把该对象与线程相关的状态使用<code>ThreadLocal</code>保存。</li>
</ul>
<h2 id="ThreadeLocal不能替代同步"><a href="#ThreadeLocal不能替代同步" class="headerlink" title="ThreadeLocal不能替代同步"></a>ThreadeLocal不能替代同步</h2><p><code>ThreadLocal</code>并不能替代同步机制,两者面向的问题领域不同。</p>
<ul>
<li><strong>同步机制是为了同步多个线程对相同资源的并发访问,是多个线程之间进行通信的有效方式</strong>;</li>
<li>而<code>ThreadLocal</code>是为了隔离多个线程的数据共享,<strong>从根本上避免多个线程之间对共享资源(变量)的竞争</strong>,也就不需要对多个线程进行同步了。</li>
</ul>
<h2 id="什么时候用同步机制-什么时候使用ThreadLocal"><a href="#什么时候用同步机制-什么时候使用ThreadLocal" class="headerlink" title="什么时候用同步机制 什么时候使用ThreadLocal"></a>什么时候用同步机制 什么时候使用<code>ThreadLocal</code></h2><p>通常建议:</p>
<ul>
<li><strong>如果多个线程之间需要共享资源,以达到线程之间的通信功能</strong>,就使用<strong>同步机制</strong>;</li>
<li><strong>如果仅仅需要隔离多个线程之间的共享冲突,则可以使用<code>ThreadLocal</code></strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a4641bde/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a4641bde/" class="post-title-link" itemprop="url">16.8.2 Java8增强的ForkJoinPool</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 05:12:19" itemprop="dateCreated datePublished" datetime="2020-01-10T05:12:19+08:00">2020-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-27 09:59:12" itemprop="dateModified" datetime="2020-03-27T09:59:12+08:00">2020-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-8-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">16.8 线程池</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a4641bde/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a4641bde/" data-xid="/JavaReadingNotes/a4641bde/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-8-2-Java8增强的ForkJoinPool"><a href="#16-8-2-Java8增强的ForkJoinPool" class="headerlink" title="16.8.2 Java8增强的ForkJoinPool"></a>16.8.2 Java8增强的ForkJoinPool</h1><p>现在计算机大多已向多<code>CPU</code>方向发展,即使普通<code>PC</code>,甚至小型智能设备(如手机)、多核处理器也已被广泛应用。在未来的日子里,处理器的核心数将会发展到更多。<br>虽然硬件上的多核<code>CPU</code>已经十分成熟,但很多应用程序并未为这种多核<code>CPU</code>做好准备,因此并不能很好地利用多核<code>CPU</code>的性能优势。<br>为了充分利用多<code>CPU</code>、多核<code>CPU</code>的性能优势,计算机软件系统应该可以充分“挖掘”每个<code>CPU</code>的计算能力,绝不能让某个<code>CPU</code>处于“空闲”状态。为了充分利用多<code>CPU</code>、多核<code>CPU</code>的优势,可以考虑把一个任务拆分成多个“小任务”,把多个“小任务”放到多个处理器核心上并行执行;当多个“小任务”执行完成之后,再将这些执行结果合并起来即可。</p>
<h2 id="Java7提供的ForkJoinPool"><a href="#Java7提供的ForkJoinPool" class="headerlink" title="Java7提供的ForkJoinPool"></a>Java7提供的ForkJoinPool</h2><p><strong><code>Java7</code>提供了<code>ForkJoinPool</code>来支持将一个任务拆分成多个“小任务”并行计算,再把多个“小任务”的结果合并成总的计算结果</strong>。<br><strong><code>ForkJoinPool</code>是<code>ExecutorService</code>的实现类,因此是一种特殊的线程池</strong>。</p>
<h3 id="ForkJoinPool构造器"><a href="#ForkJoinPool构造器" class="headerlink" title="ForkJoinPool构造器"></a>ForkJoinPool构造器</h3><p><code>ForkJoinPool</code>提供了如下两个常用的构造器。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ForkJoinPool(int parallelism)</code></td>
<td align="left">创建一个包含<code>parallelism</code>个并行线程的<code>ForkJoinPool</code>。</td>
</tr>
<tr>
<td align="left"><code>ForkJoinPool()</code></td>
<td align="left">以<code>Runtime.availableProcessors()</code>方法的返回值作为<code>parallelism</code>参数来创建<code>ForkJoinPool</code>。</td>
</tr>
</tbody></table>
<h2 id="Java8对ForkJoinPool的扩展"><a href="#Java8对ForkJoinPool的扩展" class="headerlink" title="Java8对ForkJoinPool的扩展"></a>Java8对ForkJoinPool的扩展</h2><p><code>Java8</code>进一步扩展了<code>ForkJoinPool</code>的功能,<code>Java8</code>为<code>ForkJoinPool</code>增加了<strong>通用池</strong>功能。</p>
<p><code>ForkJoinPool</code>类通过如下两个静态方法提供通用池功能。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ForkJoinPool commonPool()</code></td>
<td align="left">该方法返回一个通用池.<br>通用池的运行状态不会受<code>shutdown()</code>或<code>shutdownNow()</code>方法的影响。<br>当然,如果程序直接执行<code>System.exit(0);</code>来终止虚拟机,<br>则通用池以及通用池中正在执行的任务都会被自动终止。</td>
</tr>
<tr>
<td align="left"><code>static int getCommonPoolParallelism()</code></td>
<td align="left">返回通用池的并行级别</td>
</tr>
</tbody></table>
<h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p>创建了<code>ForkJoinPool</code>实例之后,就可调用<code>ForkJoinPool</code>的<code>submit(ForkJoinTask task)</code>或<code>invoke(ForkJoinTask task)</code>方法来执行指定任务了。</p>
<ul>
<li>其中**<code>ForkJoinTask</code>代表一个可以并行、合并的任务**。</li>
<li>这个<code>ForkJoinTask</code>是一个抽象类,它还有两个抽象子类:<code>RecursiveAction</code>和<code>RecursiveTask</code>。其中<ul>
<li><code>RecursiveTask</code>代表<strong>有返回值的任务</strong>,</li>
<li><code>RecursiveAction</code>代表<strong>没有返回值的任务</strong>。</li>
</ul>
</li>
</ul>
<p>图16.14显示了<code>ForkJoinPool</code>、<code>ForkJoinTask</code>等类的类图。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter16/16.8.2/1.png" alt="这里有一张图片"></p>
<h2 id="无返回值的大任务分解"><a href="#无返回值的大任务分解" class="headerlink" title="无返回值的大任务分解"></a>无返回值的大任务分解</h2><h3 id="程序-使用ForkJoinPool将大任务拆分"><a href="#程序-使用ForkJoinPool将大任务拆分" class="headerlink" title="程序 使用ForkJoinPool将大任务拆分"></a>程序 使用ForkJoinPool将大任务拆分</h3><p>下面以执行没有返回值的“大任务”(简单地打印0-300的数值)为例,程序将一个“大任务”拆分成多个“小任务”,并将任务交给<code>ForkJoinPool</code>来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承RecursiveAction来实现&quot;可分解&quot;的任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个“小任务”只最多只打印50个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印从start到end的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当end与start之间的差小于THRESHOLD时，开始打印</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值：&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个</span></span><br><span class="line">            <span class="comment">// 将大任务分解成两个小任务。</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            PrintTask left = <span class="keyword">new</span> PrintTask(start, middle);</span><br><span class="line">            PrintTask right = <span class="keyword">new</span> PrintTask(middle, end);</span><br><span class="line">            <span class="comment">// 并行执行两个“小任务”</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">// 提交可分解的PrintTask任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> PrintTask(<span class="number">0</span>, <span class="number">300</span>));</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个</span></span><br><span class="line"><span class="comment">// 将大任务分解成两个小任务。</span></span><br><span class="line"><span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">PrintTask left = <span class="keyword">new</span> PrintTask(start, middle);</span><br><span class="line">PrintTask right = <span class="keyword">new</span> PrintTask(middle, end);</span><br><span class="line"><span class="comment">// 并行执行两个“小任务”</span></span><br><span class="line">left.fork();</span><br><span class="line">right.fork();</span><br></pre></td></tr></table></figure>
<p>实现了对指定打印任务的分解,分解后的任务分别调用<code>fork()</code>方法开始并行执行运行上面程序,可以看到下所示的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-1-worker-1的i值：262</span><br><span class="line">ForkJoinPool-1-worker-3的i值：37 </span><br><span class="line">ForkJoinPool-1-worker-4的i值：0  </span><br><span class="line">ForkJoinPool-1-worker-2的i值：112</span><br><span class="line">ForkJoinPool-1-worker-4的i值：1  </span><br><span class="line">ForkJoinPool-1-worker-3的i值：38 </span><br><span class="line">ForkJoinPool-1-worker-1的i值：263</span><br><span class="line">ForkJoinPool-1-worker-3的i值：39 </span><br><span class="line">ForkJoinPool-1-worker-4的i值：2  </span><br><span class="line">ForkJoinPool-1-worker-2的i值：113</span><br><span class="line">ForkJoinPool-1-worker-4的i值：3  </span><br><span class="line">ForkJoinPool-1-worker-3的i值：40 </span><br><span class="line">ForkJoinPool-1-worker-1的i值：264</span><br><span class="line">ForkJoinPool-1-worker-3的i值：41 </span><br><span class="line">ForkJoinPool-1-worker-4的i值：4  </span><br><span class="line">ForkJoinPool-1-worker-2的i值：114</span><br><span class="line">ForkJoinPool-1-worker-4的i值：5  </span><br><span class="line">......</span><br><span class="line">ForkJoinPool-1-worker-2的i值：257</span><br><span class="line">ForkJoinPool-1-worker-2的i值：258</span><br><span class="line">ForkJoinPool-1-worker-2的i值：259</span><br><span class="line">ForkJoinPool-1-worker-2的i值：260</span><br><span class="line">ForkJoinPool-1-worker-2的i值：261</span><br></pre></td></tr></table></figure>
<p>从执行结果来看,<code>ForkJoinPool</code>启动了4个线程来执行这个打印任务—这是因为测试计算机的<code>CPU</code>是4核的。不仅如此,读者可以看到程序虽然打印了0-299这300个数字,但并不是连续打印的,这是因为程序将这个打印任务进行了分解,分解后的任务会并行执行,所以不会按顺序从0打印到299。</p>
<h2 id="有返回值的大任务分解"><a href="#有返回值的大任务分解" class="headerlink" title="有返回值的大任务分解"></a>有返回值的大任务分解</h2><p>上面定义的任务是一个没有返回值的打印任务,如果大任务是有返回值的任务,则可以<strong>让任务继承<code>RecursiveTask&lt;T&gt;</code>,其中泛型参数<code>T</code>就代表了该任务的返回值类型。</strong></p>
<h3 id="程序-使用RecursiveTask对数组求和"><a href="#程序-使用RecursiveTask对数组求和" class="headerlink" title="程序 使用RecursiveTask对数组求和"></a>程序 使用<code>RecursiveTask</code>对数组求和</h3><p>下面程序示范了使用<code>RecursiveTask</code>对一个长度为100的数组的元素值进行累加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承RecursiveTask来实现&quot;可分解&quot;的任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 每个“小任务”只最多只累加20个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> arr[];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加从start到end的数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CalTask</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当end与start之间的差小于THRESHOLD时，开始进行实际累加</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当end与start之间的差大于THRESHOLD时，即要累加的数超过20个时</span></span><br><span class="line">            <span class="comment">// 将大任务分解成两个小任务。</span></span><br><span class="line">            <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            CalTask left = <span class="keyword">new</span> CalTask(arr, start, middle);</span><br><span class="line">            CalTask right = <span class="keyword">new</span> CalTask(arr, middle, end);</span><br><span class="line">            <span class="comment">// 并行执行两个“小任务”</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="comment">// 把两个“小任务”累加的结果合并起来</span></span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join(); <span class="comment">// ①</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化100个数字元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = rand.nextInt(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">// 对数组元素赋值，并将数组元素的值添加到sum总和中。</span></span><br><span class="line">            total += (arr[i] = tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        <span class="comment">// 创建一个通用池</span></span><br><span class="line">        ForkJoinPool pool = ForkJoinPool.commonPool();</span><br><span class="line">        <span class="comment">// 提交可分解的CalTask任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> CalTask(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序与前一个程序基本相似,同样是将任务进行了分解,并调用分解后的任务的<code>fork()</code>方法使它们并行执行。与前一个程序不同的是,现在任务是带返回值的,因此程序还在①号代码处将两个分解后的“小任务”的返回值进行了合并。<br>运行上面程序,将可以看到程序通过<code>CalTask</code>计算出来的总和,与初始化数组元素时统计出来的总和总是相等,这表明程序一切正常。</p>
<!-- CrazyJavaHandout4/Chapter16/16.8.2/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/547f08c8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/547f08c8/" class="post-title-link" itemprop="url">16.8 线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 04:36:02" itemprop="dateCreated datePublished" datetime="2020-01-10T04:36:02+08:00">2020-01-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-27 09:36:33" itemprop="dateModified" datetime="2020-03-27T09:36:33+08:00">2020-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-8-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">16.8 线程池</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/547f08c8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/547f08c8/" data-xid="/JavaReadingNotes/547f08c8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-8-线程池"><a href="#16-8-线程池" class="headerlink" title="16.8 线程池"></a>16.8 线程池</h1><p>系统启动一个新线程的成本是比较高的,因为它涉及与操作系统交互。在这种情形下,使用线程池可以很好地提高性能,尤其是当程序中需要创建大量生存期很短暂的线程时,更应该考虑使用线程池。<br>与数据库连接池类似的是,线程池在系统<code>启动时</code>即创建大量空闲的线程,程序将一个<code>Runnable</code>对象或<code>Callable</code>对象传给线程池,线程池就会启动一个空闲的线程来执行它们的<code>run()</code>或<code>call()</code>方法,<strong>当<code>run()</code>或<code>call()</code>方法执行结束后,该线程并不会死亡,而是再次返回线程池中成为空闲状态,等待执行下一个<code>Runnable</code>对象的<code>run()</code>(或<code>cal()</code>方法</strong>。<br>除此之外,使用线程池可以有效地控制系统中并发线程的数量,当系统中包含大量并发线程时,会导致系统性能剧烈下降,甚至导致<code>JVM</code>崩溃,而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。</p>
<h1 id="16-8-1-Java8改进的线程池"><a href="#16-8-1-Java8改进的线程池" class="headerlink" title="16.8.1 Java8改进的线程池"></a>16.8.1 Java8改进的线程池</h1><h2 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h2><p>在<code>Java5</code>以前,开发者必须手动实现自己的线程池;从<code>Java5</code>开始,<code>Java</code>内建支持线程池。<code>Java5</code>新增了一个<code>Executors</code>工厂类来产生线程池,该工厂类包含如下几个静态工厂方法来创建线程池</p>
<h3 id="创建ExecutorService线程池"><a href="#创建ExecutorService线程池" class="headerlink" title="创建ExecutorService线程池"></a>创建ExecutorService线程池</h3><table>
<thead>
<tr>
<th align="left"><code>Executors</code>类方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ExecutorService newCachedThreadPool()</code></td>
<td align="left">创建一个具有<strong>缓存功能</strong>的线程池,系统根据需要创建线程,这些线程将会被缓存在线程池中。</td>
</tr>
<tr>
<td align="left"><code>static ExecutorService newFixedThreadPool(int nThreads)</code></td>
<td align="left">创建一个<strong>可重用的、具有固定线程数</strong>的线程池。</td>
</tr>
<tr>
<td align="left"><code>static ExecutorService newSingleThreadExecutor()</code></td>
<td align="left">创建一个<strong>只有单线程的线程池</strong>,它相当于调用<code>newFixedThreadPool()</code>方法时传入参数为1。</td>
</tr>
</tbody></table>
<p><code>ExecutorService</code>对象对象代表一个线程池,它可以执行<code>Runnable</code>对象或<code>Callable</code>对象所代表的线程;</p>
<h3 id="创建ScheduledExecutorService线程池"><a href="#创建ScheduledExecutorService线程池" class="headerlink" title="创建ScheduledExecutorService线程池"></a>创建ScheduledExecutorService线程池</h3><table>
<thead>
<tr>
<th align="left"><code>Executors</code>类方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code></td>
<td align="left">创建具有指定线程数的线程池,它可以在指定延迟后执行线程任务。<br><code>corePoolSize</code>指池中所保存的线程数,即使线程是空闲的也被保存在线程池内。</td>
</tr>
<tr>
<td align="left"><code>static ScheduledExecutorService newSingleThreadScheduledExecutor()</code></td>
<td align="left">创建只有一个线程的线程池,它可以在指定延迟后执行线程任务。</td>
</tr>
</tbody></table>
<p><code>ScheduledExecutorService</code>是<code>ExecutorService</code>的子类,它可以在指定延迟后执行线程任务;</p>
<h3 id="java8-新增的workStealing池"><a href="#java8-新增的workStealing池" class="headerlink" title="java8 新增的workStealing池"></a>java8 新增的workStealing池</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ExecutorService newWorkStealingPool(int parallelism)</code></td>
<td align="left">创建持有足够的线程的线程池来支持给定的并行级别,该方法还会使用多个队列来减少竞争。</td>
</tr>
<tr>
<td align="left"><code>static ExecutorService newWorkStealingPool()</code></td>
<td align="left">该方法是前一个方法的简化版本。如果当前机器有4个<code>CPU</code>,则目标并行级别被设置为4,也就是相当于为前一个方法传入4作为参数。</td>
</tr>
</tbody></table>
<p>这两个方法则是<code>Java8</code>新增的,这两个方法可<strong>充分利用多<code>CPU</code>并行</strong>的能力。这两个方法生成的<code>workStealing</code>池,都相当于<strong>后台线程池</strong>,<strong>如果所有的前台线程都死亡了,<code>workStealing</code>池中的线程会自动死亡</strong>。<br>由于目前计算机硬件的发展日新月异,即使普通用户使用的电脑通常也都是多核<code>CPU</code>,因此<code>Java8</code>在线程支持上也增加了利用多<code>CPU</code>并行的能力,这样可以更好地发挥底层硬件的性能。</p>
<h2 id="尽快执行线程池ExecutorService"><a href="#尽快执行线程池ExecutorService" class="headerlink" title="尽快执行线程池ExecutorService"></a>尽快执行线程池ExecutorService</h2><p><strong><code>ExecutorService</code>代表尽快执行线程的线程池</strong>(只要线程池中有空闲线程,就立即执行线程任务),程序只要将一个<code>Runnable</code>对象或<code>Callable</code>对象(代表线程任务)提交给该线程池,该线程池就会尽快执行该任务。</p>
<p><code>ExecutorService</code>里提供了如下三个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Future&lt;?&gt; submit(Runnable task)</code></td>
<td align="left">将一个<code>Runnable</code>对象提交给指定的线程池,线程池将在有空闲线程时执行<code>Runnable</code>对象代表的任务。<br>其中<code>Future</code>对象代表<code>Runnable</code>任务的返回值——但<code>run()</code>方法没有返回值,<br>所以<code>Future</code>对象将在<code>run()</code>方法执行结束后返回<code>null</code>,<br>但可以调用<code>Future</code>的<code>isDone()</code>、<code>isCancelled()</code>方法来获得<code>Runnable</code>对象的执行状态。</td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code></td>
<td align="left">将一个<code>Runnable</code>对象提交给指定的线程池,线程池将在有空闲线程时执行<code>Runnable</code>对象代表的任务。<br>其中<code>result</code>显式指定线程执行结束后的返回值,<br>所以<code>Future</code>对象将在<code>run()</code>方法执行结束后返回<code>result</code></td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td>
<td align="left">将一个<code>Callable</code>对象提交给指定的线程池,线程池将在有空闲线程时执行<code>Callable</code>对象代表的任务。<br>其中<code>Future</code>代表<code>Callable</code>对象里<code>call()</code>方法的返回值。</td>
</tr>
</tbody></table>
<h2 id="延迟周期线程池ScheduledExecutorService"><a href="#延迟周期线程池ScheduledExecutorService" class="headerlink" title="延迟周期线程池ScheduledExecutorService"></a>延迟周期线程池ScheduledExecutorService</h2><p><strong><code>ScheduledExecutorService</code>代表可在指定延迟后或周期性地执行线程任务的线程池</strong>,它提供了如下4个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></td>
<td align="left">指定<code>command</code>任务将在<code>delay</code>延迟后执行。</td>
</tr>
<tr>
<td align="left"><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td>
<td align="left">指定<code>callable</code>任务将在<code>delay</code>延迟后执行。</td>
</tr>
<tr>
<td align="left"><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td align="left">指定<code>command</code>任务将在<code>delay</code>延迟后执行,而且以设定频率重复执行。也就是说,在<code>initialDelay</code>后开始执行,依次在<code>initialDelay+Period</code>、<code>initialDelay+2*period</code>,…,处重复执行,依此类推。</td>
</tr>
<tr>
<td align="left"><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td>
<td align="left">创建并执行一个在给定初始延迟后首次启用的定期操作,随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务在任一次执行时遇到异常,就会取消后续执行;否则,只能通过程序来显式取消或终止该任务。</td>
</tr>
</tbody></table>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><h3 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h3><p>用完一个线程池后,应该调用该线程池的<code>shutdown</code>方法,该方法将启动线程池的关闭序列,<strong>调用<code>shutdown()</code>方法后的线程池不再接收新任务,但会将以前所有已提交任务执行完成</strong>。当线程池中的所有任务都执行完成后,池中的所有线程都会死亡;</p>
<h3 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h3><p>另外也可以调用线程池的<code>shutdownNow()</code>方法来关闭线程池,该方法试图停止所有正在执行的活动任务,暂停处理正在等待的任务,并返回等待执行的任务列表。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void shutdown()</code></td>
<td align="left">Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted.</td>
</tr>
<tr>
<td align="left"><code>List&lt;Runnable&gt; shutdownNow()</code></td>
<td align="left">Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.</td>
</tr>
</tbody></table>
<h2 id="使用线程池步骤"><a href="#使用线程池步骤" class="headerlink" title="使用线程池步骤"></a>使用线程池步骤</h2><p>使用线程池来执行线程任务的步骤如下:</p>
<ol>
<li>调用<code>Executors</code>类的静态工厂方法创建一个<code>ExecutorService</code>对象,该对象代表一个线程池。</li>
<li>创建<code>Runnable</code>实现类或<code>Callable</code>实现类的实例,作为线程执行任务。</li>
<li>调用<code>ExecutorService</code>对象的<code>submit</code>方法来提交<code>Runnable</code>实例或<code>Callable</code>实例。</li>
<li>当不想提交任何任务时,调用<code>ExecutorService</code>对象的<code>shutdown()</code>方法来关闭线程池。</li>
</ol>
<h2 id="程序-使用线程池"><a href="#程序-使用线程池" class="headerlink" title="程序 使用线程池"></a>程序 使用线程池</h2><p>下面程序使用线程池来执行指定<code>Runnable</code>对象所代表的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建足够的线程来支持4个CPU并行的线程池</span></span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数（6）的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式创建Runnable对象</span></span><br><span class="line">        Runnable target = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值为:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 向线程池中提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中创建<code>Runnable</code>实现类与最开始创建线程池并没有太大差别,创建了<code>Runnable</code>实现类之后程序没有直接创建线程、启动线程来执行该<code>Runnable</code>任务,而是通过线程池来执行该任务,使用线程池来执行<code>Runnable</code>任务的代码如程序中粗体字代码所示。运行上面程序,将看到两个线程交替执行的效果,如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1的i值为:0</span><br><span class="line">pool-1-thread-2的i值为:0 </span><br><span class="line">pool-1-thread-1的i值为:1 </span><br><span class="line">pool-1-thread-2的i值为:1 </span><br><span class="line">pool-1-thread-2的i值为:2 </span><br><span class="line">......</span><br><span class="line">pool-1-thread-1的i值为:98</span><br><span class="line">pool-1-thread-2的i值为:97</span><br><span class="line">pool-1-thread-1的i值为:99</span><br><span class="line">pool-1-thread-2的i值为:98</span><br><span class="line">pool-1-thread-2的i值为:99</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/84/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/84/">84</a><span class="page-number current">85</span><a class="page-number" href="/JavaReadingNotes/page/86/">86</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/86/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/85/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/85/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
