<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/85/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/85/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/85/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6e1b7e8f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6e1b7e8f/" class="post-title-link" itemprop="url">17.0 第17章 前言</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-13 01:44:19" itemprop="dateCreated datePublished" datetime="2020-01-13T01:44:19+08:00">2020-01-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-02-07 01:34:56" itemprop="dateModified" datetime="2020-02-07T01:34:56+08:00">2020-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第17章 网络编程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC17%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/17-0-%E5%89%8D%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">17.0 前言</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6e1b7e8f/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6e1b7e8f/" data-xid="/JavaReadingNotes/6e1b7e8f/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>945</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第17章-网络编程-前言"><a href="#第17章-网络编程-前言" class="headerlink" title="第17章 网络编程 前言"></a>第17章 网络编程 前言</h1><h2 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h2><ul>
<li>计算机网络基础</li>
<li><code>IP</code>地址和端口</li>
<li>使用<code>InetAddress</code>包装<code>IP</code>地址</li>
<li>使用<code>URLEncoder</code>和<code>URLDecoder</code>工具类</li>
<li>使用<code>URLConnection</code>访问远程资源</li>
<li><code>TCP</code>协议基础</li>
<li>使用<code>ServerSocket</code>和<code>Socket</code></li>
<li>使用<code>NIO</code>实现非阻塞式网络通信</li>
<li>使用<code>AIO</code>实现异步网络通信</li>
<li><code>UDP</code>协议基础</li>
<li>使用<code>DatagramSocket</code>发送&#x2F;接收数据报(<code>DatagramPacket</code>)</li>
<li>使用<code>MulticastSocket</code>实现多点广播</li>
<li>通过<code>Proxy</code>使用代理服务器</li>
<li>通过<code>ProxySelector</code>使用代理服务器</li>
</ul>
<p>本章将主要介绍<code>Java</code>网络通信的支持,通过这些网络支持类,<code>Java</code>程序可以非常方便地访问互联网上的<code>HTTP</code>服务、<code>FTP</code>服务等,并可以直接取得互联网上的远程资源,还可以向远程资源发送<code>GET</code>、<code>POST</code>请求</p>
<h2 id="介绍网络工具类"><a href="#介绍网络工具类" class="headerlink" title="介绍网络工具类"></a>介绍网络工具类</h2><p>本章先简要介绍计算机网络的基础知识,包括酽地址和端口等概念,这些知识是网络编程的基础。本章会详细介绍<code>InetAddress</code>、<code>URLDecoder</code>、<code>URLEncoder</code>、<code>URL</code>和<code>URLConnection</code>等网络工具类,并会深入介绍通过<code>URLConnection</code>发送请求、访问远程资源等操作。</p>
<h2 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h2><p>本章将重点介绍<code>Java</code>提供的<code>TCP</code>网络通信支持,包括如何利用<code>ServerSocket</code>建立<code>TCP</code>服务器,利用<code>Socket</code>建立<code>TCP</code>客户端。实际上<code>Java</code>的网络通信非常简单,服务器端通过<code>ServerSocket</code>建立监听,客户端通过<code>Socket</code>连接到指定服务器后,通信双方就可以通过IO流进行通信。本章将以采用逐步迭代的方式开发一个C&#x2F;S结构多人网络聊天工具为例,向读者介绍基于<code>TCP</code>协议的网络编程。</p>
<h2 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h2><p>本章还将重点介绍<code>Java</code>提供的<code>UDP</code>网络通信支持,主要介绍如何使用<code>DatagramSocket</code>来发送、接收数据报(<code>DatagramPacket</code>),并讲解如何使用<code>MulticastSocket</code>来实现多点广播通信。本章也将以开发局域网通信程序为例来介绍<code>MulticastSocket</code>和<code>DatagramSocket</code>的实际用法</p>
<h2 id="代理服务器访问远程资源"><a href="#代理服务器访问远程资源" class="headerlink" title="代理服务器访问远程资源"></a>代理服务器访问远程资源</h2><p>本章最后还会介绍利用<code>Proxy</code>和<code>ProxySelector</code>在<code>Java</code>程序中通过代理服务器访问远程资源。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/37d7c517/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/37d7c517/" class="post-title-link" itemprop="url">16.10 本章小结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 05:11:57" itemprop="dateCreated datePublished" datetime="2020-01-11T05:11:57+08:00">2020-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-28 03:14:50" itemprop="dateModified" datetime="2020-03-28T03:14:50+08:00">2020-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-10-%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93/" itemprop="url" rel="index"><span itemprop="name">16.10 本章小结</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/37d7c517/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/37d7c517/" data-xid="/JavaReadingNotes/37d7c517/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>554</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-10-本章小结"><a href="#16-10-本章小结" class="headerlink" title="16.10 本章小结"></a>16.10 本章小结</h1><p>本章主要介绍了<code>Java</code>的多线程编程支持:</p>
<ul>
<li>简要介绍了线程的基本概念,并讲解了线程和进程之间的区别与联系。</li>
<li>本章详细讲解了如何创建、启动多线程,并对比了三种创建多线程方式之间的优势和劣势,也详细介绍了线程的生命周期。</li>
<li>本章通过示例程序示范了控制线程的几个方法,</li>
<li>还详细讲解了线程同步的意义和必要性,并介绍了三种不同的线程同步方法:<ul>
<li>同步方法、</li>
<li>同步代码块，</li>
<li>显式使用<code>Lock</code>控制线程同步。</li>
</ul>
</li>
<li>本章也介绍了三种实现线程通信的方式:<ul>
<li>使用同步监视器的方法实现通信、</li>
<li>显式使用<code>Condition</code>对象实现线程通信，</li>
<li>使用阻塞对象实现线程通信。</li>
</ul>
</li>
</ul>
<p>此外,本章还介绍了线程组和线程池,由于线程属于创建成本较大的对象,因此程序应该考虑复用线程,线程池是在实际开发中不错的选择.<br>本章最后介绍了线程相关的工具类,比如<code>ThreadLocal</code>，线程安全的集合类，以及如果使用<code>Collections</code>包装线程不安全的集合类.</p>
<h1 id="本章练习"><a href="#本章练习" class="headerlink" title="本章练习"></a>本章练习</h1><ol>
<li>写2个线程,其中一个线程打印<code>1~52</code>,另一个线程打印<code>A~Z</code>,<strong>每两个数字后打印一个字母</strong>,也就是打印顺序应该是<code>12A34B56C...5152Z</code>。该习题需要利用多线程通信的知识。</li>
<li>假设车库有3个车位(可以用<code>boolean</code>口数组来表示车库)可以停车,写一个程序模拟多个用户开车离开、停车入库的效果。注意:车位有车时不能停车</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/b58c8736/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/b58c8736/" class="post-title-link" itemprop="url">16.9.4 Java9新增的发布-订阅框架</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 04:15:24" itemprop="dateCreated datePublished" datetime="2020-01-11T04:15:24+08:00">2020-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-28 03:12:04" itemprop="dateModified" datetime="2020-03-28T03:12:04+08:00">2020-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/b58c8736/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/b58c8736/" data-xid="/JavaReadingNotes/b58c8736/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-4-Java9新增的发布-订阅框架"><a href="#16-9-4-Java9新增的发布-订阅框架" class="headerlink" title="16.9.4 Java9新增的发布-订阅框架"></a>16.9.4 Java9新增的发布-订阅框架</h1><p><code>Java9</code>新增了一个发布-订阅框架,该框架是基于<code>异步响应流</code>的。这个发布-订阅框架可以非常方便地处理异步线程之间的<code>流数据交换</code>(比如两个线程之间需要交换数据)。而且这个发布-订阅框架不需要使用数据中心来缓冲数据,同时具有非常高效的性能。</p>
<h2 id="Flow类静态内部接口"><a href="#Flow类静态内部接口" class="headerlink" title="Flow类静态内部接口"></a>Flow类静态内部接口</h2><p>这个发布订阅框架使用<code>Flow</code>类的4个静态内部接口作为核心<code>API</code></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static interface Flow.Publisher&lt;T&gt;</code></td>
<td align="left">代表数据发布者、生产者</td>
</tr>
<tr>
<td align="left"><code>static interface Flow.Subscriber&lt;T&gt;</code></td>
<td align="left">代表数据订阅者、消费者</td>
</tr>
<tr>
<td align="left"><code>static interface Flow.Subscription</code></td>
<td align="left">代表发布者和订阅者之间的链接纽带。<br>订阅者既可通过调用该对象的<code>request()</code>方法来获取数据项,<br>也可通过调用对象的<code>cancel()</code>方法来取消订阅。</td>
</tr>
<tr>
<td align="left"><code>static interface Flow.Processor&lt;T,​R&gt;</code></td>
<td align="left">数据处理器,它可同时作为发布者和订阅者使用</td>
</tr>
</tbody></table>
<h2 id="Flow-Publisher接口方法"><a href="#Flow-Publisher接口方法" class="headerlink" title="Flow.Publisher接口方法"></a><code>Flow.Publisher</code>接口方法</h2><p><code>Flow.Publisher</code>作为<strong>生产者</strong>,负责发布数据项,并注册订阅者。<code>Flow.Publisher</code>接口定义了如下方法来注册订阅者。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void subscribe(Flow.Subscriber&lt;? super T&gt; subscriber)</code></td>
<td align="left">程序调用此方法注册订阅者时,会触发订阅者的<code>onSubscribe()</code>方法,将<code>Flow.Subscription</code>对象作为参数传给该方法;<br>如果注册失败,将会触发订阅者的<code>onError()</code>方法。</td>
</tr>
</tbody></table>
<h2 id="Flow-Subscriber接口方法"><a href="#Flow-Subscriber接口方法" class="headerlink" title="Flow.Subscriber接口方法"></a><code>Flow.Subscriber</code>接口方法</h2><p><code>Flow.Subscriber</code>接口定义了如下方法</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void onSubscribe(Flow.Subscription subscription)</code></td>
<td align="left">订阅者注册时自动触发该方法</td>
</tr>
<tr>
<td align="left"><code>void onComplete()</code></td>
<td align="left">当订阅结束时触发该方法</td>
</tr>
<tr>
<td align="left"><code>void onError(Throwable throwable)</code></td>
<td align="left">当订阅失败时触发该方法</td>
</tr>
<tr>
<td align="left"><code>void onNext(T item)</code></td>
<td align="left">订阅者从发布者处获取数据项时触发该方法,订阅者可通过该方法获取数据项</td>
</tr>
</tbody></table>
<h2 id="Flow-Publisher的SubmissionPublisher实现类"><a href="#Flow-Publisher的SubmissionPublisher实现类" class="headerlink" title="Flow.Publisher的SubmissionPublisher实现类"></a><code>Flow.Publisher</code>的<code>SubmissionPublisher</code>实现类</h2><p>为了处理一些通用发布者的场景,<code>Java9</code>为<code>Flow.Publisher</code>提供了一个<code>SubmissionPublisher</code>实现类,它可向当前订阅者异步提交非空的数据项,直到它被关闭。每个订阅者都能以相同的顺序接收到新提交的数据项。<br>程序创建<code>SubmissionPublisher</code>对象时,需要传入一个线程池作为底层支撑;该类也提供了一个无参数的构造器,该构造器使用<code>ForkJoinPool.commonPool()</code>方法来提交发布者,以此实现发布者向订阅者提供数据项的异步特性。</p>
<h2 id="程序示例-使用SubmissionPublisher作为发布者"><a href="#程序示例-使用SubmissionPublisher作为发布者" class="headerlink" title="程序示例 使用SubmissionPublisher作为发布者"></a>程序示例 使用<code>SubmissionPublisher</code>作为发布者</h2><p>下面程序示范了使用<code>SubmissionPublisher</code>作为发布者的用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Flow.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PubSubTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个SubmissionPublisher作为发布者</span></span><br><span class="line">        SubmissionPublisher&lt;String&gt; publisher = <span class="keyword">new</span> <span class="title class_">SubmissionPublisher</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建订阅者</span></span><br><span class="line">        MySubscriber&lt;String&gt; subscriber = <span class="keyword">new</span> <span class="title class_">MySubscriber</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 注册订阅者</span></span><br><span class="line">        publisher.subscribe(subscriber);</span><br><span class="line">        <span class="comment">// 发布几个数据项</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开发发布数据...&quot;</span>);</span><br><span class="line">        List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Kotlin&quot;</span>, <span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Erlang&quot;</span>, <span class="string">&quot;Swift&quot;</span>, <span class="string">&quot;Lua&quot;</span>).forEach(im -&gt; &#123;</span><br><span class="line">            <span class="comment">// 提交数据</span></span><br><span class="line">            publisher.submit(im);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 发布结束</span></span><br><span class="line">        publisher.close();</span><br><span class="line">        <span class="comment">// 发布结束后，为了让发布者线程不会死亡，暂停线程</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;fkjava&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="string">&quot;fkjava&quot;</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MySubscriber</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Subscriber</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 发布者与订阅者之间的纽带</span></span><br><span class="line">    <span class="keyword">private</span> Subscription subscription;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 订阅时触发该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription subscription)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subscription = subscription;</span><br><span class="line">        <span class="comment">// 开始请求数据</span></span><br><span class="line">        subscription.request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 接收到数据时触发该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取到数据: &quot;</span> + item);</span><br><span class="line">        <span class="comment">// 请求下一条数据</span></span><br><span class="line">        subscription.request(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 订阅出错时触发该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        t.printStackTrace();</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;fkjava&quot;</span>) &#123;</span><br><span class="line">            <span class="string">&quot;fkjava&quot;</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 订阅结束时触发该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;订阅结束&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="string">&quot;fkjava&quot;</span>) &#123;</span><br><span class="line">            <span class="string">&quot;fkjava&quot;</span>.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中先创建<code>SubmissionPublisher</code>对象,该对象可作为发布者;然后创建订阅者对象,该订阅者类是一个自定义类;接着注册订阅者。<br>完成上面步骤之后,程序即可<strong>调用<code>SubmissionPublisher</code>对象的<code>submit()</code>方法来发布数据项,发布者通过该方法发布数据项</strong>。<br>上面程序实现了一个自定义的订阅者,该<strong>订阅者实现了<code>Subscriber</code>接口的4个方法,重点就是实现<code>onNext()</code>方法,当订阅者获取到数据时就会触发这个<code>onNext()</code>方法,订阅者通过该方法接收数据</strong>。<br>至于订阅者接收到数据项之后的处理,则取决于程序的业务需求<br>运行该程序,可以看到订阅者逐项获得数据的过程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开发发布数据...</span><br><span class="line">获取到数据: Java</span><br><span class="line">获取到数据: Kotlin</span><br><span class="line">获取到数据: Go</span><br><span class="line">获取到数据: Erlang</span><br><span class="line">获取到数据: Swift</span><br><span class="line">获取到数据: Lua</span><br><span class="line">订阅结束</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31ba8933/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/31ba8933/" class="post-title-link" itemprop="url">16.9.3 线程安全的集合类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 04:14:35" itemprop="dateCreated datePublished" datetime="2020-01-11T04:14:35+08:00">2020-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-28 03:03:09" itemprop="dateModified" datetime="2020-03-28T03:03:09+08:00">2020-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31ba8933/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31ba8933/" data-xid="/JavaReadingNotes/31ba8933/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-3-线程安全的集合类"><a href="#16-9-3-线程安全的集合类" class="headerlink" title="16.9.3 线程安全的集合类"></a>16.9.3 线程安全的集合类</h1><p>实际上从<code>Java5</code>开始,在<code>java.util.concurrent</code>包下提供了大量支持高效并发访问的集合接口和实现类,如图16.7所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter16/19.6/1.png" alt="这里有一张图片"></p>
<h2 id="线程安全集合分类"><a href="#线程安全集合分类" class="headerlink" title="线程安全集合分类"></a>线程安全集合分类</h2><p>从图16.17所示的类图可以看出,这些线程安全的集合类可分为如下两类</p>
<ul>
<li>以<code>Concurrent</code>开头的集合类,如<code>ConcurrentHashMap</code>、<code>ConcurrentSkipListMap</code>、<code>ConcurrentSkipListSet</code>、<code>ConcurrentLinkedQueue</code>,<code>ConcurrentLinkedDeque</code>.</li>
<li>以<code>CopyOnWrite</code>开头的集合类,如<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code></li>
</ul>
<h2 id="Concurrent开头的集合类"><a href="#Concurrent开头的集合类" class="headerlink" title="Concurrent开头的集合类"></a>Concurrent开头的集合类</h2><p>其中<strong>以<code>Concurrent</code>开头的集合类代表了支持并发访问的集合,它们可以支持多个线程并发<code>写入</code>访问</strong>,这些<strong>写入线程的所有操作都是线程安全的</strong>,但读取操作不必锁定。以<code>Concurrent</code>开头的集合类采用了更复杂的算法来保证永远不会锁住整个集合,因此在并发写入时有较好的性能。</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>当多个线程共享访问一个公共集合时,<code>ConcurrentLinkedQueue</code>是一个恰当的选择。<code>ConcurrentLinkedQueue</code>不允许使用<code>null</code>元素。<code>ConcurrentLinkedQueue</code>实现了多线程的高效访问,多个线程访问<code>ConcurrentLinkedQueue</code>集合时无须等待。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>在默认情况下,<code>ConcurrentHashMap</code>支持<strong>16</strong>个线程并发写入,当有超过16个线程并发向该<code>Map</code>中写入数据时,可能有一些线程需要等待。实际上,程序通过设置<code>concurrencyLevel</code>构造参数(默认值为16)来支持更多的并发写入线程</p>
<h3 id="java-util-concurrent包下的集合和java-util包的集合在迭代时的区别"><a href="#java-util-concurrent包下的集合和java-util包的集合在迭代时的区别" class="headerlink" title="java.util.concurrent包下的集合和java.util包的集合在迭代时的区别"></a>java.util.concurrent包下的集合和java.util包的集合在迭代时的区别</h3><p>使用<code>java.util</code>包下的<code>Collection</code>作为集合对象时,<strong>如果该集合对象创建迭代器后集合元素发生改变,则会引发<code>ConcurrentModificationException</code>异常</strong>。<br>与前面介绍的<code>HashMap</code>和普通集合不同的是,因为<code>ConcurrentLinkedQueue</code>和<code>ConcurrentHashMap</code>支持多线程并发访问,所以<strong>当使用迭代器来遍历集合元素时,该迭代器可能无法反映出创建迭代器之后所做的修改,并且程序不会抛出任何异常</strong>。</p>
<h3 id="java8对ConcurrentHashMap的扩展"><a href="#java8对ConcurrentHashMap的扩展" class="headerlink" title="java8对ConcurrentHashMap的扩展"></a>java8对ConcurrentHashMap的扩展</h3><p><code>Java8</code>扩展了<code>ConcurrentHashMap</code>的功能,<code>Java8</code>为该类新增了30多个新方法,这些方法可借助于<code>Stream</code>和<code>Lambda</code>表达式支持执行聚集操作。</p>
<h3 id="Java8的ConcurrentHashMap新的的方法"><a href="#Java8的ConcurrentHashMap新的的方法" class="headerlink" title="Java8的ConcurrentHashMap新的的方法"></a>Java8的ConcurrentHashMap新的的方法</h3><p><code>ConcurrentHashMap</code>新增的方法大致可分为如下三类。</p>
<ul>
<li><code>forEach</code>系列(<code>forEach</code>,<code>ForEachKey</code>,<code>ForEachValue</code>,<code>ForEachEntry</code>)</li>
<li><code>search</code>系列(<code>search</code>,<code>SearchKeys</code>,<code>SearchValues</code>,<code>SearchEntries</code>)</li>
<li><code>reduce</code>系列(<code>reduce</code>,<code>reduceToDouble</code>,<code>reduceToLong</code>,<code>reduceKeys</code>,<code>reduceValues</code>)</li>
</ul>
<p>除此之外,<code>ConcurrentHashMap</code>还新增了<code>mappingCount()</code>、<code>newKeySet()</code>等方法,增强后的<code>ConcurrentHashMap</code>更适合作为缓存实现类使用。</p>
<h2 id="CopyOn开头的集合"><a href="#CopyOn开头的集合" class="headerlink" title="CopyOn开头的集合"></a>CopyOn开头的集合</h2><p>由于<code>CopyOnWriteArraySet</code>的底层封装了<code>CopyOnWriteArrayList</code>,因此它的实现机制完全类似于<code>CopyOnWriteArrayList</code>集合。<br>对于<code>CopyOnWriteArrayList</code>集合,正如它的名字所暗示的,它<strong>釆用复制底层数组的方式来实现写操作</strong></p>
<ul>
<li>当线程对<code>CopyOnWriteArrayList</code>集合执行读取操作时,线程将会直接读取集合本身,无须加锁与阻塞。</li>
<li>当线程对<code>CopyOnWriteArraylist</code>集合执行写入操作时(包括调用<code>add()</code>、<code>remove()</code>、<code>set()</code>等方法),该集合会在底层复制一份新的数组,接下来对新的数组执行写入操作。<ul>
<li>由于对**<code>CopyOnWriteArrayList</code>集合的写入操作都是对数组的副本执行操作,因此它是线程安全的**</li>
</ul>
</li>
</ul>
<p>需要指出的是,由于<code>CopyOnWriteArrayList</code>执行写入操作时需要频繁地复制数组,性能比较差,但由于读操作与写操作不是操作同一个数组,而且读操作也不需要加锁,因此<strong>读操作就很快、很安全</strong>。<br>由此可见,<strong><code>CopyOnWriteArrayList</code>适合用在读取操作远远大于写入操作的场景中,例如缓存等</strong>。</p>
<!-- CrazyJavaHandout4/Chapter16/19.6/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8df965bc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8df965bc/" class="post-title-link" itemprop="url">16.9.2 包装线程不安全的集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 07:04:24" itemprop="dateCreated datePublished" datetime="2020-01-10T07:04:24+08:00">2020-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-27 10:36:08" itemprop="dateModified" datetime="2020-03-27T10:36:08+08:00">2020-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8df965bc/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8df965bc/" data-xid="/JavaReadingNotes/8df965bc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-2-包装线程不安全的集合"><a href="#16-9-2-包装线程不安全的集合" class="headerlink" title="16.9.2 包装线程不安全的集合"></a>16.9.2 包装线程不安全的集合</h1><p>前面介绍<code>Java</code>集合时所讲的<code>ArrayList</code>、<code>Linkedlist</code>、<code>HashSet</code>、<code>TreeSet</code>、<code>HashMap</code>、<code>TreeMap</code>等都是线程不安全的,也就是说,当多个并发线程向这些集合中存、取元素时,就可能会破坏这些集合的数据完整性。</p>
<h2 id="Collections的synchronizedXxx方法"><a href="#Collections的synchronizedXxx方法" class="headerlink" title="Collections的synchronizedXxx方法"></a>Collections的synchronizedXxx方法</h2><p>如果程序中有多个线程可能访问以上这些集合,就可以<strong>使用<code>Collections</code>提供的类方法把这些集合包装成线程安全的集合</strong>。<br><code>Collections</code>提供了如下几个静态方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c)</code></td>
<td align="left">返回指定<code>collection</code>对应的线程安全的<code>collection</code></td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></td>
<td align="left">返回指定<code>List</code>对象对应的线程安全的<code>List</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;K,​V&gt; Map&lt;K,​V&gt; synchronizedMap(Map&lt;K,​V&gt; m)</code></td>
<td align="left">返回指定<code>Map</code>对象对应的线程安全的<code>Map</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></td>
<td align="left">返回指定<code>Set</code>对象对应的线程安全的<code>Set</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;K,​V&gt; SortedMap&lt;K,​V&gt; synchronizedSortedMap(SortedMap&lt;K,​V&gt; m)</code></td>
<td align="left">返回指定<code>SortedMap</code>对象对应的线程安全的<code>SortedMap</code>对象。</td>
</tr>
<tr>
<td align="left"><code>static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s)</code></td>
<td align="left">返回指定<code>SortedSet</code>对象对应的线程安全的<code>SortedSet</code>对象</td>
</tr>
</tbody></table>
<h2 id="代码-使用线程安全的HashMap"><a href="#代码-使用线程安全的HashMap" class="headerlink" title="代码 使用线程安全的HashMap"></a>代码 使用线程安全的HashMap</h2><p>例如需要在多线程中使用线程安全的<code>HashMap</code>对象,则可以采用如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Collectionss的synchronizedMap方法将一个普通的HashMap包装成线程安全的类</span></span><br><span class="line">HashMap m=Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br></pre></td></tr></table></figure>
<h2 id="创建后就包装"><a href="#创建后就包装" class="headerlink" title="创建后就包装"></a>创建后就包装</h2><p>如果需要把某个集合包装成线程安全的集合,则<strong>应该在创建之后立即包装</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a8a61bd3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a8a61bd3/" class="post-title-link" itemprop="url">16.9 线程相关类 16.9.1 Threadlocal类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 05:37:52" itemprop="dateCreated datePublished" datetime="2020-01-10T05:37:52+08:00">2020-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-27 10:30:54" itemprop="dateModified" datetime="2020-03-27T10:30:54+08:00">2020-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-9-%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">16.9 线程相关类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a8a61bd3/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a8a61bd3/" data-xid="/JavaReadingNotes/a8a61bd3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-9-线程相关类"><a href="#16-9-线程相关类" class="headerlink" title="16.9 线程相关类"></a>16.9 线程相关类</h1><p><code>Java</code>还为线程安全提供了一些工具类,如<code>ThreadLocal</code>类,它代表一个<strong>线程局部变量</strong>,<strong>通过把数据放在<code>ThreadLocal</code>中就可以<mark>让每个线程创建一个该变量的副本</mark>,从而避免并发访问的线程安全问题</strong>。除此之外,<code>Java5</code>还新增了大量的线程安全类。</p>
<h1 id="16-9-1-Threadlocal类"><a href="#16-9-1-Threadlocal类" class="headerlink" title="16.9.1 Threadlocal类"></a>16.9.1 Threadlocal类</h1><p>早在<code>JDK1.2</code>推出之时,<code>Java</code>就为多线程编程提供了一个<code>ThreadLocal</code>类;从<code>Java5.0</code>以后,<code>Java</code>引入了泛型支持,<code>Java</code>为该<code>ThreadLocal</code>类增加了泛型支持,即:<code>ThreadLocal&lt;T&gt;</code>。<strong>通过使用<code>ThreadLocal</code>类可以简化多线程编程时的并发访问,使用这个<code>ThreadLocal</code>类可以很简捷地隔离多线程程序的竞争资源</strong>.<br><code>ThreadLocal</code>,是<code>ThreadLocalVariable</code>(线程局部变量)的意思,也许将它命名为<code>ThreadLocalVar</code>更加合适。</p>
<h2 id="线程局部变量的作用"><a href="#线程局部变量的作用" class="headerlink" title="线程局部变量的作用"></a>线程局部变量的作用</h2><p>线程局部变量(<code>ThreadLocal</code>)的功用其实非常简单,就是<strong>为每一个使用该变量的线程都提供一个变量值的副本,使每一个线程都可以独立地改变自己的副本,而不会和其他线程的副本冲突</strong>。从线程的角度看,<strong>就好像每一个线程都完全拥有该变量一样</strong>。</p>
<h2 id="ThreadLocal常用方法"><a href="#ThreadLocal常用方法" class="headerlink" title="ThreadLocal常用方法"></a>ThreadLocal常用方法</h2><p><code>ThreadLocal</code>类的用法非常简单,它只提供了如下三个<code>public</code>方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>T get()</code></td>
<td align="left">返回此线程局部变量中当前线程副本中的值。</td>
</tr>
<tr>
<td align="left"><code>void remove()</code></td>
<td align="left">删除此线程局部变量中当前线程的值。</td>
</tr>
<tr>
<td align="left"><code>void set(T value)</code></td>
<td align="left">设置此线程局部变量中当前线程副本中的值</td>
</tr>
<tr>
<td align="left"><code>protected T initialValue()</code></td>
<td align="left">Returns the current thread’s “initial value” for this thread-local variable.</td>
</tr>
<tr>
<td align="left"><code>static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)</code></td>
<td align="left">Creates a thread local variable.</td>
</tr>
</tbody></table>
<h2 id="程序-ThreadLocal示例"><a href="#程序-ThreadLocal示例" class="headerlink" title="程序 ThreadLocal示例"></a>程序 ThreadLocal示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 定义一个ThreadLocal类型的变量，该变量将是一个线程局部变量 每个线程都会保留该变量的一个副本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个初始化name成员变量的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name.set(str);</span><br><span class="line">        <span class="comment">// 下面代码用于访问当前线程的name副本的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---&quot;</span> + <span class="built_in">this</span>.name.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// name的setter和getter方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name.set(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个Account类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyTest</span><span class="params">(Account account, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 循环10次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 当i == 6时输出将账户名替换成当前线程名</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">6</span>) &#123;</span><br><span class="line">                account.setName(getName());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出同一个账户的账户名和循环变量</span></span><br><span class="line">            System.out.println(account.getName() + <span class="string">&quot; 账户的i值：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动两条线程，两条线程共享同一个Account</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">at</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;初始名&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 虽然两条线程共享同一个账户，即只有一个账户名</span></span><br><span class="line"><span class="comment">         * 但由于账户名是ThreadLocal类型的，所以每条线程 都完全拥有各自的账户名副本，</span></span><br><span class="line"><span class="comment">         * 所以从i == 6之后，将看到两条 线程访问同一个账户时看到不同的账户名。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyTest</span>(at, <span class="string">&quot;线程甲&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyTest</span>(at, <span class="string">&quot;线程乙&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于程序中的账户名是一个<code>ThreadLocal</code>变量,所以虽然程序中只有一个<code>Account</code>对象,但两个子线程将会产生两个账户名(主线程也持有一个账户名的副本)。两个线程进行循环时都会在<code>i==6</code>时<strong>将账户名 改为 线程名</strong>,这样就可以看到两个线程拥有两个账户名的情形:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---初始名</span><br><span class="line">null 账户的i值：0</span><br><span class="line">null 账户的i值：0</span><br><span class="line">null 账户的i值：1</span><br><span class="line">null 账户的i值：1</span><br><span class="line">null 账户的i值：2</span><br><span class="line">null 账户的i值：2</span><br><span class="line">null 账户的i值：3</span><br><span class="line">null 账户的i值：3</span><br><span class="line">null 账户的i值：4</span><br><span class="line">null 账户的i值：5</span><br><span class="line">null 账户的i值：4</span><br><span class="line">线程乙 账户的i值：6</span><br><span class="line">null 账户的i值：5</span><br><span class="line">线程乙 账户的i值：7</span><br><span class="line">线程甲 账户的i值：6</span><br><span class="line">线程乙 账户的i值：8</span><br><span class="line">线程甲 账户的i值：7</span><br><span class="line">线程乙 账户的i值：9</span><br><span class="line">线程甲 账户的i值：8</span><br><span class="line">线程甲 账户的i值：9</span><br></pre></td></tr></table></figure>
<p>从上面程序可以看出,实际上账户名有三个副本,主线程一个,另外启动的两个线程各一个,它们的值互不干扰,<strong>每个线程完全拥有自己的<code>ThreadLocal</code>变量,这就是<code>ThreadLocal</code>的用途</strong>。</p>
<h2 id="ThreadLocal和加锁同步的区别"><a href="#ThreadLocal和加锁同步的区别" class="headerlink" title="ThreadLocal和加锁同步的区别"></a>ThreadLocal和加锁同步的区别</h2><p><code>ThreadLocal</code>和其他所有的同步机制一样,<strong>都是为了解决多线程中对同一变量的访问冲突</strong>.</p>
<ul>
<li>在普通的同步机制中,<strong>是通过对象加锁来实现多个线程对同一变量的安全访问的。该<mark>变量是多个线程共享的</mark></strong>,所以要使用这种同步机制,需要很细致地分析在什么时候对变量进行读写,什么时候需要锁定某个对象,什么时候释放该对象的锁等。在这种情况下,系统并没有将这份资源复制多份,只是采用了安全机制来控制对这份资源的访问而已。</li>
<li><code>ThreadLocal</code>从另一个角度来解决多线程的并发访问,<code>ThreadLocal</code>将需要并发访问的资源复制多份,<strong>每个线程拥有一份资源</strong>,每个线程都拥有自己的资源副本,从而也就没有必要对该变量进行同步了,<code>ThreadLocal</code>提供了线程安全的共享对象,在编写多线程代码时,可以把不安全的整个变量封装进<code>ThreadLocal</code>,或者把该对象与线程相关的状态使用<code>ThreadLocal</code>保存。</li>
</ul>
<h2 id="ThreadeLocal不能替代同步"><a href="#ThreadeLocal不能替代同步" class="headerlink" title="ThreadeLocal不能替代同步"></a>ThreadeLocal不能替代同步</h2><p><code>ThreadLocal</code>并不能替代同步机制,两者面向的问题领域不同。</p>
<ul>
<li><strong>同步机制是为了同步多个线程对相同资源的并发访问,是多个线程之间进行通信的有效方式</strong>;</li>
<li>而<code>ThreadLocal</code>是为了隔离多个线程的数据共享,<strong>从根本上避免多个线程之间对共享资源(变量)的竞争</strong>,也就不需要对多个线程进行同步了。</li>
</ul>
<h2 id="什么时候用同步机制-什么时候使用ThreadLocal"><a href="#什么时候用同步机制-什么时候使用ThreadLocal" class="headerlink" title="什么时候用同步机制 什么时候使用ThreadLocal"></a>什么时候用同步机制 什么时候使用<code>ThreadLocal</code></h2><p>通常建议:</p>
<ul>
<li><strong>如果多个线程之间需要共享资源,以达到线程之间的通信功能</strong>,就使用<strong>同步机制</strong>;</li>
<li><strong>如果仅仅需要隔离多个线程之间的共享冲突,则可以使用<code>ThreadLocal</code></strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a4641bde/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a4641bde/" class="post-title-link" itemprop="url">16.8.2 Java8增强的ForkJoinPool</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 05:12:19" itemprop="dateCreated datePublished" datetime="2020-01-10T05:12:19+08:00">2020-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-27 09:59:12" itemprop="dateModified" datetime="2020-03-27T09:59:12+08:00">2020-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-8-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">16.8 线程池</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a4641bde/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a4641bde/" data-xid="/JavaReadingNotes/a4641bde/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-8-2-Java8增强的ForkJoinPool"><a href="#16-8-2-Java8增强的ForkJoinPool" class="headerlink" title="16.8.2 Java8增强的ForkJoinPool"></a>16.8.2 Java8增强的ForkJoinPool</h1><p>现在计算机大多已向多<code>CPU</code>方向发展,即使普通<code>PC</code>,甚至小型智能设备(如手机)、多核处理器也已被广泛应用。在未来的日子里,处理器的核心数将会发展到更多。<br>虽然硬件上的多核<code>CPU</code>已经十分成熟,但很多应用程序并未为这种多核<code>CPU</code>做好准备,因此并不能很好地利用多核<code>CPU</code>的性能优势。<br>为了充分利用多<code>CPU</code>、多核<code>CPU</code>的性能优势,计算机软件系统应该可以充分“挖掘”每个<code>CPU</code>的计算能力,绝不能让某个<code>CPU</code>处于“空闲”状态。为了充分利用多<code>CPU</code>、多核<code>CPU</code>的优势,可以考虑把一个任务拆分成多个“小任务”,把多个“小任务”放到多个处理器核心上并行执行;当多个“小任务”执行完成之后,再将这些执行结果合并起来即可。</p>
<h2 id="Java7提供的ForkJoinPool"><a href="#Java7提供的ForkJoinPool" class="headerlink" title="Java7提供的ForkJoinPool"></a>Java7提供的ForkJoinPool</h2><p><strong><code>Java7</code>提供了<code>ForkJoinPool</code>来支持将一个任务拆分成多个“小任务”并行计算,再把多个“小任务”的结果合并成总的计算结果</strong>。<br><strong><code>ForkJoinPool</code>是<code>ExecutorService</code>的实现类,因此是一种特殊的线程池</strong>。</p>
<h3 id="ForkJoinPool构造器"><a href="#ForkJoinPool构造器" class="headerlink" title="ForkJoinPool构造器"></a>ForkJoinPool构造器</h3><p><code>ForkJoinPool</code>提供了如下两个常用的构造器。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ForkJoinPool(int parallelism)</code></td>
<td align="left">创建一个包含<code>parallelism</code>个并行线程的<code>ForkJoinPool</code>。</td>
</tr>
<tr>
<td align="left"><code>ForkJoinPool()</code></td>
<td align="left">以<code>Runtime.availableProcessors()</code>方法的返回值作为<code>parallelism</code>参数来创建<code>ForkJoinPool</code>。</td>
</tr>
</tbody></table>
<h2 id="Java8对ForkJoinPool的扩展"><a href="#Java8对ForkJoinPool的扩展" class="headerlink" title="Java8对ForkJoinPool的扩展"></a>Java8对ForkJoinPool的扩展</h2><p><code>Java8</code>进一步扩展了<code>ForkJoinPool</code>的功能,<code>Java8</code>为<code>ForkJoinPool</code>增加了<strong>通用池</strong>功能。</p>
<p><code>ForkJoinPool</code>类通过如下两个静态方法提供通用池功能。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ForkJoinPool commonPool()</code></td>
<td align="left">该方法返回一个通用池.<br>通用池的运行状态不会受<code>shutdown()</code>或<code>shutdownNow()</code>方法的影响。<br>当然,如果程序直接执行<code>System.exit(0);</code>来终止虚拟机,<br>则通用池以及通用池中正在执行的任务都会被自动终止。</td>
</tr>
<tr>
<td align="left"><code>static int getCommonPoolParallelism()</code></td>
<td align="left">返回通用池的并行级别</td>
</tr>
</tbody></table>
<h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p>创建了<code>ForkJoinPool</code>实例之后,就可调用<code>ForkJoinPool</code>的<code>submit(ForkJoinTask task)</code>或<code>invoke(ForkJoinTask task)</code>方法来执行指定任务了。</p>
<ul>
<li>其中**<code>ForkJoinTask</code>代表一个可以并行、合并的任务**。</li>
<li>这个<code>ForkJoinTask</code>是一个抽象类,它还有两个抽象子类:<code>RecursiveAction</code>和<code>RecursiveTask</code>。其中<ul>
<li><code>RecursiveTask</code>代表<strong>有返回值的任务</strong>,</li>
<li><code>RecursiveAction</code>代表<strong>没有返回值的任务</strong>。</li>
</ul>
</li>
</ul>
<p>图16.14显示了<code>ForkJoinPool</code>、<code>ForkJoinTask</code>等类的类图。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter16/16.8.2/1.png" alt="这里有一张图片"></p>
<h2 id="无返回值的大任务分解"><a href="#无返回值的大任务分解" class="headerlink" title="无返回值的大任务分解"></a>无返回值的大任务分解</h2><h3 id="程序-使用ForkJoinPool将大任务拆分"><a href="#程序-使用ForkJoinPool将大任务拆分" class="headerlink" title="程序 使用ForkJoinPool将大任务拆分"></a>程序 使用ForkJoinPool将大任务拆分</h3><p>下面以执行没有返回值的“大任务”(简单地打印0-300的数值)为例,程序将一个“大任务”拆分成多个“小任务”,并将任务交给<code>ForkJoinPool</code>来执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承RecursiveAction来实现&quot;可分解&quot;的任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveAction</span> &#123;</span><br><span class="line">    <span class="comment">// 每个“小任务”只最多只打印50个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印从start到end的任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintTask</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 当end与start之间的差小于THRESHOLD时，开始打印</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值：&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个</span></span><br><span class="line">            <span class="comment">// 将大任务分解成两个小任务。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">PrintTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTask</span>(start, middle);</span><br><span class="line">            <span class="type">PrintTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTask</span>(middle, end);</span><br><span class="line">            <span class="comment">// 并行执行两个“小任务”</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="comment">// 提交可分解的PrintTask任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">PrintTask</span>(<span class="number">0</span>, <span class="number">300</span>));</span><br><span class="line">        pool.awaitTermination(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果当end与start之间的差大于THRESHOLD时，即要打印的数超过50个</span></span><br><span class="line"><span class="comment">// 将大任务分解成两个小任务。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line"><span class="type">PrintTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTask</span>(start, middle);</span><br><span class="line"><span class="type">PrintTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintTask</span>(middle, end);</span><br><span class="line"><span class="comment">// 并行执行两个“小任务”</span></span><br><span class="line">left.fork();</span><br><span class="line">right.fork();</span><br></pre></td></tr></table></figure>
<p>实现了对指定打印任务的分解,分解后的任务分别调用<code>fork()</code>方法开始并行执行运行上面程序,可以看到下所示的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-1-worker-1的i值：262</span><br><span class="line">ForkJoinPool-1-worker-3的i值：37 </span><br><span class="line">ForkJoinPool-1-worker-4的i值：0  </span><br><span class="line">ForkJoinPool-1-worker-2的i值：112</span><br><span class="line">ForkJoinPool-1-worker-4的i值：1  </span><br><span class="line">ForkJoinPool-1-worker-3的i值：38 </span><br><span class="line">ForkJoinPool-1-worker-1的i值：263</span><br><span class="line">ForkJoinPool-1-worker-3的i值：39 </span><br><span class="line">ForkJoinPool-1-worker-4的i值：2  </span><br><span class="line">ForkJoinPool-1-worker-2的i值：113</span><br><span class="line">ForkJoinPool-1-worker-4的i值：3  </span><br><span class="line">ForkJoinPool-1-worker-3的i值：40 </span><br><span class="line">ForkJoinPool-1-worker-1的i值：264</span><br><span class="line">ForkJoinPool-1-worker-3的i值：41 </span><br><span class="line">ForkJoinPool-1-worker-4的i值：4  </span><br><span class="line">ForkJoinPool-1-worker-2的i值：114</span><br><span class="line">ForkJoinPool-1-worker-4的i值：5  </span><br><span class="line">......</span><br><span class="line">ForkJoinPool-1-worker-2的i值：257</span><br><span class="line">ForkJoinPool-1-worker-2的i值：258</span><br><span class="line">ForkJoinPool-1-worker-2的i值：259</span><br><span class="line">ForkJoinPool-1-worker-2的i值：260</span><br><span class="line">ForkJoinPool-1-worker-2的i值：261</span><br></pre></td></tr></table></figure>
<p>从执行结果来看,<code>ForkJoinPool</code>启动了4个线程来执行这个打印任务—这是因为测试计算机的<code>CPU</code>是4核的。不仅如此,读者可以看到程序虽然打印了0-299这300个数字,但并不是连续打印的,这是因为程序将这个打印任务进行了分解,分解后的任务会并行执行,所以不会按顺序从0打印到299。</p>
<h2 id="有返回值的大任务分解"><a href="#有返回值的大任务分解" class="headerlink" title="有返回值的大任务分解"></a>有返回值的大任务分解</h2><p>上面定义的任务是一个没有返回值的打印任务,如果大任务是有返回值的任务,则可以<strong>让任务继承<code>RecursiveTask&lt;T&gt;</code>,其中泛型参数<code>T</code>就代表了该任务的返回值类型。</strong></p>
<h3 id="程序-使用RecursiveTask对数组求和"><a href="#程序-使用RecursiveTask对数组求和" class="headerlink" title="程序 使用RecursiveTask对数组求和"></a>程序 使用<code>RecursiveTask</code>对数组求和</h3><p>下面程序示范了使用<code>RecursiveTask</code>对一个长度为100的数组的元素值进行累加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承RecursiveTask来实现&quot;可分解&quot;的任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">// 每个“小任务”只最多只累加20个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> arr[];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加从start到end的数组元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalTask</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当end与start之间的差小于THRESHOLD时，开始进行实际累加</span></span><br><span class="line">        <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当end与start之间的差大于THRESHOLD时，即要累加的数超过20个时</span></span><br><span class="line">            <span class="comment">// 将大任务分解成两个小任务。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">CalTask</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, start, middle);</span><br><span class="line">            <span class="type">CalTask</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, middle, end);</span><br><span class="line">            <span class="comment">// 并行执行两个“小任务”</span></span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="comment">// 把两个“小任务”累加的结果合并起来</span></span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join(); <span class="comment">// ①</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化100个数字元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> rand.nextInt(<span class="number">20</span>);</span><br><span class="line">            <span class="comment">// 对数组元素赋值，并将数组元素的值添加到sum总和中。</span></span><br><span class="line">            total += (arr[i] = tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(total);</span><br><span class="line">        <span class="comment">// 创建一个通用池</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> ForkJoinPool.commonPool();</span><br><span class="line">        <span class="comment">// 提交可分解的CalTask任务</span></span><br><span class="line">        Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> <span class="title class_">CalTask</span>(arr, <span class="number">0</span>, arr.length));</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序与前一个程序基本相似,同样是将任务进行了分解,并调用分解后的任务的<code>fork()</code>方法使它们并行执行。与前一个程序不同的是,现在任务是带返回值的,因此程序还在①号代码处将两个分解后的“小任务”的返回值进行了合并。<br>运行上面程序,将可以看到程序通过<code>CalTask</code>计算出来的总和,与初始化数组元素时统计出来的总和总是相等,这表明程序一切正常。</p>
<!-- CrazyJavaHandout4/Chapter16/16.8.2/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/547f08c8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/547f08c8/" class="post-title-link" itemprop="url">16.8 线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-10 04:36:02" itemprop="dateCreated datePublished" datetime="2020-01-10T04:36:02+08:00">2020-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-27 09:36:33" itemprop="dateModified" datetime="2020-03-27T09:36:33+08:00">2020-03-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-8-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" itemprop="url" rel="index"><span itemprop="name">16.8 线程池</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/547f08c8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/547f08c8/" data-xid="/JavaReadingNotes/547f08c8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-8-线程池"><a href="#16-8-线程池" class="headerlink" title="16.8 线程池"></a>16.8 线程池</h1><p>系统启动一个新线程的成本是比较高的,因为它涉及与操作系统交互。在这种情形下,使用线程池可以很好地提高性能,尤其是当程序中需要创建大量生存期很短暂的线程时,更应该考虑使用线程池。<br>与数据库连接池类似的是,线程池在系统<code>启动时</code>即创建大量空闲的线程,程序将一个<code>Runnable</code>对象或<code>Callable</code>对象传给线程池,线程池就会启动一个空闲的线程来执行它们的<code>run()</code>或<code>call()</code>方法,<strong>当<code>run()</code>或<code>call()</code>方法执行结束后,该线程并不会死亡,而是再次返回线程池中成为空闲状态,等待执行下一个<code>Runnable</code>对象的<code>run()</code>(或<code>cal()</code>方法</strong>。<br>除此之外,使用线程池可以有效地控制系统中并发线程的数量,当系统中包含大量并发线程时,会导致系统性能剧烈下降,甚至导致<code>JVM</code>崩溃,而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。</p>
<h1 id="16-8-1-Java8改进的线程池"><a href="#16-8-1-Java8改进的线程池" class="headerlink" title="16.8.1 Java8改进的线程池"></a>16.8.1 Java8改进的线程池</h1><h2 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h2><p>在<code>Java5</code>以前,开发者必须手动实现自己的线程池;从<code>Java5</code>开始,<code>Java</code>内建支持线程池。<code>Java5</code>新增了一个<code>Executors</code>工厂类来产生线程池,该工厂类包含如下几个静态工厂方法来创建线程池</p>
<h3 id="创建ExecutorService线程池"><a href="#创建ExecutorService线程池" class="headerlink" title="创建ExecutorService线程池"></a>创建ExecutorService线程池</h3><table>
<thead>
<tr>
<th align="left"><code>Executors</code>类方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ExecutorService newCachedThreadPool()</code></td>
<td align="left">创建一个具有<strong>缓存功能</strong>的线程池,系统根据需要创建线程,这些线程将会被缓存在线程池中。</td>
</tr>
<tr>
<td align="left"><code>static ExecutorService newFixedThreadPool(int nThreads)</code></td>
<td align="left">创建一个<strong>可重用的、具有固定线程数</strong>的线程池。</td>
</tr>
<tr>
<td align="left"><code>static ExecutorService newSingleThreadExecutor()</code></td>
<td align="left">创建一个<strong>只有单线程的线程池</strong>,它相当于调用<code>newFixedThreadPool()</code>方法时传入参数为1。</td>
</tr>
</tbody></table>
<p><code>ExecutorService</code>对象对象代表一个线程池,它可以执行<code>Runnable</code>对象或<code>Callable</code>对象所代表的线程;</p>
<h3 id="创建ScheduledExecutorService线程池"><a href="#创建ScheduledExecutorService线程池" class="headerlink" title="创建ScheduledExecutorService线程池"></a>创建ScheduledExecutorService线程池</h3><table>
<thead>
<tr>
<th align="left"><code>Executors</code>类方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</code></td>
<td align="left">创建具有指定线程数的线程池,它可以在指定延迟后执行线程任务。<br><code>corePoolSize</code>指池中所保存的线程数,即使线程是空闲的也被保存在线程池内。</td>
</tr>
<tr>
<td align="left"><code>static ScheduledExecutorService newSingleThreadScheduledExecutor()</code></td>
<td align="left">创建只有一个线程的线程池,它可以在指定延迟后执行线程任务。</td>
</tr>
</tbody></table>
<p><code>ScheduledExecutorService</code>是<code>ExecutorService</code>的子类,它可以在指定延迟后执行线程任务;</p>
<h3 id="java8-新增的workStealing池"><a href="#java8-新增的workStealing池" class="headerlink" title="java8 新增的workStealing池"></a>java8 新增的workStealing池</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ExecutorService newWorkStealingPool(int parallelism)</code></td>
<td align="left">创建持有足够的线程的线程池来支持给定的并行级别,该方法还会使用多个队列来减少竞争。</td>
</tr>
<tr>
<td align="left"><code>static ExecutorService newWorkStealingPool()</code></td>
<td align="left">该方法是前一个方法的简化版本。如果当前机器有4个<code>CPU</code>,则目标并行级别被设置为4,也就是相当于为前一个方法传入4作为参数。</td>
</tr>
</tbody></table>
<p>这两个方法则是<code>Java8</code>新增的,这两个方法可<strong>充分利用多<code>CPU</code>并行</strong>的能力。这两个方法生成的<code>workStealing</code>池,都相当于<strong>后台线程池</strong>,<strong>如果所有的前台线程都死亡了,<code>workStealing</code>池中的线程会自动死亡</strong>。<br>由于目前计算机硬件的发展日新月异,即使普通用户使用的电脑通常也都是多核<code>CPU</code>,因此<code>Java8</code>在线程支持上也增加了利用多<code>CPU</code>并行的能力,这样可以更好地发挥底层硬件的性能。</p>
<h2 id="尽快执行线程池ExecutorService"><a href="#尽快执行线程池ExecutorService" class="headerlink" title="尽快执行线程池ExecutorService"></a>尽快执行线程池ExecutorService</h2><p><strong><code>ExecutorService</code>代表尽快执行线程的线程池</strong>(只要线程池中有空闲线程,就立即执行线程任务),程序只要将一个<code>Runnable</code>对象或<code>Callable</code>对象(代表线程任务)提交给该线程池,该线程池就会尽快执行该任务。</p>
<p><code>ExecutorService</code>里提供了如下三个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Future&lt;?&gt; submit(Runnable task)</code></td>
<td align="left">将一个<code>Runnable</code>对象提交给指定的线程池,线程池将在有空闲线程时执行<code>Runnable</code>对象代表的任务。<br>其中<code>Future</code>对象代表<code>Runnable</code>任务的返回值——但<code>run()</code>方法没有返回值,<br>所以<code>Future</code>对象将在<code>run()</code>方法执行结束后返回<code>null</code>,<br>但可以调用<code>Future</code>的<code>isDone()</code>、<code>isCancelled()</code>方法来获得<code>Runnable</code>对象的执行状态。</td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</code></td>
<td align="left">将一个<code>Runnable</code>对象提交给指定的线程池,线程池将在有空闲线程时执行<code>Runnable</code>对象代表的任务。<br>其中<code>result</code>显式指定线程执行结束后的返回值,<br>所以<code>Future</code>对象将在<code>run()</code>方法执行结束后返回<code>result</code></td>
</tr>
<tr>
<td align="left"><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td>
<td align="left">将一个<code>Callable</code>对象提交给指定的线程池,线程池将在有空闲线程时执行<code>Callable</code>对象代表的任务。<br>其中<code>Future</code>代表<code>Callable</code>对象里<code>call()</code>方法的返回值。</td>
</tr>
</tbody></table>
<h2 id="延迟周期线程池ScheduledExecutorService"><a href="#延迟周期线程池ScheduledExecutorService" class="headerlink" title="延迟周期线程池ScheduledExecutorService"></a>延迟周期线程池ScheduledExecutorService</h2><p><strong><code>ScheduledExecutorService</code>代表可在指定延迟后或周期性地执行线程任务的线程池</strong>,它提供了如下4个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</code></td>
<td align="left">指定<code>command</code>任务将在<code>delay</code>延迟后执行。</td>
</tr>
<tr>
<td align="left"><code>&lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td>
<td align="left">指定<code>callable</code>任务将在<code>delay</code>延迟后执行。</td>
</tr>
<tr>
<td align="left"><code>ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td>
<td align="left">指定<code>command</code>任务将在<code>delay</code>延迟后执行,而且以设定频率重复执行。也就是说,在<code>initialDelay</code>后开始执行,依次在<code>initialDelay+Period</code>、<code>initialDelay+2*period</code>,…,处重复执行,依此类推。</td>
</tr>
<tr>
<td align="left"><code>ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td>
<td align="left">创建并执行一个在给定初始延迟后首次启用的定期操作,随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务在任一次执行时遇到异常,就会取消后续执行;否则,只能通过程序来显式取消或终止该任务。</td>
</tr>
</tbody></table>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><h3 id="shutdown方法"><a href="#shutdown方法" class="headerlink" title="shutdown方法"></a>shutdown方法</h3><p>用完一个线程池后,应该调用该线程池的<code>shutdown</code>方法,该方法将启动线程池的关闭序列,<strong>调用<code>shutdown()</code>方法后的线程池不再接收新任务,但会将以前所有已提交任务执行完成</strong>。当线程池中的所有任务都执行完成后,池中的所有线程都会死亡;</p>
<h3 id="shutdownNow方法"><a href="#shutdownNow方法" class="headerlink" title="shutdownNow方法"></a>shutdownNow方法</h3><p>另外也可以调用线程池的<code>shutdownNow()</code>方法来关闭线程池,该方法试图停止所有正在执行的活动任务,暂停处理正在等待的任务,并返回等待执行的任务列表。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void shutdown()</code></td>
<td align="left">Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted.</td>
</tr>
<tr>
<td align="left"><code>List&lt;Runnable&gt; shutdownNow()</code></td>
<td align="left">Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution.</td>
</tr>
</tbody></table>
<h2 id="使用线程池步骤"><a href="#使用线程池步骤" class="headerlink" title="使用线程池步骤"></a>使用线程池步骤</h2><p>使用线程池来执行线程任务的步骤如下:</p>
<ol>
<li>调用<code>Executors</code>类的静态工厂方法创建一个<code>ExecutorService</code>对象,该对象代表一个线程池。</li>
<li>创建<code>Runnable</code>实现类或<code>Callable</code>实现类的实例,作为线程执行任务。</li>
<li>调用<code>ExecutorService</code>对象的<code>submit</code>方法来提交<code>Runnable</code>实例或<code>Callable</code>实例。</li>
<li>当不想提交任何任务时,调用<code>ExecutorService</code>对象的<code>shutdown()</code>方法来关闭线程池。</li>
</ol>
<h2 id="程序-使用线程池"><a href="#程序-使用线程池" class="headerlink" title="程序 使用线程池"></a>程序 使用线程池</h2><p>下面程序使用线程池来执行指定<code>Runnable</code>对象所代表的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建足够的线程来支持4个CPU并行的线程池</span></span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数（6）的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式创建Runnable对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;的i值为:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 向线程池中提交两个线程</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中创建<code>Runnable</code>实现类与最开始创建线程池并没有太大差别,创建了<code>Runnable</code>实现类之后程序没有直接创建线程、启动线程来执行该<code>Runnable</code>任务,而是通过线程池来执行该任务,使用线程池来执行<code>Runnable</code>任务的代码如程序中粗体字代码所示。运行上面程序,将看到两个线程交替执行的效果,如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1的i值为:0</span><br><span class="line">pool-1-thread-2的i值为:0 </span><br><span class="line">pool-1-thread-1的i值为:1 </span><br><span class="line">pool-1-thread-2的i值为:1 </span><br><span class="line">pool-1-thread-2的i值为:2 </span><br><span class="line">......</span><br><span class="line">pool-1-thread-1的i值为:98</span><br><span class="line">pool-1-thread-2的i值为:97</span><br><span class="line">pool-1-thread-1的i值为:99</span><br><span class="line">pool-1-thread-2的i值为:98</span><br><span class="line">pool-1-thread-2的i值为:99</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/5795df74/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/5795df74/" class="post-title-link" itemprop="url">16.7 线程组和未处理的异常</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-09 08:40:26" itemprop="dateCreated datePublished" datetime="2020-01-09T08:40:26+08:00">2020-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-26 04:10:29" itemprop="dateModified" datetime="2020-03-26T04:10:29+08:00">2020-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-7-%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E6%9C%AA%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8/" itemprop="url" rel="index"><span itemprop="name">16.7 线程组和未处理的异常</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/5795df74/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/5795df74/" data-xid="/JavaReadingNotes/5795df74/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-7-线程组和未处理的异常"><a href="#16-7-线程组和未处理的异常" class="headerlink" title="16.7 线程组和未处理的异常"></a>16.7 线程组和未处理的异常</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p><code>Java</code>使用<code>ThreadGroup</code>来表示线程组,它可以对一批线程进行分类管理,<code>Java</code>允许程序直接对线程组进行控制。<strong>对线程组的控制相当于同时控制这批线程</strong>。<br>用户创建的所有线程都属于指定线程组,如果程序没有显式指定线程属于哪个线程组,则该线程属于<strong>默认线程组</strong>。</p>
<h3 id="子线程默认和父线程同组"><a href="#子线程默认和父线程同组" class="headerlink" title="子线程默认和父线程同组"></a>子线程默认和父线程同组</h3><p><strong>在默认情况下,子线程和创建它的父线程处于同一个线程组内</strong>,例如A线程创建了B线程,并且没有指定B线程的线程组,则B线程属于A线程所在的线程组。</p>
<h3 id="一天是不良人一辈子都是不良人"><a href="#一天是不良人一辈子都是不良人" class="headerlink" title="一天是不良人一辈子都是不良人"></a>一天是不良人一辈子都是不良人</h3><p>一旦某个线程加入了指定线程组之后,该线程将一直属于该线程组,直到该线程死亡,线程运行中途不能改变它所属的线程组。</p>
<h3 id="Thread类线程组构造器"><a href="#Thread类线程组构造器" class="headerlink" title="Thread类线程组构造器"></a>Thread类线程组构造器</h3><p><code>Thread</code>类提供了如下几个构造器来设置新创建的线程属于哪个线程组。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Thread(ThreadGroup group, Runnable target)</code></td>
<td align="left">以<code>target</code>的<code>run()</code>方法作为线程执行体创建新线程,该线程属于<code>group</code>线程组。</td>
</tr>
<tr>
<td align="left"><code>Thread(ThreadGroup group, Runnable target, String name)</code></td>
<td align="left">以<code>target</code>的<code>run()</code>方法作为线程执行体创建新线程,该线程属于<code>group</code>线程组,且线程名为<code>name</code>。</td>
</tr>
<tr>
<td align="left"><code>Thread(ThreadGroup group, String name)</code></td>
<td align="left">创建新线程,新线程名为<code>name</code>,属于<code>group</code>线程组。</td>
</tr>
<tr>
<td align="left"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize)</code></td>
<td align="left">Allocates a new Thread object so that it has target as its run object, has the specified name as its name, and belongs to the thread group referred to by group, and has the specified stack size.</td>
</tr>
<tr>
<td align="left"><code>Thread(ThreadGroup group, Runnable target, String name, long stackSize, boolean inheritThreadLocals)</code></td>
<td align="left">Allocates a new Thread object so that it has target as its run object, has the specified name as its name, belongs to the thread group referred to by group, has the specified stackSize, and inherits initial values for inheritable thread-local variables if inheritThreadLocals is true.</td>
</tr>
</tbody></table>
<h3 id="获取当前线程的线程组"><a href="#获取当前线程的线程组" class="headerlink" title="获取当前线程的线程组"></a>获取当前线程的线程组</h3><p>因为<strong>中途不可改变线程所属的线程组</strong>,所以<code>Thread</code>类没有提供<code>setThreadGroup()</code>方法来改变线程所属的线程组,但提供了一个<code>getThreadGroup()</code>方法来返回该线程所属的线程组,<code>getThreadGroup()</code>方法的返回值是<code>ThreadGroup</code>对象,表示一个线程组。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ThreadGroup getThreadGroup()</code></td>
<td align="left">Returns the thread group to which this thread belongs.</td>
</tr>
</tbody></table>
<h3 id="ThreadGroup构造器"><a href="#ThreadGroup构造器" class="headerlink" title="ThreadGroup构造器"></a>ThreadGroup构造器</h3><p><code>ThreadGroup</code>类提供了如下两个简单的构造器来创建实例。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ThreadGroup(String name)</code></td>
<td align="left">以指定的线程组名字来创建新的线程组。</td>
</tr>
<tr>
<td align="left"><code>ThreadGroup(ThreadGroup parent, String name)</code></td>
<td align="left">以指定的名字、指定的父线程组创建一个新线程组。</td>
</tr>
</tbody></table>
<p>上面两个构造器在创建线程组实例时都必须为其指定一个名字,也就是说,线程组总会具有一个字符串类型的名字,该名字可通过调用<code>ThreadGroup</code>的<code>getName()</code>方法来获取,但<strong>不允许改变线程组的名字</strong>。</p>
<h3 id="ThreadGroup方法"><a href="#ThreadGroup方法" class="headerlink" title="ThreadGroup方法"></a>ThreadGroup方法</h3><p><code>ThreadGroup</code>类提供了如下几个常用的方法来操作整个线程组里的所有线程。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int activeCount()</code></td>
<td align="left">返回此线程组中活动线程的数目</td>
</tr>
<tr>
<td align="left"><code>void interrupt()</code></td>
<td align="left">中断此线程组中的所有线程</td>
</tr>
<tr>
<td align="left"><code>boolean isDaemon()</code></td>
<td align="left">判断该线程组是否是后台线程组</td>
</tr>
<tr>
<td align="left"><code>void setDaemon(boolean daemon)</code></td>
<td align="left">把该线程组设置成后台线程组。<br>后台线程组具有一个特征:<br><strong>当后台线程组的最后一个线程执行结束或最后一个线程被销毁后,后台线程组将自动销毁</strong>。</td>
</tr>
<tr>
<td align="left"><code>void setMaxPriority(int pri)</code></td>
<td align="left">设置线程组的最高优先级</td>
</tr>
</tbody></table>
<h3 id="程序-线程组"><a href="#程序-线程组" class="headerlink" title="程序 线程组"></a>程序 线程组</h3><p>下面程序创建了几个线程,它们分别属于不同的线程组,程序还将一个线程组设置成后台线程组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 提供指定线程名的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供指定线程名、线程组的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(ThreadGroup group, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(group, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; 线程的i变量&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadGroupTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取主线程所在的线程组，这是所有线程默认的线程组</span></span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">mainGroup</span> <span class="operator">=</span> Thread.currentThread().getThreadGroup();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程组的名字：&quot;</span> + mainGroup.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程组是否是后台线程组：&quot;</span> + mainGroup.isDaemon());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;主线程组的线程&quot;</span>).start();</span><br><span class="line">        <span class="type">ThreadGroup</span> <span class="variable">tg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadGroup</span>(<span class="string">&quot;新线程组&quot;</span>);</span><br><span class="line">        <span class="comment">// 设为后台线程</span></span><br><span class="line">        tg.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;tg线程组是否是后台线程组：&quot;</span> + tg.isDaemon());</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">tt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(tg, <span class="string">&quot;tg组的线程甲&quot;</span>);</span><br><span class="line">        tt.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(tg, <span class="string">&quot;tg组的线程乙&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">主线程组的名字：main</span><br><span class="line">主线程组是否是后台线程组：false</span><br><span class="line">tg线程组是否是后台线程组：true </span><br><span class="line">主线程组的线程 线程的i变量0    </span><br><span class="line">主线程组的线程 线程的i变量1    </span><br><span class="line">tg组的线程甲 线程的i变量0      </span><br><span class="line">tg组的线程乙 线程的i变量0      </span><br><span class="line">主线程组的线程 线程的i变量2    </span><br><span class="line">...</span><br><span class="line">tg组的线程乙 线程的i变量19</span><br><span class="line">tg组的线程甲 线程的i变量10</span><br><span class="line">...</span><br><span class="line">主线程组的线程 线程的i变量19</span><br><span class="line">tg组的线程甲 线程的i变量18</span><br><span class="line">tg组的线程甲 线程的i变量19</span><br></pre></td></tr></table></figure>
<h2 id="线程组异常处理"><a href="#线程组异常处理" class="headerlink" title="线程组异常处理"></a>线程组异常处理</h2><h3 id="处理线程组内抛出的异常"><a href="#处理线程组内抛出的异常" class="headerlink" title="处理线程组内抛出的异常"></a>处理线程组内抛出的异常</h3><p><code>ThreadGroup</code>内还定义了一个很有用的<code>uncaughtException</code>方法:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void uncaughtException(Thread t, Throwable e)</code></td>
<td align="left">该方法可以<strong>处理该线程组内的任意线程所抛出的未处理异常</strong></td>
</tr>
</tbody></table>
<p>从<code>Java5</code>开始,<code>Java</code>加强了线程的异常处理,如果线程执行过程中抛出了一个未处理异常,<code>JVM</code>在结束该线程之前会自动查找是否有对应的<code>Thread.UncaughtExceptionHandler</code>对象,如果找到该处理器对象,则会调用该对象的<code>uncaughtException(Thread t, Throwable e)</code>方法来处理该异常。</p>
<p><code>Thread.UncaughtExceptionHandler</code>是<code>Thread</code>类的一个静态内部接口,该接口内只有一个方法:<code>void uncaughtException(Thread t, Throwable e)</code>,该方法中的t代表出现异常的线程,而e代表该线程抛出的异常。</p>
<h3 id="设置线程异常处理器"><a href="#设置线程异常处理器" class="headerlink" title="设置线程异常处理器"></a>设置线程异常处理器</h3><p><code>Thread</code>类提供了如下两个方法来<strong>设置异常处理器</strong>。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></td>
<td align="left">为该线程类的所有线程实例设置默认的异常处理器。</td>
</tr>
<tr>
<td align="left"><code>set UncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)</code></td>
<td align="left">为指定的线程实例设置异常处理器</td>
</tr>
</tbody></table>
<p><code>ThreadGroup</code>类实现了<code>ThreadUncaughtHandler</code>接口,所以每个线程所属的<strong>线程组将会作为默认的异常处理器</strong>。当一个线程抛出未处理异常时,</p>
<ul>
<li>首先,<code>JVM</code>会査找该异常对应的异常处理器(<code>setUncaughtExceptionHandler</code>方法设置的异常处理器),如果找到该异常处理器,则将调用该异常处理器处理该异常;</li>
<li>否则,<code>JVM</code>将会调用该线程所属的线程组对象的<code>uncaughtException</code>方法来处理该异常线程组处理异常的默认流程如下。<ul>
<li>如果该线程组有父线程组,则调用父线程组的<code>uncaughtException()</code>方法来处理该异常</li>
<li>如果该线程实例所属的线程类有默认的异常处理器(由<code>setDefaultUncaughtExceptionHandler</code>方法设置的异常处理器),那么就调用该异常处理器来处理该异常。</li>
<li>如果该异常对象是<code>ThreadDeath</code>的对象,则不做任何处理;否则,将异常跟踪栈的信息打印到<code>System.Err</code>错误输出流,并结束该线程。</li>
</ul>
</li>
</ul>
<h3 id="程序-为线程设置异常处理器"><a href="#程序-为线程设置异常处理器" class="headerlink" title="程序 为线程设置异常处理器"></a>程序 为线程设置异常处理器</h3><p>下面程序为主线程设置了异常处理器,当主线程运行抛出未处理异常时,该异常处理器将会起作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自己的异常处理器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyExHandler</span> <span class="keyword">implements</span> <span class="title class_">Thread</span>.UncaughtExceptionHandler &#123;</span><br><span class="line">    <span class="comment">// 实现uncaughtException方法，该方法将处理线程的未处理异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">        System.out.println(t + <span class="string">&quot; 线程出现了异常：&quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置主线程的异常处理器</span></span><br><span class="line">        Thread.currentThread().setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">MyExHandler</span>());</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span> / <span class="number">0</span>; <span class="comment">// ①</span></span><br><span class="line">        System.out.println(<span class="string">&quot;程序正常结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的主方法中为主线程设置了异常处理器,而①号代码处将引发一个未处理异常,则该异常处理器会负责处理该异常。运行该程序,会看到如下输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,5,main] 线程出现了异常：java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure>
<h3 id="异常处理器与通过catch捕获异常的不同"><a href="#异常处理器与通过catch捕获异常的不同" class="headerlink" title="异常处理器与通过catch捕获异常的不同"></a>异常处理器与通过<code>catch</code>捕获异常的不同</h3><p>从上面程序的执行结果来看,虽然程序中粗体字代码指定了异常处理器对未捕获的异常进行处理,而且该异常处理器也确实起作用了,但程序依然不会正常结束。这说明异常处理器与通过<code>catch</code>捕获异常是不同的:</p>
<ul>
<li>当使用<code>catch</code>捕获异常时,异常不会向上传播给上一级调用者;</li>
<li>但<strong>使用异常处理器对异常进行处理之后,异常依然会传播给上一级调用者</strong></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/f2e9e8d2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/f2e9e8d2/" class="post-title-link" itemprop="url">16.6.3 使用阻塞队列(BlockingQueue)控制线程通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-08 09:12:14" itemprop="dateCreated datePublished" datetime="2020-01-08T09:12:14+08:00">2020-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-26 03:48:11" itemprop="dateModified" datetime="2020-03-26T03:48:11+08:00">2020-03-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">第16章 多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC16%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/16-6-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">16.6 线程通信</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/f2e9e8d2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/f2e9e8d2/" data-xid="/JavaReadingNotes/f2e9e8d2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="16-6-3-使用阻塞队列-BlockingQueue-控制线程通信"><a href="#16-6-3-使用阻塞队列-BlockingQueue-控制线程通信" class="headerlink" title="16.6.3 使用阻塞队列(BlockingQueue)控制线程通信"></a>16.6.3 使用阻塞队列(BlockingQueue)控制线程通信</h1><p><code>Java5</code>提供了一个<code>BlockingQueue</code>接口,虽然<code>BlockingQueue</code>也是<code>Queue</code>的子接口,但<code>BlockingQueue</code>的主要用途并不是作为容器,而是作为线程同步的工具。</p>
<h2 id="BlockingQueue特征"><a href="#BlockingQueue特征" class="headerlink" title="BlockingQueue特征"></a>BlockingQueue特征</h2><p><code>BlockingQueue</code>具有一个特征:</p>
<ul>
<li>当生产者线程试图向<code>BlockingQueue</code>中放入元素时,如果该队列已满,则该生产者线程被阻塞;</li>
<li>当消费者线程试图从<code>BlockingQueue</code>中取出元素时,如果该队列已空,则该消费者线程被阻塞</li>
</ul>
<p>程序的两个线程通过交替向<code>BlockingQueue</code>中放入元素、取出元素,即可很好地控制线程的通信。</p>
<h2 id="BlockingQueue阻塞方法"><a href="#BlockingQueue阻塞方法" class="headerlink" title="BlockingQueue阻塞方法"></a>BlockingQueue阻塞方法</h2><p><code>BlockingQueue</code>提供如下两个支持阻塞的方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void put(E e)</code></td>
<td align="left">尝试把<code>E</code>元素放入<code>BlockingQueue</code>中,如果该队列的元素已满,则阻塞该线程。</td>
</tr>
<tr>
<td align="left"><code>E take()</code></td>
<td align="left">尝试从<code>BlockingQueue</code>的头部取出元素,如果该队列的元素已空,则阻塞该线程。</td>
</tr>
</tbody></table>
<h2 id="Queue接口方法"><a href="#Queue接口方法" class="headerlink" title="Queue接口方法"></a>Queue接口方法</h2><p><code>BlockingQueue</code>继承了<code>Queue</code>接口,当然也可使用<code>Queue</code>接口中的方法。这些方法归纳起来可分为如下三组。</p>
<ol>
<li>在队列尾部插入元素。包括<code>add(E e)</code>、<code>offer(E e)</code>和<code>put(E e)</code>方法,当该队列已满时,这三个方法分别会抛出异常、返回<code>false</code>、<strong>阻塞队列</strong>。</li>
<li>在队列头部删除并返回删除的元素。包括<code>remove</code>、<code>poll()</code>和<code>take()</code>方法。当该队列已空时,这三个方法分别会抛出异常、返回<code>false</code>、阻塞队列。</li>
<li>在队列头部取出但不删除元素。包括<code>element()</code>和<code>pek()</code>方法,当队列已空时,这两个方法分别抛出异常、返回<code>false</code></li>
</ol>
<h2 id="BlockingQueue方法分类"><a href="#BlockingQueue方法分类" class="headerlink" title="BlockingQueue方法分类"></a>BlockingQueue方法分类</h2><p><code>BlockingQueue</code>包含的方法之间的对应关系如表16.1所示。</p>
<table>
<thead>
<tr>
<th align="left">功能</th>
<th align="left">抛出异常</th>
<th align="left">不同返回值</th>
<th align="left">阻塞线程</th>
<th align="left">指定超时时长</th>
</tr>
</thead>
<tbody><tr>
<td align="left">队尾插入元素</td>
<td align="left"><code>add(e)</code></td>
<td align="left"><code>offer(e)</code></td>
<td align="left"><code>put(e)</code></td>
<td align="left"><code>offer(e,time,unit)</code></td>
</tr>
<tr>
<td align="left">队头删除元素</td>
<td align="left"><code>remove()</code></td>
<td align="left"><code>poll()</code></td>
<td align="left"><code>take()</code></td>
<td align="left"><code>poll(time,unit)</code></td>
</tr>
<tr>
<td align="left">获取、不删除元素</td>
<td align="left"><code>element()</code></td>
<td align="left"><code>peek()</code></td>
<td align="left">无</td>
<td align="left">无</td>
</tr>
</tbody></table>
<h2 id="BlockingQueue实现类"><a href="#BlockingQueue实现类" class="headerlink" title="BlockingQueue实现类"></a>BlockingQueue实现类</h2><p><code>BlockingQueue</code>与其实现类之间的类图如图16.11所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter16/16.6.3/1.png" alt="图片"></p>
<!-- CrazyJavaHandout4/Chapter16/16.6.3/1 -->
<p>图16.11中以黑色方框框出的都是<code>Java7</code>新增的阻塞队列。从图16.11可以看到,<code>BlockingQueue</code>包含如下5个实现类。</p>
<table>
<thead>
<tr>
<th align="left"><code>BlockingQueue</code>实现类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ArrayBlockingQueue</code></td>
<td align="left">基于数组实现的<code>BlockingQueue</code>队列。</td>
</tr>
<tr>
<td align="left"><code>LinkedBlockingQueue</code></td>
<td align="left">基于链表实现的<code>BlockingQueue</code>队列。</td>
</tr>
<tr>
<td align="left"><code>SynchronousQueue</code></td>
<td align="left">同步队列。对该队列的存、取操作必须交替进行。</td>
</tr>
<tr>
<td align="left"><code>PriorityBlockingQueue</code></td>
<td align="left">它并不是标准的阻塞队列。<br>与前面介绍的<code>PriorityQueue</code>类似,该队列调用<code>remove()</code>、<code>poll()</code>、<code>take()</code>等方法取出元素时,并不是取出队列中存在时间最长的元素,而是<strong>队列中最小的元素</strong>。<br><code>PriorityBlockingQueue</code>判断元素的大小即可根据元素(实现<code>Comparable</code>接口)的本身大小来自然排序,也可使用<code>Comparator</code>进行定制排序。</td>
</tr>
<tr>
<td align="left"><code>DelayQueue</code></td>
<td align="left">它是一个特殊的<code>BlockingQueue</code>,底层基于<code>PriorityBlockingQueue</code>实现。不过,<code>DelayQueue</code>要求集合元素都实现<code>Delay</code>接口(该接口里只有一个<code>longGetDelay()</code>方法),<code>DelayQueue</code>根据集合元素的<code>getDalay()</code>方法的返回值进行排序</td>
</tr>
</tbody></table>
<h2 id="程序示例-ArrayBlockingQueue阻塞队列"><a href="#程序示例-ArrayBlockingQueue阻塞队列" class="headerlink" title="程序示例 ArrayBlockingQueue阻塞队列"></a>程序示例 ArrayBlockingQueue阻塞队列</h2><p>下面以<code>ArrayBlockingQueue</code>为例介绍阻塞队列的功能和用法。下面先用一个最简单的程序来测试<code>BlockingQueue</code>的<code>put()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 定义一个长度为2的阻塞队列</span></span><br><span class="line">        BlockingQueue&lt;String&gt; bq = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        bq.put(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 与bq.add(&quot;Java&quot;、bq.offer(&quot;Java&quot;)相同</span></span><br><span class="line">        bq.put(<span class="string">&quot;Java&quot;</span>); <span class="comment">// 与bq.add(&quot;Java&quot;、bq.offer(&quot;Java&quot;)相同</span></span><br><span class="line">        bq.put(<span class="string">&quot;Java&quot;</span>); <span class="comment">// ① 阻塞线程。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序先定义一个大小为2的<code>BlockingQueue</code>,程序先向该队列中放入两个元素,此时队列还没有满,两个元素都可以放入,因此使用<code>put()</code>、<code>add()</code>和<code>offer()</code>方法效果完全一样。当程序试图放入第三个元素时,</p>
<ul>
<li>如果使用<code>put()</code>方法尝试放入元素将会阻塞线程,如上面程序①号代码所示。</li>
<li>此时,如果使用<code>add()</code>方法尝试放入元素将会引发异常;</li>
<li>此时,如果使用<code>offer()</code>方法尝试放入元素则会返回<code>false</code>,元素不会被放入</li>
</ul>
<p>与此类似的是,在<code>BlockingQueue</code>已空的情况下,程序</p>
<ul>
<li>使用<code>take()</code>方法尝试取出元素将会<strong>阻塞线程</strong>;</li>
<li>使用<code>remove()</code>方法尝试取出元素将<strong>引发异常</strong>;</li>
<li>使用<code>poll()</code>方法尝试取出元素将<strong>返回<code>false</code>,元素不会被删除</strong>.</li>
</ul>
<h2 id="程序-使用BlockingQueue实现线程通信"><a href="#程序-使用BlockingQueue实现线程通信" class="headerlink" title="程序 使用BlockingQueue实现线程通信"></a>程序 使用BlockingQueue实现线程通信</h2><p>掌握了<code>BlockingQueue</code>阻塞队列的特性之后,下面程序就可以利用<code>BlockingQueue</code>来实现线程通信了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; bq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(BlockingQueue&lt;String&gt; bq)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bq = bq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Struts&quot;</span>, <span class="string">&quot;Spring&quot;</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">999999999</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;生产者准备生产集合元素！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                <span class="comment">// 尝试放入元素，如果队列已满，线程被阻塞</span></span><br><span class="line">                bq.put(strArr[i % <span class="number">3</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;生产完成：&quot;</span> + bq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;String&gt; bq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(BlockingQueue&lt;String&gt; bq)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bq = bq;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;消费者准备消费集合元素！&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                <span class="comment">// 尝试取出元素，如果队列已空，线程被阻塞</span></span><br><span class="line">                bq.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;消费完成：&quot;</span> + bq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个容量为1的BlockingQueue</span></span><br><span class="line">        BlockingQueue&lt;String&gt; bq = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 启动3条生产者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(bq).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(bq).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(bq).start();</span><br><span class="line">        <span class="comment">// 启动一条消费者线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(bq).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序启动了3个生产者线程向<code>BlockingQueue</code>集合放入元素,启动了1个消费者线程从<code>BlockingQueue</code>集合取出元素。<br>本程序的<code>BlockingQueue</code>集合容量为1,因此3个生产者线程无法连续放入元素,必须等待消费者线程取出一个元素后,3个生产者线程的其中之一才能放入一个元素。运行该程序,会看到如下所示的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Thread-1生产者准备生产集合元素！</span><br><span class="line">Thread-0生产者准备生产集合元素！</span><br><span class="line">Thread-2生产者准备生产集合元素！</span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br><span class="line">Thread-0生产完成：[Java]</span><br><span class="line">Thread-0生产者准备生产集合元素！</span><br><span class="line">Thread-3消费完成：[]</span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br><span class="line">Thread-2生产完成：[Java]</span><br><span class="line">Thread-2生产者准备生产集合元素！</span><br><span class="line">Thread-1生产完成：[Java]</span><br><span class="line">Thread-1生产者准备生产集合元素！</span><br><span class="line">Thread-3消费完成：[Java]</span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br><span class="line">Thread-3消费完成：[]</span><br><span class="line">Thread-3消费者准备消费集合元素！</span><br></pre></td></tr></table></figure>
<p>3个生产者线程都想向<code>BlockingQueue</code>中放入元素,但只要其中一个线程向该队列中放入元素之后,其他生产者线程就必须等待,等待消费者线程取出<code>BlockingQueue</code>队列里的元素。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/84/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/84/">84</a><span class="page-number current">85</span><a class="page-number" href="/JavaReadingNotes/page/86/">86</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/86/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:07</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/85/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/85/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
