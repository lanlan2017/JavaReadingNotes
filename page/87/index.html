<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/87/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/87/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/87/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/233df632/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/233df632/" class="post-title-link" itemprop="url">15.9.3 使用Channel</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-06 08:07:48" itemprop="dateCreated datePublished" datetime="2020-01-06T08:07:48+08:00">2020-01-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-9-NIO/" itemprop="url" rel="index"><span itemprop="name">15.9 NIO</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/233df632/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/233df632/" data-xid="/JavaReadingNotes/233df632/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-9-3-使用Channel"><a href="#15-9-3-使用Channel" class="headerlink" title="15.9.3 使用Channel"></a>15.9.3 使用Channel</h1><h2 id="Channel与流对象的区别"><a href="#Channel与流对象的区别" class="headerlink" title="Channel与流对象的区别"></a>Channel与流对象的区别</h2><p><strong><code>Channel</code>类似于传统的流对象</strong>,但与传统的流对象有两个主要区别。</p>
<ol>
<li><strong><code>Channel</code>可以直接将指定文件的部分或全部直接映射成<code>Buffer</code></strong></li>
<li><strong>程序不能直接访问<code>Channel</code>中的数据</strong>,包括读取、写入都不行,<strong><code>Channel</code>只能与<code>Buffer</code>进行交互</strong>。也就是说:<ul>
<li><strong>如果要从<code>Channel</code>中取得数据,必须先用<code>Buffer</code>从<code>Channel</code>中取出一些数据,然后让程序从<code>Buffer</code>中取出这些数据</strong>;</li>
<li><strong>如果要将程序中的数据写入<code>Channel</code>,一样先让程序将数据放入<code>Buffer</code>中,程序再将<code>Buffer</code>里的数据写入<code>Channe</code>中</strong>。</li>
</ul>
</li>
</ol>
<h2 id="Channel分类"><a href="#Channel分类" class="headerlink" title="Channel分类"></a>Channel分类</h2><p><code>Java</code>为<code>Channel</code>接口提供了<code>DatagramChannel</code>、<code>FileChannel</code>、<code>Pipe.SinkChannel</code>、<code>Pipe.SourceChannel</code>、<code>SelectableChannel</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>等实现类,本节主要介绍<code>FileChannel</code>的用法。<br><strong>根据这些<code>Channel</code>的名字不难发现,新<code>IO</code>里的<code>Channel</code>是按功能来划分的</strong>,例如</p>
<ul>
<li><code>Pipe.SinkChannel</code>、<code>Pipe.SourceChannel</code>是用于支持<strong>线程之间通信</strong>的管道<code>Channel</code>;</li>
<li><code>ServerSocketChannel</code>、<code>SocketChannel</code>是用于支持**<code>TCP</code>网络通信**的<code>Channel</code>;</li>
<li><code>DatagramChannel</code>则是用于支持**<code>UDP</code>网络通信**的<code>Channel</code></li>
</ul>
<p>本书将会在第17章介绍网络通信编程的详细内容,如果需要掌握<code>ServerSocketChannel</code>,<code>SocketChannel</code>等<code>Channel</code>的用法,可以参考本书第17章。</p>
<h2 id="如何创建Channel"><a href="#如何创建Channel" class="headerlink" title="如何创建Channel"></a>如何创建Channel</h2><p><strong>所有的<code>Channel</code>都不应该通过构造器来直接创建,而是通过传统的节点<code>InputStream</code>、<code>OutputStream</code>的<code>getChannel()</code>方法来返回对应的<code>Channel</code></strong>,不同的节点流获得的<code>Channel</code>不一样。例如:</p>
<ul>
<li><code>FileInputStream</code>、<code>FileOutputStream</code>的<code>getChannel()</code>方法返回的是<code>FileChannel</code>,</li>
<li><code>PipedInputStream</code>和<code>PipedOutputStream</code>的<code>getChannel()</code>方法返回的是<code>Pipe.SinkChannel</code>、<code>Pipe.SourceChannel</code></li>
</ul>
<h2 id="Channel常用方法"><a href="#Channel常用方法" class="headerlink" title="Channel常用方法"></a>Channel常用方法</h2><p><code>Channel</code>中最常用的三类方法是<code>map()</code>、<code>read()</code>和<code>write()</code>,其中</p>
<ul>
<li><code>map()</code>方法用于将<code>Channel</code>对应的部分或全部数据映射成<code>ByteBuffer</code>;</li>
<li><code>read</code>或<code>write</code>方法都有一系列重载形式,这些方法用于从<code>Buffer</code>中读取数据或向<code>Buffer</code>中写入数据。</li>
</ul>
<h3 id="FileChannel的map方法"><a href="#FileChannel的map方法" class="headerlink" title="FileChannel的map方法"></a>FileChannel的map方法</h3><p><code>map()</code>方法的方法签名为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(FileChannel.MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数执行映射时的模式,分别有只读、读写等模式</li>
<li>而第二个、第三个参数用于控制将<code>Channel</code>的哪些数据映射成<code>ByteBuffer</code></li>
</ul>
<h2 id="程序-FileChannel示例"><a href="#程序-FileChannel示例" class="headerlink" title="程序 FileChannel示例"></a>程序 FileChannel示例</h2><p>下面程序示范了直接将<code>FileChannel</code>的全部数据映射成<code>ByteBuffer</code>的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;FileChannelTest.java&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建FileInputStream，以该文件输入流创建FileChannel</span></span><br><span class="line">                FileChannel inChannel = <span class="keyword">new</span> FileInputStream(f).getChannel();</span><br><span class="line">                <span class="comment">// 以文件输出流创建FileBuffer，用以控制输出</span></span><br><span class="line">                FileChannel outChannel = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;a.txt&quot;</span>).getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 将FileChannel里的全部数据映射成ByteBuffer</span></span><br><span class="line">            MappedByteBuffer buffer = </span><br><span class="line">                inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length()); <span class="comment">// ①</span></span><br><span class="line">            <span class="comment">// 使用GBK的字符集来创建解码器</span></span><br><span class="line">            <span class="comment">// Charset charset = Charset.forName(&quot;GBK&quot;);</span></span><br><span class="line">            Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 直接将buffer里的数据全部输出到outChannel中</span></span><br><span class="line">            outChannel.write(buffer); <span class="comment">// ②</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 再次调用buffer的clear()方法，复原limit、position的位置,准备再次读取Buffer</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="comment">// 创建解码器(CharsetDecoder)对象</span></span><br><span class="line">            CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">            <span class="comment">// 使用解码器将ByteBuffer转换成CharBuffer</span></span><br><span class="line">            CharBuffer charBuffer = decoder.decode(buffer);</span><br><span class="line">            <span class="comment">// CharBuffer的toString方法可以获取对应的字符串</span></span><br><span class="line">            System.out.println(charBuffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中分别使用<code>FileInputStream</code>、<code>FileOutputStream</code>来获取<code>FileChannel</code>,虽然<code>FileChannel</code>既可以读取也可以写入,</p>
<ul>
<li>但**<code>FileInputStream</code>获取的<code>FileChannel</code>只能读**,</li>
<li>而**<code>FileOutputStream</code>获取的<code>FileChannel</code>只能写**。</li>
</ul>
<p>程序中①号代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer buffer = </span><br><span class="line">    inChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length()); <span class="comment">// ①</span></span><br></pre></td></tr></table></figure>
<p>直接将指定<code>Channel</code>中的全部数据映射成<code>ByteBuffer</code>.<br>然后程序中②号代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outChannel.write(buffer); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>
<p>直接将整个<code>ByteBuffer</code>的全部数据写入一个输出<code>FileChannel</code>中,这就完成了文件的复制.<br>程序后面部分为了能将<code>FileChannelTest.java</code>文件里的内容打印出来,使用了<code>Charset</code>类和<code>CharsetDecoder</code>类将<code>ByteBuffer</code>转换成<code>CharBuffer</code>关于<code>Charset</code>和<code>CharsetDecoder</code>下一节将会有更详细的介绍。</p>
<h2 id="程序-RandomAccessFile获取的Channel"><a href="#程序-RandomAccessFile获取的Channel" class="headerlink" title="程序 RandomAccessFile获取的Channel"></a>程序 RandomAccessFile获取的Channel</h2><p>不仅<code>InputStream</code>、<code>OutputStream</code>包含了<code>getChannel()</code>方法,在<code>RandomAccessFile</code>中也包含了一个<code>getChannel()</code>方法,<strong><code>RandomAccessFile</code>返回的<code>FileChannel</code>是只读的还是读写的,则取决于<code>RandomAccessFile</code>打开文件的模式</strong>。<br>例如,下面程序将会对<code>a.txt</code>文件的内容进行复制,追加在该文件后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomFileChannelTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个RandomAccessFile对象</span></span><br><span class="line">                RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">                <span class="comment">// 获取RandomAccessFile对应的Channel</span></span><br><span class="line">                FileChannel randomChannel = raf.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 将Channel中所有数据映射成ByteBuffer</span></span><br><span class="line">            ByteBuffer buffer = randomChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, f.length());</span><br><span class="line">            <span class="comment">// 把Channel的记录指针移动到最后</span></span><br><span class="line">            <span class="comment">// 代码1</span></span><br><span class="line">            randomChannel.position(f.length());</span><br><span class="line">            <span class="comment">// 将buffer中所有数据输出</span></span><br><span class="line">            randomChannel.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<strong>代码1</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">randomChannel.position(f.length());</span><br></pre></td></tr></table></figure>
<p>可以将<code>Channel</code>的记录指针移动到该<code>Channel</code>的最后,从而可以让程序将指定<code>ByteBuffer</code>的数据追加到该<code>Channel</code>的后面。每次运行上面程序,都会把<code>a.txt</code>文件的内容复制份,并将全部内容追加到该文件的后面。</p>
<h2 id="像传统IO那样使用Channel和Buffer读写文件"><a href="#像传统IO那样使用Channel和Buffer读写文件" class="headerlink" title="像传统IO那样使用Channel和Buffer读写文件"></a>像传统IO那样使用Channel和Buffer读写文件</h2><p>如果读者习惯了传统<code>IO</code>的“用竹筒多次重复取水”的过程,或者担心<code>Channel</code>对应的文件过大,使用<code>map()</code>方法一次将所有的文件内容映射到内存中引起性能下降,也可以使用<code>Channel</code>和<code>Buffer</code>传统的“用竹筒多次重复取水”的方式。<br>如下程序所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建文件输入流</span></span><br><span class="line">                FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;ReadFile.java&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建一个FileChannel</span></span><br><span class="line">                FileChannel fcin = fis.getChannel()) &#123;</span><br><span class="line">            <span class="comment">// 定义一个ByteBuffer对象，用于重复取水</span></span><br><span class="line">            ByteBuffer bbuff = ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">            <span class="comment">// 将FileChannel中数据读取到ByteBuffer中</span></span><br><span class="line">            <span class="keyword">while</span> (fcin.read(bbuff) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 准备读取Buffer中的数据</span></span><br><span class="line">                bbuff.flip();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建Charset对象</span></span><br><span class="line">                <span class="comment">// Charset charset = Charset.forName(&quot;GBK&quot;);</span></span><br><span class="line">                Charset charset = Charset.forName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="comment">// 创建解码器(CharsetDecoder)对象</span></span><br><span class="line">                CharsetDecoder decoder = charset.newDecoder();</span><br><span class="line">                <span class="comment">// 将ByteBuffer的内容转码</span></span><br><span class="line">                CharBuffer cbuff = decoder.decode(bbuff);</span><br><span class="line">                System.out.print(cbuff);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将Buffer初始化，为下一次读取数据做准备</span></span><br><span class="line">                bbuff.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码虽然使用<code>FileChannel</code>和<code>Buffer</code>来读取文件,但处理方式和使用<code>InputStream</code>、<code>byte[]</code>来读取文件的方式几乎一样,都是采用“用竹筒多次重复取水”的方式。但因为<code>Buffer</code>提供了<code>fip()</code>和<code>clear()</code>两个方法,所以程序处理起来比较方便</p>
<h3 id="类似传统方式使用NIO步骤"><a href="#类似传统方式使用NIO步骤" class="headerlink" title="类似传统方式使用NIO步骤"></a>类似传统方式使用NIO步骤</h3><ul>
<li>读取数据到<code>Buffer</code>中</li>
<li><strong>每次读取数据后调用<code>fip()</code>方法</strong>将没有数据的区域“封印”起来,避免程序从<code>Buffer</code>中取出<code>null</code>值;</li>
<li>从<code>Buffer</code>中取出数据</li>
<li>数据取出后立即调用<code>clear()</code>方法将<code>Buffer</code>的<code>position</code>设0,为下次读取数据做准备。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d63ba950/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d63ba950/" class="post-title-link" itemprop="url">15.9.2 使用Buffer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-06 04:35:02" itemprop="dateCreated datePublished" datetime="2020-01-06T04:35:02+08:00">2020-01-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-9-NIO/" itemprop="url" rel="index"><span itemprop="name">15.9 NIO</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d63ba950/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d63ba950/" data-xid="/JavaReadingNotes/d63ba950/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-9-2-使用Buffer"><a href="#15-9-2-使用Buffer" class="headerlink" title="15.9.2 使用Buffer"></a>15.9.2 使用Buffer</h1><p>从内部结构上来看,<code>Buffer</code>就像一个数组,它可以保存多个类型相同的数据。<code>Buffer</code>是一个抽象类,其最常用的子类是<code>ByteBuffer</code>,它可以在底层字节数组上进行<code>get/set</code>操作。除<code>ByteBuffer</code>之外,对应于其他基本数据类型(<code>boolean</code>除外)都有相应的<code>Buffer</code>类:<code>CharBuffer</code>、<code>ShortBuffer</code>、<code>IntBuffer</code>、<code>LongBuffer</code>、<code>FloatBuffer</code>、<code>DoubleBuffer</code>。</p>
<h2 id="创建Buffer对象"><a href="#创建Buffer对象" class="headerlink" title="创建Buffer对象"></a>创建Buffer对象</h2><p>上面这些<code>Buffer</code>类,除<code>ByteBuffer</code>之外,它们都采用相同或相似的方法来管理数据,只是各自管理的数据类型不同而已。这些<code>Buffer</code>类都没有提供构造器,通过使用如下方法来得到一个<code>Buffer</code>对象。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static XxxBuffer allocate(int capacity)</code></td>
<td align="left">创建一个容量为<code>capacity</code>的<code>XxX Buffer</code>对象。</td>
</tr>
</tbody></table>
<details><summary>展开/折叠</summary>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ByteBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new byte buffer.</td>
</tr>
<tr>
<td align="left"><code>static ShortBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new short buffer.</td>
</tr>
<tr>
<td align="left"><code>static IntBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new int buffer.</td>
</tr>
<tr>
<td align="left"><code>static LongBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new long buffer.</td>
</tr>
<tr>
<td align="left"><code>static CharBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new char buffer.</td>
</tr>
<tr>
<td align="left"><code>static FloatBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new float buffer.</td>
</tr>
<tr>
<td align="left"><code>static DoubleBuffer allocate(int capacity)</code></td>
<td align="left">Allocates a new double buffer.</td>
</tr>
</tbody></table>
</details>

<p>但实际使用较多的是<code>ByteBuffer</code>和<code>CharBuffer</code>,其他<code>Buffer</code>子类则较少用到。</p>
<h2 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h2><p>其中<code>ByteBuffer</code>类还有一个子类:<code>MappedByteBuffer</code>,<strong><code>MappedByteBuffer</code>用于表示<code>Channel</code>将磁盘文件的部分或全部内容映射到内存中后得到的<mark>结果</mark></strong>,通常<code>MappedByteBuffer</code>对象由<code>Channel</code>的<code>map()</code>方法返回。</p>
<h2 id="容量-界限-位置"><a href="#容量-界限-位置" class="headerlink" title="容量 界限 位置"></a>容量 界限 位置</h2><p>在<code>Buffer</code>中有三个重要的概念:容量(<code>capacity</code>)、界限(<code>limit</code>)和位置(<code>position</code>)</p>
<ul>
<li><strong>容量(<code>capacity</code>)</strong>:<ul>
<li>缓冲区的容量(<code>capacity</code>)表示该<code>Buffer</code>的最大数据容量,即<strong>最多可以存储多少数据</strong>。<strong>缓冲区的容量不可能为负值,创建后不能改变</strong>。</li>
</ul>
</li>
<li><strong>界限(<code>limit</code>)</strong>:<ul>
<li><strong>第一个不应该被读出或者写入的缓冲区位置索引</strong>。也就是说,<strong>位于<code>limit</code>后的数据既不可被读,也不可被写</strong>。</li>
</ul>
</li>
<li><strong>位置(<code>position</code>)</strong>:<ul>
<li>用于指明<strong>下一个可以被读出的或者写入的缓冲区位置索引</strong>(类似于<code>IO</code>流中的记录指针)。<strong>当使用<code>Buffer</code>从<code>Channel</code>中读取数据时,<code>position</code>的<mark>值</mark>恰好等于已经读到了多少数据</strong>:</li>
<li>当刚刚新建一个<code>Buffer</code>对象时,其<code>position</code>为0,也就是<strong>第1个位置的索引为0</strong>;</li>
<li>如果从<code>Channel</code>中读取了2个数据到该<code>Buffer</code>中,则<code>position</code>为2,指向<code>Buffer</code>中第3个位置</li>
</ul>
</li>
</ul>
<h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>除此之外,<code>Buffer</code>里还支持一个可选的标记(<code>mark</code>),类似于传统<code>IO</code>流中的<code>mark()</code>,<strong><code>Buffer</code>允许直接将<code>position</code>定位到该<code>mark</code>处</strong>。这些值满足如下关系:<br><strong>0≤mark≤position≤limit≤capacity</strong><br>图15.16显示了某个<code>Buffer</code>读入了一些数据后的示意图<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter/15/15.9.2/1.png" alt="这里有一张图片"></p>
<h2 id="Buffer的作用"><a href="#Buffer的作用" class="headerlink" title="Buffer的作用"></a>Buffer的作用</h2><p><strong><code>Buffer</code>的主要作用就是装入数据,然后输出数据</strong>(其作用类似于前面介绍的取水的“竹筒”),<strong>开始时<code>Buffer</code>的<code>position</code>为0,<code>limit</code>为<code>capacity</code></strong></p>
<h2 id="装入数据-put方法"><a href="#装入数据-put方法" class="headerlink" title="装入数据 put方法"></a>装入数据 put方法</h2><p><strong>程序可通过<code>put()</code>方法向<code>Buffer</code>中放入一些数据</strong>(或者从<code>Channel</code>中获取一些数据),<strong>每放入一些数据,<code>Buffer</code>的<code>position</code>相应地向后移动一些位置</strong>。</p>
<h3 id="ByteBuffer的put方法"><a href="#ByteBuffer的put方法" class="headerlink" title="ByteBuffer的put方法"></a>ByteBuffer的put方法</h3><details><summary>展开/折叠</summary>

<table>
<thead>
<tr>
<th align="left"><code>ByteBuffer</code>的<code>put</code>方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>abstract ByteBuffer put(byte b)</code></td>
<td align="left">Relative put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>ByteBuffer put(byte[] src)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>ByteBuffer put(byte[] src, int offset, int length)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer put(int index, byte b)</code></td>
<td align="left">Absolute put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>ByteBuffer put(ByteBuffer src)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>abstract ByteBuffer putChar(char value)</code></td>
<td align="left">Relative put method for writing a char value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putChar(int index, char value)</code></td>
<td align="left">Absolute put method for writing a char value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putDouble(double value)</code></td>
<td align="left">Relative put method for writing a double value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putDouble(int index, double value)</code></td>
<td align="left">Absolute put method for writing a double value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putFloat(float value)</code></td>
<td align="left">Relative put method for writing a float value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putFloat(int index, float value)</code></td>
<td align="left">Absolute put method for writing a float value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putInt(int value)</code></td>
<td align="left">Relative put method for writing an int value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putInt(int index, int value)</code></td>
<td align="left">Absolute put method for writing an int value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putLong(int index, long value)</code></td>
<td align="left">Absolute put method for writing a long value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putLong(long value)</code></td>
<td align="left">Relative put method for writing a long value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putShort(int index, short value)</code></td>
<td align="left">Absolute put method for writing a short value (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract ByteBuffer putShort(short value)</code></td>
<td align="left">Relative put method for writing a short value (optional operation).</td>
</tr>
</tbody></table>
</details>

<h3 id="CharBuffer的put方法"><a href="#CharBuffer的put方法" class="headerlink" title="CharBuffer的put方法"></a>CharBuffer的put方法</h3><details><summary>展开/折叠</summary>

<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>abstract CharBuffer put(char c)</code></td>
<td align="left">Relative put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>CharBuffer put(char[] src)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>CharBuffer put(char[] src, int offset, int length)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>abstract CharBuffer put(int index, char c)</code></td>
<td align="left">Absolute put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>CharBuffer put(String src)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>CharBuffer put(String src, int start, int end)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
<tr>
<td align="left"><code>CharBuffer put(CharBuffer src)</code></td>
<td align="left">Relative bulk put method (optional operation).</td>
</tr>
</tbody></table>
</details>

<h2 id="准备输出数据-flip方法"><a href="#准备输出数据-flip方法" class="headerlink" title="准备输出数据 flip方法"></a>准备输出数据 flip方法</h2><p>当<code>Buffer</code>装入数据结束后,调用<code>Buffer</code>的<code>flip()</code>方法,<strong>该方法将<code>limit</code>设置为<code>position</code>所在位置,并将<code>position</code>设为0,这就使得<code>Buffer</code>的读写指针又移到了开始位置。</strong></p>
<h3 id="需要读取Buffer中的数据时调用flip方法"><a href="#需要读取Buffer中的数据时调用flip方法" class="headerlink" title="需要读取Buffer中的数据时调用flip方法"></a>需要读取Buffer中的数据时调用flip方法</h3><p>也就是说,<strong><code>Buffer</code>调用<code>flip()</code>方法之后,<code>Buffer</code><mark>为输出数据做好了准备</mark></strong>;</p>
<table>
<thead>
<tr>
<th align="left">Buffer类的flip方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Buffer flip()</code></td>
<td align="left">Flips this buffer.</td>
</tr>
</tbody></table>
<h2 id="准备再次装入数据-clear方法"><a href="#准备再次装入数据-clear方法" class="headerlink" title="准备再次装入数据 clear方法"></a>准备再次装入数据 clear方法</h2><p>当<code>Buffer</code>输出数据结束后,<code>Buffer</code>调用<code>clear()</code>方法,<code>clear</code>方法不是清空<code>Buffer</code>的数据,它仅仅<strong>将<code>position</code>置为0,将<code>limit</code>置为<code>capacity</code></strong>,这样<strong>为再次向<code>Buffer</code>中装入数据做好准备</strong>。</p>
<table>
<thead>
<tr>
<th align="left">Buffer类的clear方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Buffer clear()</code></td>
<td align="left">Clears this buffer.</td>
</tr>
</tbody></table>
<h2 id="取出flip-再次装入clear"><a href="#取出flip-再次装入clear" class="headerlink" title="取出flip 再次装入clear"></a>取出flip 再次装入clear</h2><p><code>Buffer</code>中包含两个重要的方法,即<code>flip()</code>和<code>clear()</code>,</p>
<ul>
<li><code>flip</code>为从<code>Buffer</code>中取出数据做好准备,</li>
<li><code>clear</code>为再次向<code>Buffer</code>中装入数据做好准备</li>
</ul>
<h2 id="Buffer其他常用方法"><a href="#Buffer其他常用方法" class="headerlink" title="Buffer其他常用方法"></a>Buffer其他常用方法</h2><p>除此之外,<code>Buffer</code>还包含如下一些常用的方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int capacity()</code></td>
<td align="left">返回<code>Buffer</code>的<code>capacity</code>大小。</td>
</tr>
<tr>
<td align="left"><code>boolean hasRemaining()</code></td>
<td align="left">判断当前位置(<code>position</code>)和界限(<code>limit</code>)之间是否还有元素可供处理</td>
</tr>
<tr>
<td align="left"><code>int limit()</code></td>
<td align="left">返回<code>Buffer</code>的界限(<code>limit</code>)的位置。</td>
</tr>
<tr>
<td align="left"><code>Buffer limit(int newLimit)</code></td>
<td align="left">重新设置界限(<code>limit</code>)的值,并返回一个具有新的<code>limit</code>的缓冲区对象</td>
</tr>
<tr>
<td align="left"><code>Buffer mark()</code></td>
<td align="left">设置<code>Buffer</code>的<code>mark</code>位置,它只能在0和位置(<code>position</code>)之间做<code>mark</code>。</td>
</tr>
<tr>
<td align="left"><code>int position()</code></td>
<td align="left">返回<code>Buffer</code>中的<code>position</code>值</td>
</tr>
<tr>
<td align="left"><code>Buffer position(int newPosition)</code></td>
<td align="left">设置<code>Buffer</code>的<code>position</code>,并返回<code>position</code>被修改后的<code>Buffer</code>对象</td>
</tr>
<tr>
<td align="left"><code>int remaining()</code></td>
<td align="left">返回当前位置和界限(<code>limit</code>)之间的元素个数</td>
</tr>
<tr>
<td align="left"><code>Buffer reset()</code></td>
<td align="left">将位置(<code>position</code>)转到<code>mark</code>所在的位置。</td>
</tr>
<tr>
<td align="left"><code>Buffer rewind()</code></td>
<td align="left">将位置(<code>position</code>)设置成0,取消设置的<code>mark</code></td>
</tr>
</tbody></table>
<h2 id="放入-取出"><a href="#放入-取出" class="headerlink" title="放入 取出"></a>放入 取出</h2><p>除这些移动<code>position</code>、<code>limit</code>、<code>mark</code>的方法之外,<code>Buffer</code>的所有子类还提供了两个重要的方法:<code>put()</code>和<code>get()</code>方法,用于向<code>Buffer</code>中放入数据和从<code>Buffer</code>中取出数据。<strong>当使用<code>put()</code>和<code>get()</code>方法放入、取出数据时,<code>Buffer</code>既支持对单个数据的访问,也支持对批量数据的访问</strong>(以数组作为参数)。</p>
<h3 id="相对-绝对"><a href="#相对-绝对" class="headerlink" title="相对 绝对"></a>相对 绝对</h3><p>当使用<code>put()</code>和<code>get()</code>来访问<code>Buffer</code>中的数据时,分为相对和绝对两种。</p>
<ul>
<li><strong>相对(<code>Relative</code>)</strong>:<ul>
<li>从<code>Buffer</code>的当前<code>position</code>处开始读取或写入数据,然后将位置(<code>position</code>)的值按处理元素的个数增加</li>
</ul>
</li>
<li><strong>绝对(<code>Absolute</code>)</strong>:<ul>
<li>直接**<mark>根据索引</mark>向<code>Buffer</code>中读取或写入数据**,<strong>使用绝对方式访问<code>Buffer</code>里的数据时,并不会影响位置(<code>position</code>)的值</strong>。</li>
</ul>
</li>
</ul>
<h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>下面程序示范了<code>Buffer</code>的一些常规操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建Buffer</span></span><br><span class="line">        CharBuffer buff = CharBuffer.allocate(<span class="number">8</span>); <span class="comment">// ①</span></span><br><span class="line">        System.out.println(<span class="string">&quot;capacity: &quot;</span> + buff.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;limit: &quot;</span> + buff.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;position: &quot;</span> + buff.position());</span><br><span class="line">        <span class="comment">// 放入元素</span></span><br><span class="line">        buff.put(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        buff.put(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">        buff.put(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// ②</span></span><br><span class="line">        System.out.println(<span class="string">&quot;加入三个元素后，position = &quot;</span> + buff.position());</span><br><span class="line">        <span class="comment">// 调用flip()方法 准备取出数据</span></span><br><span class="line">        buff.flip(); <span class="comment">// ③</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行flip()后，limit = &quot;</span> + buff.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;position = &quot;</span> + buff.position());</span><br><span class="line">        <span class="comment">// 取出第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一个元素(position=0)：&quot;</span> + buff.get()); <span class="comment">// ④</span></span><br><span class="line">        System.out.println(<span class="string">&quot;取出一个元素后，position = &quot;</span> + buff.position());</span><br><span class="line">        <span class="comment">// 调用clear方法 准备再次放入数据</span></span><br><span class="line">        buff.clear(); <span class="comment">// ⑤</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行clear()后，limit = &quot;</span> + buff.limit());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行clear()后，position = &quot;</span> + buff.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;执行clear()后，缓冲区内容并没有被清除：&quot;</span> +</span><br><span class="line">            <span class="string">&quot;第三个元素为：&quot;</span> + buff.get(<span class="number">2</span>)); <span class="comment">// ⑥</span></span><br><span class="line">        System.out.println(<span class="string">&quot;执行绝对读取后，position = &quot;</span> + buff.position());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面程序的①号代码处:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buff = CharBuffer.allocate(<span class="number">8</span>); <span class="comment">// ①</span></span><br></pre></td></tr></table></figure>
<p>通过<code>CharBuffer</code>的一个静态方法<code>allocate()</code>创建了一个<code>capacity</code>为8的<code>CharBuffer</code>,此时该<code>Buffer</code>的<code>limit</code>和<code>capacity</code>为8,<code>position</code>为0,如图15.17所示<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter/15/15.9.2/2.png" alt="这里有一张图片"><br>接下来程序执行到②号代码处:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buff.put(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">buff.put(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">buff.put(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// ②</span></span><br></pre></td></tr></table></figure>
<p>程序向<code>CharBuffer</code>中放入3个数值,放入3个数值后的<code>CharBuffer</code>效果如图15.18所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter/15/15.9.2/3.png" alt="这里有一张图片"><br>程序执行到③号代码处:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff.flip(); <span class="comment">// ③</span></span><br></pre></td></tr></table></figure>
<p>调用了<code>Buffer</code>的<code>flip()</code>方法,该方法将把<code>limit</code>设为<code>position</code>处,把<code>position</code>设为0,如图15.19所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter/15/15.9.2/4.png" alt="这里有一张图片"><br>从图15.19中可以看出,当<code>Buffer</code>调用了<code>flip()</code>方法之后,<code>limit</code>就移到了原来<code>position</code>所在位置,这样<strong>相当于把<code>Buffer</code>中<code>没有数据的存储空间“封印”起来</code>,从而避免读取<code>Buffer</code>数据时读到<code>null</code>值</strong>。</p>
<h3 id="无参get方法会使得position加一"><a href="#无参get方法会使得position加一" class="headerlink" title="无参get方法会使得position加一"></a>无参get方法会使得position加一</h3><p>接下来程序在④号代码处:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;第一个元素(position=0)：&quot;</span> + buff.get()); <span class="comment">// ④</span></span><br></pre></td></tr></table></figure>
<p>取出一个元素,<strong>取出一个元素后<code>position</code>向后移动一位</strong>,也就是该<code>Buffer</code>的<code>position</code>等于1。<br>程序执行到⑤号代码处:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buff.clear(); <span class="comment">// ⑤</span></span><br></pre></td></tr></table></figure>
<p><code>Buffer</code>调用<code>clear()</code>方法将<code>position</code>设为0,将<code>limit</code>设为与<code>capacity</code>相等。执行<code>clear()</code>方法后的<code>Buffer</code>示意图如图15.20所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter/15/15.9.2/5.png" alt="这里有一张图片"></p>
<h3 id="根据索引获取值的get方法不会影响position"><a href="#根据索引获取值的get方法不会影响position" class="headerlink" title="根据索引获取值的get方法不会影响position"></a>根据索引获取值的get方法不会影响position</h3><p>从图15.20中可以看出,对<code>Buffer</code>执行<code>clear</code>方法后,该<code>Buffer</code>对象里的数据依然存在,所以程序在⑥号代码处依然可以取出位置为2的值,也就是字符c。因为⑥号代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;执行clear()后，缓冲区内容并没有被清除：&quot;</span> +</span><br><span class="line">    <span class="string">&quot;第三个元素为：&quot;</span> + buff.get(<span class="number">2</span>)); <span class="comment">// ⑥</span></span><br></pre></td></tr></table></figure>
<p>采用的是<strong>根据索引来取值的方式</strong>,所以该方法不会影响<code>Buffer</code>的<code>position</code>.</p>
<h2 id="普通Buffer-直接Buffer"><a href="#普通Buffer-直接Buffer" class="headerlink" title="普通Buffer 直接Buffer"></a>普通Buffer 直接Buffer</h2><p>通过<code>allocate</code>方法创建的<code>Buffer</code>对象是<strong>普通<code>Buffer</code></strong>.<br><code>ByteBuffer</code>还提供了一个<code>allocateDirect()</code>方法来创建<strong>直接<code>Buffer</code><strong>。</strong>直接<code>Buffer</code>的创建成本比普通<code>Buffer</code>的创建成本高,但直接<code>Buffer</code>的读取效率更高</strong>。</p>
<h3 id="只有在ByteBuffer级别上才能创建直接Buffer"><a href="#只有在ByteBuffer级别上才能创建直接Buffer" class="headerlink" title="只有在ByteBuffer级别上才能创建直接Buffer"></a>只有在<code>ByteBuffer</code>级别上才能创建直接<code>Buffer</code></h3><p>由于直接<code>Buffer</code>的创建成本很高,所以**直接<code>Buffer</code>只适用于长生存期的<code>Buffer</code>,而不适用于短生存期、一次用完就丢弃的<code>Buffer</code><strong>。而且只有<code>ByteBuffer</code>才提供了<code>allocateDirect()</code>方法,所以</strong>只有在<code>ByteBuffer</code>级别上才能创建直接<code>Buffer</code><strong>。如果希望使用其他类型,则应该将该</strong>直接<code>Buffer</code>**转换成其他类型的<code>Buffer</code>。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>static ByteBuffer allocateDirect(int capacity)</code></td>
<td align="left">Allocates a new direct byte buffer.</td>
</tr>
</tbody></table>
<!-- CrazyJavaHandout4/Chapter/15/15.9.2/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/32004866/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/32004866/" class="post-title-link" itemprop="url">15.9 NIO 15.9.1 Java新IO概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-06 03:41:44" itemprop="dateCreated datePublished" datetime="2020-01-06T03:41:44+08:00">2020-01-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-9-NIO/" itemprop="url" rel="index"><span itemprop="name">15.9 NIO</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/32004866/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/32004866/" data-xid="/JavaReadingNotes/32004866/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-9-NIO-15-9-1-Java新IO概述"><a href="#15-9-NIO-15-9-1-Java新IO概述" class="headerlink" title="15.9 NIO 15.9.1 Java新IO概述"></a>15.9 NIO 15.9.1 Java新IO概述</h1><h2 id="旧IO"><a href="#旧IO" class="headerlink" title="旧IO"></a>旧IO</h2><h3 id="旧IO阻塞"><a href="#旧IO阻塞" class="headerlink" title="旧IO阻塞"></a>旧IO阻塞</h3><p>前面介绍<code>BufferedReader</code>时提到它的一个特征—当<code>BufferedReader</code>读取输入流中的数据时,如果没有读到有效数据,程序将在此处阻塞该线程的执行(使用<code>InputStream</code>的<code>read()</code>方法从流中读取数据时,如果数据源中没有数据,它也会阻塞该线程),<strong>也就是前面介绍的输入流、输出流都是阻塞式的输入、输出</strong>。</p>
<h3 id="旧IO一次只能处理一个字节"><a href="#旧IO一次只能处理一个字节" class="headerlink" title="旧IO一次只能处理一个字节"></a>旧IO一次只能处理一个字节</h3><p>不仅如此,传统的输入流、输出流都是通过字节的移动来处理的(即使不直接去处理字节流,但底层的实现还是依赖于字节处理),也就是说,<strong>面向流的输入输出系统一次只能处理一个字节,因此面向流的输入输出系统通常效率不高</strong>。</p>
<h2 id="新IO"><a href="#新IO" class="headerlink" title="新IO"></a>新IO</h2><p>从<code>JDK1.4</code>开始,<code>Java</code>提供了一系列改进的输入输出处理的新功能,这些功能被统称为<code>新IO</code>(<code>New IO</code>,简称<code>NIO</code>),新增了许多用于处理输入输出的类,这些类都被放在<code>java.nio</code>包以及子包下,并且<strong>对原<code>java.io</code>包中的很多类都以<code>NIO</code>为基础进行了改写,新增了满足<code>NIO</code>的功能</strong>。</p>
<h1 id="15-9-1-Java新IO概述"><a href="#15-9-1-Java新IO概述" class="headerlink" title="15.9.1 Java新IO概述"></a>15.9.1 Java新IO概述</h1><p>新<code>IO</code>和传统的<code>IO</code>有相同的目的,都是用于进行输入输出,但新<code>IO</code>使用了不同的方式来处理输入/输出。</p>
<h2 id="内存映射文件方式"><a href="#内存映射文件方式" class="headerlink" title="内存映射文件方式"></a>内存映射文件方式</h2><p><strong>新<code>IO</code>采用<mark>内存映射文件</mark>的方式来处理输入/输出</strong>,新<code>IO</code>模拟了操作系统上的虚拟内存的概念:<strong>将文件或文件的一段区域映射到内存中,这样就可以像访问内存一样来访问文件了</strong>,通过这种方式来进行输入输出比传统的输入输出要快得多。</p>
<h2 id="NIO相关包"><a href="#NIO相关包" class="headerlink" title="NIO相关包"></a>NIO相关包</h2><p><code>Java</code>中与新<code>IO</code>相关的包如下:</p>
<table>
<thead>
<tr>
<th align="left">新<code>IO</code>相关的包</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>java.nio</code>包</td>
<td align="left">主要包含各种与<code>Buffer</code>相关的类</td>
</tr>
<tr>
<td align="left"><code>java.nio.channels</code>包</td>
<td align="left">主要包含与<code>Channel</code>和<code>Selector</code>相关的类。</td>
</tr>
<tr>
<td align="left"><code>java.nio.charset</code>包</td>
<td align="left">主要包含与字符集相关的类</td>
</tr>
<tr>
<td align="left"><code>java.nio.channels.spi</code>包</td>
<td align="left">主要包含与<code>Channel</code>相关的服务提供者编程接口。</td>
</tr>
<tr>
<td align="left"><code>java.nio.charset.spi</code>包</td>
<td align="left">包含与字符集相关的服务提供者编程接口。</td>
</tr>
</tbody></table>
<h2 id="Channel简介"><a href="#Channel简介" class="headerlink" title="Channel简介"></a>Channel简介</h2><p><code>Channel</code>(通道)和<code>Buffer</code>(缓冲)是新<code>IO</code>中的两个核心对象,<code>Channel</code>是对传统的输入输出系统的模拟,在新<code>IO</code>系统中所有的数据都需要通过通道传输;<br><code>Channel</code>与传统的<code>InputStream</code>、<code>OutputStream</code>最大的区别在于它提供了一个<code>map()</code>方法,通过该<code>map()</code>方法可以直接将“一块数据”映射到内存中。<br>如果说<strong>传统的输入输出系统是面向<code>流</code>的处理</strong>,则<strong>新<code>IO</code>则是面向<code>块</code>的处理</strong>。</p>
<h2 id="Buffer简介"><a href="#Buffer简介" class="headerlink" title="Buffer简介"></a>Buffer简介</h2><p><code>Buffer</code>可以被理解成一个容器,它的本质是一个数组,<strong>发送到<code>Channel</code>中的所有对象都必须首先放到<code>Buffer</code>中</strong>,而从<code>Channel</code>中读取的数据也必须先放到<code>Buffer</code>中。<br>此处的<code>Buffer</code>有点类似于前面介绍的“竹筒”,但该<code>Buffer</code>既可以像“竹筒”那样一次次去<code>Channel</code>中取水,也允许使用<code>Channel</code>直接将文件的某块数据映射成<code>Buffer</code></p>
<h2 id="Charset和Selector简介"><a href="#Charset和Selector简介" class="headerlink" title="Charset和Selector简介"></a>Charset和Selector简介</h2><p>除<code>Channel</code>和<code>Buffer</code>之外,</p>
<ul>
<li>新<code>IO</code>还提供了<strong>用于将<mark>Unicode字符串</mark>映射成<mark>字节序列</mark>以及<mark>逆映射</mark>操作的<code>Charset</code>类</strong>,</li>
<li>也提供<strong>了用于支持<mark>非阻塞式输入输出</mark>的<code>Selector</code>类</strong>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/ccf88e22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/ccf88e22/" class="post-title-link" itemprop="url">15.8.7 版本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-06 02:24:04" itemprop="dateCreated datePublished" datetime="2020-01-06T02:24:04+08:00">2020-01-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/ccf88e22/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/ccf88e22/" data-xid="/JavaReadingNotes/ccf88e22/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-7-版本"><a href="#15-8-7-版本" class="headerlink" title="15.8.7 版本"></a>15.8.7 版本</h1><p>根据前面的介绍可以知道,反序列化<code>Java</code>对象时必须提供该对象的<code>class</code>文件,现在的问题是,随着项目的升级,系统的<code>class</code>文件也会升级,<code>Java</code>如何保证两个<code>class</code>文件的兼容性?</p>
<h2 id="版本serialVersionUID"><a href="#版本serialVersionUID" class="headerlink" title="版本serialVersionUID"></a>版本serialVersionUID</h2><p><code>Java</code>序列化机制允许为序列化类提供一个<code>private static final</code>的<code>serialVersionUID</code>值,该类变量的值用于标识该<code>Java</code>类的序列化版本,也就是说,如果一个类升级后,<strong>只要它的<code>serialVersionUID</code>类变量值保持不变,序列化机制也会把它们当成同一个序列化版本</strong>。<br>分配<code>serialVersionUID</code>类变量的值非常简单,例如下面代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//为该类指定一个serialVersionUID类变量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialversionUID=<span class="number">512L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在反序列化时确保序列化版本的兼容性,最好在每个要序列化的类中加入<code>private static final long serialVersionUID</code>这个类变量,具体数值自己定义。这样,即使在某个对象被序列化之后,它所对应的类被修改了,该对象也依然可以被正确地反序列化。</p>
<h2 id="不显示指定版本可能造成序列化失败"><a href="#不显示指定版本可能造成序列化失败" class="headerlink" title="不显示指定版本可能造成序列化失败"></a>不显示指定版本可能造成序列化失败</h2><p>如果不显式定义<code>serialversionUID</code>类变量的值,该类变量的值将由<code>JVM</code>根据类的相关信息计算,而修改后的类的计算结果与修改前的类的计算结果往往不同,从而造成对象的反序列化因为类版本不兼容而失败.</p>
<h2 id="使用serialver-exe生成版本"><a href="#使用serialver-exe生成版本" class="headerlink" title="使用serialver.exe生成版本"></a>使用serialver.exe生成版本</h2><p>可以通过<code>JDK</code>安装路径的<code>bin</code>目录下的<code>serialver.exe</code>工具来获得该类的<code>serialVersionUID</code>类变量的值,该命令帮助文档如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS G:\Desktop\codes\15\15.8\externalizable&gt; serialver</span><br><span class="line">用法: serialver [-classpath 类路径] [-show] [类名称...]</span><br></pre></td></tr></table></figure>
<p><code>serialver</code>依赖于.<code>class</code>文件,所以先编译得到.<code>class</code>文件:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-<span class="number">8</span> Person.java</span><br></pre></td></tr></table></figure>
<p>然后输入命令:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialver person</span><br></pre></td></tr></table></figure>
<p>运行该命令,输出结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person: static final long serialVersionUID =-3719034423096421849L;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS G:\Desktop\codes\15\15.8\externalizable&gt; javac -encoding utf-8 Person.java</span><br><span class="line">PS G:\Desktop\codes\15\15.8\externalizable&gt; serialver Person</span><br><span class="line">Person:    private static final long serialVersionUID = -3719034423096421849L;</span><br></pre></td></tr></table></figure>
<p>上面的<code>-3719034423096421849L</code>就是系统为该<code>Person</code>类生成的<code>serialVersionUID</code>类变量的值。如果在运行<code>serialver</code>命令时指定<code>-show</code>选项(不要跟类名参数),即可启动如图15.15所示的图形用户界面。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter15/15_8_7/1.png" alt="这里有一张图片"></p>
<h2 id="不指定版本不利于程序移植"><a href="#不指定版本不利于程序移植" class="headerlink" title="不指定版本不利于程序移植"></a>不指定版本不利于程序移植</h2><p>不显式指定<code>serialVersionUID</code>类变量的值的另一个坏处是,不利于程序在不同的<code>JVM</code>之间移植。因为不同的编译器对该类变量的计算策略可能不同,从而造成虽然类完全没有改变,但是因为<code>JVM</code>不同,也会出现序列化版本不兼容而无法正确反序列化的现象<br>如果类的修改确实会导致该类反序列化失败,则应该为该类的<code>serialVersionUID</code>类变量重新分配值。</p>
<h2 id="类的哪些修改可能导致该类实例的-反序列化失败"><a href="#类的哪些修改可能导致该类实例的-反序列化失败" class="headerlink" title="类的哪些修改可能导致该类实例的 反序列化失败"></a>类的哪些修改可能导致该类实例的 反序列化失败</h2><p>那么对类的哪些修改可能导致该类实例的反序列化失败呢?下面分三种情况来具体讨论</p>
<h3 id="方法的修改-不需要修改版本"><a href="#方法的修改-不需要修改版本" class="headerlink" title="方法的修改 不需要修改版本"></a>方法的修改 不需要修改版本</h3><p>如果修改类时仅仅修改了方法,则反序列化不受任何影响,类定义无须修改<code>serialVersionUID</code>类变量的值。</p>
<h3 id="静态变量和瞬态变量的修改-不需要修改版本"><a href="#静态变量和瞬态变量的修改-不需要修改版本" class="headerlink" title="静态变量和瞬态变量的修改 不需要修改版本"></a>静态变量和瞬态变量的修改 不需要修改版本</h3><p>如果修改类时仅仅修改了静态变量或瞬态实例变量,则反序列化不受任何影响,类定义无须修改<code>serialVersionUID</code>类变量的值。</p>
<h3 id="修改非瞬态实例变量-可能要修改版本"><a href="#修改非瞬态实例变量-可能要修改版本" class="headerlink" title="修改非瞬态实例变量 可能要修改版本"></a>修改非瞬态实例变量 可能要修改版本</h3><ul>
<li>如果修改类时修改了非瞬态的实例变量,则可能导致序列化版本不兼容。<ul>
<li>如果<mark>对象流中的对象</mark>和<mark>新类</mark>中<strong>包含同名的实例变量,而实例变量类型不同</strong>,则反序列化失败,类定义应该更新<code>serialVersionUID</code>类变量的值。(修改实例变量的类型后应该更新版本)</li>
<li>如果<mark>对象流中的对象</mark>比<mark>新类</mark>中<strong>包含更多的实例变量</strong>,则多出的实例变量值被忽略,序列化版本可以兼容,类定义可以不更新<code>serialVersionuID</code>类变量的值(减少实例变量可以不更新版本)</li>
<li>如果<mark>新类</mark>比<mark>对象流中的对象</mark><strong>包含更多的实例变量</strong>,则序列化版本也可以兼容,类定义可以不更新<code>serialversionUID</code>类变量的值;但反序列化得到的新对象中多出的实例变量值都是<code>null</code>(引用类型实例变量)或0(基本类型实例变量)。(增加新的实例变量可以不更新版本)</li>
</ul>
</li>
</ul>
<!-- CrazyJavaHandout4/Chapter15/15_8_7/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/e7c339d4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/e7c339d4/" class="post-title-link" itemprop="url">15.8.6 另一种自定义序列化机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-05 10:17:33" itemprop="dateCreated datePublished" datetime="2020-01-05T10:17:33+08:00">2020-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/e7c339d4/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/e7c339d4/" data-xid="/JavaReadingNotes/e7c339d4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-6-另一种自定义序列化机制"><a href="#15-8-6-另一种自定义序列化机制" class="headerlink" title="15.8.6 另一种自定义序列化机制"></a>15.8.6 另一种自定义序列化机制</h1><p><code>Java</code>还提供了另一种序列化机制,这种序列化方式完全由程序员决定存储和恢复对象数据。要实现该目标,<code>Java</code>类必须实现<code>Externalizable</code>接口。</p>
<h2 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h2><p><code>Externalizable</code>接口里定义了如下两个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void writeExternal(ObjectOutput out)</code></td>
<td align="left">需要序列化的类实现这个<code>writeExternal</code>方法来保存对象的状态。<br>该方法<ul><li>调用<code>DataOutput</code>的方法来保存<code>基本类型</code>的实例变量值,</li><li>调用<code>ObjectOutput</code>的<code>writeObject()</code>方法来保存<code>引用类型</code>的实例变量值。</li></ul></td>
</tr>
<tr>
<td align="left"><code>void readExternal(ObjectInput in)</code></td>
<td align="left">需要序列化的类实现这个<code>readExternal()</code>方法来实现反序列化。<br>该方法<ul><li>调用<code>DataInput</code>的方法来恢复<code>基本类型</code>的实例变量值,</li><li>调用<code>ObjectInput</code>的<code>readObject()</code>方法来恢复<code>引用类型</code>的实例变量值。</li></ul></td>
</tr>
</tbody></table>
<ul>
<li><code>DataInput</code>是<code>ObjectInput</code>的父接口</li>
<li><code>DataOutput</code>是<code>ObjectOutput</code>的父接口</li>
</ul>
<h2 id="程序-实现Externalizable接口自定义序列化"><a href="#程序-实现Externalizable接口自定义序列化" class="headerlink" title="程序 实现Externalizable接口自定义序列化"></a>程序 实现<code>Externalizable</code>接口自定义序列化</h2><p>实际上,采用实现<code>Externalizable</code>接口方式的序列化与前面介绍的自定义序列化非常相似,只是**<code>Externalizable</code>接口强制自定义序列化**。<br>下面的<code>Person</code>类实现了<code>Externalizable</code>接口,并且实现了该接口里提供的两个方法,用以实现自定义序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Externalizable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意必须提供无参数的构造器，否则反序列化时会失败。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(java.io.ObjectOutput out)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(java.io.ObjectInput in)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<code>Person</code>类实现了<code>java.io.Externalizable</code>接口,该<code>Person</code>类还实现了<code>readExternal</code>、<code>writeExternal</code>两个方法,这两个方法除方法签名和<code>readObject</code>、<code>writeObject</code>两个方法的方法签名不同之外,其方法体完全一样。</p>
<h2 id="序列化和反序列化方法相同"><a href="#序列化和反序列化方法相同" class="headerlink" title="序列化和反序列化方法相同"></a>序列化和反序列化方法相同</h2><p>如果程序需要</p>
<ul>
<li>序列化实现<code>Externalizable</code>接口的对象,一样调用<code>ObjectOutputStream</code>的<code>writeObject()</code>方法输出该对象即可;</li>
<li>反序列化实现<code>Externalizable</code>接口的对象,则调用<code>ObjectInputStream</code>的<code>readObject()</code>方法</li>
</ul>
<h2 id="必须提供-public的-无参数构造器"><a href="#必须提供-public的-无参数构造器" class="headerlink" title="必须提供 public的 无参数构造器"></a>必须提供 public的 无参数构造器</h2><p>需要指出的是,当使用<code>Externalizable</code>机制反序列化对象时,程序会先使用<code>public</code>的无参数构造器创建实例,然后才执行<code>readExternal()</code>方法进行反序列化,因此<strong>实现<code>Externalizable</code>的序列化类必须提供<code>public</code>的无参数构造器</strong>。</p>
<h2 id="表15-2两种序列化机制的对比"><a href="#表15-2两种序列化机制的对比" class="headerlink" title="表15.2两种序列化机制的对比"></a>表15.2两种序列化机制的对比</h2><table>
<thead>
<tr>
<th align="left">实现<code>Serializable</code>接口</th>
<th align="left">实现<code>Externalizable</code>接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">系统自动存储必要信息</td>
<td align="left">程序员决定存储哪些信息</td>
</tr>
<tr>
<td align="left"><code>Java</code>内建支持,易于实现,<strong>只需实现该接口即可,无须任何代码支持</strong></td>
<td align="left">仅仅提供两个空方法,<strong>实现该接口必须实现g该接口的两个空方法</strong></td>
</tr>
<tr>
<td align="left">性能略差</td>
<td align="left">性能略好</td>
</tr>
</tbody></table>
<p>虽然实现<code>Externalizable</code>接口能带来一定的性能提升,但由于实现<code>Externalizable</code>接口导致了编程复杂度的增加,所以大部分时候都是采用实现<code>Serializable</code>接口方式来实现序列化。</p>
<h2 id="对象序列化需要注意的地方"><a href="#对象序列化需要注意的地方" class="headerlink" title="对象序列化需要注意的地方"></a>对象序列化需要注意的地方</h2><p>关于对象序列化,还有如下几点需要注意。</p>
<ol>
<li>对象的<strong>类名</strong>、<strong>实例变量</strong>(包括基本类型、数组、对其他对象的引用)都会被序列化;<ol>
<li>方法、类变量(即<code>static</code>修饰的成员变量)、<code>transient</code>实例变量(也被称为瞬态实例变量)都<strong>不会被序列化</strong>。</li>
</ol>
</li>
<li>实现<code>Serializable</code>接口的类<strong>如果需要让某个实例变量不被序列化,则可在该实例变量前加<code>transient</code>修饰符</strong>,而不是加<code>static</code>关键字。虽然<code>static</code>关键字也可达到这个效果,但<code>static</code>关键字不能这样用。</li>
<li>保证序列化对象的实例变量类型也是可序列化的,否则需要使用<code>transient</code>关键字来修饰该实例变量,要不然,该类是不可序列化的。</li>
<li>反序列化对象时必须有序列化对象的<code>class</code>文件。</li>
<li>当通过文件、网络来读取序列化后的对象时,必须按实际写入的顺序读取。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/1c0498d6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/1c0498d6/" class="post-title-link" itemprop="url">15.8.5 自定义序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-03 10:21:52" itemprop="dateCreated datePublished" datetime="2020-01-03T10:21:52+08:00">2020-01-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/1c0498d6/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/1c0498d6/" data-xid="/JavaReadingNotes/1c0498d6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-5-自定义序列化"><a href="#15-8-5-自定义序列化" class="headerlink" title="15.8.5 自定义序列化"></a>15.8.5 自定义序列化</h1><h2 id="递归序列化"><a href="#递归序列化" class="headerlink" title="递归序列化"></a>递归序列化</h2><ul>
<li>当对某个对象进行序列化时,系统会自动<strong>把该对象的所有<mark>实例变量</mark>依次进行序列化</strong>,<ul>
<li>如果某个实例变量引用到另一个对象,则被引用的对象也会被序列化;<ul>
<li>如果被引用的对象的实例变量也引用了其他对象,则被引用的对象也会被序列化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这种情况被称为<strong>递归序列化</strong>。</p>
<h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><h3 id="不希望序列化的实例变量的情况"><a href="#不希望序列化的实例变量的情况" class="headerlink" title="不希望序列化的实例变量的情况"></a>不希望序列化的实例变量的情况</h3><p>在一些特殊的场景下,如果一个类里包含的某些实例变量是<strong>敏感信息</strong>,例如银行账户信息等,这时不希望系统将该实例变量值进行序列化;<br>或者某个实例变量的类型是不可序列化的,因此不希望对该实例变量进行递归序列化,以避免引发<code>java.io.NotSerializableException</code>异常。<br><strong>通过在实例变量前面使用<code>transient</code>关键字修饰,可以指定<code>Java</code>序列化时无须理会该实例变量</strong>。<br><strong><code>transient</code>关键字只能用于修饰实例变量,不可修饰<code>Java</code>程序中的其他成分</strong>。</p>
<h3 id="程序-transient关键字修饰实例变量"><a href="#程序-transient关键字修饰实例变量" class="headerlink" title="程序 transient关键字修饰实例变量"></a>程序 transient关键字修饰实例变量</h3><p>如下<code>Person</code>类与前面的<code>Person</code>类几乎完全一样,只是它的<code>age</code>使用了<code>transient</code>关键字修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2595800114629327570L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序-序列化后反序列化-再输出transient修饰的实例变量"><a href="#程序-序列化后反序列化-再输出transient修饰的实例变量" class="headerlink" title="程序 序列化后反序列化 再输出transient修饰的实例变量"></a>程序 序列化后反序列化 再输出transient修饰的实例变量</h3><p>下面程序先序列化一个<code>Person</code>对象,然后再反序列化该<code>Person</code>对象,得到反序列化的<code>Person</code>对象后程序输出该对象的<code>age</code>实例变量值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">                ObjectOutputStream oos =</span><br><span class="line">                    <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                ObjectInputStream ois = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;transient.txt&quot;</span>))) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);<span class="comment">// 代码1</span></span><br><span class="line">            <span class="comment">// 系统会per对象转换字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);<span class="comment">// 代码2</span></span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            Person p = (Person) ois.readObject();<span class="comment">// 代码3</span></span><br><span class="line">            System.out.println(p.getAge());<span class="comment">//代码4</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<br><strong>代码1</strong>创建了一个<code>Person</code>对象,并为它的<code>name</code>、<code>age</code>两个实例变量指定了值;<br><strong>代码2</strong>将该<code>Person</code>对象序列化后输出;<br><strong>代码3</strong>从序列化文件中读取该<code>Person</code>对象;<br><strong>代码4</strong>输出该<code>Person</code>对象的<code>age</code>实例变量值。</p>
<p><strong>由于本程序中的<code>Person</code>类的<code>age</code>实例变量使用<code>transient</code>关键字修饰,所以p.getAge()将得到0,而不是500</strong>。</p>
<h3 id="transient关键字的问题"><a href="#transient关键字的问题" class="headerlink" title="transient关键字的问题"></a>transient关键字的问题</h3><p>使用<code>transient</code>关键字修饰实例变量虽然简单、方便,但<strong>被<code>transient</code>修饰的实例变量将被完全隔离在序列化机制之外,这样导致在反序列化恢复<code>Java</code>对象时无法取得该实例变量值</strong>。</p>
<h2 id="自定义序列化机制"><a href="#自定义序列化机制" class="headerlink" title="自定义序列化机制"></a>自定义序列化机制</h2><p><code>Java</code>还提供了一种自定义序列化机制,**通过这种自定义序列化机制<mark>可以让程序控制如何序列化各实例变量</mark>,<mark>甚至完全不序列化某些实例变量</mark>(与使用<code>transient</code>关键字的效果相同)**。</p>
<h3 id="在类中添加特殊的方法"><a href="#在类中添加特殊的方法" class="headerlink" title="在类中添加特殊的方法"></a>在类中添加特殊的方法</h3><p>在序列化和反序列化过程中需要特殊处理的类应该提供如下特殊签名的方法,<strong>这些特殊的方法用以实现自定义序列化。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObjectNoData</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException</span></span><br></pre></td></tr></table></figure>
<h4 id="writeObject方法"><a href="#writeObject方法" class="headerlink" title="writeObject方法"></a>writeObject方法</h4><p><code>writeObject</code>方法负责写入特定类的实例状态,以便相应的<code>readObject</code>方法可以恢复它。<strong>通过重写该writeObject方法,程序员可以完全获得对序列化机制的控制,可以自主决定哪些实例变量需要序列化,需要怎样序列化</strong>。在默认情况下,该方法会调用<code>out.defaultObject</code>来保存<code>Java</code>对象的各实例变量,从而可以实现序列化<code>Java</code>对象状态的目的</p>
<h4 id="readObject方法"><a href="#readObject方法" class="headerlink" title="readObject方法"></a>readObject方法</h4><p><code>readObject</code>方法负责从流中读取并恢复对象实例变量,<strong>通过重写该readObject方法,程序员可以完全获得对反序列化机制的控制,可以自主决定需要反序列化哪些实例变量,以及如何进行反序列化</strong>。在默认情况下,该方法会调用<code>in default Readobject</code>来恢复<code>Java</code>对象的非瞬态实例变量。在通常情况下,<code>readObject</code>方法与<code>writeObject</code>方法对应,如果<code>writeObject</code>方法中对<code>Java</code>对象的实例变量进行了一些处理,则应该在<code>readObject</code>方法中对其实例变量进行相应的反处理,以便正确恢复该对象。</p>
<h4 id="readObjectNoData方法"><a href="#readObjectNoData方法" class="headerlink" title="readObjectNoData方法"></a>readObjectNoData方法</h4><p>当序列化流不完整时,<code>readObjectNoData</code>方法可以用来正确地初始化反序列化的对象。例如,接收方使用的反序列化类的版本不同于发送方,或者接收方版本扩展的类不是发送方版本扩展的类,或者序列化流被篡改时,系统都会调用<code>readObjectNoData</code>方法来初始化反序列化的对象。</p>
<h3 id="程序-自定义序列化"><a href="#程序-自定义序列化" class="headerlink" title="程序 自定义序列化"></a>程序 自定义序列化</h3><p>下面的<code>Person</code>类提供了<code>writeObject</code>和<code>readObject</code>两个方法,其中<br><code>writeObject</code>方法在保存<code>Person</code>对象时将其<code>name</code>实例变量包装成<code>StringBuffer</code>,并将其字符序列反转后写入;<br>在<code>readObject</code>方法中处理<code>name</code>的策略与此对应——先将读取的数据强制类型转换成<code>StringBuffer</code>,再将其反转后赋给<code>nane</code>实例变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3069227031912694124L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> StringBuffer(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">        <span class="keyword">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        <span class="keyword">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中提供了<code>writeObject</code>和<code>readObject</code>用以实现自定义序列化,对于这个<code>Person</code>类而言,序列化、反序列化<code>Person</code>实例并没有任何区别——区别在于序列化后的对象流,即使有<code>Cracker</code>截获到<code>Person</code>对象流,他看到的<code>name</code>也是加密后的<code>name</code>值,这样就提高了序列化的安全性。<br><code>writeObject</code>方法存储实例变量的顺序应该和<code>readObject</code>方法中恢复实例变量的顺序一致,否则将不能正常恢复该<code>Java</code>对象。<br>对<code>Person</code>对象进行序列化和反序列化的程序与前面程序没有任何区别,故此处不再赘述。</p>
<h2 id="更彻底的自定义序列化方式"><a href="#更彻底的自定义序列化方式" class="headerlink" title="更彻底的自定义序列化方式"></a>更彻底的自定义序列化方式</h2><h3 id="writeReplace方法"><a href="#writeReplace方法" class="headerlink" title="writeReplace方法"></a>writeReplace方法</h3><p>还有一种更彻底的自定义机制,它甚至可以在序列化对象时将该对象替换成其他对象。如果需要实现序列化某个对象时替换该对象,则应为序列化类提供如下特殊方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span></span><br></pre></td></tr></table></figure>
<p>此<code>writeReplace</code>方法将由序列化机制调用,只要该方法存在。因为该方法可以拥有私有(<code>private</code>)受保护的(<code>protected</code>)和包私有(<code>package-private</code>)等访问权限,所以其子类有可能获得该方法。</p>
<h4 id="程序-使用writeReplace方法"><a href="#程序-使用writeReplace方法" class="headerlink" title="程序 使用writeReplace方法"></a>程序 使用writeReplace方法</h4><p>例如下面的<code>Person</code>类提供了<code>writeReplace</code>方法,这样可以在写入<code>Person</code>对象时将该对象替换成<code>ArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">    <span class="comment">// 重写writeReplace方法，程序在序列化该对象之前，先调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(name);</span><br><span class="line">        list.add(age);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Java</code>的序列化机制保证在序列化某个对象之前,先调用该对象的<code>writeReplace</code>方法,如果该方法返回另一个<code>Java</code>对象,则系统转为序列化另一个对象。如下程序表面上是序列化<code>Person</code>对象,但实际上序列化的是<code>ArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">                ObjectOutputStream oos = </span><br><span class="line">                    <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;replace.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                ObjectInputStream ois = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;replace.txt&quot;</span>))) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 系统将per对象转换字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);<span class="comment">//代码一</span></span><br><span class="line">            <span class="comment">// 反序列化读取得到的是ArrayList</span></span><br><span class="line">            ArrayList list = (ArrayList) ois.readObject();<span class="comment">//代码二</span></span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中<strong>代码一</strong>使用<code>writeObject</code>写入了一个<code>Person</code>对象,但<strong>代码二</strong>使用<code>readObject</code>方法返回的实际上是一个<code>ArayList</code>对象,这是因为<code>Person</code>类的<code>writeReplace</code>方法返回了个<code>ArrayList</code>对象,所以序列化机制在序列化<code>Person</code>对象时,实际上是转为序列化<code>ArrayList</code>对象。</p>
<h4 id="先调用writeReplace方法-再调用writeObject方法"><a href="#先调用writeReplace方法-再调用writeObject方法" class="headerlink" title="先调用writeReplace方法 再调用writeObject方法"></a>先调用writeReplace方法 再调用writeObject方法</h4><p>根据上面的介绍,可以知道系统在序列化某个对象之前,会先调用该对象的<code>writeReplace</code>和<code>writeObject</code>两个方法,<strong>系统总是先调用被序列化对象的<code>writeReplace</code>方法,如果该方法返回另一个对象,系统将再次调用另一个对象的<code>writeReplace</code>方法…直到该方法不再返回另一个对象为止,程序最后将调用该对象的<code>writeObject</code>方法来保存该对象的状态</strong>。</p>
<h3 id="readResolve方法"><a href="#readResolve方法" class="headerlink" title="readResolve方法"></a>readResolve方法</h3><p>与<code>writeReplace()</code>方法相对的是,序列化机制里还有一个特殊的方法,它可以实现保护性复制整个对象。这个方法就是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY-ACCESS-<span class="function">MODIFIER Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>;</span><br></pre></td></tr></table></figure>
<p><code>readResolve</code>方法会紧接着<code>readObject</code>之后被调用,<code>readResolve</code>方法的返回值将会代替原来反序列化的对象,而原来<code>readObject</code>反序列化的对象将会被立即丢弃。</p>
<p><strong><code>readResolve()</code>方法在序列化单例类、枚举类时尤其有用</strong>。<br>当然,如果使用<code>Java5</code>提供的<code>enum</code>来定义枚举类,则完全不用担心,程序没有任何问题。</p>
<h4 id="早期枚举类问题"><a href="#早期枚举类问题" class="headerlink" title="早期枚举类问题"></a>早期枚举类问题</h4><p>但如果应用中有早期遗留下来的枚举类,例如下面的<code>Orientation</code>类就是一个枚举类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orientation</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation HORIZONTAL = <span class="keyword">new</span> Orientation(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation VERTICAL = <span class="keyword">new</span> Orientation(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Orientation</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 为枚举类增加readResolve()方法</span></span><br><span class="line">    <span class="comment">// private Object readResolve()throws ObjectStreamException</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (value == 1)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return HORIZONTAL;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if (value == 2)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return VERTICAL;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return null;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Java5</code>以前,这种代码是很常见的。<code>Orientation</code>类的构造器私有,程序只有两个<code>Orientation</code>对象,分别通过<code>Orientation</code>的<code>HORIZONTAL</code>和<code>VERTICAL</code>两个常量来引用。但如果让该类实现<code>Serializable</code>接口,则会引发一个问题,如果将一个<code>Orientation. HORIZONTAL</code>值序列化后再读出,如下代码片段所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolveTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输入流</span></span><br><span class="line">                ObjectOutputStream oos = </span><br><span class="line">                    <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                ObjectInputStream ois = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;transient.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(Orientation.HORIZONTAL);</span><br><span class="line">            Orientation ori = (Orientation) ois.readObject();</span><br><span class="line">            System.out.println(ori == Orientation.HORIZONTAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**如果立即拿<code>ori</code>和<code>Orientation.HORIZONTAL</code>值进行比较,将会发现返回<code>false</code>**。也就是说,<code>ori</code>是个新的<code>Orientation</code>对象,而不等于<code>Orientation</code>类中的任何枚举值——虽然<code>Orientation</code>的构造器是<code>private</code>的,但反序列化依然可以创建<code>Orientation</code>对象。</p>
<p>前面已经指出,反序列化机制在恢复<code>Java</code>对象时无须调用构造器来初始化<code>Java</code>对象从这个意义上来看,<strong>序列化机制可以用来“克隆”对象</strong>。<br>在这种情况下,可以通过为<code>Orientation</code>类提供一个<code>readResolve()</code>方法来解决该问题,<code>readResolve()</code>方法的返回值将会代替原来反序列化的对象,也就是让反序列化得到的<code>Orientation</code>对象被直接丢弃。<br>下面是为<code>Orientation</code>类提供的<code>readResolve()</code>方法(程序清单同上)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为枚举类增加readResolve()方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> HORIZONTAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> VERTICAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重写<code>readResolve()</code>方法可以保证反序列化得到的依然是<code>Orientation</code>的<code>HORIZONTAL</code>或<code>VERTICAL</code>两个枚举值之一。</p>
<h4 id="单例类-枚举类都应该提供readResolve方法"><a href="#单例类-枚举类都应该提供readResolve方法" class="headerlink" title="单例类 枚举类都应该提供readResolve方法"></a>单例类 枚举类都应该提供readResolve方法</h4><p><strong>所有的单例类、枚举类在实现序列化时都应该提供<code>readResolve()</code>方法,这样才可以保证反序列化的对象依然正常</strong>。</p>
<h4 id="readResolve方法需要注意的问题"><a href="#readResolve方法需要注意的问题" class="headerlink" title="readResolve方法需要注意的问题"></a>readResolve方法需要注意的问题</h4><p>与<code>writeReplace()</code>方法类似的是,<code>readResolve()</code>方法也可以使用任意的访问控制符,因此父类的<code>readResolve()</code>方法可能被其子类继承。这样利用<code>readResolve()</code>方法时就会存在一个明显的缺点,就是当父类已经实现了<code>readResolve()</code>方法后,子类将变得无从下手。如果父类包含一个<code>protected</code>或<code>public</code>的<code>readResolve</code>方法,而且子类也没有重写该方法,将会使得子类反序列化时得到一个父类的对象——这显然不是程序要的结果,而且也不容易发现这种错误。<br>总是让子类重写<code>readResolve()</code>方法无疑是一个负担,因此对于要被作为父类继承的类而言,实现<code>readResolve(()</code>方法可能有一些潜在的危险。<br>通常的建议是:</p>
<ul>
<li>对于<code>final</code>类,重写<code>readResolve()</code>方法不会有任何问题;</li>
<li>否则,重写<code>readResolve()</code>方法时应尽量使用<code>private</code>修饰该方法。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8cec0944/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8cec0944/" class="post-title-link" itemprop="url">15.8.4 Java9增加的过滤功能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-03 10:00:35" itemprop="dateCreated datePublished" datetime="2020-01-03T10:00:35+08:00">2020-01-03</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8cec0944/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8cec0944/" data-xid="/JavaReadingNotes/8cec0944/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-4-Java9增加的过滤功能"><a href="#15-8-4-Java9增加的过滤功能" class="headerlink" title="15.8.4 Java9增加的过滤功能"></a>15.8.4 Java9增加的过滤功能</h1><p><code>Java9</code>为<code>ObjectInputStream</code>增加了<code>setObjectInputFilter()</code>、<code>getObjectInputFilter()</code>两个方法:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void setObjectInputFilter(ObjectInputFilter filter)</code></td>
<td align="left">Set the serialization filter for the stream.</td>
</tr>
<tr>
<td align="left"><code>ObjectInputFilter getObjectInputFilter()</code></td>
<td align="left">Returns the serialization filter for this stream.</td>
</tr>
</tbody></table>
<p>其中<code>setObjectInputFilter</code>方法用于为对象输入流设置<strong>过滤器</strong>。</p>
<h2 id="反序列化时-过滤器ObjectInputFilter的checkInput方法会自动触发"><a href="#反序列化时-过滤器ObjectInputFilter的checkInput方法会自动触发" class="headerlink" title="反序列化时 过滤器ObjectInputFilter的checkInput方法会自动触发"></a>反序列化时 过滤器ObjectInputFilter的checkInput方法会自动触发</h2><p><strong>当程序通过<code>ObjectInputStream</code>反序列化对象时,过滤器的<code>checkInput()</code>方法会被自动激发,用于检查序列化数据是否有效</strong>。</p>
<h2 id="ObjectInputFilter是函数式接口"><a href="#ObjectInputFilter是函数式接口" class="headerlink" title="ObjectInputFilter是函数式接口"></a>ObjectInputFilter是函数式接口</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ObjectInputFilter.Status checkInput(ObjectInputFilter.FilterInfo filterInfo)</code></td>
<td align="left">Check the class, array length, number of object references, depth, stream size, and other available filtering information.</td>
</tr>
</tbody></table>
<h2 id="checkInput方法返回值"><a href="#checkInput方法返回值" class="headerlink" title="checkInput方法返回值"></a>checkInput方法返回值</h2><p>使用<code>checkInput()</code>方法检查序列化数据时有3种返回值。</p>
<table>
<thead>
<tr>
<th align="left"><code>checkInput()</code>方法返回值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ObjectInputFilter.Status.REJECTED</code></td>
<td align="left">拒绝恢复</td>
</tr>
<tr>
<td align="left"><code>ObjectInputFilter.Status.ALLOWED</code></td>
<td align="left">允许恢复</td>
</tr>
<tr>
<td align="left"><code>ObjectInputFilter.Status.UNDECIDED</code></td>
<td align="left">未决定状态,程序继续执行检查</td>
</tr>
</tbody></table>
<p><code>ObjectInputStream</code>将会根据<code>ObjectInputFilter</code>的检查结果来决定是否执行反序列化:</p>
<ul>
<li>如果<code>checkInput</code>方法返回<code>Status.REJECtED</code>,反序列化将会被阻止;</li>
<li>如果<code>checkInput</code>方法返回<code>Status.ALLOWED</code>,程序将可执行反序列化;</li>
</ul>
<h2 id="程序-反序列化之前先检查数据"><a href="#程序-反序列化之前先检查数据" class="headerlink" title="程序 反序列化之前先检查数据"></a>程序 反序列化之前先检查数据</h2><p>下面程序对前的<code>ReadObject.java</code>程序进行改进,该程序将会在反序列化之前对数据执行检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>))) </span><br><span class="line">        &#123;</span><br><span class="line">            ois.setObjectInputFilter((info) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;===执行数据过滤===&quot;</span>);</span><br><span class="line">                ObjectInputFilter serialFilter = ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">                <span class="keyword">if</span> (serialFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 首先使用ObjectInputFilter执行默认的检查</span></span><br><span class="line">                    ObjectInputFilter.Status status = serialFilter.checkInput(info);</span><br><span class="line">                    <span class="comment">// 如果默认检查的结果不是Status.UNDECIDED</span></span><br><span class="line">                    <span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">                        <span class="comment">// 直接返回检查结果</span></span><br><span class="line">                        <span class="keyword">return</span> status;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果要恢复的对象不是1个</span></span><br><span class="line">                <span class="keyword">if</span> (info.references() != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不允许恢复对象</span></span><br><span class="line">                    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果恢复的不是Person类</span></span><br><span class="line">                <span class="keyword">if</span> (info.serialClass() != <span class="keyword">null</span> &amp;&amp; info.serialClass() != Person.class) &#123;</span><br><span class="line">                    <span class="comment">// 不允许恢复对象</span></span><br><span class="line">                    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span></span><br><span class="line">            Person p = (Person) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName() + <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的粗体字代码为<code>ObjectInputStream</code>设置了<code>ObjectInputFilter</code>过滤器(程序使用<code>Lambda</code>表达式创建过滤器),程序重写了<code>checkInput</code>方法。<br>重写<code>checkInput</code>方法时先使用默认的<code>ObjectInputFilter</code>执行检查,</p>
<ul>
<li>如果检查结果不是<code>Status.UNDECIDED</code>,程序直接返回检查结果。</li>
<li>接下来程序通过<code>FilterInfo</code>检验序列化数据,<ul>
<li>如果序列化数据中的对象不唯一(数据已被污染),程序拒绝执行反序列化;</li>
<li>如果序列化数据中的对象不是<code>Person</code>对象(数据被污染),程序拒绝执行反序列化。</li>
</ul>
</li>
</ul>
<p><strong>通过这种检查,程序可以保证反序列化出来的是唯一的<code>Person</code>对象,这样就让反序列化更加安全、健壮</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a9bda96a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a9bda96a/" class="post-title-link" itemprop="url">15.8.3 对象引用的序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-02 04:17:56" itemprop="dateCreated datePublished" datetime="2020-01-02T04:17:56+08:00">2020-01-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a9bda96a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a9bda96a/" data-xid="/JavaReadingNotes/a9bda96a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-3-对象引用的序列化"><a href="#15-8-3-对象引用的序列化" class="headerlink" title="15.8.3 对象引用的序列化"></a>15.8.3 对象引用的序列化</h1><h2 id="可序列化类-的成员变量-的类型必须可序列化"><a href="#可序列化类-的成员变量-的类型必须可序列化" class="headerlink" title="可序列化类 的成员变量 的类型必须可序列化"></a>可序列化类 的成员变量 的类型必须可序列化</h2><p>前面介绍的<code>Person</code>类的两个成员变量分别是<code>String</code>类型和<code>int</code>类型,<strong>如果某个类的成员变量的类型不是基本类型或<code>String</code>类型,而是另一个引用类型,那么这个引用类必须是可序列化的,否则拥有该类型成员变量的类也是不可序列化的</strong>。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>如下<code>Teacher</code>类持有一个<code>Person</code>类的引用,只有<code>Person</code>类是可序列化的,<code>Teacher</code>类才是可序列化的。如果<code>Person</code>类不可序列化,不管<code>Teacher</code>类是否实现<code>Sterilizable</code>或<code>Externalizable</code>接口,<code>Teacher</code>类都是不可序列化的。<br>这是因为当程序序列化一个<code>Teacher</code>对象时,<strong>如果该<code>Teacher</code>对象持有一个<code>Person</code>对象的引用为了在反序列化时可以正常恢复该<code>Teacher</code>对象,程序会顺带将该<code>Person</code>对象也进行序列化</strong>,所以<code>Person</code>类也必须是可序列化的,否则<code>Teacher</code>类将不可序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1184339136873829552L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person student;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String name, Person student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略了name和student的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个对象可能被多次序列化的情况"><a href="#一个对象可能被多次序列化的情况" class="headerlink" title="一个对象可能被多次序列化的情况"></a>一个对象可能被多次序列化的情况</h2><p>现在假设有如下一种特殊情形:<br>程序中有两个<code>Teacher</code>对象,它们的<code>Student</code>实例变量都引用到同个<code>Person</code>对象,而且该<code>Person</code>对象还有一个引用变量引用它。如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person per= <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">500</span>);</span><br><span class="line">Teacher t1= <span class="keyword">new</span> Teacher(<span class="string">&quot;唐僧&quot;</span>,per);</span><br><span class="line">Teacher t2= <span class="keyword">new</span> Teacher(<span class="string">&quot;菩提祖师&quot;</span>,per);</span><br></pre></td></tr></table></figure>
<p>上面代码创建了两个<code>Teacher</code>对象和一个<code>Person</code>对象,这三个对象在内存中的存储示意图如图15.13所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter15/15_8_3/1.png" alt="这里有一张图片"></p>
<p>这里产生了一个问题:</p>
<ul>
<li>如果先序列化<code>t1</code>对象,则系统将该<code>t1</code>对象所引用的<code>Person</code>对象一起序列化;<ul>
<li>如果程序再序列化<code>t2</code>对象,系统将一样会序列化该<code>t2</code>对象,并且将再次序列化该<code>t2</code>对象所引用的<code>Person</code>对象;<ul>
<li>如果程序再显式序列化<code>per</code>对象,系统将再次序列化该<code>Person</code>对象。<ul>
<li>这个过程似乎会向输出流中输出三个<code>Person</code>对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果系统向输出流中写入了三个<code>Person</code>对象,那么后果是当程序从输入流中反序列化这些对象时,将会得到三个<code>Person</code>对象,从而引起<code>t1</code>和<code>t2</code>所引用的<code>Person</code>对象不是同一个对象,这显然与图5.13所示的效果不一致——这也就违背了<code>Java</code>序列化机制的初衷。</p>
<h2 id="Java序列化机制"><a href="#Java序列化机制" class="headerlink" title="Java序列化机制"></a>Java序列化机制</h2><p>所以,<code>Java</code>序列化机制采用了一种特殊的序列化算法,其算法内容如下。</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号。</li>
<li>当程序试图序列化一个对象时,程序将先检查该对象是否已经被序列化过,<ul>
<li><strong>只有该对象从未(在本次虚拟机中)被序列化过,系统才会将该对象转换成字节序列并输出</strong>。</li>
<li>如果某个对象已经序列化过,程序将只是直接输出一个序列化编号,而不是再次重新序列化该对象。</li>
</ul>
</li>
</ul>
<p>根据上面的序列化算法,可以得到一个结论:<br>当第二次、第三次序列化<code>Person</code>对象时,程序不会再次将<code>Person</code>对象转换成字节序列并输出,而是仅仅输出一个序列化编号。假设有如下顺序的序列化代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(t1);</span><br><span class="line">oos.writeObject(t2);</span><br><span class="line">oos.writeObject(per);</span><br></pre></td></tr></table></figure>
<p>上面代码依次序列化了<code>t1</code>、<code>t2</code>和<code>per</code>对象,序列化后磁盘文件的存储示意图如图15.14所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter15/15_8_3/2.png" alt="这里有一张图片"><br>通过图15.14可以很好地理解<code>Java</code>序列化的底层机制,通过该机制不难看出,<strong>当多次调用<code>writeObject()</code>方法输出同一个对象时,只有第一次调用<code>writeObject()</code>方法时才会将该对象转换成字节序列并输出</strong>。</p>
<h2 id="程序-多次写入一个对象"><a href="#程序-多次写入一个对象" class="headerlink" title="程序 多次写入一个对象"></a>程序 多次写入一个对象</h2><p>下面程序序列化了两个<code>Teacher</code>对象,两个<code>Teacher</code>对象都持有一个引用到同一个<code>Person</code>对象的引用,而且程序两次调用<code>writeObject()</code>方法输出同一个<code>Teacher</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">                ObjectOutputStream oos =</span><br><span class="line">                     <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            Teacher t1 = <span class="keyword">new</span> Teacher(<span class="string">&quot;唐僧&quot;</span>, per);</span><br><span class="line">            Teacher t2 = <span class="keyword">new</span> Teacher(<span class="string">&quot;菩提祖师&quot;</span>, per);</span><br><span class="line">            <span class="comment">// 依次将四个对象写入输出流</span></span><br><span class="line">            oos.writeObject(t1);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中4次调用了<code>writeObject()</code>方法来输出对象,实际上只序列化了三个对象,而且序列的两个<code>Teacher</code>对象的<code>student</code>引用实际是同一个<code>Person</code>对象。</p>
<h2 id="程序-读取被写入多次的对象"><a href="#程序-读取被写入多次的对象" class="headerlink" title="程序 读取被写入多次的对象"></a>程序 读取被写入多次的对象</h2><p>下面程序读取序列化文件中的对象即可证明这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTeacher</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输出流</span></span><br><span class="line">                ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 依次读取ObjectInputStream输入流中的四个对象</span></span><br><span class="line">            Teacher t1 = (Teacher) ois.readObject();</span><br><span class="line">            Teacher t2 = (Teacher) ois.readObject();</span><br><span class="line">            Person p = (Person) ois.readObject();</span><br><span class="line">            Teacher t3 = (Teacher) ois.readObject();</span><br><span class="line">            <span class="comment">// 输出true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t1的student引用和p是否相同：&quot;</span> + (t1.getStudent() == p));</span><br><span class="line">            <span class="comment">// 输出true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2的student引用和p是否相同：&quot;</span> + (t2.getStudent() == p));</span><br><span class="line">            <span class="comment">// 输出true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2和t3是否是同一个对象：&quot;</span> + (t2 == t3));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1的student引用和p是否相同：true</span><br><span class="line">t2的student引用和p是否相同：true</span><br><span class="line">t2和t3是否是同一个对象：true</span><br></pre></td></tr></table></figure>
<p>上面程序中依次读取了序列化文件中的4个<code>Java</code>对象,但通过后面比较判断,不难发现<code>t2</code>和<code>t3</code>是同一个<code>Java</code>对象,<code>t1</code>的<code>student</code>引用的、<code>t2</code>的<code>student</code>引用的和<code>p</code>引用变量引用的也是同个<code>Java</code>对象——这证明了图15.14所示的序列化机制。</p>
<h2 id="序列化可变对象引起的问题"><a href="#序列化可变对象引起的问题" class="headerlink" title="序列化可变对象引起的问题"></a>序列化可变对象引起的问题</h2><p>由于<code>Java</code>序列化机制使然:如果多次序列化同一个<code>Java</code>对象时,只有第一次序列化时才会把该<code>Java</code>对象转换成字节序列并输出,这样可能引起一个潜在的问题——当程序序列化一个可变对象时,只有第一次使用<code>writeObject()</code>方法输出时才会将该对象转换成字节序列并输出,当程序再次调用<code>writeObject()</code>方法时,程序只是输出前面的序列化编号,<strong>即使后面该对象的实例变量值已被改变,改变的实例变量值也不会被输出</strong>。<br>如下程序所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializeMutable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输入流</span></span><br><span class="line">                ObjectOutputStream oos = </span><br><span class="line">                    <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;mutable.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                ObjectInputStream ois = </span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;mutable.txt&quot;</span>))) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 系统会per对象转换字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            <span class="comment">// 改变per对象的name实例变量</span></span><br><span class="line">            per.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">            <span class="comment">// 系统只是输出序列化编号，所以改变后的name不会被序列化</span></span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            Person p1 = (Person) ois.readObject(); <span class="comment">// 代码1</span></span><br><span class="line">            Person p2 = (Person) ois.readObject(); <span class="comment">// 代码2</span></span><br><span class="line">            <span class="comment">// 下面输出true，即反序列化后p1等于p2</span></span><br><span class="line">            System.out.println(p1 == p2);</span><br><span class="line">            <span class="comment">// 下面依然看到输出&quot;孙悟空&quot;，即改变后的实例变量没有被序列化</span></span><br><span class="line">            System.out.println(p2.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中先使用<code>writeObject()</code>方法写入了一个<code>Person</code>对象,接着程序改变了<code>Person</code>对象的<code>name</code>实例变量值,然后程序再次输出<code>Person</code>对象,但这次的输出已经不会将<code>Person</code>对象转换成字节序列并输出了,而是仅仅输出了一个序列化编号<br>程序中<strong>代码1</strong>,<strong>代码2</strong>两次调用<code>readObject()</code>方法读取了序列化文件中的<code>Java</code>对象,比较两次读取的<code>Java</code>对象将完全相同,程序输岀第二次读取的<code>Person</code>对象的<code>name</code>实例变量的值依然是“孙悟空”,这表明改变后的<code>Person</code>对象并没有被写入,这与<code>Java</code>序列化机制相符。</p>
<h3 id="只有第一次调用wirteObject方法时才会将对象转换成字节序列"><a href="#只有第一次调用wirteObject方法时才会将对象转换成字节序列" class="headerlink" title="只有第一次调用wirteObject方法时才会将对象转换成字节序列"></a>只有第一次调用<code>wirteObject</code>方法时才会将对象转换成字节序列</h3><p>当使用<code>Java</code>序列化机制序列化可变对象时一定要注意,<strong>只有第一次调用<code>wirteObject</code>方法来输出对象时才会将对象转换成字节序列</strong>,并写入到<code>ObjectOutputStream</code>,在后面程序中即使该对象的实例变量发生了改变,再次调用<code>writeObjecto</code>方法输出该对象时,改变后的实例变量也不会被输出。</p>
<!-- CrazyJavaHandout4/Chapter15/15_8_3/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31e7c09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/31e7c09/" class="post-title-link" itemprop="url">15.8.2 使用对象流实现序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-29 12:39:01" itemprop="dateCreated datePublished" datetime="2019-12-29T12:39:01+08:00">2019-12-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31e7c09/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31e7c09/" data-xid="/JavaReadingNotes/31e7c09/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-2-使用对象流实现序列化"><a href="#15-8-2-使用对象流实现序列化" class="headerlink" title="15.8.2 使用对象流实现序列化"></a>15.8.2 使用对象流实现序列化</h1><p>如果需要将某个对象保存到磁盘上或者通过网络传输,那么这个类应该实现<code>Serializable</code>接口或者<code>Externalizable</code>接口之一。关于这两个接口的区别和联系,后面将有更详细的介绍,读者先不去理会<code>Externalizable</code>接口。<br>使用<code>Serializable</code>来实现序列化非常简单,主要让目标类实现<code>Serializable</code>标记接口即可,无须实现任何方法.</p>
<h2 id="序列化对象步骤"><a href="#序列化对象步骤" class="headerlink" title="序列化对象步骤"></a>序列化对象步骤</h2><p>一旦某个类实现了<code>Serializable</code>接口,该类的对象就是可序列化的,程序可以通过如下两个步骤来序列化该对象。</p>
<h3 id="1-创建objectOutputStream"><a href="#1-创建objectOutputStream" class="headerlink" title="1. 创建objectOutputStream"></a>1. 创建objectOutputStream</h3><p>创建一个<code>ObjectorOutputStream</code>,这个输出流是一个<strong>处理流</strong>,所以必须建立在其他节点流的基础之上。如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建个 Objectoutputstream输出流</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">    <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="2-调用writeObject方法"><a href="#2-调用writeObject方法" class="headerlink" title="2. 调用writeObject方法"></a>2. 调用writeObject方法</h3><p>调用<code>ObjectOutputStream</code>对象的<code>writeObject</code>方法输出可序列化对象,如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个 Person对象输出到输出流中</span></span><br><span class="line">oos.writeObject(person);</span><br></pre></td></tr></table></figure>

<h2 id="程序-对象序列化"><a href="#程序-对象序列化" class="headerlink" title="程序 对象序列化"></a>程序 对象序列化</h2><p>下面程序定义了一个<code>Person</code>类,这个<code>Person</code>类就是一个普通的<code>Java</code>类,只是实现了<code>Serializable</code>接口,该接口标识该类的对象是可序列化的。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3069227031912694124L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面程序使用<code>ObjectOutputStream</code>将一个<code>Person</code>对象写入磁盘文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">            ObjectOutputStream oos = </span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.txt&quot;</span>))<span class="comment">// 1号代码</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            Person per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 将per对象写入输出流</span></span><br><span class="line">            oos.writeObject(per);<span class="comment">// 2号代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<strong>1号代码</strong>创建了一个<code>ObjectOutputStream</code>输出流,这个<code>ObjectOutputStream</code>输出流建立在一个文件输出流的基础之上;<br>程序中的<strong>2号代码</strong>使用<code>writeObject()</code>方法将一个<code>Person</code>对象写入输出流。</p>
<p><strong>运行上面程序</strong>,将会看到生成了一个<code>object.txt</code>文件,该文件的内容就是<code>Person</code>对象.</p>
<h2 id="对象反序列化步骤"><a href="#对象反序列化步骤" class="headerlink" title="对象反序列化步骤"></a>对象反序列化步骤</h2><p>如果希望从二进制流中恢复<code>Java</code>对象,则需要使用反序列化。反序列化的步骤如下。</p>
<h3 id="1-创建ObjectInputStream"><a href="#1-创建ObjectInputStream" class="headerlink" title="1. 创建ObjectInputStream"></a>1. 创建ObjectInputStream</h3><p>这个输入流是一个<strong>处理流</strong>,所以必须建立在其他节点流的基础之上。如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ObjectInputstream输入流</span></span><br><span class="line">ObjectInputstream ois=<span class="keyword">new</span> ObjectInputstream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="2-调用readObject方法"><a href="#2-调用readObject方法" class="headerlink" title="2. 调用readObject方法"></a>2. 调用readObject方法</h3><p>调用<code>ObjectInputStream</code>对象的<code>readObject()</code>方法读取流中的对象,该方法返回一个<code>Object</code>类型的<code>Java</code>对象,如果程序知道该<code>Java</code>对象的类型,则可以<strong>将该对象强制类型转换成其真实的类型</strong>。如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从输入流中读取一个Java对象,并将其强制类型转换为 Person类</span></span><br><span class="line">Person p = (Person)ois.readObject();</span><br></pre></td></tr></table></figure>

<h2 id="程序-对象反序列化"><a href="#程序-对象反序列化" class="headerlink" title="程序 对象反序列化"></a>程序 对象反序列化</h2><p>下面程序示范了从刚刚生成的<code>object.txt</code>文件中读取<code>Person</code>对象的步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                <span class="comment">// 1号代码</span></span><br><span class="line">                ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span></span><br><span class="line">            <span class="comment">// 2号代码</span></span><br><span class="line">            Person p = (Person) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName() + <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中<strong>1号代码</strong>将一个文件输入流包装成<code>ObjectInputStream</code>输入流,<br><strong>2号代码</strong>使用<code>readObject()</code>方法读取了文件中的<code>Java</code>对象,这就完成了反序列化过程。<br>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字为：孙悟空</span><br><span class="line">年龄为：500</span><br></pre></td></tr></table></figure>
<h2 id="反序列化只能恢复对象的数据"><a href="#反序列化只能恢复对象的数据" class="headerlink" title="反序列化只能恢复对象的数据"></a>反序列化只能恢复对象的数据</h2><p>必须指出的是,<strong>反序列化读取的仅仅是<code>Java</code>对象的数据</strong>,而不是<code>Java</code>类,因此<strong>采用反序列化恢复<code>Java</code>对象时,必须提供该<code>Java</code>对象所属类的<code>class</code>文件,否则将会引发<code>ClassNotFoundException</code>异常</strong>。<br>在<code>ObjectInputStream</code>输入流中的<code>readObject()</code>方法声明抛出了<code>ClassNotFoundException</code>异常,也就是说,当反序列化时找不到对应的<code>Java</code>类时将会引发该异常。</p>
<h2 id="反序列化不会调用构造器"><a href="#反序列化不会调用构造器" class="headerlink" title="反序列化不会调用构造器"></a>反序列化不会调用构造器</h2><p>还有一点需要指出:<code>Person</code>类只有一个有参数的构造器,没有无参数的构造器,而且该构造器内有个普通的打印语句。当反序列化读取<code>Java</code>对象时,并没有看到程序调用该构造器,这表明<strong>反序列化机制无须通过构造器来初始化<code>Java</code>对象</strong>。</p>
<h2 id="反序列化读取对象时要按序列化时的写入的顺序读取"><a href="#反序列化读取对象时要按序列化时的写入的顺序读取" class="headerlink" title="反序列化读取对象时要按序列化时的写入的顺序读取"></a>反序列化读取对象时要按序列化时的写入的顺序读取</h2><p>如果使用序列化机制向文件中写入了多个<code>Java</code>对象,使用反序列化机制恢复对象时必须按实际写入的顺序读取</p>
<h2 id="可序列化类的祖先类要满足的条件"><a href="#可序列化类的祖先类要满足的条件" class="headerlink" title="可序列化类的祖先类要满足的条件"></a>可序列化类的祖先类要满足的条件</h2><p>当一个可序列化类有多个父类时(包括直接父类和间接父类),这些<strong>父类要么有无参数的构造器,要么也是可序列化的</strong>——否则反序列化时将抛出<code>InvalidClassException</code>异常。</p>
<p><strong>如果父类是不可序列化的,只是带有无参数的构造器,则该<mark>父类中定义的成员变量值</mark>不会序列化到二进制流中</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/da4c1ea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/da4c1ea/" class="post-title-link" itemprop="url">15.8 Java9改进的对象序列化 15.8.1 序列化的含义和意义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-28 10:46:59" itemprop="dateCreated datePublished" datetime="2019-12-28T10:46:59+08:00">2019-12-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/da4c1ea/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/da4c1ea/" data-xid="/JavaReadingNotes/da4c1ea/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-Java9改进的对象序列化"><a href="#15-8-Java9改进的对象序列化" class="headerlink" title="15.8 Java9改进的对象序列化"></a>15.8 Java9改进的对象序列化</h1><h2 id="保存对象或者传输对象"><a href="#保存对象或者传输对象" class="headerlink" title="保存对象或者传输对象"></a>保存对象或者传输对象</h2><p><strong>对象序列化的目标是将对象保存到磁盘中,或允许在网络中直接传输对象</strong>。<br>对象序列化机制允许把内存中的<code>Java</code>对象转换成平台无关的二进制流,从而允许把这种二进制流持久地保存在磁盘上,通过网络将这种二进制流传输到另一个网络节点。其他程序一旦获得了这种二进制流(无论是从磁盘中获取的,还是通过网络获取的),都可以将这种二进制流恢复成原来的<code>Java</code>对象。</p>
<h1 id="15-8-1-序列化的含义和意义"><a href="#15-8-1-序列化的含义和意义" class="headerlink" title="15.8.1 序列化的含义和意义"></a>15.8.1 序列化的含义和意义</h1><h2 id="对象可以脱离程序的运行而独立存在"><a href="#对象可以脱离程序的运行而独立存在" class="headerlink" title="对象可以脱离程序的运行而独立存在"></a>对象可以脱离程序的运行而独立存在</h2><p>序列化机制允许将实现序列化的**<code>Java</code>对象** 转换成 <strong>字节序列</strong>,这些字节序列可以保存在磁盘上,或通过网络传输,以备以后重新恢复成原来的对象，序列化机制<strong>使得对象可以脱离程序的运行而独立存在</strong>。</p>
<ul>
<li>对象的序列化(<code>Serialize</code>)指将一个<code>Java</code>对象写入<code>IO</code>流中,</li>
<li>对象的反序列化(<code>Deserialize</code>)则指从<code>IO</code>流中恢复该<code>Java</code>对象.</li>
</ul>
<h2 id="Java9可以过滤读入的序列化数据"><a href="#Java9可以过滤读入的序列化数据" class="headerlink" title="Java9可以过滤读入的序列化数据"></a>Java9可以过滤读入的序列化数据</h2><p><code>Java9</code>增强了对象序列化机制,它允许对读入的序列化数据进行过滤,这种过滤可在反序列化之前对数据执行校验,从而提高安全性和健壮性。</p>
<h2 id="可序列化的类"><a href="#可序列化的类" class="headerlink" title="可序列化的类"></a>可序列化的类</h2><p>如果需要让某个对象支持序列化机制,则必须让它的类是可序列化的(<code>serializable</code>)。<strong>为了让某个类是可序列化的,该类必须实现如下两个接口之一</strong></p>
<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
<h2 id="无须实现Serializable接口方法"><a href="#无须实现Serializable接口方法" class="headerlink" title="无须实现Serializable接口方法"></a>无须实现Serializable接口方法</h2><p><code>Java</code>的很多类已经实现了<code>Serializable</code>,该接口是一个标记接口,<strong>实现该接口无须实现任何方法</strong>,它只是表明该类的实例是可序列化的。</p>
<h2 id="可序列化的类才可以保存到磁盘中-才可以在网络上传输"><a href="#可序列化的类才可以保存到磁盘中-才可以在网络上传输" class="headerlink" title="可序列化的类才可以保存到磁盘中 才可以在网络上传输"></a>可序列化的类才可以保存到磁盘中 才可以在网络上传输</h2><p><strong>所有可能在网络上传输的对象的类都应该是可序列化的</strong>,否则程序将会出现异常,比如<code>RMI</code>(<code>Remote method Invoke</code>,即远程方法调用,是<code>Java EE</code>的基础)过程中的参数和返回值;<br><strong>所有需要保存到磁盘里的对象的类都必须可序列化</strong>,比如<code>Web</code>应用中需要保存到<code>HttpSession</code>或<code>ServletContext</code>属性的<code>Java</code>对象。</p>
<h2 id="建议每个JavaBean类都实现Serializable"><a href="#建议每个JavaBean类都实现Serializable" class="headerlink" title="建议每个JavaBean类都实现Serializable"></a>建议每个JavaBean类都实现Serializable</h2><p>因为序列化是<code>RMI</code>过程的参数和返回值都必须实现的机制,而<code>RMI</code>又是<code>Java EE</code>技术的基础所有的分布式应用常常需要跨平台、跨网络,所以要求所有传递的参数、返回值必须实现序列化。因此序列化机制是<code>Java EE</code>平台的基础。通常建议:<strong>程序创建的每个<code>JavaBean</code>类都实现<code>Serializable</code></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/86/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/86/">86</a><span class="page-number current">87</span><a class="page-number" href="/JavaReadingNotes/page/88/">88</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/88/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/87/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/87/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
