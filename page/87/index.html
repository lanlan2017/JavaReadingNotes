<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/87/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/87/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/87/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/32004866/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/32004866/" class="post-title-link" itemprop="url">15.9 NIO 15.9.1 Java新IO概述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-06 03:41:44" itemprop="dateCreated datePublished" datetime="2020-01-06T03:41:44+08:00">2020-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-9-NIO/" itemprop="url" rel="index"><span itemprop="name">15.9 NIO</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/32004866/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/32004866/" data-xid="/JavaReadingNotes/32004866/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-9-NIO-15-9-1-Java新IO概述"><a href="#15-9-NIO-15-9-1-Java新IO概述" class="headerlink" title="15.9 NIO 15.9.1 Java新IO概述"></a>15.9 NIO 15.9.1 Java新IO概述</h1><h2 id="旧IO"><a href="#旧IO" class="headerlink" title="旧IO"></a>旧IO</h2><h3 id="旧IO阻塞"><a href="#旧IO阻塞" class="headerlink" title="旧IO阻塞"></a>旧IO阻塞</h3><p>前面介绍<code>BufferedReader</code>时提到它的一个特征—当<code>BufferedReader</code>读取输入流中的数据时,如果没有读到有效数据,程序将在此处阻塞该线程的执行(使用<code>InputStream</code>的<code>read()</code>方法从流中读取数据时,如果数据源中没有数据,它也会阻塞该线程),<strong>也就是前面介绍的输入流、输出流都是阻塞式的输入、输出</strong>。</p>
<h3 id="旧IO一次只能处理一个字节"><a href="#旧IO一次只能处理一个字节" class="headerlink" title="旧IO一次只能处理一个字节"></a>旧IO一次只能处理一个字节</h3><p>不仅如此,传统的输入流、输出流都是通过字节的移动来处理的(即使不直接去处理字节流,但底层的实现还是依赖于字节处理),也就是说,<strong>面向流的输入输出系统一次只能处理一个字节,因此面向流的输入输出系统通常效率不高</strong>。</p>
<h2 id="新IO"><a href="#新IO" class="headerlink" title="新IO"></a>新IO</h2><p>从<code>JDK1.4</code>开始,<code>Java</code>提供了一系列改进的输入输出处理的新功能,这些功能被统称为<code>新IO</code>(<code>New IO</code>,简称<code>NIO</code>),新增了许多用于处理输入输出的类,这些类都被放在<code>java.nio</code>包以及子包下,并且<strong>对原<code>java.io</code>包中的很多类都以<code>NIO</code>为基础进行了改写,新增了满足<code>NIO</code>的功能</strong>。</p>
<h1 id="15-9-1-Java新IO概述"><a href="#15-9-1-Java新IO概述" class="headerlink" title="15.9.1 Java新IO概述"></a>15.9.1 Java新IO概述</h1><p>新<code>IO</code>和传统的<code>IO</code>有相同的目的,都是用于进行输入输出,但新<code>IO</code>使用了不同的方式来处理输入&#x2F;输出。</p>
<h2 id="内存映射文件方式"><a href="#内存映射文件方式" class="headerlink" title="内存映射文件方式"></a>内存映射文件方式</h2><p><strong>新<code>IO</code>采用<mark>内存映射文件</mark>的方式来处理输入&#x2F;输出</strong>,新<code>IO</code>模拟了操作系统上的虚拟内存的概念:<strong>将文件或文件的一段区域映射到内存中,这样就可以像访问内存一样来访问文件了</strong>,通过这种方式来进行输入输出比传统的输入输出要快得多。</p>
<h2 id="NIO相关包"><a href="#NIO相关包" class="headerlink" title="NIO相关包"></a>NIO相关包</h2><p><code>Java</code>中与新<code>IO</code>相关的包如下:</p>
<table>
<thead>
<tr>
<th align="left">新<code>IO</code>相关的包</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>java.nio</code>包</td>
<td align="left">主要包含各种与<code>Buffer</code>相关的类</td>
</tr>
<tr>
<td align="left"><code>java.nio.channels</code>包</td>
<td align="left">主要包含与<code>Channel</code>和<code>Selector</code>相关的类。</td>
</tr>
<tr>
<td align="left"><code>java.nio.charset</code>包</td>
<td align="left">主要包含与字符集相关的类</td>
</tr>
<tr>
<td align="left"><code>java.nio.channels.spi</code>包</td>
<td align="left">主要包含与<code>Channel</code>相关的服务提供者编程接口。</td>
</tr>
<tr>
<td align="left"><code>java.nio.charset.spi</code>包</td>
<td align="left">包含与字符集相关的服务提供者编程接口。</td>
</tr>
</tbody></table>
<h2 id="Channel简介"><a href="#Channel简介" class="headerlink" title="Channel简介"></a>Channel简介</h2><p><code>Channel</code>(通道)和<code>Buffer</code>(缓冲)是新<code>IO</code>中的两个核心对象,<code>Channel</code>是对传统的输入输出系统的模拟,在新<code>IO</code>系统中所有的数据都需要通过通道传输;<br><code>Channel</code>与传统的<code>InputStream</code>、<code>OutputStream</code>最大的区别在于它提供了一个<code>map()</code>方法,通过该<code>map()</code>方法可以直接将“一块数据”映射到内存中。<br>如果说<strong>传统的输入输出系统是面向<code>流</code>的处理</strong>,则<strong>新<code>IO</code>则是面向<code>块</code>的处理</strong>。</p>
<h2 id="Buffer简介"><a href="#Buffer简介" class="headerlink" title="Buffer简介"></a>Buffer简介</h2><p><code>Buffer</code>可以被理解成一个容器,它的本质是一个数组,<strong>发送到<code>Channel</code>中的所有对象都必须首先放到<code>Buffer</code>中</strong>,而从<code>Channel</code>中读取的数据也必须先放到<code>Buffer</code>中。<br>此处的<code>Buffer</code>有点类似于前面介绍的“竹筒”,但该<code>Buffer</code>既可以像“竹筒”那样一次次去<code>Channel</code>中取水,也允许使用<code>Channel</code>直接将文件的某块数据映射成<code>Buffer</code></p>
<h2 id="Charset和Selector简介"><a href="#Charset和Selector简介" class="headerlink" title="Charset和Selector简介"></a>Charset和Selector简介</h2><p>除<code>Channel</code>和<code>Buffer</code>之外,</p>
<ul>
<li>新<code>IO</code>还提供了<strong>用于将<mark>Unicode字符串</mark>映射成<mark>字节序列</mark>以及<mark>逆映射</mark>操作的<code>Charset</code>类</strong>,</li>
<li>也提供<strong>了用于支持<mark>非阻塞式输入输出</mark>的<code>Selector</code>类</strong>。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/ccf88e22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/ccf88e22/" class="post-title-link" itemprop="url">15.8.7 版本</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-06 02:24:04" itemprop="dateCreated datePublished" datetime="2020-01-06T02:24:04+08:00">2020-01-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/ccf88e22/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/ccf88e22/" data-xid="/JavaReadingNotes/ccf88e22/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-7-版本"><a href="#15-8-7-版本" class="headerlink" title="15.8.7 版本"></a>15.8.7 版本</h1><p>根据前面的介绍可以知道,反序列化<code>Java</code>对象时必须提供该对象的<code>class</code>文件,现在的问题是,随着项目的升级,系统的<code>class</code>文件也会升级,<code>Java</code>如何保证两个<code>class</code>文件的兼容性?</p>
<h2 id="版本serialVersionUID"><a href="#版本serialVersionUID" class="headerlink" title="版本serialVersionUID"></a>版本serialVersionUID</h2><p><code>Java</code>序列化机制允许为序列化类提供一个<code>private static final</code>的<code>serialVersionUID</code>值,该类变量的值用于标识该<code>Java</code>类的序列化版本,也就是说,如果一个类升级后,<strong>只要它的<code>serialVersionUID</code>类变量值保持不变,序列化机制也会把它们当成同一个序列化版本</strong>。<br>分配<code>serialVersionUID</code>类变量的值非常简单,例如下面代码片段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为该类指定一个serialVersionUID类变量值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialversionUID=<span class="number">512L</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在反序列化时确保序列化版本的兼容性,最好在每个要序列化的类中加入<code>private static final long serialVersionUID</code>这个类变量,具体数值自己定义。这样,即使在某个对象被序列化之后,它所对应的类被修改了,该对象也依然可以被正确地反序列化。</p>
<h2 id="不显示指定版本可能造成序列化失败"><a href="#不显示指定版本可能造成序列化失败" class="headerlink" title="不显示指定版本可能造成序列化失败"></a>不显示指定版本可能造成序列化失败</h2><p>如果不显式定义<code>serialversionUID</code>类变量的值,该类变量的值将由<code>JVM</code>根据类的相关信息计算,而修改后的类的计算结果与修改前的类的计算结果往往不同,从而造成对象的反序列化因为类版本不兼容而失败.</p>
<h2 id="使用serialver-exe生成版本"><a href="#使用serialver-exe生成版本" class="headerlink" title="使用serialver.exe生成版本"></a>使用serialver.exe生成版本</h2><p>可以通过<code>JDK</code>安装路径的<code>bin</code>目录下的<code>serialver.exe</code>工具来获得该类的<code>serialVersionUID</code>类变量的值,该命令帮助文档如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS G:\Desktop\codes\15\15.8\externalizable&gt; serialver</span><br><span class="line">用法: serialver [-classpath 类路径] [-show] [类名称...]</span><br></pre></td></tr></table></figure>
<p><code>serialver</code>依赖于.<code>class</code>文件,所以先编译得到.<code>class</code>文件:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-<span class="number">8</span> Person.java</span><br></pre></td></tr></table></figure>
<p>然后输入命令:</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serialver person</span><br></pre></td></tr></table></figure>
<p>运行该命令,输出结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person: static final long serialVersionUID =-3719034423096421849L;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS G:\Desktop\codes\15\15.8\externalizable&gt; javac -encoding utf-8 Person.java</span><br><span class="line">PS G:\Desktop\codes\15\15.8\externalizable&gt; serialver Person</span><br><span class="line">Person:    private static final long serialVersionUID = -3719034423096421849L;</span><br></pre></td></tr></table></figure>
<p>上面的<code>-3719034423096421849L</code>就是系统为该<code>Person</code>类生成的<code>serialVersionUID</code>类变量的值。如果在运行<code>serialver</code>命令时指定<code>-show</code>选项(不要跟类名参数),即可启动如图15.15所示的图形用户界面。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter15/15_8_7/1.png" alt="这里有一张图片"></p>
<h2 id="不指定版本不利于程序移植"><a href="#不指定版本不利于程序移植" class="headerlink" title="不指定版本不利于程序移植"></a>不指定版本不利于程序移植</h2><p>不显式指定<code>serialVersionUID</code>类变量的值的另一个坏处是,不利于程序在不同的<code>JVM</code>之间移植。因为不同的编译器对该类变量的计算策略可能不同,从而造成虽然类完全没有改变,但是因为<code>JVM</code>不同,也会出现序列化版本不兼容而无法正确反序列化的现象<br>如果类的修改确实会导致该类反序列化失败,则应该为该类的<code>serialVersionUID</code>类变量重新分配值。</p>
<h2 id="类的哪些修改可能导致该类实例的-反序列化失败"><a href="#类的哪些修改可能导致该类实例的-反序列化失败" class="headerlink" title="类的哪些修改可能导致该类实例的 反序列化失败"></a>类的哪些修改可能导致该类实例的 反序列化失败</h2><p>那么对类的哪些修改可能导致该类实例的反序列化失败呢?下面分三种情况来具体讨论</p>
<h3 id="方法的修改-不需要修改版本"><a href="#方法的修改-不需要修改版本" class="headerlink" title="方法的修改 不需要修改版本"></a>方法的修改 不需要修改版本</h3><p>如果修改类时仅仅修改了方法,则反序列化不受任何影响,类定义无须修改<code>serialVersionUID</code>类变量的值。</p>
<h3 id="静态变量和瞬态变量的修改-不需要修改版本"><a href="#静态变量和瞬态变量的修改-不需要修改版本" class="headerlink" title="静态变量和瞬态变量的修改 不需要修改版本"></a>静态变量和瞬态变量的修改 不需要修改版本</h3><p>如果修改类时仅仅修改了静态变量或瞬态实例变量,则反序列化不受任何影响,类定义无须修改<code>serialVersionUID</code>类变量的值。</p>
<h3 id="修改非瞬态实例变量-可能要修改版本"><a href="#修改非瞬态实例变量-可能要修改版本" class="headerlink" title="修改非瞬态实例变量 可能要修改版本"></a>修改非瞬态实例变量 可能要修改版本</h3><ul>
<li>如果修改类时修改了非瞬态的实例变量,则可能导致序列化版本不兼容。<ul>
<li>如果<mark>对象流中的对象</mark>和<mark>新类</mark>中<strong>包含同名的实例变量,而实例变量类型不同</strong>,则反序列化失败,类定义应该更新<code>serialVersionUID</code>类变量的值。(修改实例变量的类型后应该更新版本)</li>
<li>如果<mark>对象流中的对象</mark>比<mark>新类</mark>中<strong>包含更多的实例变量</strong>,则多出的实例变量值被忽略,序列化版本可以兼容,类定义可以不更新<code>serialVersionuID</code>类变量的值(减少实例变量可以不更新版本)</li>
<li>如果<mark>新类</mark>比<mark>对象流中的对象</mark><strong>包含更多的实例变量</strong>,则序列化版本也可以兼容,类定义可以不更新<code>serialversionUID</code>类变量的值;但反序列化得到的新对象中多出的实例变量值都是<code>null</code>(引用类型实例变量)或0(基本类型实例变量)。(增加新的实例变量可以不更新版本)</li>
</ul>
</li>
</ul>
<!-- CrazyJavaHandout4/Chapter15/15_8_7/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/e7c339d4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/e7c339d4/" class="post-title-link" itemprop="url">15.8.6 另一种自定义序列化机制</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-05 10:17:33" itemprop="dateCreated datePublished" datetime="2020-01-05T10:17:33+08:00">2020-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/e7c339d4/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/e7c339d4/" data-xid="/JavaReadingNotes/e7c339d4/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-6-另一种自定义序列化机制"><a href="#15-8-6-另一种自定义序列化机制" class="headerlink" title="15.8.6 另一种自定义序列化机制"></a>15.8.6 另一种自定义序列化机制</h1><p><code>Java</code>还提供了另一种序列化机制,这种序列化方式完全由程序员决定存储和恢复对象数据。要实现该目标,<code>Java</code>类必须实现<code>Externalizable</code>接口。</p>
<h2 id="Externalizable接口"><a href="#Externalizable接口" class="headerlink" title="Externalizable接口"></a>Externalizable接口</h2><p><code>Externalizable</code>接口里定义了如下两个方法。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void writeExternal(ObjectOutput out)</code></td>
<td align="left">需要序列化的类实现这个<code>writeExternal</code>方法来保存对象的状态。<br>该方法<ul><li>调用<code>DataOutput</code>的方法来保存<code>基本类型</code>的实例变量值,</li><li>调用<code>ObjectOutput</code>的<code>writeObject()</code>方法来保存<code>引用类型</code>的实例变量值。</li></ul></td>
</tr>
<tr>
<td align="left"><code>void readExternal(ObjectInput in)</code></td>
<td align="left">需要序列化的类实现这个<code>readExternal()</code>方法来实现反序列化。<br>该方法<ul><li>调用<code>DataInput</code>的方法来恢复<code>基本类型</code>的实例变量值,</li><li>调用<code>ObjectInput</code>的<code>readObject()</code>方法来恢复<code>引用类型</code>的实例变量值。</li></ul></td>
</tr>
</tbody></table>
<ul>
<li><code>DataInput</code>是<code>ObjectInput</code>的父接口</li>
<li><code>DataOutput</code>是<code>ObjectOutput</code>的父接口</li>
</ul>
<h2 id="程序-实现Externalizable接口自定义序列化"><a href="#程序-实现Externalizable接口自定义序列化" class="headerlink" title="程序 实现Externalizable接口自定义序列化"></a>程序 实现<code>Externalizable</code>接口自定义序列化</h2><p>实际上,采用实现<code>Externalizable</code>接口方式的序列化与前面介绍的自定义序列化非常相似,只是**<code>Externalizable</code>接口强制自定义序列化**。<br>下面的<code>Person</code>类实现了<code>Externalizable</code>接口,并且实现了该接口里提供的两个方法,用以实现自定义序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Externalizable &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 注意必须提供无参数的构造器，否则反序列化时会失败。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(java.io.ObjectOutput out)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(java.io.ObjectInput in)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        <span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<code>Person</code>类实现了<code>java.io.Externalizable</code>接口,该<code>Person</code>类还实现了<code>readExternal</code>、<code>writeExternal</code>两个方法,这两个方法除方法签名和<code>readObject</code>、<code>writeObject</code>两个方法的方法签名不同之外,其方法体完全一样。</p>
<h2 id="序列化和反序列化方法相同"><a href="#序列化和反序列化方法相同" class="headerlink" title="序列化和反序列化方法相同"></a>序列化和反序列化方法相同</h2><p>如果程序需要</p>
<ul>
<li>序列化实现<code>Externalizable</code>接口的对象,一样调用<code>ObjectOutputStream</code>的<code>writeObject()</code>方法输出该对象即可;</li>
<li>反序列化实现<code>Externalizable</code>接口的对象,则调用<code>ObjectInputStream</code>的<code>readObject()</code>方法</li>
</ul>
<h2 id="必须提供-public的-无参数构造器"><a href="#必须提供-public的-无参数构造器" class="headerlink" title="必须提供 public的 无参数构造器"></a>必须提供 public的 无参数构造器</h2><p>需要指出的是,当使用<code>Externalizable</code>机制反序列化对象时,程序会先使用<code>public</code>的无参数构造器创建实例,然后才执行<code>readExternal()</code>方法进行反序列化,因此<strong>实现<code>Externalizable</code>的序列化类必须提供<code>public</code>的无参数构造器</strong>。</p>
<h2 id="表15-2两种序列化机制的对比"><a href="#表15-2两种序列化机制的对比" class="headerlink" title="表15.2两种序列化机制的对比"></a>表15.2两种序列化机制的对比</h2><table>
<thead>
<tr>
<th align="left">实现<code>Serializable</code>接口</th>
<th align="left">实现<code>Externalizable</code>接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">系统自动存储必要信息</td>
<td align="left">程序员决定存储哪些信息</td>
</tr>
<tr>
<td align="left"><code>Java</code>内建支持,易于实现,<strong>只需实现该接口即可,无须任何代码支持</strong></td>
<td align="left">仅仅提供两个空方法,<strong>实现该接口必须实现g该接口的两个空方法</strong></td>
</tr>
<tr>
<td align="left">性能略差</td>
<td align="left">性能略好</td>
</tr>
</tbody></table>
<p>虽然实现<code>Externalizable</code>接口能带来一定的性能提升,但由于实现<code>Externalizable</code>接口导致了编程复杂度的增加,所以大部分时候都是采用实现<code>Serializable</code>接口方式来实现序列化。</p>
<h2 id="对象序列化需要注意的地方"><a href="#对象序列化需要注意的地方" class="headerlink" title="对象序列化需要注意的地方"></a>对象序列化需要注意的地方</h2><p>关于对象序列化,还有如下几点需要注意。</p>
<ol>
<li>对象的<strong>类名</strong>、<strong>实例变量</strong>(包括基本类型、数组、对其他对象的引用)都会被序列化;<ol>
<li>方法、类变量(即<code>static</code>修饰的成员变量)、<code>transient</code>实例变量(也被称为瞬态实例变量)都<strong>不会被序列化</strong>。</li>
</ol>
</li>
<li>实现<code>Serializable</code>接口的类<strong>如果需要让某个实例变量不被序列化,则可在该实例变量前加<code>transient</code>修饰符</strong>,而不是加<code>static</code>关键字。虽然<code>static</code>关键字也可达到这个效果,但<code>static</code>关键字不能这样用。</li>
<li>保证序列化对象的实例变量类型也是可序列化的,否则需要使用<code>transient</code>关键字来修饰该实例变量,要不然,该类是不可序列化的。</li>
<li>反序列化对象时必须有序列化对象的<code>class</code>文件。</li>
<li>当通过文件、网络来读取序列化后的对象时,必须按实际写入的顺序读取。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/1c0498d6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/1c0498d6/" class="post-title-link" itemprop="url">15.8.5 自定义序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-03 10:21:52" itemprop="dateCreated datePublished" datetime="2020-01-03T10:21:52+08:00">2020-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/1c0498d6/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/1c0498d6/" data-xid="/JavaReadingNotes/1c0498d6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-5-自定义序列化"><a href="#15-8-5-自定义序列化" class="headerlink" title="15.8.5 自定义序列化"></a>15.8.5 自定义序列化</h1><h2 id="递归序列化"><a href="#递归序列化" class="headerlink" title="递归序列化"></a>递归序列化</h2><ul>
<li>当对某个对象进行序列化时,系统会自动<strong>把该对象的所有<mark>实例变量</mark>依次进行序列化</strong>,<ul>
<li>如果某个实例变量引用到另一个对象,则被引用的对象也会被序列化;<ul>
<li>如果被引用的对象的实例变量也引用了其他对象,则被引用的对象也会被序列化</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这种情况被称为<strong>递归序列化</strong>。</p>
<h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><h3 id="不希望序列化的实例变量的情况"><a href="#不希望序列化的实例变量的情况" class="headerlink" title="不希望序列化的实例变量的情况"></a>不希望序列化的实例变量的情况</h3><p>在一些特殊的场景下,如果一个类里包含的某些实例变量是<strong>敏感信息</strong>,例如银行账户信息等,这时不希望系统将该实例变量值进行序列化;<br>或者某个实例变量的类型是不可序列化的,因此不希望对该实例变量进行递归序列化,以避免引发<code>java.io.NotSerializableException</code>异常。<br><strong>通过在实例变量前面使用<code>transient</code>关键字修饰,可以指定<code>Java</code>序列化时无须理会该实例变量</strong>。<br><strong><code>transient</code>关键字只能用于修饰实例变量,不可修饰<code>Java</code>程序中的其他成分</strong>。</p>
<h3 id="程序-transient关键字修饰实例变量"><a href="#程序-transient关键字修饰实例变量" class="headerlink" title="程序 transient关键字修饰实例变量"></a>程序 transient关键字修饰实例变量</h3><p>如下<code>Person</code>类与前面的<code>Person</code>类几乎完全一样,只是它的<code>age</code>使用了<code>transient</code>关键字修饰。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2595800114629327570L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序-序列化后反序列化-再输出transient修饰的实例变量"><a href="#程序-序列化后反序列化-再输出transient修饰的实例变量" class="headerlink" title="程序 序列化后反序列化 再输出transient修饰的实例变量"></a>程序 序列化后反序列化 再输出transient修饰的实例变量</h3><p>下面程序先序列化一个<code>Person</code>对象,然后再反序列化该<code>Person</code>对象,得到反序列化的<code>Person</code>对象后程序输出该对象的<code>age</code>实例变量值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransientTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;transient.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);<span class="comment">// 代码1</span></span><br><span class="line">            <span class="comment">// 系统会per对象转换字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);<span class="comment">// 代码2</span></span><br><span class="line">            <span class="comment">// 反序列化</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();<span class="comment">// 代码3</span></span><br><span class="line">            System.out.println(p.getAge());<span class="comment">//代码4</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<br><strong>代码1</strong>创建了一个<code>Person</code>对象,并为它的<code>name</code>、<code>age</code>两个实例变量指定了值;<br><strong>代码2</strong>将该<code>Person</code>对象序列化后输出;<br><strong>代码3</strong>从序列化文件中读取该<code>Person</code>对象;<br><strong>代码4</strong>输出该<code>Person</code>对象的<code>age</code>实例变量值。</p>
<p><strong>由于本程序中的<code>Person</code>类的<code>age</code>实例变量使用<code>transient</code>关键字修饰,所以p.getAge()将得到0,而不是500</strong>。</p>
<h3 id="transient关键字的问题"><a href="#transient关键字的问题" class="headerlink" title="transient关键字的问题"></a>transient关键字的问题</h3><p>使用<code>transient</code>关键字修饰实例变量虽然简单、方便,但<strong>被<code>transient</code>修饰的实例变量将被完全隔离在序列化机制之外,这样导致在反序列化恢复<code>Java</code>对象时无法取得该实例变量值</strong>。</p>
<h2 id="自定义序列化机制"><a href="#自定义序列化机制" class="headerlink" title="自定义序列化机制"></a>自定义序列化机制</h2><p><code>Java</code>还提供了一种自定义序列化机制,**通过这种自定义序列化机制<mark>可以让程序控制如何序列化各实例变量</mark>,<mark>甚至完全不序列化某些实例变量</mark>(与使用<code>transient</code>关键字的效果相同)**。</p>
<h3 id="在类中添加特殊的方法"><a href="#在类中添加特殊的方法" class="headerlink" title="在类中添加特殊的方法"></a>在类中添加特殊的方法</h3><p>在序列化和反序列化过程中需要特殊处理的类应该提供如下特殊签名的方法,<strong>这些特殊的方法用以实现自定义序列化。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObjectNoData</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException</span><br></pre></td></tr></table></figure>
<h4 id="writeObject方法"><a href="#writeObject方法" class="headerlink" title="writeObject方法"></a>writeObject方法</h4><p><code>writeObject</code>方法负责写入特定类的实例状态,以便相应的<code>readObject</code>方法可以恢复它。<strong>通过重写该writeObject方法,程序员可以完全获得对序列化机制的控制,可以自主决定哪些实例变量需要序列化,需要怎样序列化</strong>。在默认情况下,该方法会调用<code>out.defaultObject</code>来保存<code>Java</code>对象的各实例变量,从而可以实现序列化<code>Java</code>对象状态的目的</p>
<h4 id="readObject方法"><a href="#readObject方法" class="headerlink" title="readObject方法"></a>readObject方法</h4><p><code>readObject</code>方法负责从流中读取并恢复对象实例变量,<strong>通过重写该readObject方法,程序员可以完全获得对反序列化机制的控制,可以自主决定需要反序列化哪些实例变量,以及如何进行反序列化</strong>。在默认情况下,该方法会调用<code>in default Readobject</code>来恢复<code>Java</code>对象的非瞬态实例变量。在通常情况下,<code>readObject</code>方法与<code>writeObject</code>方法对应,如果<code>writeObject</code>方法中对<code>Java</code>对象的实例变量进行了一些处理,则应该在<code>readObject</code>方法中对其实例变量进行相应的反处理,以便正确恢复该对象。</p>
<h4 id="readObjectNoData方法"><a href="#readObjectNoData方法" class="headerlink" title="readObjectNoData方法"></a>readObjectNoData方法</h4><p>当序列化流不完整时,<code>readObjectNoData</code>方法可以用来正确地初始化反序列化的对象。例如,接收方使用的反序列化类的版本不同于发送方,或者接收方版本扩展的类不是发送方版本扩展的类,或者序列化流被篡改时,系统都会调用<code>readObjectNoData</code>方法来初始化反序列化的对象。</p>
<h3 id="程序-自定义序列化"><a href="#程序-自定义序列化" class="headerlink" title="程序 自定义序列化"></a>程序 自定义序列化</h3><p>下面的<code>Person</code>类提供了<code>writeObject</code>和<code>readObject</code>两个方法,其中<br><code>writeObject</code>方法在保存<code>Person</code>对象时将其<code>name</code>实例变量包装成<code>StringBuffer</code>,并将其字符序列反转后写入;<br>在<code>readObject</code>方法中处理<code>name</code>的策略与此对应——先将读取的数据强制类型转换成<code>StringBuffer</code>,再将其反转后赋给<code>nane</code>实例变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3069227031912694124L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">        out.writeObject(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse());</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">        <span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">        <span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中提供了<code>writeObject</code>和<code>readObject</code>用以实现自定义序列化,对于这个<code>Person</code>类而言,序列化、反序列化<code>Person</code>实例并没有任何区别——区别在于序列化后的对象流,即使有<code>Cracker</code>截获到<code>Person</code>对象流,他看到的<code>name</code>也是加密后的<code>name</code>值,这样就提高了序列化的安全性。<br><code>writeObject</code>方法存储实例变量的顺序应该和<code>readObject</code>方法中恢复实例变量的顺序一致,否则将不能正常恢复该<code>Java</code>对象。<br>对<code>Person</code>对象进行序列化和反序列化的程序与前面程序没有任何区别,故此处不再赘述。</p>
<h2 id="更彻底的自定义序列化方式"><a href="#更彻底的自定义序列化方式" class="headerlink" title="更彻底的自定义序列化方式"></a>更彻底的自定义序列化方式</h2><h3 id="writeReplace方法"><a href="#writeReplace方法" class="headerlink" title="writeReplace方法"></a>writeReplace方法</h3><p>还有一种更彻底的自定义机制,它甚至可以在序列化对象时将该对象替换成其他对象。如果需要实现序列化某个对象时替换该对象,则应为序列化类提供如下特殊方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY-ACCESS-MODIFIER Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br></pre></td></tr></table></figure>
<p>此<code>writeReplace</code>方法将由序列化机制调用,只要该方法存在。因为该方法可以拥有私有(<code>private</code>)受保护的(<code>protected</code>)和包私有(<code>package-private</code>)等访问权限,所以其子类有可能获得该方法。</p>
<h4 id="程序-使用writeReplace方法"><a href="#程序-使用writeReplace方法" class="headerlink" title="程序 使用writeReplace方法"></a>程序 使用writeReplace方法</h4><p>例如下面的<code>Person</code>类提供了<code>writeReplace</code>方法,这样可以在写入<code>Person</code>对象时将该对象替换成<code>ArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略getter和setter方法,请自己补上</span></span><br><span class="line">    <span class="comment">// 重写writeReplace方法，程序在序列化该对象之前，先调用该方法</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(name);</span><br><span class="line">        list.add(age);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Java</code>的序列化机制保证在序列化某个对象之前,先调用该对象的<code>writeReplace</code>方法,如果该方法返回另一个<code>Java</code>对象,则系统转为序列化另一个对象。如下程序表面上是序列化<code>Person</code>对象,但实际上序列化的是<code>ArrayList</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplaceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;replace.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;replace.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 系统将per对象转换字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);<span class="comment">//代码一</span></span><br><span class="line">            <span class="comment">// 反序列化读取得到的是ArrayList</span></span><br><span class="line">            <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> (ArrayList) ois.readObject();<span class="comment">//代码二</span></span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中<strong>代码一</strong>使用<code>writeObject</code>写入了一个<code>Person</code>对象,但<strong>代码二</strong>使用<code>readObject</code>方法返回的实际上是一个<code>ArayList</code>对象,这是因为<code>Person</code>类的<code>writeReplace</code>方法返回了个<code>ArrayList</code>对象,所以序列化机制在序列化<code>Person</code>对象时,实际上是转为序列化<code>ArrayList</code>对象。</p>
<h4 id="先调用writeReplace方法-再调用writeObject方法"><a href="#先调用writeReplace方法-再调用writeObject方法" class="headerlink" title="先调用writeReplace方法 再调用writeObject方法"></a>先调用writeReplace方法 再调用writeObject方法</h4><p>根据上面的介绍,可以知道系统在序列化某个对象之前,会先调用该对象的<code>writeReplace</code>和<code>writeObject</code>两个方法,<strong>系统总是先调用被序列化对象的<code>writeReplace</code>方法,如果该方法返回另一个对象,系统将再次调用另一个对象的<code>writeReplace</code>方法…直到该方法不再返回另一个对象为止,程序最后将调用该对象的<code>writeObject</code>方法来保存该对象的状态</strong>。</p>
<h3 id="readResolve方法"><a href="#readResolve方法" class="headerlink" title="readResolve方法"></a>readResolve方法</h3><p>与<code>writeReplace()</code>方法相对的是,序列化机制里还有一个特殊的方法,它可以实现保护性复制整个对象。这个方法就是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY-ACCESS-MODIFIER Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException;</span><br></pre></td></tr></table></figure>
<p><code>readResolve</code>方法会紧接着<code>readObject</code>之后被调用,<code>readResolve</code>方法的返回值将会代替原来反序列化的对象,而原来<code>readObject</code>反序列化的对象将会被立即丢弃。</p>
<p><strong><code>readResolve()</code>方法在序列化单例类、枚举类时尤其有用</strong>。<br>当然,如果使用<code>Java5</code>提供的<code>enum</code>来定义枚举类,则完全不用担心,程序没有任何问题。</p>
<h4 id="早期枚举类问题"><a href="#早期枚举类问题" class="headerlink" title="早期枚举类问题"></a>早期枚举类问题</h4><p>但如果应用中有早期遗留下来的枚举类,例如下面的<code>Orientation</code>类就是一个枚举类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orientation</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Orientation</span> <span class="variable">HORIZONTAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orientation</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Orientation</span> <span class="variable">VERTICAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orientation</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Orientation</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// // 为枚举类增加readResolve()方法</span></span><br><span class="line">    <span class="comment">// private Object readResolve()throws ObjectStreamException</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if (value == 1)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return HORIZONTAL;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if (value == 2)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         return VERTICAL;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return null;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Java5</code>以前,这种代码是很常见的。<code>Orientation</code>类的构造器私有,程序只有两个<code>Orientation</code>对象,分别通过<code>Orientation</code>的<code>HORIZONTAL</code>和<code>VERTICAL</code>两个常量来引用。但如果让该类实现<code>Serializable</code>接口,则会引发一个问题,如果将一个<code>Orientation. HORIZONTAL</code>值序列化后再读出,如下代码片段所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResolveTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输入流</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;transient.txt&quot;</span>))) &#123;</span><br><span class="line">            oos.writeObject(Orientation.HORIZONTAL);</span><br><span class="line">            <span class="type">Orientation</span> <span class="variable">ori</span> <span class="operator">=</span> (Orientation) ois.readObject();</span><br><span class="line">            System.out.println(ori == Orientation.HORIZONTAL);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**如果立即拿<code>ori</code>和<code>Orientation.HORIZONTAL</code>值进行比较,将会发现返回<code>false</code>**。也就是说,<code>ori</code>是个新的<code>Orientation</code>对象,而不等于<code>Orientation</code>类中的任何枚举值——虽然<code>Orientation</code>的构造器是<code>private</code>的,但反序列化依然可以创建<code>Orientation</code>对象。</p>
<p>前面已经指出,反序列化机制在恢复<code>Java</code>对象时无须调用构造器来初始化<code>Java</code>对象从这个意义上来看,<strong>序列化机制可以用来“克隆”对象</strong>。<br>在这种情况下,可以通过为<code>Orientation</code>类提供一个<code>readResolve()</code>方法来解决该问题,<code>readResolve()</code>方法的返回值将会代替原来反序列化的对象,也就是让反序列化得到的<code>Orientation</code>对象被直接丢弃。<br>下面是为<code>Orientation</code>类提供的<code>readResolve()</code>方法(程序清单同上)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为枚举类增加readResolve()方法</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span><span class="keyword">throws</span> ObjectStreamException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> HORIZONTAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> VERTICAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重写<code>readResolve()</code>方法可以保证反序列化得到的依然是<code>Orientation</code>的<code>HORIZONTAL</code>或<code>VERTICAL</code>两个枚举值之一。</p>
<h4 id="单例类-枚举类都应该提供readResolve方法"><a href="#单例类-枚举类都应该提供readResolve方法" class="headerlink" title="单例类 枚举类都应该提供readResolve方法"></a>单例类 枚举类都应该提供readResolve方法</h4><p><strong>所有的单例类、枚举类在实现序列化时都应该提供<code>readResolve()</code>方法,这样才可以保证反序列化的对象依然正常</strong>。</p>
<h4 id="readResolve方法需要注意的问题"><a href="#readResolve方法需要注意的问题" class="headerlink" title="readResolve方法需要注意的问题"></a>readResolve方法需要注意的问题</h4><p>与<code>writeReplace()</code>方法类似的是,<code>readResolve()</code>方法也可以使用任意的访问控制符,因此父类的<code>readResolve()</code>方法可能被其子类继承。这样利用<code>readResolve()</code>方法时就会存在一个明显的缺点,就是当父类已经实现了<code>readResolve()</code>方法后,子类将变得无从下手。如果父类包含一个<code>protected</code>或<code>public</code>的<code>readResolve</code>方法,而且子类也没有重写该方法,将会使得子类反序列化时得到一个父类的对象——这显然不是程序要的结果,而且也不容易发现这种错误。<br>总是让子类重写<code>readResolve()</code>方法无疑是一个负担,因此对于要被作为父类继承的类而言,实现<code>readResolve(()</code>方法可能有一些潜在的危险。<br>通常的建议是:</p>
<ul>
<li>对于<code>final</code>类,重写<code>readResolve()</code>方法不会有任何问题;</li>
<li>否则,重写<code>readResolve()</code>方法时应尽量使用<code>private</code>修饰该方法。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8cec0944/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8cec0944/" class="post-title-link" itemprop="url">15.8.4 Java9增加的过滤功能</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-03 10:00:35" itemprop="dateCreated datePublished" datetime="2020-01-03T10:00:35+08:00">2020-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8cec0944/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8cec0944/" data-xid="/JavaReadingNotes/8cec0944/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-4-Java9增加的过滤功能"><a href="#15-8-4-Java9增加的过滤功能" class="headerlink" title="15.8.4 Java9增加的过滤功能"></a>15.8.4 Java9增加的过滤功能</h1><p><code>Java9</code>为<code>ObjectInputStream</code>增加了<code>setObjectInputFilter()</code>、<code>getObjectInputFilter()</code>两个方法:</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void setObjectInputFilter(ObjectInputFilter filter)</code></td>
<td align="left">Set the serialization filter for the stream.</td>
</tr>
<tr>
<td align="left"><code>ObjectInputFilter getObjectInputFilter()</code></td>
<td align="left">Returns the serialization filter for this stream.</td>
</tr>
</tbody></table>
<p>其中<code>setObjectInputFilter</code>方法用于为对象输入流设置<strong>过滤器</strong>。</p>
<h2 id="反序列化时-过滤器ObjectInputFilter的checkInput方法会自动触发"><a href="#反序列化时-过滤器ObjectInputFilter的checkInput方法会自动触发" class="headerlink" title="反序列化时 过滤器ObjectInputFilter的checkInput方法会自动触发"></a>反序列化时 过滤器ObjectInputFilter的checkInput方法会自动触发</h2><p><strong>当程序通过<code>ObjectInputStream</code>反序列化对象时,过滤器的<code>checkInput()</code>方法会被自动激发,用于检查序列化数据是否有效</strong>。</p>
<h2 id="ObjectInputFilter是函数式接口"><a href="#ObjectInputFilter是函数式接口" class="headerlink" title="ObjectInputFilter是函数式接口"></a>ObjectInputFilter是函数式接口</h2><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ObjectInputFilter.Status checkInput(ObjectInputFilter.FilterInfo filterInfo)</code></td>
<td align="left">Check the class, array length, number of object references, depth, stream size, and other available filtering information.</td>
</tr>
</tbody></table>
<h2 id="checkInput方法返回值"><a href="#checkInput方法返回值" class="headerlink" title="checkInput方法返回值"></a>checkInput方法返回值</h2><p>使用<code>checkInput()</code>方法检查序列化数据时有3种返回值。</p>
<table>
<thead>
<tr>
<th align="left"><code>checkInput()</code>方法返回值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ObjectInputFilter.Status.REJECTED</code></td>
<td align="left">拒绝恢复</td>
</tr>
<tr>
<td align="left"><code>ObjectInputFilter.Status.ALLOWED</code></td>
<td align="left">允许恢复</td>
</tr>
<tr>
<td align="left"><code>ObjectInputFilter.Status.UNDECIDED</code></td>
<td align="left">未决定状态,程序继续执行检查</td>
</tr>
</tbody></table>
<p><code>ObjectInputStream</code>将会根据<code>ObjectInputFilter</code>的检查结果来决定是否执行反序列化:</p>
<ul>
<li>如果<code>checkInput</code>方法返回<code>Status.REJECtED</code>,反序列化将会被阻止;</li>
<li>如果<code>checkInput</code>方法返回<code>Status.ALLOWED</code>,程序将可执行反序列化;</li>
</ul>
<h2 id="程序-反序列化之前先检查数据"><a href="#程序-反序列化之前先检查数据" class="headerlink" title="程序 反序列化之前先检查数据"></a>程序 反序列化之前先检查数据</h2><p>下面程序对前的<code>ReadObject.java</code>程序进行改进,该程序将会在反序列化之前对数据执行检查。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>))) </span><br><span class="line">        &#123;</span><br><span class="line">            ois.setObjectInputFilter((info) -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;===执行数据过滤===&quot;</span>);</span><br><span class="line">                <span class="type">ObjectInputFilter</span> <span class="variable">serialFilter</span> <span class="operator">=</span> ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">                <span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 首先使用ObjectInputFilter执行默认的检查</span></span><br><span class="line">                    ObjectInputFilter.<span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> serialFilter.checkInput(info);</span><br><span class="line">                    <span class="comment">// 如果默认检查的结果不是Status.UNDECIDED</span></span><br><span class="line">                    <span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">                        <span class="comment">// 直接返回检查结果</span></span><br><span class="line">                        <span class="keyword">return</span> status;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果要恢复的对象不是1个</span></span><br><span class="line">                <span class="keyword">if</span> (info.references() != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不允许恢复对象</span></span><br><span class="line">                    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果恢复的不是Person类</span></span><br><span class="line">                <span class="keyword">if</span> (info.serialClass() != <span class="literal">null</span> &amp;&amp; info.serialClass() != Person.class) &#123;</span><br><span class="line">                    <span class="comment">// 不允许恢复对象</span></span><br><span class="line">                    <span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName() + <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的粗体字代码为<code>ObjectInputStream</code>设置了<code>ObjectInputFilter</code>过滤器(程序使用<code>Lambda</code>表达式创建过滤器),程序重写了<code>checkInput</code>方法。<br>重写<code>checkInput</code>方法时先使用默认的<code>ObjectInputFilter</code>执行检查,</p>
<ul>
<li>如果检查结果不是<code>Status.UNDECIDED</code>,程序直接返回检查结果。</li>
<li>接下来程序通过<code>FilterInfo</code>检验序列化数据,<ul>
<li>如果序列化数据中的对象不唯一(数据已被污染),程序拒绝执行反序列化;</li>
<li>如果序列化数据中的对象不是<code>Person</code>对象(数据被污染),程序拒绝执行反序列化。</li>
</ul>
</li>
</ul>
<p><strong>通过这种检查,程序可以保证反序列化出来的是唯一的<code>Person</code>对象,这样就让反序列化更加安全、健壮</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a9bda96a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a9bda96a/" class="post-title-link" itemprop="url">15.8.3 对象引用的序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-02 04:17:56" itemprop="dateCreated datePublished" datetime="2020-01-02T04:17:56+08:00">2020-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a9bda96a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a9bda96a/" data-xid="/JavaReadingNotes/a9bda96a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-3-对象引用的序列化"><a href="#15-8-3-对象引用的序列化" class="headerlink" title="15.8.3 对象引用的序列化"></a>15.8.3 对象引用的序列化</h1><h2 id="可序列化类-的成员变量-的类型必须可序列化"><a href="#可序列化类-的成员变量-的类型必须可序列化" class="headerlink" title="可序列化类 的成员变量 的类型必须可序列化"></a>可序列化类 的成员变量 的类型必须可序列化</h2><p>前面介绍的<code>Person</code>类的两个成员变量分别是<code>String</code>类型和<code>int</code>类型,<strong>如果某个类的成员变量的类型不是基本类型或<code>String</code>类型,而是另一个引用类型,那么这个引用类必须是可序列化的,否则拥有该类型成员变量的类也是不可序列化的</strong>。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>如下<code>Teacher</code>类持有一个<code>Person</code>类的引用,只有<code>Person</code>类是可序列化的,<code>Teacher</code>类才是可序列化的。如果<code>Person</code>类不可序列化,不管<code>Teacher</code>类是否实现<code>Sterilizable</code>或<code>Externalizable</code>接口,<code>Teacher</code>类都是不可序列化的。<br>这是因为当程序序列化一个<code>Teacher</code>对象时,<strong>如果该<code>Teacher</code>对象持有一个<code>Person</code>对象的引用为了在反序列化时可以正常恢复该<code>Teacher</code>对象,程序会顺带将该<code>Person</code>对象也进行序列化</strong>,所以<code>Person</code>类也必须是可序列化的,否则<code>Teacher</code>类将不可序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">1184339136873829552L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Person student;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">(String name, Person student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处省略了name和student的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个对象可能被多次序列化的情况"><a href="#一个对象可能被多次序列化的情况" class="headerlink" title="一个对象可能被多次序列化的情况"></a>一个对象可能被多次序列化的情况</h2><p>现在假设有如下一种特殊情形:<br>程序中有两个<code>Teacher</code>对象,它们的<code>Student</code>实例变量都引用到同个<code>Person</code>对象,而且该<code>Person</code>对象还有一个引用变量引用它。如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person per= <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">500</span>);</span><br><span class="line">Teacher t1= <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;唐僧&quot;</span>,per);</span><br><span class="line">Teacher t2= <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;菩提祖师&quot;</span>,per);</span><br></pre></td></tr></table></figure>
<p>上面代码创建了两个<code>Teacher</code>对象和一个<code>Person</code>对象,这三个对象在内存中的存储示意图如图15.13所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter15/15_8_3/1.png" alt="这里有一张图片"></p>
<p>这里产生了一个问题:</p>
<ul>
<li>如果先序列化<code>t1</code>对象,则系统将该<code>t1</code>对象所引用的<code>Person</code>对象一起序列化;<ul>
<li>如果程序再序列化<code>t2</code>对象,系统将一样会序列化该<code>t2</code>对象,并且将再次序列化该<code>t2</code>对象所引用的<code>Person</code>对象;<ul>
<li>如果程序再显式序列化<code>per</code>对象,系统将再次序列化该<code>Person</code>对象。<ul>
<li>这个过程似乎会向输出流中输出三个<code>Person</code>对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果系统向输出流中写入了三个<code>Person</code>对象,那么后果是当程序从输入流中反序列化这些对象时,将会得到三个<code>Person</code>对象,从而引起<code>t1</code>和<code>t2</code>所引用的<code>Person</code>对象不是同一个对象,这显然与图5.13所示的效果不一致——这也就违背了<code>Java</code>序列化机制的初衷。</p>
<h2 id="Java序列化机制"><a href="#Java序列化机制" class="headerlink" title="Java序列化机制"></a>Java序列化机制</h2><p>所以,<code>Java</code>序列化机制采用了一种特殊的序列化算法,其算法内容如下。</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号。</li>
<li>当程序试图序列化一个对象时,程序将先检查该对象是否已经被序列化过,<ul>
<li><strong>只有该对象从未(在本次虚拟机中)被序列化过,系统才会将该对象转换成字节序列并输出</strong>。</li>
<li>如果某个对象已经序列化过,程序将只是直接输出一个序列化编号,而不是再次重新序列化该对象。</li>
</ul>
</li>
</ul>
<p>根据上面的序列化算法,可以得到一个结论:<br>当第二次、第三次序列化<code>Person</code>对象时,程序不会再次将<code>Person</code>对象转换成字节序列并输出,而是仅仅输出一个序列化编号。假设有如下顺序的序列化代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(t1);</span><br><span class="line">oos.writeObject(t2);</span><br><span class="line">oos.writeObject(per);</span><br></pre></td></tr></table></figure>
<p>上面代码依次序列化了<code>t1</code>、<code>t2</code>和<code>per</code>对象,序列化后磁盘文件的存储示意图如图15.14所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/CrazyJavaHandout4/Chapter15/15_8_3/2.png" alt="这里有一张图片"><br>通过图15.14可以很好地理解<code>Java</code>序列化的底层机制,通过该机制不难看出,<strong>当多次调用<code>writeObject()</code>方法输出同一个对象时,只有第一次调用<code>writeObject()</code>方法时才会将该对象转换成字节序列并输出</strong>。</p>
<h2 id="程序-多次写入一个对象"><a href="#程序-多次写入一个对象" class="headerlink" title="程序 多次写入一个对象"></a>程序 多次写入一个对象</h2><p>下面程序序列化了两个<code>Teacher</code>对象,两个<code>Teacher</code>对象都持有一个引用到同一个<code>Person</code>对象的引用,而且程序两次调用<code>writeObject()</code>方法输出同一个<code>Teacher</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteTeacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span></span><br><span class="line">                     <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;唐僧&quot;</span>, per);</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;菩提祖师&quot;</span>, per);</span><br><span class="line">            <span class="comment">// 依次将四个对象写入输出流</span></span><br><span class="line">            oos.writeObject(t1);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            oos.writeObject(t2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中4次调用了<code>writeObject()</code>方法来输出对象,实际上只序列化了三个对象,而且序列的两个<code>Teacher</code>对象的<code>student</code>引用实际是同一个<code>Person</code>对象。</p>
<h2 id="程序-读取被写入多次的对象"><a href="#程序-读取被写入多次的对象" class="headerlink" title="程序 读取被写入多次的对象"></a>程序 读取被写入多次的对象</h2><p>下面程序读取序列化文件中的对象即可证明这一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadTeacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输出流</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;teacher.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 依次读取ObjectInputStream输入流中的四个对象</span></span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> (Teacher) ois.readObject();</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> (Teacher) ois.readObject();</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">            <span class="type">Teacher</span> <span class="variable">t3</span> <span class="operator">=</span> (Teacher) ois.readObject();</span><br><span class="line">            <span class="comment">// 输出true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t1的student引用和p是否相同：&quot;</span> + (t1.getStudent() == p));</span><br><span class="line">            <span class="comment">// 输出true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2的student引用和p是否相同：&quot;</span> + (t2.getStudent() == p));</span><br><span class="line">            <span class="comment">// 输出true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;t2和t3是否是同一个对象：&quot;</span> + (t2 == t3));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1的student引用和p是否相同：true</span><br><span class="line">t2的student引用和p是否相同：true</span><br><span class="line">t2和t3是否是同一个对象：true</span><br></pre></td></tr></table></figure>
<p>上面程序中依次读取了序列化文件中的4个<code>Java</code>对象,但通过后面比较判断,不难发现<code>t2</code>和<code>t3</code>是同一个<code>Java</code>对象,<code>t1</code>的<code>student</code>引用的、<code>t2</code>的<code>student</code>引用的和<code>p</code>引用变量引用的也是同个<code>Java</code>对象——这证明了图15.14所示的序列化机制。</p>
<h2 id="序列化可变对象引起的问题"><a href="#序列化可变对象引起的问题" class="headerlink" title="序列化可变对象引起的问题"></a>序列化可变对象引起的问题</h2><p>由于<code>Java</code>序列化机制使然:如果多次序列化同一个<code>Java</code>对象时,只有第一次序列化时才会把该<code>Java</code>对象转换成字节序列并输出,这样可能引起一个潜在的问题——当程序序列化一个可变对象时,只有第一次使用<code>writeObject()</code>方法输出时才会将该对象转换成字节序列并输出,当程序再次调用<code>writeObject()</code>方法时,程序只是输出前面的序列化编号,<strong>即使后面该对象的实例变量值已被改变,改变的实例变量值也不会被输出</strong>。<br>如下程序所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeMutable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectOutputStream输入流</span></span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;mutable.txt&quot;</span>));</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;mutable.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 系统会per对象转换字节序列并输出</span></span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            <span class="comment">// 改变per对象的name实例变量</span></span><br><span class="line">            per.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line">            <span class="comment">// 系统只是输出序列化编号，所以改变后的name不会被序列化</span></span><br><span class="line">            oos.writeObject(per);</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject(); <span class="comment">// 代码1</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) ois.readObject(); <span class="comment">// 代码2</span></span><br><span class="line">            <span class="comment">// 下面输出true，即反序列化后p1等于p2</span></span><br><span class="line">            System.out.println(p1 == p2);</span><br><span class="line">            <span class="comment">// 下面依然看到输出&quot;孙悟空&quot;，即改变后的实例变量没有被序列化</span></span><br><span class="line">            System.out.println(p2.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序中先使用<code>writeObject()</code>方法写入了一个<code>Person</code>对象,接着程序改变了<code>Person</code>对象的<code>name</code>实例变量值,然后程序再次输出<code>Person</code>对象,但这次的输出已经不会将<code>Person</code>对象转换成字节序列并输出了,而是仅仅输出了一个序列化编号<br>程序中<strong>代码1</strong>,<strong>代码2</strong>两次调用<code>readObject()</code>方法读取了序列化文件中的<code>Java</code>对象,比较两次读取的<code>Java</code>对象将完全相同,程序输岀第二次读取的<code>Person</code>对象的<code>name</code>实例变量的值依然是“孙悟空”,这表明改变后的<code>Person</code>对象并没有被写入,这与<code>Java</code>序列化机制相符。</p>
<h3 id="只有第一次调用wirteObject方法时才会将对象转换成字节序列"><a href="#只有第一次调用wirteObject方法时才会将对象转换成字节序列" class="headerlink" title="只有第一次调用wirteObject方法时才会将对象转换成字节序列"></a>只有第一次调用<code>wirteObject</code>方法时才会将对象转换成字节序列</h3><p>当使用<code>Java</code>序列化机制序列化可变对象时一定要注意,<strong>只有第一次调用<code>wirteObject</code>方法来输出对象时才会将对象转换成字节序列</strong>,并写入到<code>ObjectOutputStream</code>,在后面程序中即使该对象的实例变量发生了改变,再次调用<code>writeObjecto</code>方法输出该对象时,改变后的实例变量也不会被输出。</p>
<!-- CrazyJavaHandout4/Chapter15/15_8_3/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31e7c09/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/31e7c09/" class="post-title-link" itemprop="url">15.8.2 使用对象流实现序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-29 12:39:01" itemprop="dateCreated datePublished" datetime="2019-12-29T12:39:01+08:00">2019-12-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31e7c09/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31e7c09/" data-xid="/JavaReadingNotes/31e7c09/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-2-使用对象流实现序列化"><a href="#15-8-2-使用对象流实现序列化" class="headerlink" title="15.8.2 使用对象流实现序列化"></a>15.8.2 使用对象流实现序列化</h1><p>如果需要将某个对象保存到磁盘上或者通过网络传输,那么这个类应该实现<code>Serializable</code>接口或者<code>Externalizable</code>接口之一。关于这两个接口的区别和联系,后面将有更详细的介绍,读者先不去理会<code>Externalizable</code>接口。<br>使用<code>Serializable</code>来实现序列化非常简单,主要让目标类实现<code>Serializable</code>标记接口即可,无须实现任何方法.</p>
<h2 id="序列化对象步骤"><a href="#序列化对象步骤" class="headerlink" title="序列化对象步骤"></a>序列化对象步骤</h2><p>一旦某个类实现了<code>Serializable</code>接口,该类的对象就是可序列化的,程序可以通过如下两个步骤来序列化该对象。</p>
<h3 id="1-创建objectOutputStream"><a href="#1-创建objectOutputStream" class="headerlink" title="1. 创建objectOutputStream"></a>1. 创建objectOutputStream</h3><p>创建一个<code>ObjectorOutputStream</code>,这个输出流是一个<strong>处理流</strong>,所以必须建立在其他节点流的基础之上。如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建个 Objectoutputstream输出流</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="2-调用writeObject方法"><a href="#2-调用writeObject方法" class="headerlink" title="2. 调用writeObject方法"></a>2. 调用writeObject方法</h3><p>调用<code>ObjectOutputStream</code>对象的<code>writeObject</code>方法输出可序列化对象,如下代码所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个 Person对象输出到输出流中</span></span><br><span class="line">oos.writeObject(person);</span><br></pre></td></tr></table></figure>

<h2 id="程序-对象序列化"><a href="#程序-对象序列化" class="headerlink" title="程序 对象序列化"></a>程序 对象序列化</h2><p>下面程序定义了一个<code>Person</code>类,这个<code>Person</code>类就是一个普通的<code>Java</code>类,只是实现了<code>Serializable</code>接口,该接口标识该类的对象是可序列化的。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3069227031912694124L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面程序使用<code>ObjectOutputStream</code>将一个<code>Person</code>对象写入磁盘文件.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>))<span class="comment">// 1号代码</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">            <span class="comment">// 将per对象写入输出流</span></span><br><span class="line">            oos.writeObject(per);<span class="comment">// 2号代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<strong>1号代码</strong>创建了一个<code>ObjectOutputStream</code>输出流,这个<code>ObjectOutputStream</code>输出流建立在一个文件输出流的基础之上;<br>程序中的<strong>2号代码</strong>使用<code>writeObject()</code>方法将一个<code>Person</code>对象写入输出流。</p>
<p><strong>运行上面程序</strong>,将会看到生成了一个<code>object.txt</code>文件,该文件的内容就是<code>Person</code>对象.</p>
<h2 id="对象反序列化步骤"><a href="#对象反序列化步骤" class="headerlink" title="对象反序列化步骤"></a>对象反序列化步骤</h2><p>如果希望从二进制流中恢复<code>Java</code>对象,则需要使用反序列化。反序列化的步骤如下。</p>
<h3 id="1-创建ObjectInputStream"><a href="#1-创建ObjectInputStream" class="headerlink" title="1. 创建ObjectInputStream"></a>1. 创建ObjectInputStream</h3><p>这个输入流是一个<strong>处理流</strong>,所以必须建立在其他节点流的基础之上。如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ObjectInputstream输入流</span></span><br><span class="line">ObjectInputstream ois=<span class="keyword">new</span> <span class="title class_">ObjectInputstream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="2-调用readObject方法"><a href="#2-调用readObject方法" class="headerlink" title="2. 调用readObject方法"></a>2. 调用readObject方法</h3><p>调用<code>ObjectInputStream</code>对象的<code>readObject()</code>方法读取流中的对象,该方法返回一个<code>Object</code>类型的<code>Java</code>对象,如果程序知道该<code>Java</code>对象的类型,则可以<strong>将该对象强制类型转换成其真实的类型</strong>。如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从输入流中读取一个Java对象,并将其强制类型转换为 Person类</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)ois.readObject();</span><br></pre></td></tr></table></figure>

<h2 id="程序-对象反序列化"><a href="#程序-对象反序列化" class="headerlink" title="程序 对象反序列化"></a>程序 对象反序列化</h2><p>下面程序示范了从刚刚生成的<code>object.txt</code>文件中读取<code>Person</code>对象的步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">                <span class="comment">// 1号代码</span></span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span></span><br><span class="line">            <span class="comment">// 2号代码</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName() + <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中<strong>1号代码</strong>将一个文件输入流包装成<code>ObjectInputStream</code>输入流,<br><strong>2号代码</strong>使用<code>readObject()</code>方法读取了文件中的<code>Java</code>对象,这就完成了反序列化过程。<br>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">名字为：孙悟空</span><br><span class="line">年龄为：500</span><br></pre></td></tr></table></figure>
<h2 id="反序列化只能恢复对象的数据"><a href="#反序列化只能恢复对象的数据" class="headerlink" title="反序列化只能恢复对象的数据"></a>反序列化只能恢复对象的数据</h2><p>必须指出的是,<strong>反序列化读取的仅仅是<code>Java</code>对象的数据</strong>,而不是<code>Java</code>类,因此<strong>采用反序列化恢复<code>Java</code>对象时,必须提供该<code>Java</code>对象所属类的<code>class</code>文件,否则将会引发<code>ClassNotFoundException</code>异常</strong>。<br>在<code>ObjectInputStream</code>输入流中的<code>readObject()</code>方法声明抛出了<code>ClassNotFoundException</code>异常,也就是说,当反序列化时找不到对应的<code>Java</code>类时将会引发该异常。</p>
<h2 id="反序列化不会调用构造器"><a href="#反序列化不会调用构造器" class="headerlink" title="反序列化不会调用构造器"></a>反序列化不会调用构造器</h2><p>还有一点需要指出:<code>Person</code>类只有一个有参数的构造器,没有无参数的构造器,而且该构造器内有个普通的打印语句。当反序列化读取<code>Java</code>对象时,并没有看到程序调用该构造器,这表明<strong>反序列化机制无须通过构造器来初始化<code>Java</code>对象</strong>。</p>
<h2 id="反序列化读取对象时要按序列化时的写入的顺序读取"><a href="#反序列化读取对象时要按序列化时的写入的顺序读取" class="headerlink" title="反序列化读取对象时要按序列化时的写入的顺序读取"></a>反序列化读取对象时要按序列化时的写入的顺序读取</h2><p>如果使用序列化机制向文件中写入了多个<code>Java</code>对象,使用反序列化机制恢复对象时必须按实际写入的顺序读取</p>
<h2 id="可序列化类的祖先类要满足的条件"><a href="#可序列化类的祖先类要满足的条件" class="headerlink" title="可序列化类的祖先类要满足的条件"></a>可序列化类的祖先类要满足的条件</h2><p>当一个可序列化类有多个父类时(包括直接父类和间接父类),这些<strong>父类要么有无参数的构造器,要么也是可序列化的</strong>——否则反序列化时将抛出<code>InvalidClassException</code>异常。</p>
<p><strong>如果父类是不可序列化的,只是带有无参数的构造器,则该<mark>父类中定义的成员变量值</mark>不会序列化到二进制流中</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/da4c1ea/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/da4c1ea/" class="post-title-link" itemprop="url">15.8 Java9改进的对象序列化 15.8.1 序列化的含义和意义</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-28 10:46:59" itemprop="dateCreated datePublished" datetime="2019-12-28T10:46:59+08:00">2019-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-8-Java9%E6%94%B9%E8%BF%9B%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">15.8 Java9改进的对象序列化</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/da4c1ea/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/da4c1ea/" data-xid="/JavaReadingNotes/da4c1ea/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-8-Java9改进的对象序列化"><a href="#15-8-Java9改进的对象序列化" class="headerlink" title="15.8 Java9改进的对象序列化"></a>15.8 Java9改进的对象序列化</h1><h2 id="保存对象或者传输对象"><a href="#保存对象或者传输对象" class="headerlink" title="保存对象或者传输对象"></a>保存对象或者传输对象</h2><p><strong>对象序列化的目标是将对象保存到磁盘中,或允许在网络中直接传输对象</strong>。<br>对象序列化机制允许把内存中的<code>Java</code>对象转换成平台无关的二进制流,从而允许把这种二进制流持久地保存在磁盘上,通过网络将这种二进制流传输到另一个网络节点。其他程序一旦获得了这种二进制流(无论是从磁盘中获取的,还是通过网络获取的),都可以将这种二进制流恢复成原来的<code>Java</code>对象。</p>
<h1 id="15-8-1-序列化的含义和意义"><a href="#15-8-1-序列化的含义和意义" class="headerlink" title="15.8.1 序列化的含义和意义"></a>15.8.1 序列化的含义和意义</h1><h2 id="对象可以脱离程序的运行而独立存在"><a href="#对象可以脱离程序的运行而独立存在" class="headerlink" title="对象可以脱离程序的运行而独立存在"></a>对象可以脱离程序的运行而独立存在</h2><p>序列化机制允许将实现序列化的**<code>Java</code>对象** 转换成 <strong>字节序列</strong>,这些字节序列可以保存在磁盘上,或通过网络传输,以备以后重新恢复成原来的对象，序列化机制<strong>使得对象可以脱离程序的运行而独立存在</strong>。</p>
<ul>
<li>对象的序列化(<code>Serialize</code>)指将一个<code>Java</code>对象写入<code>IO</code>流中,</li>
<li>对象的反序列化(<code>Deserialize</code>)则指从<code>IO</code>流中恢复该<code>Java</code>对象.</li>
</ul>
<h2 id="Java9可以过滤读入的序列化数据"><a href="#Java9可以过滤读入的序列化数据" class="headerlink" title="Java9可以过滤读入的序列化数据"></a>Java9可以过滤读入的序列化数据</h2><p><code>Java9</code>增强了对象序列化机制,它允许对读入的序列化数据进行过滤,这种过滤可在反序列化之前对数据执行校验,从而提高安全性和健壮性。</p>
<h2 id="可序列化的类"><a href="#可序列化的类" class="headerlink" title="可序列化的类"></a>可序列化的类</h2><p>如果需要让某个对象支持序列化机制,则必须让它的类是可序列化的(<code>serializable</code>)。<strong>为了让某个类是可序列化的,该类必须实现如下两个接口之一</strong></p>
<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
<h2 id="无须实现Serializable接口方法"><a href="#无须实现Serializable接口方法" class="headerlink" title="无须实现Serializable接口方法"></a>无须实现Serializable接口方法</h2><p><code>Java</code>的很多类已经实现了<code>Serializable</code>,该接口是一个标记接口,<strong>实现该接口无须实现任何方法</strong>,它只是表明该类的实例是可序列化的。</p>
<h2 id="可序列化的类才可以保存到磁盘中-才可以在网络上传输"><a href="#可序列化的类才可以保存到磁盘中-才可以在网络上传输" class="headerlink" title="可序列化的类才可以保存到磁盘中 才可以在网络上传输"></a>可序列化的类才可以保存到磁盘中 才可以在网络上传输</h2><p><strong>所有可能在网络上传输的对象的类都应该是可序列化的</strong>,否则程序将会出现异常,比如<code>RMI</code>(<code>Remote method Invoke</code>,即远程方法调用,是<code>Java EE</code>的基础)过程中的参数和返回值;<br><strong>所有需要保存到磁盘里的对象的类都必须可序列化</strong>,比如<code>Web</code>应用中需要保存到<code>HttpSession</code>或<code>ServletContext</code>属性的<code>Java</code>对象。</p>
<h2 id="建议每个JavaBean类都实现Serializable"><a href="#建议每个JavaBean类都实现Serializable" class="headerlink" title="建议每个JavaBean类都实现Serializable"></a>建议每个JavaBean类都实现Serializable</h2><p>因为序列化是<code>RMI</code>过程的参数和返回值都必须实现的机制,而<code>RMI</code>又是<code>Java EE</code>技术的基础所有的分布式应用常常需要跨平台、跨网络,所以要求所有传递的参数、返回值必须实现序列化。因此序列化机制是<code>Java EE</code>平台的基础。通常建议:<strong>程序创建的每个<code>JavaBean</code>类都实现<code>Serializable</code></strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8c3461a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8c3461a8/" class="post-title-link" itemprop="url">15.7 RandomAccessFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-28 09:24:23" itemprop="dateCreated datePublished" datetime="2019-12-28T09:24:23+08:00">2019-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-7-RandomAccessFile/" itemprop="url" rel="index"><span itemprop="name">15.7 RandomAccessFile</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8c3461a8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8c3461a8/" data-xid="/JavaReadingNotes/8c3461a8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-7-RandomAccessFile"><a href="#15-7-RandomAccessFile" class="headerlink" title="15.7 RandomAccessFile"></a>15.7 RandomAccessFile</h1><h2 id="RandomAccessFile可读可写"><a href="#RandomAccessFile可读可写" class="headerlink" title="RandomAccessFile可读可写"></a>RandomAccessFile可读可写</h2><p><code>RandomAccessFile</code>是<code>Java</code>输入输出流体系中功能最丰富的文件内容访问类,它提供了众多的方法来访问文件内容,<strong>它既可以读取文件内容,也可以向文件输出数据</strong>。</p>
<h2 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h2><p>与普通的输入&#x2F;输出流不同的是,<strong><code>RandomAccessFile</code>支持“随机访问”的方式,程序可以直接跳转到文件的任意地方来读写数据</strong>。<br>由于<code>RandomAccessFile</code>可以自由访问文件的任意位置,所以<strong>如果只需要访问文件部分内容,而不是把文件从头读到尾,使用<code>RandomAccessFile</code>将是更好的选择</strong>。<br>与<code>OutputStream</code>、<code>Writer</code>等输出流不同的是,<code>RandomAccessFile</code>允许自由定位文件记录指针,<code>RandomAccessFile</code>可以不从开始的地方开始输出,因此<code>RandomAccessFile</code>可以向已存在的文件后追加内容。<strong>如果程序需要向已存在的文件后追加内容,则应该使用<code>RandomAccessFile</code></strong></p>
<h2 id="只能读写文件"><a href="#只能读写文件" class="headerlink" title="只能读写文件"></a>只能读写文件</h2><p><code>RandomAccessFile</code>的方法虽然多,但它有一个最大的局限,就是<strong>只能读写<code>文件</code>,不能读写其他<code>IO</code>节点</strong>。</p>
<h2 id="文件记录指针"><a href="#文件记录指针" class="headerlink" title="文件记录指针"></a>文件记录指针</h2><p><code>RandomAccessFile</code>对象也包含了一个记录指针,用以标识当前读写处的位置,当程序新创建一个<code>RandomAccessFile</code>对象时,该对象的文件记录指针位于<strong>文件头</strong>(也就是0处),当读写了n个字节后,文件记录指针将会向后移动n个字节。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="移动记录指针的方法"><a href="#移动记录指针的方法" class="headerlink" title="移动记录指针的方法"></a>移动记录指针的方法</h3><p>除此之外,<code>RandomAccessFile</code>可以自由移动该记录指针,既可以向前移动,也可以向后移动。<code>RandomAccessFile</code>包含了如下两个方法来操作文件记录指针。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>long getFilePointer()</code></td>
<td align="left">返回文件记录指针的当前位置。</td>
</tr>
<tr>
<td align="left"><code>void seek(long pos)</code></td>
<td align="left">将文件记录指针定位到<code>pos</code>位置</td>
</tr>
</tbody></table>
<h3 id="read方法"><a href="#read方法" class="headerlink" title="read方法"></a>read方法</h3><p><code>RandomAccessFile</code>既可以读文件,也可以写,所以它既包含了完全类似于<code>InputStream</code>的三个<code>read()</code>方法,其用法和<code>InputStream</code>的三个<code>read()</code>方法完全一样;<br>也包含了完全类似于<code>OutputStream</code>的三个<code>write</code>方法,其用法和<code>OutputStream</code>的三个<code>write</code>方法完全一样。<br>除此之外,<code>RandomAccessFile</code>还包含了系列的<code>readXxx()</code>和<code>writeXxx()</code>方法来完成输入、输出。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>int read()</code></td>
<td align="left">Reads a byte of data from this file.</td>
</tr>
<tr>
<td align="left"><code>int read(byte[] b)</code></td>
<td align="left">Reads up to b.length bytes of data from this file into an array of bytes.</td>
</tr>
<tr>
<td align="left"><code>int read(byte[] b, int off, int len)</code></td>
<td align="left">Reads up to len bytes of data from this file into an array of bytes.</td>
</tr>
</tbody></table>
<h3 id="write方法"><a href="#write方法" class="headerlink" title="write方法"></a>write方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void write(int b)</code></td>
<td align="left">Writes the specified byte to this file.</td>
</tr>
<tr>
<td align="left"><code>void write(byte[] b)</code></td>
<td align="left">Writes b.length bytes from the specified byte array to this file, starting at the current file pointer.</td>
</tr>
<tr>
<td align="left"><code>void write(byte[] b, int off, int len)</code></td>
<td align="left">Writes len bytes from the specified byte array starting at offset off to this file.</td>
</tr>
</tbody></table>
<h3 id="readXxx方法"><a href="#readXxx方法" class="headerlink" title="readXxx方法"></a>readXxx方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>boolean readBoolean()</code></td>
<td align="left">Reads a boolean from this file.</td>
</tr>
<tr>
<td align="left"><code>byte readByte()</code></td>
<td align="left">Reads a signed eight-bit value from this file.</td>
</tr>
<tr>
<td align="left"><code>char readChar()</code></td>
<td align="left">Reads a character from this file.</td>
</tr>
<tr>
<td align="left"><code>double readDouble()</code></td>
<td align="left">Reads a double from this file.</td>
</tr>
<tr>
<td align="left"><code>float readFloat()</code></td>
<td align="left">Reads a float from this file.</td>
</tr>
<tr>
<td align="left"><code>void readFully(byte[] b)</code></td>
<td align="left">Reads b.length bytes from this file into the byte array, starting at the current file pointer.</td>
</tr>
<tr>
<td align="left"><code>void readFully(byte[] b, int off, int len)</code></td>
<td align="left">Reads exactly len bytes from this file into the byte array, starting at the current file pointer.</td>
</tr>
<tr>
<td align="left"><code>int readInt()</code></td>
<td align="left">Reads a signed 32-bit integer from this file.</td>
</tr>
<tr>
<td align="left"><code>String readLine()</code></td>
<td align="left">Reads the next line of text from this file.</td>
</tr>
<tr>
<td align="left"><code>long readLong()</code></td>
<td align="left">Reads a signed 64-bit integer from this file.</td>
</tr>
<tr>
<td align="left"><code>short readShort()</code></td>
<td align="left">Reads a signed 16-bit number from this file.</td>
</tr>
<tr>
<td align="left"><code>int readUnsignedByte()</code></td>
<td align="left">Reads an unsigned eight-bit number from this file.</td>
</tr>
<tr>
<td align="left"><code>int readUnsignedShort()</code></td>
<td align="left">Reads an unsigned 16-bit number from this file.</td>
</tr>
<tr>
<td align="left"><code>String readUTF()</code></td>
<td align="left">Reads in a string from this file.</td>
</tr>
</tbody></table>
<h3 id="writeXxx方法"><a href="#writeXxx方法" class="headerlink" title="writeXxx方法"></a>writeXxx方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void writeBoolean(boolean v)</code></td>
<td align="left">Writes a boolean to the file as a one-byte value.</td>
</tr>
<tr>
<td align="left"><code>void writeByte(int v)</code></td>
<td align="left">Writes a byte to the file as a one-byte value.</td>
</tr>
<tr>
<td align="left"><code>void writeBytes(String s)</code></td>
<td align="left">Writes the string to the file as a sequence of bytes.</td>
</tr>
<tr>
<td align="left"><code>void writeChar(int v)</code></td>
<td align="left">Writes a char to the file as a two-byte value, high byte first.</td>
</tr>
<tr>
<td align="left"><code>void writeChars(String s)</code></td>
<td align="left">Writes a string to the file as a sequence of characters.</td>
</tr>
<tr>
<td align="left"><code>void writeDouble(double v)</code></td>
<td align="left">Converts the double argument to a long using the doubleToLongBits method in class Double, and then writes that long value to the file as an eight-byte quantity, high byte first.</td>
</tr>
<tr>
<td align="left"><code>void writeFloat(float v)</code></td>
<td align="left">Converts the float argument to an int using the floatToIntBits method in class Float, and then writes that int value to the file as a four-byte quantity, high byte first.</td>
</tr>
<tr>
<td align="left"><code>void writeInt(int v)</code></td>
<td align="left">Writes an int to the file as four bytes, high byte first.</td>
</tr>
<tr>
<td align="left"><code>void writeLong(long v)</code></td>
<td align="left">Writes a long to the file as eight bytes, high byte first.</td>
</tr>
<tr>
<td align="left"><code>void writeShort(int v)</code></td>
<td align="left">Writes a short to the file as two bytes, high byte first.</td>
</tr>
<tr>
<td align="left"><code>void writeUTF(String str)</code></td>
<td align="left">Writes a string to the file using modified UTF-8 encoding in a machine-independent manner.</td>
</tr>
</tbody></table>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>void close()</code></td>
<td align="left">Closes this random access file stream and releases any system resources associated with the stream.</td>
</tr>
<tr>
<td align="left"><code>FileChannel getChannel()</code></td>
<td align="left">Returns the unique FileChannel object associated with this file.</td>
</tr>
<tr>
<td align="left"><code>FileDescriptor getFD()</code></td>
<td align="left">Returns the opaque file descriptor object associated with this stream.</td>
</tr>
<tr>
<td align="left"><code>long length()</code></td>
<td align="left">Returns the length of this file.</td>
</tr>
<tr>
<td align="left"><code>void setLength(long newLength)</code></td>
<td align="left">Sets the length of this file.</td>
</tr>
<tr>
<td align="left"><code>int skipBytes(int n)</code></td>
<td align="left">Attempts to skip over n bytes of input discarding the skipped bytes.</td>
</tr>
</tbody></table>
<h2 id="随机访问翻译不对"><a href="#随机访问翻译不对" class="headerlink" title="随机访问翻译不对"></a>随机访问翻译不对</h2><p><code>RandomAccessFile</code>的含义是可以自由访问文件的任意地方(与<code>InputStream</code>、<code>Reader</code>需要依次向后读取相区分),所以<code>Random Access File</code>的含义决不是“随机访问”,而应该是“<strong>任意访问</strong>”。</p>
<h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p><code>RandomAccessFile</code>类有两个构造器,其实这两个构造器基本相同,只是指定文件的形式不同而已个使用<code>String</code>参数来指定文件名,一个使用<code>File</code>参数来指定文件本身。</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>RandomAccessFile(File file, String mode)</code></td>
<td align="left">Creates a random access file stream to read from, and optionally to write to, the file specified by the File argument.</td>
</tr>
<tr>
<td align="left"><code>RandomAccessFile(String name, String mode)</code></td>
<td align="left">Creates a random access file stream to read from, and optionally to write to, a file with the specified name.</td>
</tr>
</tbody></table>
<h3 id="mode参数"><a href="#mode参数" class="headerlink" title="mode参数"></a>mode参数</h3><p>除此之外,创建<code>RandomAccessFile</code>对象时还需要指定一个<code>mode</code>参数,该参数指定<code>RandomAccessfile</code>的访问模式,该参数有如下4个值。</p>
<table>
<thead>
<tr>
<th align="left"><code>mode</code>参数值</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“r”</td>
<td align="left">以<strong>只读</strong>方式打开指定文件。如果试图对该<code>RandomAccessFile</code>执行写入方法,都将抛出<code>IOException</code>异常</td>
</tr>
<tr>
<td align="left">“rw”</td>
<td align="left">以<strong>读、写</strong>方式打开指定文件。如果该文件尚不存在,则尝试创建该文件。</td>
</tr>
<tr>
<td align="left">“rwd”</td>
<td align="left">以<strong>读、写</strong>方式打开指定文件。相对于”<code>rw</code>“模式,还要求对<strong>文件<mark>内容</mark>的每个更新都同步写入到底层存储设备</strong>。</td>
</tr>
<tr>
<td align="left">“rws”</td>
<td align="left">以<strong>读、写</strong>方式打开指定文件。相对于”<code>rw</code>“模式,还要求<strong>对文件的<mark>内容</mark>或<mark>元数据</mark>的每个更新都同步写入到底层存储设备</strong>。</td>
</tr>
</tbody></table>
<h2 id="程序-从文件中间读取"><a href="#程序-从文件中间读取" class="headerlink" title="程序 从文件中间读取"></a>程序 从文件中间读取</h2><p>下面程序使用了<code>RandomAccessFile</code>来访问指定的中间部分数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomAccessFileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;RandomAccessFileTest.java&quot;</span>, <span class="string">&quot;r&quot;</span>)<span class="comment">// 代码1</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 获取RandomAccessFile对象文件指针的位置，初始位置是0</span></span><br><span class="line">            System.out.println(<span class="string">&quot;RandomAccessFile的文件指针的初始位置：&quot;</span> + raf.getFilePointer());</span><br><span class="line">            <span class="comment">// 移动raf的文件记录指针的位置</span></span><br><span class="line">            raf.seek(<span class="number">300</span>);<span class="comment">// 代码2</span></span><br><span class="line">            <span class="type">byte</span>[] bbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 用于保存实际读取的字节数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">hasRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 使用循环来重复“取水”过程</span></span><br><span class="line">            <span class="keyword">while</span> ((hasRead = raf.read(bbuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！</span></span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bbuf, <span class="number">0</span>, hasRead));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<strong>代码1</strong>创建了一个<code>RandomAccessFile</code>对象,该对象以只读方式打开了<code>RandomAccessFileTest.java</code>文件,这意味着该<code>RandomAccessFile</code>对象只能读取文件内容,不能执行写入。<br>程序中<strong>代码2</strong>将文件记录指针定位到300处,也就是说,<strong>程序将从300字节处开始读、写</strong>,程序<strong>接下来的部分与使用<code>InputStream</code>读取并没有太大的区别</strong>。<br>运行上面程序,将看到程序只读取后面部分的效果。</p>
<h2 id="程序-在文件末尾追加内容"><a href="#程序-在文件末尾追加内容" class="headerlink" title="程序 在文件末尾追加内容"></a>程序 在文件末尾追加内容</h2><p>下面程序示范了如何向指定文件后追加内容,为了追加内容,程序应该<strong>先将记录指针移动到文件最后,然后开始向文件中输出内容</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppendContent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 以读、写方式打开一个RandomAccessFile对象</span></span><br><span class="line">                <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 将记录指针移动到out.txt文件的最后</span></span><br><span class="line">            raf.seek(raf.length());</span><br><span class="line">            raf.write(<span class="string">&quot;追加的内容！\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中先以读、写方式创建了一个<code>RandomAccessFile</code>对象,然后将<code>RandomAccessFile</code>对象的记录指针移动到最后;接下来使用<code>RandomAccessfile</code>执行输出,与使用<code>OutputStream</code>或<code>Writer</code>执行输出并没有太大区别。<br>每运行上面程序一次,都可以看到<code>out.txt</code>件中多一行“追加的内容!”字符串,程序在该字符串后使用“<code>\r\n</code>”是为了控制换行。</p>
<h2 id="在文件中间插入内容"><a href="#在文件中间插入内容" class="headerlink" title="在文件中间插入内容"></a>在文件中间插入内容</h2><h3 id="直接在中间位置插入内容-会丢失原来中间之后的内容"><a href="#直接在中间位置插入内容-会丢失原来中间之后的内容" class="headerlink" title="直接在中间位置插入内容 会丢失原来中间之后的内容"></a>直接在中间位置插入内容 会丢失原来中间之后的内容</h3><p><code>RandomAccessFile</code>依然不能向文件的指定位置插入内容,<strong>如果直接将文件记录指针移动到中间某位置后开始输出,则新输岀的内容会覆盖文件中原有的内容</strong>。</p>
<h3 id="先缓存中间之后的内容-再插入新内容-最后插入原来中间的内容"><a href="#先缓存中间之后的内容-再插入新内容-最后插入原来中间的内容" class="headerlink" title="先缓存中间之后的内容 再插入新内容 最后插入原来中间的内容"></a>先缓存中间之后的内容 再插入新内容 最后插入原来中间的内容</h3><p>如果需要向指定位置插入内容,程序需要<strong>先把插入点后面的内容读入缓冲区,等把需要插入的数据写入文件后,再将缓冲区的内容追加到文件后面</strong>。</p>
<h3 id="程序-在文件中间插入内容"><a href="#程序-在文件中间插入内容" class="headerlink" title="程序 在文件中间插入内容"></a>程序 在文件中间插入内容</h3><p>下面程序实现了向指定文件、指定位置插入内容的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertContent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String fileName, <span class="type">long</span> pos, String insertContent)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> File.createTempFile(<span class="string">&quot;tmp&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        tmp.deleteOnExit();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(fileName, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">                <span class="comment">// 使用临时文件来保存插入点后的数据</span></span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">tmpOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp);</span><br><span class="line">                <span class="type">FileInputStream</span> <span class="variable">tmpIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(tmp)) &#123;</span><br><span class="line">            raf.seek(pos);</span><br><span class="line">            <span class="comment">// ------下面代码将插入点后的内容读入临时文件中保存------</span></span><br><span class="line">            <span class="type">byte</span>[] bbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>];</span><br><span class="line">            <span class="comment">// 用于保存实际读取的字节数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">hasRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 使用循环方式读取插入点后的数据</span></span><br><span class="line">            <span class="keyword">while</span> ((hasRead = raf.read(bbuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将读取的数据写入临时文件</span></span><br><span class="line">                tmpOut.write(bbuf, <span class="number">0</span>, hasRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ----------下面代码插入内容----------</span></span><br><span class="line">            <span class="comment">// 把文件记录指针重新定位到pos位置</span></span><br><span class="line">            raf.seek(pos);</span><br><span class="line">            <span class="comment">// 追加需要插入的内容,会覆盖插入点后的内容</span></span><br><span class="line">            raf.write(insertContent.getBytes());</span><br><span class="line">            <span class="comment">// 重新读入被覆盖的内容,追加临时文件中的内容</span></span><br><span class="line">            <span class="keyword">while</span> ((hasRead = tmpIn.read(bbuf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                raf.write(bbuf, <span class="number">0</span>, hasRead);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        insert(<span class="string">&quot;InsertContent.java&quot;</span>, <span class="number">45</span>, <span class="string">&quot;插入的内容\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中使用<code>File</code>的<code>createTempFile(String prefix, String suffix)</code>方法创建了一个临时文件(该临时文件将在<code>JVM</code>退出时被删除),用以保存被插入文件的插入点后面的内容。程序先将文件中插入点后的内容读入临时文件中,然后重新定位到插入点,将需要插入的内容添加到文件后面,最后将临时文件的内容添加到文件后面。<br>这样就可以向指定文件、指定位置插入内容。</p>
<h2 id="实现多线程断点传输工具"><a href="#实现多线程断点传输工具" class="headerlink" title="实现多线程断点传输工具"></a>实现多线程断点传输工具</h2><p>多线程断点的网络下载工具(如<code>FlashGet</code>等)就可通过<code>RandomAccessFile</code>类来实现.<br>所有的下载工具在下载开始时都会建立两个文件:</p>
<ul>
<li>一个是与被下载文件大小相同的空文件，</li>
<li>一个是记录文件指针的位置文件</li>
</ul>
<p>下载工具用多条线程启动输入流来读取网络数据,并使用<code>RandomAccessFile</code>将从网络上读取的数据写入前面建立的空文件中,每写一些数据后,记录文件指针的文件就分别记下每个<code>RandomAccessFile</code>当前的文件指针位置——网络断开后,再次开始下载时,每个<code>RandomAccessFile</code>都根据记录文件指针的文件中记录的位置继续向下写数据。</p>
<p>本书将会在介绍多线程和网络知识之后,更加详细地介绍如何开发类似于<code>FlashGet</code>的多线程断点传输工具。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/fa2b9d19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/fa2b9d19/" class="post-title-link" itemprop="url">15.6 Java虚拟机读写其他进程的数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-28 04:56:08" itemprop="dateCreated datePublished" datetime="2019-12-28T04:56:08+08:00">2019-12-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-03-15 08:15:12" itemprop="dateModified" datetime="2020-03-15T08:15:12+08:00">2020-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">1 疯狂Java讲义 (第4版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" itemprop="url" rel="index"><span itemprop="name">第15章 输入输出</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/1-%E7%96%AF%E7%8B%82Java%E8%AE%B2%E4%B9%89-%E7%AC%AC4%E7%89%88/%E7%AC%AC15%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/15-6-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AF%BB%E5%86%99%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">15.6 Java虚拟机读写其他进程的数据</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/fa2b9d19/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/fa2b9d19/" data-xid="/JavaReadingNotes/fa2b9d19/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="15-6-Java虚拟机读写其他进程的数据"><a href="#15-6-Java虚拟机读写其他进程的数据" class="headerlink" title="15.6 Java虚拟机读写其他进程的数据"></a>15.6 Java虚拟机读写其他进程的数据</h1><p>在第7章已经介绍过,使用<code>Runtime</code>对象的<code>exec()</code>方法可以运行平台上的其他程序,该方法产生个<code>Process</code>对象,<strong><code>Process</code>对象代表由该<code>Java</code>程序启动的子进程</strong>。</p>
<p><code>Process</code>类提供了如下三个方法,用于让程序和其子讲程讲行通信</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>abstract InputStream getErrorStream()</code></td>
<td align="left">获取子进程的错误流。</td>
</tr>
<tr>
<td align="left"><code>abstract InputStream getInputStream()</code></td>
<td align="left">获取子进程的输入流。</td>
</tr>
<tr>
<td align="left"><code>abstract OutputStream getOutputStream()</code></td>
<td align="left">获取子进程的输出流。</td>
</tr>
</tbody></table>
<h2 id="要从java程序的角度来看输入输出流"><a href="#要从java程序的角度来看输入输出流" class="headerlink" title="要从java程序的角度来看输入输出流"></a>要从java程序的角度来看输入输出流</h2><p>此处的输入流、输出流非常容易混淆,<strong>如果试图让子进程读取程序中的数据,那么应该用<code>输岀流</code><strong>。<br>要站在<code>Java</code>程序的角度来看问题,而不是从子进程的角度来看问题:<br><strong>子进程读取<code>Java</code>程序的数据,就是让<code>Java</code>程序把数据<mark>输岀</mark>到子进程中</strong>。<br>这就像<code>Java</code>程序把数据输出到<code>文件</code>中一样,只是现在由子进程节点代替了文件节点,所以</strong>子进程要读取java程序的内容应该使用输出流</strong>。</p>
<h2 id="程序-java读取子进程的错误输出"><a href="#程序-java读取子进程的错误输出" class="headerlink" title="程序 java读取子进程的错误输出"></a>程序 java读取子进程的错误输出</h2><p>下面程序示范了读取其他进程的输出信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadFromProcess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 运行javac命令，返回运行该命令的子进程</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;javac&quot;</span>);<span class="comment">// 代码1</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 以p进程的错误流创建BufferedReader对象</span></span><br><span class="line">                <span class="comment">// 这个错误流对本程序是输入流，对p进程则是输出流</span></span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(p.getErrorStream()))<span class="comment">// 代码2</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">buff</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 采取循环方式来读取p进程的错误输出</span></span><br><span class="line">            <span class="keyword">while</span> ((buff = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子程序的错误输出:&quot;</span>+buff);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<strong>代码1</strong>使用<code>Runtime</code>启动了<code>Javac</code>程序,获得了运行该程序对应的子进程,<br><strong>代码2</strong>以p进程的错误输入流创建了<code>BufferedReader</code>,这个输入流的流向如图15.11所示。<br><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/JavaReadingNotes/CrazyJavaLecture4/Chapter15IO/15.6/1.png" alt="这里有一张图片"><br>如图15.11所示的数据流对p进程(<code>Javac</code>进程)而言,它是输出流;但对本程序(<code>ReadFromProcess</code>)而言,它是输入流。<br><strong>衡量输入、输出时总是站在运行本程序所在内存的角度,所以该数据流应该是输入流</strong><br>运行上面程序,会看到如下信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">G:\Desktop\随书源码\疯狂Java讲义(第4版)光盘\codes\15\15.6&gt;javac -encoding utf-8 ReadFromProcess.java</span><br><span class="line"></span><br><span class="line">G:\Desktop\随书源码\疯狂Java讲义(第4版)光盘\codes\15\15.6&gt;java ReadFromProcess</span><br><span class="line">子程序的错误输出:用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">子程序的错误输出:其中, 可能的选项包括:</span><br><span class="line">子程序的错误输出:  -g                         生成所有调试信息</span><br><span class="line">子程序的错误输出:  -g:none                    不生成任何调试信息</span><br><span class="line">子程序的错误输出:  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">子程序的错误输出:  -nowarn                    不生成任何警告</span><br><span class="line">子程序的错误输出:  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">子程序的错误输出:  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">子程序的错误输出:  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">子程序的错误输出:  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">子程序的错误输出:  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">子程序的错误输出:  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">子程序的错误输出:  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">子程序的错误输出:  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">子程序的错误输出:  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">子程序的错误输出:  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">子程序的错误输出:  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">子程序的错误输出:  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">子程序的错误输出:  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">子程序的错误输出:  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">子程序的错误输出:  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">子程序的错误输出:  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">子程序的错误输出:  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">子程序的错误输出:  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">子程序的错误输出:  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">子程序的错误输出:  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">子程序的错误输出:  -version                   版本信息</span><br><span class="line">子程序的错误输出:  -help                      输出标准选项的提要</span><br><span class="line">子程序的错误输出:  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">子程序的错误输出:  -X                         输出非标准选项的提要</span><br><span class="line">子程序的错误输出:  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">子程序的错误输出:  -Werror                    出现警告时终止编译</span><br><span class="line">子程序的错误输出:  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br><span class="line">子程序的错误输出:</span><br></pre></td></tr></table></figure>
<h2 id="程序-java输出数据到子进程"><a href="#程序-java输出数据到子进程" class="headerlink" title="程序 java输出数据到子进程"></a>程序 java输出数据到子进程</h2><p>不仅如此,也可以通过<code>Process</code>的<code>getOutputStream</code>方法获得向子进程输入数据的流(该流对<code>Java</code>程序来说是输出流,对子进程来说是输入流),如下程序实现了在<code>Java</code>程序中启动<code>Java</code>虚拟机运行另一个<code>Java</code>程序,并向另一个<code>Java</code>程序中输入数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteToProcess</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 运行java ReadStandard命令，返回运行该命令的子进程</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">p</span> <span class="operator">=</span> Runtime.getRuntime().exec(<span class="string">&quot;java ReadStandard&quot;</span>);<span class="comment">// 代码1</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 以p进程的输出流创建PrintStream对象</span></span><br><span class="line">                <span class="comment">// 这个输出流对本程序是输出流，对p进程则是输入流</span></span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(p.getOutputStream())<span class="comment">// 代码2</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 向ReadStandard程序写入内容，这些内容将被ReadStandard读取</span></span><br><span class="line">            ps.println(<span class="string">&quot;普通字符串&quot;</span>);</span><br><span class="line">            ps.println(<span class="keyword">new</span> <span class="title class_">WriteToProcess</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个ReadStandard类，该类可以接受标准输入，</span></span><br><span class="line"><span class="comment">// 并将标准输入写入out.txt文件。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadStandard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">// 使用System.in创建Scanner对象，用于获取标准输入</span></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">// 增加下面一行将只把回车作为分隔符</span></span><br><span class="line">            sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 判断是否还有下一个输入项</span></span><br><span class="line">            <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">                <span class="comment">// 输出输入项</span></span><br><span class="line">                ps.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            ioe.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序中的<code>ReadStandard</code>是一个使用<code>Scanner</code>获取标准输入的类,该类提供了<code>main()</code>方法,可以被运行,但此处不打算直接运行该类,而是由<code>WriteToProcess</code>类来运行<code>ReadStandard</code>类。</p>
<p>在程序的<strong>代码1</strong>中,程序使用<code>Runtime</code>的<code>exec()</code>方法运行了<code>java Readstandard</code>命令,该命令将运行<code>ReadStandard</code>类,并返回运行该程序的子进程;<br>程序的<strong>代码2</strong>获得当前程序对进程p的输出流:<br>程序通过该输出流向进程p(也就是<code>ReadStandard</code>程序)输出数据,这些数据将被<code>ReadStandard</code>类读到。<br>运行上面的<code>WriteToProcess</code>类,程序运行结束将看到产生了一个<code>out.txt</code>文件,该文件由<code>ReadStandard</code>类产生,该文件的内容由<code>WriteToProcess</code>类写入<code>ReadStandard</code>进程里,并由<code>ReadStandard</code>读取这些数据,并将这些数据保存到<code>out.txt</code>文件中.</p>
<!-- JavaReadingNotes/CrazyJavaLecture4/Chapter15IO/15.6/ -->

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/86/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/86/">86</a><span class="page-number current">87</span><a class="page-number" href="/JavaReadingNotes/page/88/">88</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/88/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:07</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/87/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/87/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
