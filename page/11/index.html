<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.1.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.11.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>

    <meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/11/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>



<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li><li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/cb0345d2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/cb0345d2/" class="post-title-link" itemprop="url">5.3 内部类的本质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95/" itemprop="url" rel="index"><span itemprop="name">第5章 类的扩展</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/cb0345d2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/cb0345d2/" data-xid="/JavaReadingNotes/cb0345d2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="5-3-内部类的本质"><a href="#5-3-内部类的本质" class="headerlink" title="5.3 内部类的本质"></a>5.3 内部类的本质</h1><p>之前我们所说的类都对应于一个独立的Java源文件，但一个类还可以放在另一个类的内部，称之为内部类，相对而言，包含它的类称之为<strong>外部类</strong>。</p>
<p>一般而言，<strong>内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁</strong>。</p>
<p>不过，内部类只是Java编译器的概念，对于Java虚拟机而言，它是不知道内部类这回事的，<strong>每个内部类最后都会被编译为一个独立的类</strong>，生成一个独立的字节码文件。</p>
<p>也就是说，每个内部类其实都可以被替换为一个独立的类。当然，这是单纯就技术实现而言。<strong>内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁，这些都是内部类的好处</strong>。</p>
<p>在Java中，根据定义的位置和方式不同，主要有4种内部类。</p>
<ul>
<li>静态内部类。</li>
<li>成员内部类。</li>
<li>方法内部类。</li>
<li>匿名内部类。</li>
</ul>
<p>其中，方法内部类是在一个方法内定义和使用的；匿名内部类使用范围更小，它们都不能在外部使用；成员内部类和静态内部类可以被外部使用，不过它们都可以被声明为private，这样，外部就不能使用了。接下来，我们逐个介绍这些内部类的语法、实现原理以及使用场景。</p>
<h2 id="5-3-1-静态内部类"><a href="#5-3-1-静态内部类" class="headerlink" title="5.3.1 静态内部类"></a>5.3.1 静态内部类</h2><p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。</p>
<p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。</p>
<center>代码清单5-3 静态内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner &quot;</span> + shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StaticInner</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInner</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部类为Outer，静态内部类为StaticInner，带有static修饰符。语法上，静态内部类除了位置放在其他类内部外，它与一个独立的类差别不大，可以有静态变量、静态方法、成员方法、成员变量、构造方法等。</p>
<p>静态内部类与外部类的联系也不大（与其他内部类相比）。它可以访问外部类的静态变量和方法，如innerMethod直接访问shared变量，但不可以访问实例变量和方法。在类内部，可以直接使用内部静态类，如test()方法所示。</p>
<p>public静态内部类可以被外部使用，只是需要通过“外部类．静态内部类”的方式使用，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">StaticInner</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.StaticInner();</span><br><span class="line">si.innerMethod();</span><br></pre></td></tr></table></figure>

<p>静态内部类是怎么实现的呢？代码清单5-3所示的代码实际上会生成两个类：一个是Outer，另一个是Outer$StaticInner，代码大概如代码清单5-4所示。</p>
<center>代码清单5-4 静态内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Outer$StaticInner</span> <span class="variable">si</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$StaticInner</span>();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> shared;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$StaticInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inner &quot;</span> + Outer.access$<span class="number">0</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类访问了外部类的一个私有静态变量shared，而我们知道私有变量是不能被类外部访问的，Java的解决方法是：自动为Outer生成一个非私有访问方法access$0，它返回这个私有静态变量shared。</p>
<p>静态内部类的使用场景是很多的，如果它与外部类关系密切，且不依赖于外部类实例，则可以考虑定义为静态内部类。比如，一个类内部，如果既要计算最大值，又要计算最小值，可以在一次遍历中将最大值和最小值都计算出来，但怎么返回呢？可以定义一个类Pair，包括最大值和最小值，但Pair这个名字太普遍，而且它主要是类内部使用的，就可以定义为一个静态内部类。</p>
<p>我们也可以看一些在Java API中使用静态内部类的例子：</p>
<ul>
<li>Integer类内部有一个私有静态内部类IntegerCache，用于支持整数的自动装箱。</li>
<li>表示链表的LinkedList类内部有一个私有静态内部类Node，表示链表中的每个节点。</li>
<li>Character类内部有一个public静态内部类UnicodeBlock，用于表示一个Unicode block。</li>
</ul>
<p>以上一些类的细节我们在后续章节会再介绍。</p>
<h2 id="5-3-2-成员内部类"><a href="#5-3-2-成员内部类" class="headerlink" title="5.3.2 成员内部类"></a>5.3.2 成员内部类</h2><p>与静态内部类相比，成员内部类没有static修饰符，少了一个static修饰符，含义有很大不同，下面我们详细讨论。我们看个成员内部类的例子，如代码清单5-5所示。</p>
<center>代码清单5-5 成员内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;outer a &quot;</span> +a);</span><br><span class="line">            Outer.<span class="built_in">this</span>.action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner就是成员内部类，与静态内部类不同，除了静态变量和方法，成员内部类还可以直接访问外部类的实例变量和方法，如innerMethod直接访问外部类私有实例变量a。成员内部类还可以通过“外部类．this.xxx”的方式引用外部类的实例变量和方法，如Outer.this. action()，这种写法一般在重名的情况下使用，如果没有重名，那么“外部类．this. ”是多余的。</p>
<p>在外部类内，使用成员内部类与静态内部类是一样的，直接使用即可，如test()方法所示。与静态内部类不同，<strong>成员内部类对象总是与一个外部类对象相连的</strong>，在外部使用时，它不能直接通过new Outer.Inner()的方式创建对象，而是要先将创建一个Outer类对象，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.innerMethod();</span><br></pre></td></tr></table></figure>

<p>创建内部类对象的语法是“外部类对象<code>.new 内部类()</code>”，如outer.new Inner()。</p>
<p>与静态内部类不同，成员内部类中不可以定义静态变量和方法（final变量例外，它等同于常量），下面介绍的方法内部类和匿名内部类也都不可以。Java为什么要有这个规定呢？可以这么理解，这些内部类是与外部实例相连的，不应独立使用，而静态变量和方法作为类型的属性和方法，一般是独立使用的，在内部类中意义不大，而如果内部类确实需要静态变量和方法，那么也可以挪到外部类中。</p>
<p>成员内部类背后是怎么实现的呢？代码清单5-5也会生成两个类：一个是Outer，另一个是Outer$Inner，它们的代码大概如代码清单5-6所示。</p>
<center>代码清单5-6 成员内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Outer$Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$Inner</span>(<span class="built_in">this</span>);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>(Outer outer) &#123;</span><br><span class="line">        <span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">1</span>(Outer outer) &#123;</span><br><span class="line">        outer.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$Inner</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Outer outer;</span><br><span class="line">    <span class="keyword">public</span> Outer$Inner(Outer outer)&#123;</span><br><span class="line">        ths.outer = outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span> + Outer.access$<span class="number">0</span>(outer));</span><br><span class="line">        Outer.access$<span class="number">1</span>(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Outer$Inner类有个实例变量outer指向外部类的对象，它在构造方法中被初始化，Outer在新建Outer$Inner对象时给它传递当前对象，由于内部类访问了外部类的私有变量和方法，外部类Outer生成了两个非私有静态方法：access$0用于访问变量a, access$1用于访问方法action。</p>
<p>成员内部类有哪些应用场景呢？如果内部类与外部类关系密切，需要访问外部类的实例变量或方法，则可以考虑定义为成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回这个接口，外部类方法可能使用内部类实现这个接口，这个内部类可以被设为private，对外完全隐藏。</p>
<p>比如，在Java API的类LinkedList中，它的两个方法listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表遍历，listIterator和descend-ingIterator内部分别使用了成员内部类ListItr和DescendingIterator，这两个内部类都实现了接口Iterator。关于LinkedList，第9章会详细介绍。</p>
<h2 id="5-3-3-方法内部类"><a href="#5-3-3-方法内部类" class="headerlink" title="5.3.3 方法内部类"></a>5.3.3 方法内部类</h2><p>内部类还可以定义在一个方法体中。我们看个例子，如代码清单5-7所示。</p>
<center>代码清单5-7 方法内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> param)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;outer a &quot;</span> +a);</span><br><span class="line">                System.out.println(<span class="string">&quot;param &quot;</span> +param);</span><br><span class="line">                System.out.println(<span class="string">&quot;local var &quot;</span> +str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类Inner定义在外部类方法test中，方法内部类只能在定义的方法内被使用。如果方法是实例方法，则除了静态变量和方法，内部类还可以直接访问外部类的实例变量和方法，如innerMethod直接访问了外部私有实例变量a。如果方法是静态方法，则方法内部类只能访问外部类的静态变量和方法。方法内部类还可以直接访问方法的参数和方法中的局部变量，不过，这些变量必须被声明为final，如innerMethod直接访问了方法参数param和局部变量str。</p>
<p>方法内部类是怎么实现的呢？对于代码清单5-7，系统生成的两个类代码大概如代码清单5-8所示。</p>
<center>代码清单5-8 方法内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> param)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="type">OuterInner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterInner</span>(<span class="built_in">this</span>, param);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> access$<span class="number">0</span>(Outer outer)&#123;</span><br><span class="line">        <span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterInner</span> &#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    <span class="type">int</span> param;</span><br><span class="line">    OuterInner(Outer outer, <span class="type">int</span> param)&#123;</span><br><span class="line">        <span class="built_in">this</span>.outer = outer;</span><br><span class="line">        <span class="built_in">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span> + Outer.access$<span class="number">0</span>(<span class="built_in">this</span>.outer));</span><br><span class="line">        System.out.println(<span class="string">&quot;param &quot;</span> + param);</span><br><span class="line">        System.out.println(<span class="string">&quot;local var &quot;</span> + <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与成员内部类类似，OuterInner类也有一个实例变量outer指向外部对象，在构造方法中被初始化，对外部私有实例变量的访问也是通过Outer添加的方法access$0来进行的。</p>
<p>方法内部类可以访问方法中的参数和局部变量，这是通过在构造方法中传递参数来实现的，如OuterInner构造方法中有参数int param，在新建OuterInner对象时，Outer类将方法中的参数传递给了内部类，如OuterInner inner &#x3D; newOuterInner(this, param); 。在上面的代码中，String str并没有被作为参数传递，这是因为它被定义为了常量，在生成的代码中，可以直接使用它的值。</p>
<p>这也解释了为什么方法内部类访问外部方法中的参数和局部变量时，这些变量必须被声明为final，因为实际上，<strong>方法内部类操作的并不是外部的变量，而是它自己的实例变量</strong>，只是这些变量的值和外部一样，对这些变量赋值，并不会改变外部的值，为避免混淆，所以干脆强制规定必须声明为final。</p>
<p>如果的确需要修改外部的变量，那么可以将变量改为只含该变量的数组，修改数组中的值，如代码清单5-9所示。</p>
<center>代码清单5-9 方法内部类修改外部变量实例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                str[<span class="number">0</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">        System.out.println(str[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str是一个只含一个元素的数组，方法内部类不能修改str本身，但可以修改它的数组元素。</p>
<p>通过前面介绍的语法和原理可以看出，方法内部类可以用成员内部类代替，至于方法参数，也可以作为参数传递给成员内部类。不过，如果类只在某个方法内被使用，使用方法内部类，可以实现更好的封装。</p>
<h2 id="5-3-4-匿名内部类"><a href="#5-3-4-匿名内部类" class="headerlink" title="5.3.4 匿名内部类"></a>5.3.4 匿名内部类</h2><p>与前面介绍的内部类不同，匿名内部类没有单独的类定义，它在创建对象的同时定义类，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) &#123;</span><br><span class="line">    <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">    <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类是与new关联的，在创建对象的时候定义类，new后面是父类或者父接口，然后是圆括号()，里面可以是传递给父类构造方法的参数，最后是大括号{}，里面是类的定义。</p>
<p>看个具体的例子，如代码清单5-10所示。</p>
<center>代码清单5-10 匿名内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span>&#123;</span><br><span class="line">            <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">2</span>,<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(x, y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        System.out.println(p.distance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2和3，重写了distance()方法，在方法中访问了外部方法final参数x和y。</p>
<p>匿名内部类只能被使用一次，用来创建一个对象。它没有名字，没有构造方法，但可以根据参数列表，调用对应的父类构造方法。它可以定义实例变量和方法，可以有初始化代码块，初始化代码块可以起到构造方法的作用，只是构造方法可以有多个，而初始化代码块只能有一份。因为没有构造方法，它自己无法接受参数，如果必须要参数，则应该使用其他内部类。与方法内部类一样，匿名内部类也可以访问外部类的所有变量和方法，可以访问方法中的final参数和局部变量。</p>
<p>匿名内部类是怎么实现的呢？每个匿名内部类也都被生成为一个独立的类，只是类的名字以外部类加数字编号，没有有意义的名字。代码清单5-10会产生两个类Outer和Outer$1，代码大概如代码清单5-11所示。</p>
<center>代码清单5-11 匿名内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> x, <span class="keyword">final</span> <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer$1</span>(<span class="built_in">this</span>,<span class="number">2</span>,<span class="number">3</span>, x, y);</span><br><span class="line">        System.out.println(p.distance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer$1</span> <span class="keyword">extends</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">    <span class="type">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)&#123;</span><br><span class="line">        <span class="built_in">super</span>(x1, y1);</span><br><span class="line">        <span class="built_in">this</span>.outer = outer;</span><br><span class="line">        <span class="built_in">this</span>.x2 = x2;</span><br><span class="line">        <span class="built_in">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">distance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> distance(<span class="keyword">new</span> <span class="title class_">Point</span>(<span class="built_in">this</span>.x2, y2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与方法内部类类似，外部实例this、方法参数x和y都作为参数传递给了内部类构造方法。此外，new时的参数2和3也传递给了构造方法，内部类构造方法又将它们传递给了父类构造方法。</p>
<p>在调用方法时，很多方法需要一个接口参数，比如Arrays.sort方法，它可以接受一个数组，以及一个Comparator接口参数，Comparator有一个方法compare用于比较两个对象。比如，要对一个字符串数组不区分大小写排序，可以使用Arrays.sort方法，但需要传递一个实现了Comparator接口的对象，这时就可以使用匿名内部类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortIgnoreCase</span><span class="params">(String[] strs)</span>&#123;</span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator后面的<code>&lt;String&gt;</code>与泛型有关，表示比较的对象是字符串类型。匿名内部类还经常用于事件处理程序中，用于响应某个事件，比如一个Button，处理单击事件的代码可能类似如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">bt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>();</span><br><span class="line">bt.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>调用addActionListener将事件处理程序注册到了Button对象bt中，当事件发生时，会调用actionPerformed方法，并传递事件详情ActionEvent作为参数。</p>
<p>以上Arrays.sort和Button都是针对接口编程的例子，另外，它们也都是一种回调的例子。所谓回调是相对于一般的正向调用而言的，平时一般都是正向调用，但Arrays.sort中传递的Comparator对象，它的compare方法并不是在写代码的时候被调用的，而是在Arrays. sort的内部某个地方回过头来调用的。Button的addActionListener中传递的ActionListener对象，它的actionPerformed方法也一样，是在事件发生的时候回过头来调用的。</p>
<p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行协作，是计算机程序的一种常用实践。匿名内部类是实现回调接口的一种简便方式。</p>
<p>至此，关于各种内部类就介绍完了。内部类本质上都会被转换为独立的类，但一般而言，它们可以实现更好的封装，代码实现上也更为简洁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/f0edbeff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/f0edbeff/" class="post-title-link" itemprop="url">7.4 剖析Arrays</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/f0edbeff/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/f0edbeff/" data-xid="/JavaReadingNotes/f0edbeff/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-4-剖析Arrays"><a href="#7-4-剖析Arrays" class="headerlink" title="7.4 剖析Arrays"></a>7.4 剖析Arrays</h1><p>数组是存储多个同类型元素的基本数据结构，数组中的元素在内存连续存放，可以通过数组下标直接定位任意元素，相比在后续章节介绍的其他容器而言效率非常高。</p>
<p>数组操作是计算机程序中的常见基本操作。Java中有一个类Arrays，包含一些对数组操作的静态方法，本节主要就来讨论这些方法。首先介绍怎么用，然后介绍它们的实现原理。学习Arrays的用法，就可以“避免重新发明轮子”，直接使用，学习它的实现原理，就可以在需要的时候自己实现它不具备的功能。</p>
<h2 id="7-4-1-用法"><a href="#7-4-1-用法" class="headerlink" title="7.4.1 用法"></a>7.4.1 用法</h2><p>Arrays类中有很多方法，我们主要介绍toString、排序、查找，对于一些其他方法，如复制、比较、批量设置值和计算哈希值等，我们也进行简单介绍。</p>
<h3 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString"></a>1. toString</h3><p>Arrays的toString()方法可以方便地输出一个数组的字符串形式，以便查看。它有9个重载的方法，包括8个基本类型数组和1个对象类型数组，下面列举两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(Object[] a)</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">String[] strArr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(strArr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[9, 8, 3, 4]</span><br><span class="line">[hello, world]</span><br></pre></td></tr></table></figure>

<p>如果不使用Arrays.toString方法，直接输出数组自身，即代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">String[] strArr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(strArr));</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(arr);</span><br><span class="line">String[] strArr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">System.out.println(strArr);</span><br></pre></td></tr></table></figure>

<p>则输出会变为如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I@1224b90</span><br><span class="line">[Ljava.lang.String; @728edb84</span><br></pre></td></tr></table></figure>

<p>这个输出就难以阅读了，@后面的数字表示的是内存的地址。</p>
<h3 id="2．排序"><a href="#2．排序" class="headerlink" title="2．排序"></a>2．排序</h3><p>排序是一种非常常见的操作。同toString一样，对每种基本类型的数组，Arrays都有sort方法（boolean除外），例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">double</span>[] a)</span></span><br></pre></td></tr></table></figure>

<p>排序按照从小到大升序排列，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>数组已经排好序了。</p>
<p>除了基本类型，sort还可以直接接受对象类型，但对象需要实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Object[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>

<p>我们看个String数组的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Break, abc, hello, world]</span><br></pre></td></tr></table></figure>

<p>“Break”之所以排在最前面，是因为大写字母的ASCII码比小写字母都小。那如果排序的时候希望忽略大小写呢？sort还有另外两个重载方法，可以接受一个比较器作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>

<p>方法声明中的T表示泛型，泛型我们在第8章介绍，这里表示的是，这个方法可以支持所有对象类型，只要传递这个类型对应的比较器就可以了。Comparator就是比较器，它是一个接口，Java 7中的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的是compare这个方法，它比较两个对象，返回一个表示比较结果的值，-1表示o1小于o2,0表示o1等于o2,1表示o1大于o2。排序是通过比较来实现的，sort方法在排序的过程中需要对对象进行比较的时候，就调用比较器的compare方法。Java 8中Comparator增加了多个静态和默认方法，具体可参看API文档。</p>
<p>String类有一个public静态成员，表示忽略大小写的比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = <span class="keyword">new</span> <span class="title class_">CaseInsensitiveComparator</span>();</span><br></pre></td></tr></table></figure>

<p>我们通过这个比较器再来对上面的String数组排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>这样，大小写就忽略了，输出变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[abc, Break, hello, world]</span><br></pre></td></tr></table></figure>

<p>为进一步理解Comparator，我们来看下String的这个比较器的主要实现代码，如代码清单7-2所示。</p>
<center>代码清单7-2 String的CaseInsensitiveComparator实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CaseInsensitiveComparator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> s1.length();</span><br><span class="line">          <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> s2.length();</span><br><span class="line">          <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(n1, n2);</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">              <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> s1.charAt(i);</span><br><span class="line">              <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> s2.charAt(i);</span><br><span class="line">              <span class="keyword">if</span>(c1 ! = c2) &#123;</span><br><span class="line">                  c1 = Character.toUpperCase(c1);</span><br><span class="line">                  c2 = Character.toUpperCase(c2);</span><br><span class="line">                  <span class="keyword">if</span>(c1 ! = c2) &#123;</span><br><span class="line">                      c1 = Character.toLowerCase(c1);</span><br><span class="line">                      c2 = Character.toLowerCase(c2);</span><br><span class="line">                      <span class="keyword">if</span>(c1 ! = c2) &#123;</span><br><span class="line">                        <span class="comment">//No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单直接，就不解释了。</p>
<p>sort方法默认是从小到大排序，如果希望按照从大到小排序呢？对于对象类型，可以指定一个不同的Comparator，可以用匿名内部类来实现Comparator，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareToIgnoreCase(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>程序输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[world, hello, Break, abc]</span><br></pre></td></tr></table></figure>

<p>以上代码使用一个匿名内部类实现Comparator接口，返回o2与o1进行忽略大小写比较的结果，这样就能实现忽略大小写且按从大到小排序。</p>
<p>Collections类中有两个静态方法，可以返回逆序的Comparator，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title function_">reverseOrder</span><span class="params">(Comparator&lt;T&gt; cmp)</span></span><br></pre></td></tr></table></figure>

<p>关于Collections类，我们在12.2节介绍。</p>
<p>这样，上面字符串忽略大小写逆序排序的代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p><strong>传递比较器Comparator给sort方法，体现了程序设计中一种重要的思维方式。将不变和变化相分离，排序的基本步骤和算法是不变的，但按什么排序是变化的，sort方法将不变的算法设计为主体逻辑，而将变化的排序方式设计为参数，允许调用者动态指定，这也是一种常见的设计模式，称为策略模式，不同的排序方式就是不同的策略</strong>。</p>
<h3 id="3．查找"><a href="#3．查找" class="headerlink" title="3．查找"></a>3．查找</h3><p>Arrays包含很多与sort对应的查找方法，可以在已排序的数组中进行二分查找。所谓二分查找就是从中间开始查找，如果小于中间元素，则在前半部分查找，否则在后半部分查找，每比较一次，要么找到，要么将查找范围缩小一半，所以查找效率非常高。</p>
<p>二分查找既可以针对基本类型数组，也可以针对对象数组，对对象数组，也可以传递Comparator，也可以指定查找范围。比如，针对int数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> key)</span></span><br></pre></td></tr></table></figure>

<p>针对对象数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(Object[] a, Object key)</span></span><br></pre></td></tr></table></figure>

<p>指定自定义比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(T[] a, T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span></span><br></pre></td></tr></table></figure>

<p>如果能找到，binarySearch返回找到的元素索引，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">21</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">13</span>));</span><br></pre></td></tr></table></figure>

<p>输出为3。如果没找到，返回一个负数，这个负数等于-（插入点+<br>1）。插入点表示，如果在这个位置插入没找到的元素，可以保持原数组有序，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">21</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">11</span>));</span><br></pre></td></tr></table></figure>

<p>输出为-4，表示插入点为3，如果在3这个索引位置处插入11，可以保持数组有序，即数组会变为{3,5,7,11,13,21}。</p>
<p>需要注意的是，binarySearch针对的必须是已排序数组，如果指定了Comparator，需要和排序时指定的Comparator保持一致。另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。</p>
<h3 id="4．更多方法"><a href="#4．更多方法" class="headerlink" title="4．更多方法"></a>4．更多方法</h3><p>除了常用的toString、排序和查找，Arrays中还有复制、比较、批量设置值和计算哈希值等方法。</p>
<p>基于原数组，复制一个新数组，与toString一样，也有多种重载形式，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] copyOf(<span class="type">long</span>[] original, <span class="type">int</span> newLength)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength)</span><br></pre></td></tr></table></figure>

<p>判断两个数组是否相同，支持基本类型和对象类型，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">boolean</span>[] a, <span class="type">boolean</span>[] a2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object[] a, Object[] a2)</span></span><br></pre></td></tr></table></figure>

<p>只有数组长度相同，且每个元素都相同，才返回true，否则返回false。对于对象，相同是指equals返回true。</p>
<p>Arrays包含很多fill方法，可以给数组中的每个元素设置一个相同的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br></pre></td></tr></table></figure>

<p>也可以给数组中一个给定范围的每个元素设置一个相同的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> val)</span></span><br></pre></td></tr></table></figure>

<p>针对数组，计算一个数组的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">int</span> a[])</span></span><br></pre></td></tr></table></figure>

<p>计算hashCode的算法和String是类似的，我们看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> element : a)</span><br><span class="line">        result = <span class="number">31</span> ＊ result + element;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下，String计算hashCode的算法也是类似的，数组中的每个元素都影响hash值，位置不同，影响也不同，使用31一方面产生的哈希值更分散，另一方面计算效率也比较高。</p>
<p>Java 8和9对Arrays类又增加了一些方法，比如将数组转换为流、并行排序、数组比较等，具体可参看API文档。</p>
<h2 id="7-4-2-多维数组"><a href="#7-4-2-多维数组" class="headerlink" title="7.4.2 多维数组"></a>7.4.2 多维数组</h2><p>之前介绍的数组都是一维的，数组还可以是多维的。先来看二维数组，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;arr[i].length; j++)&#123;</span><br><span class="line">        arr[i][j] = i+j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr就是一个二维数组，第一维长度为2，第二维长度为3，类似于一个矩阵，或者类似于一个表格，第一维表示行，第二维表示列。arr[i]表示第i行，它本身还是一个数组， arr[i][j]表示第i行中的第j个元素。</p>
<p>除了二维，数组还可以是三维、四维等，但一般而言，很少用到三维以上的数组，有几维，就有几个[]。比如，一个三维数组的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>在创建数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至第一维中每个元素的第二维的长度可以不一样，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>arr是一个二维数组，第一维的长度为2，第一个元素的第二维长度为3，而第二个元素的第二维长度为5。</p>
<p>多维数组到底是什么呢？其实，可以认为，<strong>多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组</strong>，这样就形成二维数组；如果其中每个元素还都是一个数组，那就是三维数组。</p>
<p>Arrays中的toString、equals、hashCode都有对应的针对多维数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">deepToString</span><span class="params">(Object[] a)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">deepEquals</span><span class="params">(Object[] a1, Object[] a2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">deepHashCode</span><span class="params">(Object a[])</span></span><br></pre></td></tr></table></figure>

<p>这些deepXXX方法，都会判断参数中的元素是否也为数组，如果是，会递归进行操作。</p>
<p>看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(arr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1], [2, 3, 4], [5, 6, 7, 8]]</span><br></pre></td></tr></table></figure>

<h2 id="7-4-3-实现原理"><a href="#7-4-3-实现原理" class="headerlink" title="7.4.3 实现原理"></a>7.4.3 实现原理</h2><p>下面介绍Arrays的方法的实现原理。hashCode()的实现我们已经介绍了；fill和equals等的实现都很简单，循环操作即可，不再赘述；下面主要介绍二分查找和排序的实现代码。</p>
<h3 id="1．二分查找"><a href="#1．二分查找" class="headerlink" title="1．二分查找"></a>1．二分查找</h3><p>二分查找（binarySearch）的代码比较直接，如代码清单7-3所示。</p>
<center>代码清单7-3 Arrays的二分查找实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">int</span> <span class="title function_">binarySearch0</span><span class="params">(T[] a, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex,</span></span><br><span class="line"><span class="params">                                      T key, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> fromIndex;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">T</span> <span class="variable">midVal</span> <span class="operator">=</span> a[mid];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> c.compare(midVal, key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);   <span class="comment">//key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中有两个标志：low和high，表示查找范围，在while循环中，与中间值进行对比，大于则在后半部分查找（提高low），否则在前半部分查找（降低high）。</p>
<h3 id="2．排序-1"><a href="#2．排序-1" class="headerlink" title="2．排序"></a>2．排序</h3><p>与Arrays中的其他方法相比，sort要复杂得多。排序是计算机程序中一个非常重要的方面，几十年来，计算机科学家和工程师们对此进行了大量的研究，设计实现了各种各样的算法，进行了大量的优化。一般而言，没有一个最好的算法，不同算法往往有不同的适用场合。</p>
<p>那Arrays的sort是如何实现的呢？具体实现非常复杂，我们简单了解下。</p>
<p>对于基本类型的数组，Java采用的算法是<strong>双枢轴快速排序</strong>（Dual-PivotQuicksort）。这个算法是Java 7引入的，在此之前，Java采用的算法是普通的快速排序。双枢轴快速排序是对快速排序的优化，新算法的实现代码位于类java.util.DualPivotQuicksort中。</p>
<p>对于对象类型，Java采用的算法是TimSort。TimSort也是在Java 7引入的，在此之前， Java采用的是归并排序。TimSort实际上是对归并排序的一系列优化，TimSort的实现代码位于类java.util.TimSort中。</p>
<p>在这些排序算法中，如果数组长度比较小，它们还会采用效率更高的插入排序。</p>
<p>为什么基本类型和对象类型的算法不一样呢？排序算法有一个稳定性的概念，所谓稳定性就是对值相同的元素，如果排序前和排序后，算法可以保证它们的相对顺序不变，那算法就是稳定的，否则就是不稳定的。</p>
<p>快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。</p>
<p>这些算法的实现是比较复杂的，所幸的是，Java提供了很好的封装，绝大多数情况下，我们会用就可以了。</p>
<h2 id="7-4-4-小结"><a href="#7-4-4-小结" class="headerlink" title="7.4.4 小结"></a>7.4.4 小结</h2><p>其实，Arrays中包含的数组方法是比较少的，很多常用的操作没有，比如，Arrays的binarySearch只能针对已排序数组进行查找，那没有排序的数组怎么方便查找呢？</p>
<p>Apache有一个开源包（<a target="_blank" rel="noopener" href="http://commons.apache.org/proper/commons-lang/%EF%BC%89%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BBArrayUtils%EF%BC%88%E4%BD%8D%E4%BA%8E%E5%8C%85org.apache.commons.lang3%EF%BC%89%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%88%97%E4%B8%BE%E4%BA%86%E3%80%82">http://commons.apache.org/proper/commons-lang/），里面有一个类ArrayUtils（位于包org.apache.commons.lang3），包含了更多的常用数组操作，这里就不列举了。</a></p>
<p>数组是计算机程序中的基本数据结构，Arrays类以及ArrayUtils类封装了关于数组的常见操作，使用这些方法，避免“重新发明轮子”吧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/eb612b60/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/eb612b60/" class="post-title-link" itemprop="url">7.6 随机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/eb612b60/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/eb612b60/" data-xid="/JavaReadingNotes/eb612b60/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-6-随机"><a href="#7-6-随机" class="headerlink" title="7.6 随机"></a>7.6 随机</h1><p>本节，我们来讨论随机，随机是计算机程序中一个非常常见的需求，比如：</p>
<ul>
<li>各种游戏中有大量的随机，比如扑克游戏中的洗牌。</li>
<li>微信抢红包，抢的红包金额是随机的。</li>
<li>北京购车摇号，谁能摇到是随机的。</li>
<li>给用户生成随机密码。</li>
</ul>
<p>我们首先来介绍Java对随机的支持，同时介绍其实现原理，然后针对一些实际场景，包括洗牌、抢红包、摇号、随机高强度密码、带权重的随机选择等，讨论如何应用随机。先来看如何使用最基本的随机。</p>
<h2 id="7-6-1-Math-random"><a href="#7-6-1-Math-random" class="headerlink" title="7.6.1 Math.random"></a>7.6.1 Math.random</h2><p>Java中，对随机最基本的支持是Math类中的静态方法random()，它生成一个0～1的随机数，类型为double，包括0但不包括1。比如，随机生成并输出3个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(Math.random());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔者的计算机中的一次运行，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.4784896133823269</span><br><span class="line">0.03012515628333423</span><br><span class="line">0.7921024363953197</span><br></pre></td></tr></table></figure>

<p>每次运行，输出都不一样。Math.random()是如何实现的呢？我们来看相关代码（Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random randomNumberGenerator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Random <span class="title function_">initRNG</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> randomNumberGenerator;</span><br><span class="line">    <span class="keyword">return</span> (rnd == <span class="literal">null</span>) ? (randomNumberGenerator = <span class="keyword">new</span> <span class="title class_">Random</span>()) : rnd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">random</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> randomNumberGenerator;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="literal">null</span>) rnd = initRNG();</span><br><span class="line">    <span class="keyword">return</span> rnd.nextDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部它使用了一个Random类型的静态变量randomNumberGenerator，调用random()就是调用该变量的nextDouble()方法，这个Random变量只有在第一次使用的时候才创建。</p>
<p>下面我们来看这个Random类，它位于包java.util下。</p>
<h2 id="7-6-2-Random"><a href="#7-6-2-Random" class="headerlink" title="7.6.2 Random"></a>7.6.2 Random</h2><p>Random类提供了更为丰富的随机方法，它的方法不是静态方法，使用Random，先要创建一个Random实例，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println(rnd.nextInt());</span><br><span class="line">System.out.println(rnd.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>笔者计算机中的一次运行，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1516612608</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<p>nextInt()产生一个随机的int，可能为正数，也可能为负数，nextInt(100)产生一个随机int，范围是0～100，包括0不包括100。除了nextInt，还有一些别的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> <span class="comment">//随机生成一个long</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextBoolean</span><span class="params">()</span> <span class="comment">//随机生成一个boolean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextBytes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="comment">//产生随机字节， 字节个数就是bytes的长度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span> <span class="comment">//随机浮点数，从0到1，包括0不包括1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">nextDouble</span><span class="params">()</span> <span class="comment">//随机浮点数，从0到1，包括0不包括1</span></span><br></pre></td></tr></table></figure>

<p>除了默认构造方法，Random类还有一个构造方法，可以接受一个long类型的种子参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">(<span class="type">long</span> seed)</span></span><br></pre></td></tr></table></figure>

<p><strong>种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的</strong>。看个例子：</p>
<p>Random rnd &#x3D; new Random(20160824);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    System.out.print(rnd.nextInt(<span class="number">100</span>)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>种子为20160824，产生5个0～100的随机数，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">69 13 13 94 50</span><br></pre></td></tr></table></figure>

<p>这个程序无论执行多少遍，在哪执行，输出结果都是相同的。</p>
<p>除了在构造方法中指定种子，Random类还有一个setter实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeed</span><span class="params">(<span class="type">long</span> seed)</span></span><br></pre></td></tr></table></figure>

<p>其效果与在构造方法中指定种子是一样的。</p>
<p>为什么要指定种子呢？指定种子还是真正的随机吗？<strong>指定种子是为了实现可重复的随机</strong>。比如用于模拟测试程序中，模拟要求随机，但测试要求可重复。在北京购车摇号程序中，种子也是指定的，后面我们还会介绍。种子到底扮演了什么角色呢？随机到底是如何产生的呢？让我们看下随机的基本原理。</p>
<h2 id="7-6-3-随机的基本原理"><a href="#7-6-3-随机的基本原理" class="headerlink" title="7.6.3 随机的基本原理"></a>7.6.3 随机的基本原理</h2><p>Random产生的随机数不是真正的随机数，相反，它产生的随机数一般称为<strong>伪随机数</strong>。真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。</p>
<p>伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。</p>
<p>数学运算是固定的，所以种子确定后，产生的随机数序列就是确定的，确定的数字序列当然不是真正的随机数，但种子不同，序列就不同，每个序列中数字的分布也都是比较随机和均匀的，所以称之为伪随机数。</p>
<p>Random的默认构造方法中没有传递种子，它会自动生成一个种子，这个种子数是一个真正的随机数，如下所示（Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">seedUniquifier</span></span><br><span class="line">    <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">8682522807148012L</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Random</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">seedUniquifier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(; ; ) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> seedUniquifier.get();</span><br><span class="line">    <span class="type">long</span> <span class="variable">next</span> <span class="operator">=</span> current ＊ <span class="number">181783497276652981L</span>;</span><br><span class="line">    <span class="keyword">if</span>(seedUniquifier.compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>种子是seedUniquifier()与System.nanoTime()按位异或的结果，System.nanoTime()返回一个更高精度（纳秒）的当前时间，seedUniquifier()里面的代码涉及一些多线程相关的知识，我们后续章节再介绍，简单地说，就是返回当前seedUniquifier（current变量）与一个常数181783497276652981L相乘的结果（next变量），然后，设置seedUniquifier的值为next，使用循环和compareAndSet都是为了确保在多线程的环境下不会有两次调用返回相同的值，保证随机性。</p>
<p>有了种子数之后，其他数是怎么生成的呢？我们来看一些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nextInt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextLong</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="type">long</span>)(next(<span class="number">32</span>)) &lt;&lt; <span class="number">32</span>) + next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">nextFloat</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">24</span>) / ((<span class="type">float</span>)(<span class="number">1</span> &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextBoolean</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">1</span>) ! = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们都调用了next(int bits)，生成指定位数的随机数，我们来看下它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">multiplier</span> <span class="operator">=</span> <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">addend</span> <span class="operator">=</span> <span class="number">0xBL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">mask</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">    <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed ＊ multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (! seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单地说，就是使用了如下公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextseed = (oldseed ＊ multiplier + addend) &amp; mask;</span><br></pre></td></tr></table></figure>

<p>旧的种子（oldseed）乘以一个数（multiplier），加上一个数addend，然后取低48位作为结果（mask相与）。</p>
<p>为什么采用这个方法？这个方法为什么可以产生随机数？这个方法的名称叫线性同余随机数生成器（linear congruential pseudorandom number generator），描述在《计算机程序设计艺术》一书中。随机的理论是一个比较复杂的话题，超出了本书的范畴，我们就不讨论了。</p>
<p>我们需要知道的基本原理是：随机数基于一个种子，种子固定，随机数序列就固定，默认构造方法中，种子是一个真正的随机数。</p>
<p>理解了随机的基本概念和原理，我们来看一些应用场景，包括随机密码、洗牌、带权重的随机选择、微信抢红包算法，以及北京购车摇号算法。</p>
<h2 id="7-6-4-随机密码"><a href="#7-6-4-随机密码" class="headerlink" title="7.6.4 随机密码"></a>7.6.4 随机密码</h2><p>在给用户生成账号时，经常需要给用户生成一个默认随机密码，然后通过邮件或短信发给用户，作为初次登录使用。我们假定密码是6位数字，代码很简单，如代码清单7-4所示。</p>
<center>代码清单7-4 生成随机密码：6位数字</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomPassword</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">        chars[i] = (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就不解释了。如果要求是8位密码，字符可能由大写字母、小写字母、数字和特殊符号组成，如代码清单7-5所示。</p>
<center>代码清单7-5 生成随机密码：简单8位</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SPECIAL_CHARS</span> <span class="operator">=</span> <span class="string">&quot;! @#$%^&amp;＊_=+-/&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextChar</span><span class="params">(Random rnd)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(rnd.nextInt(<span class="number">4</span>))&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>     (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomPassword</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        chars[i] = nextChar(rnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，对每个字符，先随机选类型，然后在给定类型中随机选字符。在笔者的计算机中，一次的随机运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8Ctp2S4H</span><br></pre></td></tr></table></figure>

<p>这个结果不含特殊字符。很多环境对密码复杂度有要求，比如，至少要含一个大写字母、一个小写字母、一个特殊符号、一个数字。以上的代码满足不了这个要求，怎么满足呢？一种可能的代码如代码清单7-6所示。</p>
<center>代码清单7-6 生成随机密码：复杂8位</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">char</span>[] chars, Random rnd)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> rnd.nextInt(chars.length);</span><br><span class="line">    <span class="keyword">while</span>(chars[index]! =<span class="number">0</span>)&#123;</span><br><span class="line">    index = rnd.nextInt(chars.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextSpecialChar</span><span class="params">(Random rnd)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextUpperlLetter</span><span class="params">(Random rnd)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextLowerLetter</span><span class="params">(Random rnd)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">nextNumLetter</span><span class="params">(Random rnd)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomPassword</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextSpecialChar(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextUpperlLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextLowerLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextNumLetter(rnd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            chars[i] = nextChar(rnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nextIndex随机生成一个未赋值的位置，程序先随机生成4个不同类型的字符，放到随机位置上，然后给未赋值的其他位置随机生成字符。</p>
<h2 id="7-6-5-洗牌"><a href="#7-6-5-洗牌" class="headerlink" title="7.6.5 洗牌"></a>7.6.5 洗牌</h2><p>一种常见的随机场景是洗牌，就是将一个数组或序列随机重新排列。我们以一个整数数组为例来介绍如何随机重排，如代码清单7-7所示。</p>
<center>代码清单7-7 随机重排</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=arr.length; i&gt;<span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shuffle方法能将参数数组arr随机重排，来看使用它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">shuffle(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>调用shuffle方法前，arr是排好序的，调用后，一次调用的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 8, 11, 10, 7, 9, 4, 1, 6, 12, 5, 0, 2]</span><br></pre></td></tr></table></figure>

<p>已经随机重新排序了。shuffle的基本思路是什么呢？从后往前，逐个给每个数组位置重新赋值，值是从剩下的元素中随机挑选的。在如下关键语句中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br></pre></td></tr></table></figure>

<p>i-1表示当前要赋值的位置，rnd.nextInt(i)表示从剩下的元素中随机挑选。</p>
<h2 id="7-6-6-带权重的随机选择"><a href="#7-6-6-带权重的随机选择" class="headerlink" title="7.6.6 带权重的随机选择"></a>7.6.6 带权重的随机选择</h2><p>实际场景中，经常要从多个选项中随机选择一个，不过，不同选项经常有不同的权重。比如，给用户随机奖励，三种面额：1元、5元和10元，权重分别为70、20和10。这个怎么实现呢？实现的基本思路是，使用概率中的累计概率分布。</p>
<p>以上面的例子来说，计算每个选项的累计概率值，首先计算总的权重，这里正好是100，每个选项的概率是70%、20%和10%，累计概率则分别是70%、90%和100%。</p>
<p>有了累计概率，则随机选择的过程是：使用nextDouble()生成一个0～1的随机数，然后使用二分查找，看其落入哪个区间，如果小于等于70%则选择第一个选项，70%和90%之间选第二个，90%以上选第三个，如图7-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209110957.jpeg" alt="epub_923038_54"></p>
<center>图7-2 选项的累计概率值</center>

<p>下面来看代码，我们使用一个类Pair表示选项和权重，如代码清单7-8所示。</p>
<center>代码清单7-8 表示选项和权重的类Pair</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    Object item;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(Object item, <span class="type">int</span> weight)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用一个类WeightRandom表示带权重的选择，如代码清单7-9所示。</p>
<center>代码清单7-9 带权重的选择WeightRandom</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeightRandom</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Pair[] options;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[] cumulativeProbabilities;</span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeightRandom</span><span class="params">(Pair[] options)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.options = options;</span><br><span class="line">        <span class="built_in">this</span>.rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        prepare();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">weights</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Pair pair : options)&#123;</span><br><span class="line">            weights += pair.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">        cumulativeProbabilities = <span class="keyword">new</span> <span class="title class_">double</span>[options.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;options.length; i++) &#123;</span><br><span class="line">            sum += options[i].getWeight();</span><br><span class="line">            cumulativeProbabilities[i] = sum / (<span class="type">double</span>)weights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">public</span> Object <span class="title function_">nextItem</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="type">double</span> <span class="variable">randomValue</span> <span class="operator">=</span> rnd.nextDouble();</span><br><span class="line">          <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(cumulativeProbabilities, randomValue);</span><br><span class="line">          <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = -index-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options[index].getItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，prepare()方法计算每个选项的累计概率，保存在数组cumulativeProbabilities中， nextItem()方法根据权重随机选择一个，具体就是，首先生成一个0～1的数，然后使用二分查找，如果没找到，返回结果是-（插入点）-1，所以-index-1就是插入点，插入点的位置就对应选项的索引。</p>
<p>回到上面的例子，随机选择10次，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pair[] options = <span class="keyword">new</span> <span class="title class_">Pair</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>), <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;2元&quot;</span>, <span class="number">2</span>), <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;10元&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">WeightRandom</span> <span class="variable">rnd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeightRandom</span>(options);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    System.out.print(rnd.nextItem()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次运行中，输出正好符合预期，具体为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1元 1元 1元 2元 1元 10元 1元 2元 1元 1元</span><br></pre></td></tr></table></figure>

<p>不过，需要说明的是，由于随机，每次执行结果比例不一定正好相等。</p>
<h2 id="7-6-7-抢红包算法"><a href="#7-6-7-抢红包算法" class="headerlink" title="7.6.7 抢红包算法"></a>7.6.7 抢红包算法</h2><p>我们都知道，微信可以抢红包，红包有一个总金额和总数量，领的时候随机分配金额。金额是怎么随机分配的呢？微信具体是怎么做的，我们并不能确切地知道，但如下思路可以达到该效果。</p>
<p>维护一个剩余总金额和总数量，分配时，如果数量等于1，直接返回总金额，如果大于1，则计算平均值，并设定随机最大值为平均值的两倍，然后取一个随机值，如果随机值小于0.01，则为0.01，这个随机值就是下一个的红包金额。</p>
<p>我们来看代码，如代码清单7-10所示，为计算方便，金额用整数表示，以分为单位。</p>
<center>代码清单7-10 抢红包算法</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomRedPacket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftMoney;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftNum;</span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomRedPacket</span><span class="params">(<span class="type">int</span> total, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.leftMoney = total;</span><br><span class="line">        <span class="built_in">this</span>.leftNum = num;</span><br><span class="line">        <span class="built_in">this</span>.rnd = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">nextMoney</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.leftNum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;抢光了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.leftNum==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.leftMoney;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">max</span> <span class="operator">=</span> <span class="built_in">this</span>.leftMoney/<span class="built_in">this</span>.leftNum＊<span class="number">2d</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> (<span class="type">int</span>)(rnd.nextDouble()＊max);</span><br><span class="line">        money = Math.max(<span class="number">1</span>, money);</span><br><span class="line">        <span class="built_in">this</span>.leftMoney -= money;</span><br><span class="line">        <span class="built_in">this</span>.leftNum --;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就不解释了。关于synchronized修饰符，此处可以忽略，留待第15章介绍。看一个使用的例子，总金额为10元，10个红包，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RandomRedPacket</span> <span class="variable">redPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomRedPacket</span>(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    System.out.print(redPacket.nextMoney()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一次输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">136 48 90 151 36 178 92 18 122 129</span><br></pre></td></tr></table></figure>

<p>如果是这个算法，那先抢好，还是后抢好呢？先抢肯定抢不到特别大的，不过，后抢也不一定会，这要看前面抢的金额，剩下的多就有可能抢到大的，剩下的少就不可能有大的。</p>
<h2 id="7-6-8-北京购车摇号算法"><a href="#7-6-8-北京购车摇号算法" class="headerlink" title="7.6.8 北京购车摇号算法"></a>7.6.8 北京购车摇号算法</h2><p>我们来看下影响很多人的北京购车摇号，它的算法是怎样的呢？思路大概是这样的：<br>1）每期摇号前，将每个符合摇号资格的人，分配一个从0到总数的编号，这个编号是公开的，比如总人数为2 304 567，则编号为0～2 304 566。<br>2）摇号第一步是生成一个随机种子数，这个随机种子数在摇号当天通过一定流程生成，整个过程由公证员公证，就是生成一个真正的随机数。<br>3）种子数生成后，然后就是循环调用类似Random.nextInt(int n)方法，生成中签的编号。</p>
<p>编号是事先确定的，种子数是当场公证随机生成的，是公开的，随机算法是公开透明的，任何人都可以根据公开的种子数和编号验证中签的编号。</p>
<h2 id="7-6-9-小结"><a href="#7-6-9-小结" class="headerlink" title="7.6.9 小结"></a>7.6.9 小结</h2><p>本节介绍了随机，介绍了Java中对随机的支持Math.random()以及Random类，介绍了其使用和实现原理，同时，介绍了随机的一些应用场景，包括随机密码、洗牌、带权重的随机选择、微信抢红包和北京购车摇号，完整的代码在github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.laoma.commoncls.c34下。</p>
<p>需要说明的是，Random类是线程安全的，也就是说，多个线程可以同时使用一个Random实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的ThreadLocalRandom类。另外，Java类库中还有一个随机类SecureRandom，可以产生安全性更高、随机性更强的随机数，用于安全加密等领域。</p>
<p>至此，关于常用基础类就介绍完了。我们深入分析了各种包装类、String、String-Builder、Arrays、日期和时间、以及随机，这些都是日常程序中经常用到的功能。还有一些基础类，限于篇幅，就不介绍了，比如UUID、Math和Objects,UUID用于随机生成需要确保唯一性的标识符，Math用于进行数学运算，Objects包含一些操作对象、检查条件的方法，具体可参看API文档。</p>
<p>之前章节中，我们经常提到泛型这一概念，它到底是什么呢？让我们下一章详细探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/703d32a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/703d32a8/" class="post-title-link" itemprop="url">7.5 剖析日期和时间</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/703d32a8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/703d32a8/" data-xid="/JavaReadingNotes/703d32a8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-5-剖析日期和时间"><a href="#7-5-剖析日期和时间" class="headerlink" title="7.5 剖析日期和时间"></a>7.5 剖析日期和时间</h1><p>本节，我们讨论Java 中日期和时间处理相关的API。日期和时间是一个比较复杂的概念，Java 8之前的设计有一些不足，业界有一个广泛使用的第三方类库Joda-Time, Java 8受Joda-Time影响，重新设计了日期和时间API，新增了一个包java.time。虽然Java 8之前的API有一些不足，但依然是被大量使用的，本节只介绍Java 8之前的API。关于Java 8的API，它使用了Lambda表达式，我们还没介绍，所以留待到第26章介绍。</p>
<p>下面，我们先来看一些基本概念，然后再介绍Java的日期和时间API。</p>
<h2 id="7-5-1-基本概念"><a href="#7-5-1-基本概念" class="headerlink" title="7.5.1 基本概念"></a>7.5.1 基本概念</h2><p>关于日期和时间，有一些基本概念，包括时区、时刻、纪元时、年历等。</p>
<h3 id="1．时区"><a href="#1．时区" class="headerlink" title="1．时区"></a>1．时区</h3><p>我们都知道，同一时刻，世界上各个地区的时间可能是不一样的，具体时间与时区有关。全球一共有24个时区，英国格林尼治是0时区，北京是东八区，也就是说格林尼治凌晨1点，北京是早上9点。0时区的时间也称为GMT+0时间，GMT是格林尼治标准时间，北京的时间就是GMT+8:00。</p>
<h3 id="2．时刻和纪元时"><a href="#2．时刻和纪元时" class="headerlink" title="2．时刻和纪元时"></a>2．时刻和纪元时</h3><p>所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。为什么要用这个时间呢？更多的是历史原因，本书就不介绍了。</p>
<p>格林尼治标准时间1970年1月1日0时0分0秒也被称为Epoch Time（纪元时）。</p>
<p>这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻，但各个地区对这个时刻的解读（如年月日时分秒）可能是不一样的。</p>
<p>对于1970年以前的时间，使用负数表示。</p>
<h3 id="3．年历"><a href="#3．年历" class="headerlink" title="3．年历"></a>3．年历</h3><p>我们都知道，中国有公历和农历之分，公历和农历都是年历，不同的年历，一年有多少月，每月有多少天，甚至一天有多少小时，这些可能都是不一样的。</p>
<p>比如，公历有闰年，闰年2月是29天，而其他年份则是28天，其他月份，有的是30天，有的是31天。农历有闰月，比如闰7月，一年就会有两个7月，一共13个月。</p>
<p>公历是世界上广泛采用的年历，除了公历，还有其他一些年历，比如日本也有自己的年历。Java API的设计思想是支持国际化的，支持多种年历，但没有直接支持中国的农历，本书主要讨论公历。</p>
<p>简单总结下，时刻是一个绝对时间，对时刻的解读，则是相对的，与年历和时区相关。</p>
<h3 id="7-5-2-日期和时间API"><a href="#7-5-2-日期和时间API" class="headerlink" title="7.5.2 日期和时间API"></a>7.5.2 日期和时间API</h3><p>Java API中关于日期和时间，有三个主要的类。</p>
<ul>
<li>Date：表示时刻，即绝对时间，与年月日无关。</li>
<li>Calendar：表示年历，Calendar是一个抽象类，其中表示公历的子类是Gregorian-Calendar。</li>
<li>DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat也是一个抽象类，其中最常用的子类是SimpleDateFormat。</li>
</ul>
<p>还有两个相关的类：</p>
<ul>
<li>TimeZone：表示时区。</li>
<li>Locale：表示国家（或地区）和语言。</li>
</ul>
<p>下面，我们来看这些类。</p>
<h3 id="1-Date"><a href="#1-Date" class="headerlink" title="1. Date"></a>1. Date</h3><p>Date是Java API中最早引入的关于日期的类，一开始，Date也承载了关于年历的角色，但由于不能支持国际化，其中的很多方法都已经过时了，被标记为了@Deprecated，不再建议使用。</p>
<p>Date表示时刻，内部主要是一个long类型的值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">long</span> fastTime;</span><br></pre></td></tr></table></figure>

<p>fastTime表示距离纪元时的毫秒数，此处，关于transient关键字，我们暂时忽略。</p>
<p>Date有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">long</span> date)</span> &#123;</span><br><span class="line">    fastTime = date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个构造方法是根据传入的毫秒数进行初始化；第二个构造方法是默认构造方法，它根据System.currentTimeMillis()的返回值进行初始化。System.currentTimeMillis()是一个常用的方法，它返回当前时刻距离纪元时的毫秒数。</p>
<p>Date中的大部分方法都已经过时了，其中没有过时的主要方法有下面这些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span> <span class="comment">//返回毫秒数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> <span class="comment">//主要就是比较内部的毫秒数是否相同</span></span><br><span class="line"><span class="comment">//与其他Date进行比较，如果当前Date的毫秒数小于参数中的返回-1，相同返回0，否则返回1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Date anotherDate)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(Date when)</span> <span class="comment">//判断是否在给定日期之前</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">after</span><span class="params">(Date when)</span> <span class="comment">//判断是否在给定日期之后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="comment">//哈希值算法与Long类似</span></span><br></pre></td></tr></table></figure>

<h3 id="2-TimeZone"><a href="#2-TimeZone" class="headerlink" title="2. TimeZone"></a>2. TimeZone</h3><p>TimeZone表示时区，它是一个抽象类，有静态方法用于获取其实例。获取当前的默认时区，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimeZone</span> <span class="variable">tz</span> <span class="operator">=</span> TimeZone.getDefault();</span><br><span class="line">System.out.println(tz.getID());</span><br></pre></td></tr></table></figure>

<p>获取默认时区，并输出其ID，在笔者的计算机中，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>默认时区是在哪里设置的呢？可以更改吗？Java中有一个系统属性user.timezone，保存的就是默认时区。系统属性可以通过System.getProperty获得，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.timezone&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在笔者的计算机中，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>系统属性可以在Java启动的时候传入参数进行更改，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Duser.timezone=Asia/Shanghai xxxx</span><br></pre></td></tr></table></figure>

<p>TimeZone也有静态方法，可以获得任意给定时区的实例。比如，获取美国东部时区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimeZone</span> <span class="variable">tz</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;US/Eastern&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>ID除了可以是名称外，还可以是GMT形式表示的时区，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TimeZone</span> <span class="variable">tz</span> <span class="operator">=</span> TimeZone.getTimeZone(<span class="string">&quot;GMT+08:00&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-Locale"><a href="#3-Locale" class="headerlink" title="3. Locale"></a>3. Locale</h3><p>Locale表示国家（或地区）和语言，它有两个主要参数：一个是国家（或地区）；另一个是语言，每个参数都有一个代码，不过国家（或地区）并不是必需的。比如，中国内地的代码是CN，中国台湾地区的代码是TW，美国的代码是US，中文语言的代码是zh，英文语言的代码是en。</p>
<p>Locale类中定义了一些静态变量，表示常见的Locale，比如：</p>
<ul>
<li>Locale.US：表示美国英语。</li>
<li>Locale.ENGLISH：表示所有英语。</li>
<li>Locale.TAIWAN：表示中国台湾地区所用的中文。</li>
<li>Locale.CHINESE：表示所有中文。</li>
<li>Locale.SIMPLIFIED_CHINESE：表示中国内地所用的中文。</li>
</ul>
<p>与TimeZone类似，Locale也有静态方法获取默认值，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Locale</span> <span class="variable">locale</span> <span class="operator">=</span> Locale.getDefault();</span><br><span class="line">System.out.println(locale.toString());</span><br></pre></td></tr></table></figure>

<p>在笔者的计算机中，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zh_CN</span><br></pre></td></tr></table></figure>

<h3 id="4-Calendar"><a href="#4-Calendar" class="headerlink" title="4. Calendar"></a>4. Calendar</h3><p>Calendar类是日期和时间操作中的主要类，它表示与TimeZone和Locale相关的日历信息，可以进行各种相关的运算。我们先来看下它的内部组成，与Date类似，Calendar内部也有一个表示时刻的毫秒数，定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">long</span> time;</span><br></pre></td></tr></table></figure>

<p>除此之外，Calendar内部还有一个数组，表示日历中各个字段的值，定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> fields[];</span><br></pre></td></tr></table></figure>

<p>这个数组的长度为17，保存一个日期中各个字段的值，都有哪些字段呢？Calendar类中定义了一些静态变量，表示这些字段，主要有：</p>
<ul>
<li>Calendar.YEAR：表示年。</li>
<li>Calendar.MONTH：表示月，1月是0, Calendar同样定义了表示各个月份的静态变量，如Calendar.JULY表示7月。</li>
<li>Calendar.DAY_OF_MONTH：表示日，每月的第一天是1。</li>
<li>Calendar.HOUR_OF_DAY：表示小时，为0～23。</li>
<li>Calendar.MINUTE：表示分钟，为0～59。</li>
<li>Calendar.SECOND：表示秒，为0～59。</li>
<li>Calendar.MILLISECOND：表示毫秒，为0～999。</li>
<li>Calendar.DAY_OF_WEEK：表示星期几，周日是1，周一是2，周六是7,Calenar同样定义了表示各个星期的静态变量，如Calendar.SUNDAY表示周日。</li>
</ul>
<p>Calendar是抽象类，不能直接创建对象，它提供了多个静态方法，可以获取Calendar实例，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title function_">getInstance</span><span class="params">(TimeZone zone, Locale aLocale)</span></span><br></pre></td></tr></table></figure>

<p>最终调用的方法都是需要TimeZone和Locale的，如果没有，则会使用上面介绍的默认值。getInstance方法会根据TimeZone和Locale创建对应的Calendar子类对象，在中文系统中，子类一般是表示公历的GregorianCalendar。</p>
<p>getInstance方法封装了Calendar对象创建的细节。TimeZone和Locale不同，具体的子类可能不同，但都是Calendar。这种隐藏对象创建细节的方式，是计算机程序中一种常见的设计模式，它有一个名字，叫工厂方法，getInstance就是一个工厂方法，它生产对象。</p>
<p>与new Date()类似，新创建的Calendar对象表示的也是当前时间，与Date不同的是， Calendar对象可以方便地获取年月日等日历信息。来看代码，输出当前时间的各种信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;year: &quot;</span>+calendar.get(Calendar.YEAR));</span><br><span class="line">System.out.println(<span class="string">&quot;month: &quot;</span>+calendar.get(Calendar.MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;day: &quot;</span>+calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;hour: &quot;</span>+calendar.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(<span class="string">&quot;minute: &quot;</span>+calendar.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;second: &quot;</span>+calendar.get(Calendar.SECOND));</span><br><span class="line">System.out.println(<span class="string">&quot;millisecond: &quot;</span> +calendar.get(Calendar.MILLISECOND));</span><br><span class="line">System.out.println(<span class="string">&quot;day_of_week: &quot;</span> + calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>

<p>具体输出与执行时的时间和默认的TimeZone以及Locale有关，比如，在笔者的计算机中的一次输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">year: 2016</span><br><span class="line">month: 7</span><br><span class="line">day: 14</span><br><span class="line">hour: 13</span><br><span class="line">minute: 55</span><br><span class="line">second: 51</span><br><span class="line">millisecond: 564</span><br><span class="line">day_of_week: 2</span><br></pre></td></tr></table></figure>

<p>内部，Calendar会将表示时刻的毫秒数，按照TimeZone和Locale对应的年历，计算各个日历字段的值，存放在fields数组中，Calendar.get方法获取的就是fields数组中对应字段的值。</p>
<p>Calendar支持根据Date或毫秒数设置时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setTime</span><span class="params">(Date date)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeInMillis</span><span class="params">(<span class="type">long</span> millis)</span></span><br></pre></td></tr></table></figure>

<p>也支持根据年月日等日历字段设置时间，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> date,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> hourOfDay, <span class="type">int</span> minute, <span class="type">int</span> second)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> value)</span></span><br></pre></td></tr></table></figure>

<p>除了直接设置，Calendar支持根据字段增加和减少时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span></span><br></pre></td></tr></table></figure>

<p>amount为正数表示增加，负数表示减少。</p>
<p>比如，如果想设置Calendar为第二天的下午2点15，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.set(Calendar.HOUR_OF_DAY, <span class="number">14</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">15</span>);</span><br><span class="line">calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Calendar的这些方法中一个比较方便和强大的地方在于，它能够自动调整相关的字段。比如，我们知道2月最多有29天，如果当前时间为1月30号，对Calendar.MONTH字段加1，即增加一月，Calendar不是简单的只对月字段加1，那样日期是2月30号，是无效的，Calendar会自动调整为2月最后一天，即2月28日或29日。</p>
<p>再如，设置的值可以超出其字段最大范围，Calendar会自动更新其他字段，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.HOUR_OF_DAY, <span class="number">48</span>);</span><br><span class="line">calendar.add(Calendar.MINUTE, -<span class="number">120</span>);</span><br></pre></td></tr></table></figure>

<p>相当于增加了46小时。</p>
<p>内部，根据字段设置或修改时间时，Calendar会更新fields数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候， Calendar会重新计算并更新相关字段。</p>
<p>简单总结下，Calenar做了一项非常烦琐的工作，根据TimeZone和Locale，在绝对时间毫秒数和日历字段之间自动进行转换，且对不同日历字段的修改进行自动同步更新。</p>
<p>除了add方法，Calendar还有一个类似的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roll</span><span class="params">(<span class="type">int</span> field, <span class="type">int</span> amount)</span></span><br></pre></td></tr></table></figure>

<p>与add方法的区别是，roll方法不影响时间范围更大的字段值。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.HOUR_OF_DAY, <span class="number">13</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">calendar.add(Calendar.MINUTE, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>calendar首先设置为13:59，然后分钟字段加3，执行后的calendar时间为14:02。如果add改为roll，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.roll(Calendar.MINUTE, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>则执行后的calendar时间会变为13:02，在分钟字段上执行roll方法不会改变小时的值。</p>
<p>Calendar可以方便地转换为Date或毫秒数，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title function_">getTime</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getTimeInMillis</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>与Date类似，Calendar之间也可以进行比较，也实现了Comparable接口，相关方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Calendar anotherCalendar)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">after</span><span class="params">(Object when)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">before</span><span class="params">(Object when)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-DateFormat"><a href="#5-DateFormat" class="headerlink" title="5. DateFormat"></a>5. DateFormat</h3><p>DateFormat类主要在Date和字符串表示之间进行相互转换，它有两个主要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">format</span><span class="params">(Date date)</span></span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String source)</span></span><br></pre></td></tr></table></figure>

<p>format将Date转换为字符串，parse将字符串转换为Date。</p>
<p>Date的字符串表示与TimeZone和Locale都是相关的，除此之外，还与两个格式化风格有关，一个是日期的格式化风格，另一个是时间的格式化风格。DateFormat定义了4个静态变量，表示4种风格：SHORT、MEDIUM、LONG和FULL；还定义了一个静态变量DEFAULT，表示默认风格，值为MEDIUM，不同风格输出的信息详细程度不同。</p>
<p>与Calendar类似，DateFormat也是抽象类，也用工厂方法创建对象，提供了多个静态方法创建DateFormat对象，有三类方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title function_">getDateInstance</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>public final static DateFormat getTimeInstance()</p>
<p>getDateTimeInstance方法既处理日期也处理时间，getDateInstance方法只处理日期，get-TimeInstance方法只处理时间。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//2016-08-15 14:15:20</span></span><br><span class="line">calendar.set(<span class="number">2016</span>, <span class="number">07</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(DateFormat.getDateTimeInstance()</span><br><span class="line">        .format(calendar.getTime()));</span><br><span class="line">System.out.println(DateFormat.getDateInstance()</span><br><span class="line">        .format(calendar.getTime()));</span><br><span class="line">System.out.println(DateFormat.getTimeInstance()</span><br><span class="line">        .format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-8-15 14:15:20</span><br><span class="line">2016-8-15</span><br><span class="line">14:15:20</span><br></pre></td></tr></table></figure>

<p>每类工厂方法都有两个重载的方法，接受日期和时间风格以及Locale作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">(<span class="type">int</span> dateStyle, <span class="type">int</span> timeStyle)</span></span><br><span class="line">DateFormat <span class="title function_">getDateTimeInstance</span><span class="params">(<span class="type">int</span> dateStyle, <span class="type">int</span> timeStyle, Locale aLocale)</span></span><br></pre></td></tr></table></figure>

<p>比如，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//2016-08-15 14:15:20</span></span><br><span class="line">calendar.set(<span class="number">2016</span>, <span class="number">07</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(DateFormat.getDateTimeInstance(DateFormat.LONG,</span><br><span class="line">    DateFormat.SHORT, Locale.CHINESE).format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016年8月15日 下午2:15</span><br></pre></td></tr></table></figure>

<p>DateFormat的工厂方法里，我们没看到TimeZone参数，不过，DateFormat提供了一个setter方法，可以设置TimeZone：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTimeZone</span><span class="params">(TimeZone zone)</span></span><br></pre></td></tr></table></figure>

<p>DateFormat虽然比较方便，但如果我们要对字符串格式有更精确的控制，则应该使用SimpleDateFormat这个类。</p>
<h3 id="6-SimpleDateFormat"><a href="#6-SimpleDateFormat" class="headerlink" title="6. SimpleDateFormat"></a>6. SimpleDateFormat</h3><p>SimpleDateFormat是DateFormat的子类，相比DateFormat，它的一个主要不同是，它可以接受一个自定义的模式（pattern）作为参数，这个模式规定了Date的字符串形式。先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//2016-08-15 14:15:20</span></span><br><span class="line">calendar.set(<span class="number">2016</span>, <span class="number">07</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(</span><br><span class="line">    <span class="string">&quot;yyyy年MM月dd日 E HH时mm分ss秒&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016年08月15日 星期一 14时15分20秒</span><br></pre></td></tr></table></figure>
<p>SimpleDateFormat有个构造方法，可以接受一个pattern作为参数，这里pattern是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyyy年MM月dd日 E HH时mm分ss秒</span><br></pre></td></tr></table></figure>

<p>pattern中的英文字符a～z和A～Z表示特殊含义，其他字符原样输出，这里：</p>
<ul>
<li>yyyy：表示4位的年。</li>
<li>MM：表示月，用两位数表示。</li>
<li>dd：表示日，用两位数表示。</li>
<li>HH：表示24小时制的小时数，用两位数表示。</li>
<li>mm：表示分钟，用两位数表示。</li>
<li>ss：表示秒，用两位数表示。</li>
<li>E：表示星期几。</li>
</ul>
<p>这里需要特意提醒一下，hh也表示小时数，但表示的是12小时制的小时数，而a表示的是上午还是下午，看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">//2016-08-15 14:15:20</span><br><span class="line">calendar.set(2016, 07, 15, 14, 15, 20);</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd hh:mm:ss a&quot;);</span><br><span class="line">System.out.println(sdf.format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016/08/15 02:15:20 下午</span><br></pre></td></tr></table></figure>

<p>更多的特殊含义可以参看SimpleDateFormat的API文档。如果想原样输出英文字符，可以将其用单引号括起来。</p>
<p>除了将Date转换为字符串，SimpleDateFormat也可以方便地将字符串转化为Date，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;2016-08-15 14:15:20.456&quot;</span>;</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> sdf.parse(str);</span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">sdf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年M月d h:m:s.S a&quot;</span>);</span><br><span class="line">    System.out.println(sdf2.format(date));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016年8月15 2:15:20.456 下午</span><br></pre></td></tr></table></figure>

<p>代码将字符串解析为了一个Date对象，然后使用另外一个格式进行了输出，这里SSS表示三位的毫秒数。需要注意的是，parse会抛出一个受检异常，异常类型为ParseException，调用者必须进行处理。</p>
<h2 id="7-5-3-局限性"><a href="#7-5-3-局限性" class="headerlink" title="7.5.3 局限性"></a>7.5.3 局限性</h2><p>至此，关于Java 8之前的日期和时间相关API的主要内容基本就介绍完了。Date表示时刻，与年月日无关，Calendar表示日历，与时区和Locale相关，可进行各种运算，是日期时间操作的主要类，DateFormat&#x2F;SimpleDateFormat在Date和字符串之间进行相互转换。这些API存在着一些局限性，下面强调一下。</p>
<h3 id="1-Date中的过时方法"><a href="#1-Date中的过时方法" class="headerlink" title="1. Date中的过时方法"></a>1. Date中的过时方法</h3><p>Date中的方法参数与常识不符合，过时方法标记容易被人忽略，产生误用。比如，看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2016</span>,<span class="number">8</span>,<span class="number">15</span>);</span><br><span class="line">System.out.println(DateFormat.getDateInstance().format(date));</span><br></pre></td></tr></table></figure>

<p>想当然的输出为2016-08-15，但其实输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3916-9-15</span><br></pre></td></tr></table></figure>

<p>之所以产生这个输出，是因为Date构造方法中的year表示的是与1900年的差，month是从0开始的。</p>
<h3 id="2-Calendar操作比较烦琐"><a href="#2-Calendar操作比较烦琐" class="headerlink" title="2. Calendar操作比较烦琐"></a>2. Calendar操作比较烦琐</h3><p>Calendar API的设计不是很成功，一些简单的操作都需要多次方法调用，写很多代码，比较臃肿。</p>
<p>另外，Calendar难以进行比较复杂的日期操作，比如，计算两个日期之间有多少个月，根据生日计算年龄，计算下个月的第一个周一等。</p>
<h3 id="3-DateFormat的线程安全性"><a href="#3-DateFormat的线程安全性" class="headerlink" title="3. DateFormat的线程安全性"></a>3. DateFormat的线程安全性</h3><p>DateFormat&#x2F;SimpleDateFormat不是线程安全的。关于线程概念，第15章会详细介绍，这里简单说明一下。多个线程同时使用一个DateFormat实例的时候，会有问题，因为DateFormat内部使用了一个Calendar实例对象，多线程同时调用的时候，这个Calendar实例的状态可能就会紊乱。</p>
<p>解决这个问题大概有以下方案：</p>
<ul>
<li>每次使用DateFormat都新建一个对象。</li>
<li>使用线程同步（第15章介绍）。</li>
<li>使用ThreadLocal（第19章介绍）。</li>
<li>使用Joda-Time或Java 8的API，它们是线程安全的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/31a72ecb/" class="post-title-link" itemprop="url">7.0 第7章 常用基础类 7.1 包装类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-08 22:05:54" itemprop="dateModified" datetime="2021-12-08T22:05:54+08:00">2021-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31a72ecb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31a72ecb/" data-xid="/JavaReadingNotes/31a72ecb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第7章-常用基础类"><a href="#第7章-常用基础类" class="headerlink" title="第7章 常用基础类"></a>第7章 常用基础类</h1><p>本章介绍Java编程中一些常用的基础类，探讨它们的用法、应用和实现原理，这些类有：</p>
<ul>
<li>各种包装类；</li>
<li>文本处理的类String和StringBuilder；</li>
<li>数组操作的类Arrays；</li>
<li>日期和时间处理；</li>
<li>随机。</li>
</ul>
<h1 id="7-1-包装类"><a href="#7-1-包装类" class="headerlink" title="7.1 包装类"></a>7.1 包装类</h1><p>Java有8种基本类型，每种基本类型都有一个对应的包装类。包装类是什么呢？它是一个类，内部有一个实例变量，保存对应的基本类型的值，这个类一般还有一些静态方法、静态变量和实例方法，以方便对数据进行操作。Java中，基本类型和对应的包装类如表7-1所示。</p>
<center>表7-1 基本类型和对应的包装类</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213344.jpeg" alt="epub_923038_50"><br>包装类也都很好记，除了Integer和Character外，其他类名称与基本类型基本一样，只是首字母大写。包装类有什么用呢？Java中很多代码（比如后续章节介绍的容器类）只能操作对象，为了能操作基本类型，需要使用其对应的包装类。另外，包装类提供了很多有用的方法，可以方便对数据的操作。下面先介绍各个包装类的基本用法及其共同点，然后重点介绍Integer和Character。</p>
<h2 id="7-1-1-基本用法"><a href="#7-1-1-基本用法" class="headerlink" title="7.1.1 基本用法"></a>7.1.1 基本用法</h2><p>各个包装类都可以与其对应的基本类型相互转换，方法也是类似的，部分类型如表7-2所示。</p>
<center>表7-2 包装类与基本类型的转换</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213434.jpeg" alt="epub_923038_51"><br>包装类与基本类型的转换代码结构是类似的，每种包装类都有一个静态方法valueOf()，接受基本类型，返回引用类型，也都有一个实例方法xxxValue()返回对应的基本类型。</p>
<p>将基本类型转换为包装类的过程，一般称为“装箱”，而将包装类型转换为基本类型的过程，则称为“拆箱”。装箱&#x2F;拆箱写起来比较烦琐，Java 5以后引入了自动装箱和拆箱技术，可以直接将基本类型赋值给引用类型，反之亦可，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure>

<p>自动装箱&#x2F;拆箱是Java编译器提供的能力，背后，它会替换为调用对应的valueOf&#x2F;xxx-Value方法，比如，上面的代码会被Java编译器替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a.intValue();</span><br></pre></td></tr></table></figure>

<p>每种包装类也都有构造方法，可以通过new创建，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">100</span>);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">12.345</span>);</span><br><span class="line"><span class="type">Character</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Character</span>(<span class="string">&#x27;马&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>那到底应该用静态的valueOf方法，还是使用new呢？一般建议使用valueOf方法。new每次都会创建一个新对象，而除了Float和Double外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，提升性能。实际上，从Java 9开始，这些构造方法已经被标记为过时了，推荐使用静态的valueOf方法。</p>
<h2 id="7-1-2-共同点"><a href="#7-1-2-共同点" class="headerlink" title="7.1.2 共同点"></a>7.1.2 共同点</h2><p>各个包装类有很多共同点，比如，都重写了Object中的一些方法，都实现了Comparable接口，都有一些与String有关的方法，大部分都定义了一些静态常量，都是不可变的。下面具体介绍。</p>
<h3 id="1．重写Object方法"><a href="#1．重写Object方法" class="headerlink" title="1．重写Object方法"></a>1．重写Object方法</h3><p>所有包装类都重写了Object类的如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">toString</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>我们分别介绍。</p>
<h4 id="（1）equals"><a href="#（1）equals" class="headerlink" title="（1）equals"></a>（1）equals</h4><p>equals用于判断当前对象和参数传入的对象是否相同，Object类的默认实现是比较地址，对于两个变量，只有这两个变量指向同一个对象时，equals才返回true，它和比较运算符（&#x3D;&#x3D;）的结果是一样的。</p>
<p>equals应该反映的是对象间的逻辑相等关系，所以这个默认实现一般是不合适的，子类需要重写该实现。所有包装类都重写了该实现，实际比较用的是其包装的基本类型值，比如，对于Long类，其equals方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Float，其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">        &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Float有一个静态方法floatToIntBits()，将float的二进制表示看作int。需要注意的是，只有两个float的二进制表示完全一样的时候，equals才会返回true。在2.2节的时候，我们提到小数计算是不精确的，数学概念上运算结果一样，但计算机运算结果可能不同，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">0.01f</span>;</span><br><span class="line"><span class="type">Float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">0.1f</span>＊<span class="number">0.1f</span>;</span><br><span class="line">System.out.println(f1.equals(f2));</span><br><span class="line">System.out.println(Float.floatToIntBits(f1));</span><br><span class="line">System.out.println(Float.floatToIntBits(f2));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="number">1008981770</span></span><br><span class="line"><span class="number">1008981771</span></span><br></pre></td></tr></table></figure>

<p>也就是，两个浮点数不一样，将二进制看作整数也不一样，相差为1。</p>
<p>Double的equals方法与Float类似，它有一个静态方法doubleToLongBits，将double的二进制表示看作long，然后再按long比较。</p>
<h4 id="（2）hashCode"><a href="#（2）hashCode" class="headerlink" title="（2）hashCode"></a>（2）hashCode</h4><p>hashCode返回一个对象的哈希值。哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。一个对象的哈希值不能改变，相同对象的哈希值必须一样。不同对象的哈希值一般应不同，但这不是必需的，可以有对象不同但哈希值相同的情况。</p>
<p>比如，对于一个班的学生对象，hashCode可以是学生的出生日期，出生日期是不变的，不同学生生日一般不同，分布比较均匀，个别生日相同的也没关系。</p>
<p>hashCode和equals方法联系密切，<strong>对两个对象，如果equals方法返回true，则hashCode也必须一样</strong>。反之不要求，equal方法返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。hashCode的默认实现一般是将对象的内存地址转换为整数，<strong>子类如果重写了equals方法，也必须重写hashCode</strong>。之所以有这个规定，是因为Java API中很多类依赖于这个行为，尤其是容器中的一些类。</p>
<p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte、Short、Integer、Character, hashCode就是其内部值，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Boolean, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据基类类型值返回了两个不同的数，为什么选这两个值呢？它们是质数（即只能被1和自己整除的数），质数用于哈希时比较好，不容易冲突。</p>
<p>对于Long, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="type">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是高32位与低32位进行位异或操作。</p>
<p>对于Double, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与equals方法类似，将double的二进制表示看作long，然后再按long计算hashCode。</p>
<p>每个包装类也都重写了toString方法，返回对象的字符串表示，这个一般比较自然，不再赘述。</p>
<h3 id="2-Comparable"><a href="#2-Comparable" class="headerlink" title="2. Comparable"></a>2. Comparable</h3><p>每个包装类都实现了Java API中的Comparable接口。Comparable接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">bits</span> <span class="operator">=</span> doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span>(<span class="type">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;T&gt;</code>是泛型语法，我们在第8章介绍，T表示比较的类型，由实现接口的类传入。接口只有一个方法compareTo，当前对象与参数对象进行比较，在小于、等于、大于参数时，应分别返回-1、0、1。</p>
<p>各个包装类的实现基本都是根据基本类型值进行比较，不再赘述。对于Boolean,false小于true。对于Float和Double，存在和equals方法一样的问题，0.01和0.1*0.1相比的结果并不为0。</p>
<h3 id="3．包装类和String"><a href="#3．包装类和String" class="headerlink" title="3．包装类和String"></a>3．包装类和String</h3><p>除了toString方法外，包装类还有一些其他与String相关的方法。除了Character外，每个包装类都有一个静态的valueOf(String)方法，根据字符串表示返回包装类对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparable</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(T o)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也都有一个静态的parseXXX(String)方法，根据字符串表示返回基本类型值，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.valueOf(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="type">Float</span> <span class="variable">f</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;123.45f&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>都有一个静态的toString方法，根据基本类型值返回字符串表示，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;123.45&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boolean.toString(<span class="literal">true</span>));</span><br><span class="line">System.out.println(Double.toString(<span class="number">123.45</span>));</span><br></pre></td></tr></table></figure>

<p>对于整数类型，字符串表示除了默认的十进制外，还可以表示为其他进制，如二进制、八进制和十六进制，包装类有静态方法进行相互转换，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">123.45</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(<span class="number">12345</span>));       <span class="comment">//输出二进制</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">12345</span>));          <span class="comment">//输出十六进制</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;3039&quot;</span>, <span class="number">16</span>));        <span class="comment">//按十六进制解析</span></span><br></pre></td></tr></table></figure>

<h3 id="4．常用常量"><a href="#4．常用常量" class="headerlink" title="4．常用常量"></a>4．常用常量</h3><p>包装类中除了定义静态方法和实例方法外，还定义了一些静态变量。对于Boolean类型，有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11000000111001</span><br><span class="line">3039</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>所有数值类型都定义了MAX_VALUE和MIN_VALUE，表示能表示的最大&#x2F;最小值，比如，对Integer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">TRUE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Boolean</span> <span class="variable">FALSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>Float和Double还定义了一些特殊数值，比如正无穷、负无穷、非数值，如Double类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">POSITIVE_INFINITY</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0.0</span>; <span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NEGATIVE_INFINITY</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0.0</span>; <span class="comment">//负无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">NaN</span> <span class="operator">=</span> <span class="number">0.0d</span> / <span class="number">0.0</span>; <span class="comment">//非数值</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Number"><a href="#5-Number" class="headerlink" title="5. Number"></a>5. Number</h3><p>6种数值类型包装类有一个共同的父类Number。Number是一个抽象类，它定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">byteValue</span><span class="params">()</span></span><br><span class="line"><span class="type">short</span> <span class="title function_">shortValue</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">intValue</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">longValue</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">floatValue</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">doubleValue</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>通过这些方法，包装类实例可以返回任意的基本数值类型。</p>
<h3 id="6．不可变性"><a href="#6．不可变性" class="headerlink" title="6．不可变性"></a>6．不可变性</h3><p>包装类都是不可变类。所谓不可变是指实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：</p>
<ul>
<li>所有包装类都声明为了final，不能被继承。</li>
<li>内部基本类型值是私有的，且声明为了final。</li>
<li>没有定义setter方法。</li>
</ul>
<p>为什么要定义为不可变类呢？<strong>不可变使得程序更为简单安全</strong>，因为不用操心数据被意外改写的可能，可以安全地共享数据，尤其是在多线程的环境下。关于线程，我们在第15章介绍。</p>
<h2 id="7-1-3-剖析Integer与二进制算法"><a href="#7-1-3-剖析Integer与二进制算法" class="headerlink" title="7.1.3 剖析Integer与二进制算法"></a>7.1.3 剖析Integer与二进制算法</h2><p>本小节主要介绍Integer类， Long与Integer类似，就不再单独介绍了。一个简单的Integer还有什么要介绍的呢？它有一些二进制操作，包括位翻转和循环移位等，另外，我们也分析一下它的valueOf实现。为什么要关心实现代码呢？大部分情况下，确实不用关心，会用它就可以了，我们主要是学习其中的二进制操作。二进制是计算机的基础，但代码往往晦涩难懂，我们希望对其有一个更为清晰深刻的理解。</p>
<h3 id="1．位翻转"><a href="#1．位翻转" class="headerlink" title="1．位翻转"></a>1．位翻转</h3><p>Integer有两个静态方法，可以按位进行翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span></span><br></pre></td></tr></table></figure>

<p>位翻转就是将int当作二进制，左边的位与右边的位进行互换，reverse是按位进行互换， reverseBytes是按byte进行互换，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Integer.reverse(a);</span><br><span class="line">System.out.println(Integer.toBinaryString(r));</span><br><span class="line"><span class="type">int</span> <span class="variable">rb</span> <span class="operator">=</span> Integer.reverseBytes(a);</span><br><span class="line">System.out.println(Integer.toHexString(rb));</span><br></pre></td></tr></table></figure>

<p>a是整数，用十六进制赋值，首先输出其二进制字符串，接着输出reverse后的二进制，最后输出reverseBytes后的十六进制，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10010001101000101011001111000</span><br><span class="line">11110011010100010110001001000</span><br><span class="line">78563412</span><br></pre></td></tr></table></figure>

<p>reverseBytes是按字节翻转，78是十六进制表示的一个字节，12也是，所以结果78563412是比较容易理解的。二进制翻转初看是不对的，这是因为输出不是32位，输出时忽略了前面的0，我们补齐32位再看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00010010001101000101011001111000</span><br><span class="line">00011110011010100010110001001000</span><br></pre></td></tr></table></figure>

<p>这次结果就对了。这两个方法是怎么实现的呢？</p>
<p>先来看reverseBytes的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i &gt;&gt;&gt; <span class="number">24</span>)              ) |</span><br><span class="line">            ((i &gt;&gt;    <span class="number">8</span>) &amp;    <span class="number">0xFF00</span>) |</span><br><span class="line">            ((i &lt;&lt;    <span class="number">8</span>) &amp; <span class="number">0xFF0000</span>) |</span><br><span class="line">            ((i &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较晦涩，以参数i等于0x12345678为例，我们来分析执行过程：<br>1）<code>i&gt;&gt;&gt;24</code>无符号右移，最高字节挪到最低位，结果是0x00000012；<br>2）(<code>i&gt;&gt;8</code>) &amp; 0xFF00，左边第二个字节挪到右边第二个，i&gt;&gt;8结果是0x00123456，再进行&amp; 0xFF00，保留的是右边第二个字节，结果是0x00003400；<br>3）(<code>i &lt;&lt; 8</code>) &amp; 0xFF0000，右边第二个字节挪到左边第二个，i&lt;&lt;8结果是0x34567800，再进行&amp; 0xFF0000，保留的是右边第三个字节，结果是0x00560000；<br>4）<code>i&lt;&lt;24</code>，结果是0x78000000，最右字节挪到最左边。</p>
<p>这4个结果再进行或操作|，结果就是0x78563412，这样，通过左移、右移、与和或操作，就达到了字节翻转的目的。</p>
<p>我们再来看reverse的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">//HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然很短，但非常晦涩，到底是什么意思呢？代码第一行是一个注释，HD表示的是一本书，书名为Hacker’s Delight，中文版为《算法心得：高效算法的奥秘》, HD是它的缩写，Figure 7-1是书中的图7-1, reverse的代码就是复制了这本书中图7-1的代码，书中也说明了代码的思路，我们简要说明。</p>
<p>高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着是4位一组交换、然后是8位、16位，16位之后就完成了。这个思路不仅适用于二进制，而且适用于十进制，为便于理解，我们看个十进制的例子。比如对数字12345678进行翻转。</p>
<p>第一轮，相邻单一数字进行互换，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21 43 65 87</span><br></pre></td></tr></table></figure>

<p>第二轮，以两个数字为一组交换相邻的，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43 21 87 65</span><br></pre></td></tr></table></figure>

<p>第三轮，以4个数字为一组交换相邻的，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8765 4321</span><br></pre></td></tr></table></figure>

<p>翻转完成。</p>
<p>对十进制而言，这个效率并不高，但对于二进制而言，却是高效的，因为二进制可以在一条指令中交换多个相邻位。下面代码就是对相邻单一位进行互换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (x &amp; 0x55555555) &lt;&lt;   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;&gt;   1;</span><br></pre></td></tr></table></figure>

<p>5的二进制表示是0101,0x55555555的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01010101010101010101010101010101</span><br></pre></td></tr></table></figure>

<p>x &amp; 0x55555555就是取x的奇数位。</p>
<p>A的二进制表示是1010,0xAAAAAAAA的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10101010101010101010101010101010</span><br></pre></td></tr></table></figure>

<p>x &amp; 0xAAAAAAAA就是取x的偶数位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; 0x55555555) &lt;&lt;   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;&gt;   1;</span><br></pre></td></tr></table></figure>

<p>表示的就是x的奇数位向左移，偶数位向右移，然后通过|合并，达到相邻位互换的目的。这段代码可以有个小的优化，只使用一个常量0x55555555，后半部分先移位再进行与操作，变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555;</span><br></pre></td></tr></table></figure>

<p>同理，如下代码就是以两位为一组，对相邻位进行互换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x33333333) &lt;&lt; 2 | (i &amp; 0xCCCCCCCC)&gt;&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>3的二进制表示是0011,0x33333333的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00110011001100110011001100110011</span><br></pre></td></tr></table></figure>

<p>x &amp; 0x33333333就是取x以两位为一组的低半部分。</p>
<p>C的二进制表示是1100,0xCCCCCCCC的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11001100110011001100110011001100</span><br></pre></td></tr></table></figure>

<p>x &amp; 0xCCCCCCCC就是取x以两位为一组的高半部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x33333333) &lt;&lt; 2 | (i &amp; 0xCCCCCCCC)&gt;&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>表示的就是x以两位为一组，低半部分向高位移，高半部分向低位移，然后通过|合并，达到交换的目的。同样，可以去掉常量0xCCCCCCCC，代码可以优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x33333333) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x33333333;</span><br></pre></td></tr></table></figure>

<p>同理，下面代码就是以4位为一组进行交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x0f0f0f0f) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;</span><br></pre></td></tr></table></figure>

<p>到以8位为单位交换时，就是字节翻转了，可以写为如下更直接的形式，代码和reverse-Bytes基本完全一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &lt;&lt; 24) | ((i &amp; 0xff00) &lt;&lt; 8) |</span><br><span class="line">    ((i &gt;&gt;&gt; 8) &amp; 0xff00) | (i &gt;&gt;&gt; 24);</span><br></pre></td></tr></table></figure>

<p>reverse代码为什么要写得这么晦涩呢？或者说不能用更容易理解的方式写吗？比如，实现翻转，一种常见的思路是：第一个和最后一个交换，第二个和倒数第二个交换，直到中间两个交换完成。如果数据不是二进制位，这个思路是好的，但对于二进制位，这个思路的效率比较低。</p>
<p>CPU指令并不能高效地操作单个位，它操作的最小数据单位一般是32位（32位机器），另外，CPU可以高效地实现移位和逻辑运算，但实现加、减、乘、除运算则比较慢。</p>
<p>reverse<strong>是在充分利用CPU的这些特性，并行高效地进行相邻位的交换</strong>，也可以通过其他更容易理解的方式实现相同功能，但很难比这个代码更高效。</p>
<h3 id="2．循环移位"><a href="#2．循环移位" class="headerlink" title="2．循环移位"></a>2．循环移位</h3><p>Integer有两个静态方法可以进行循环移位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span></span><br></pre></td></tr></table></figure>

<p>rotateLeft方法是循环左移，rotateRight方法是循环右移，distance是移动的位数。所谓循环移位，是相对于普通的移位而言的，普通移位，比如左移2位，原来的最高两位就没有了，右边会补0，而如果是循环左移两位，则原来的最高两位会移到最右边，就像一个左右相接的环一样。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.rotateLeft(a, <span class="number">8</span>);</span><br><span class="line">System.out.println(Integer.toHexString(b));</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> Integer.rotateRight(a, <span class="number">8</span>);</span><br><span class="line">System.out.println(Integer.toHexString(c))</span><br></pre></td></tr></table></figure>

<p>b是a循环左移8位的结果，c是a循环右移8位的结果，所以输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">34567812</span><br><span class="line">78123456</span><br></pre></td></tr></table></figure>

<p>这两个函数的实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateLeft</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rotateRight</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;&gt;&gt; distance) | (i &lt;&lt; -distance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数中令人费解的是负数，如果distance是8，那i&gt;&gt;&gt;-8是什么意思呢？其实，实际的移位个数不是后面的直接数字，而是直接数字的最低5位的值，或者说是直接数字&amp;0x1f的结果。之所以这样，是因为5位最大表示31，移位超过31位对int整数是无效的。</p>
<p>理解了移动负数位的含义，就比较容易理解上面这段代码了，比如，-8的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111000</span><br></pre></td></tr></table></figure>

<p>其最低5位是11000，十进制表示就是24，所以i&gt;&gt;&gt;-8就是i&gt;&gt;&gt;24, i&lt;&lt;8 |i&gt;&gt;&gt;24就是循环左移8位。上面代码中，i&gt;&gt;&gt;-distance就是i&gt;&gt;&gt;(32-distance),i&lt;&lt;-distance就是i&lt;&lt;(32-distance)。</p>
<p>Integer中还有一些其他的位操作，具体可参看API文档。关于其实现代码，都有注释指向Hacker’s Delight这本书的相关章节，不再赘述。</p>
<h3 id="3-valueOf的实现"><a href="#3-valueOf的实现" class="headerlink" title="3. valueOf的实现"></a>3. valueOf的实现</h3><p>在前面，我们提到，创建包装类对象时，可以使用静态的valueOf方法，也可以直接使用new，但建议使用valueOf方法，为什么呢？我们来看Integer的valueOf的代码（基于Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它使用了IntegerCache，这是一个私有静态内部类，如代码清单7-1所示。</p>
<center>代码清单7-1 IntegerCache</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span> sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(integerCacheHighPropValue ! = <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">//Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">IntegerCache</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntegerCache表示Integer缓存，其中的cache变量是一个静态Integer数组，在静态初始化代码块中被初始化，默认情况下，保存了-128～127共256个整数对应的Integer对象。</p>
<p>在valueOf代码中，如果数值位于被缓存的范围，即默认-128～127，则直接从Integer-Cache中获取已预先创建的Integer对象，只有不在缓存范围时，才通过new创建对象。</p>
<p>通过共享常用对象，可以节省内存空间，由于Integer是不可变的，所以缓存的对象可以安全地被共享。Boolean、Byte、Short、Long、Character都有类似的实现。这种共享常用对象的思路，是一种常见的设计思路，它有一个名字，叫<strong>享元模式</strong>，英文叫Flyweight，即共享的轻量级元素。</p>
<h2 id="7-1-4-剖析Character"><a href="#7-1-4-剖析Character" class="headerlink" title="7.1.4 剖析Character"></a>7.1.4 剖析Character</h2><p>本节探讨Character类。Character类除了封装了一个char外，还有什么可介绍的呢？它有很多静态方法，封装了Unicode字符级别的各种操作，是Java文本处理的基础，注意不是char级别，Unicode字符并不等同于char，本节详细介绍这些方法。在此之前，先来回顾一下Unicode知识。</p>
<h3 id="1-Unicode基础"><a href="#1-Unicode基础" class="headerlink" title="1. Unicode基础"></a>1. Unicode基础</h3><p>Unicode给世界上每个字符分配了一个编号，编号范围为0x000000～0x10FFFF。编号范围在0x0000～0xFFFF的字符为常用字符集，称BMP（Basic MultilingualPlane）字符。编号范围在0x10000～0x10FFFF的字符叫做增补字符（supplementary character）。</p>
<p>Unicode主要规定了编号，但没有规定如何把编号映射为二进制。UTF-16是一种编码方式，或者叫映射方式，它将编号映射为两个或4个字节，对BMP字符，它直接用两个字节表示，对于增补字符，使用4个字节表示，前两个字节叫高代理项（high surrogate），范围为0xD800～0xDBFF，后两个字节叫低代理项（lowsurrogate），范围为0xDC00～0xDFFF。UTF-16定义了一个公式，可以将编号与4字节表示进行相互转换。</p>
<p>Java内部采用UTF-16编码，char表示一个字符，但只能表示BMP中的字符，对于增补字符，需要使用两个char表示，一个表示高代理项，一个表示低代理项。</p>
<p>使用int可以表示任意一个Unicode字符，低21位表示Unicode编号，高11位设为0。整数编号在Unicode中一般称为<strong>代码点</strong>（code point），表示一个Unicode字符，与之相对，还有一个词<strong>代码单元</strong>（code unit）表示一个char。</p>
<p>Character类中有很多相关静态方法，下面分别介绍。</p>
<h3 id="2．检查code-point和char"><a href="#2．检查code-point和char" class="headerlink" title="2．检查code point和char"></a>2．检查code point和char</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个int是不是一个有效的代码点，小于等于0x10FFFF的为有效，大于的为无效</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValidCodePoint</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//判断一个int是不是BMP字符，小于等于0xFFFF的为BMP字符，大于的不是</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isBmpCodePoint</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//判断一个int是不是增补字符，0x010000～0X10FFFF为增补字符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSupplementaryCodePoint</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//判断char是否是高代理项，0xD800～0xDBFF为高代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isHighSurrogate</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//判断char是否为低代理项，0xDC00～0xDFFF为低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLowSurrogate</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//判断char是否为代理项， char为低代理项或高代理项，则返回true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSurrogate</span><span class="params">(<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//判断两个字符high和low是否分别为高代理项和低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSurrogatePair</span><span class="params">(<span class="type">char</span> high, <span class="type">char</span> low)</span></span><br><span class="line"><span class="comment">//判断一个代码点由几个char组成，增补字符返回2, BMP字符返回1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">charCount</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-code-point与char的转换"><a href="#3-code-point与char的转换" class="headerlink" title="3. code point与char的转换"></a>3. code point与char的转换</h3><p>除了简单的检查外，Character类中还有很多方法，进行code point与char的相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据高代理项high和低代理项low生成代码点，这个转换有个公式，这个方法封装了这个公式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toCodePoint</span><span class="params">(<span class="type">char</span> high, <span class="type">char</span> low)</span></span><br><span class="line"><span class="comment">//根据代码点生成char数组，即UTF-16表示，如果code point为BMP字符，则返回的char</span></span><br><span class="line"><span class="comment">//数组长度为1，如果为增补字符，长度为2, char[0]为高代理项，char[1]为低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] toChars(<span class="type">int</span> codePoint)</span><br><span class="line"><span class="comment">//将代码点转换为char数组，与上面方法类似，只是结果存入指定数组dst的指定位置index</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toChars</span><span class="params">(<span class="type">int</span> codePoint, <span class="type">char</span>[] dst, <span class="type">int</span> dstIndex)</span></span><br><span class="line"><span class="comment">//对增补字符code point，生成低代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">lowSurrogate</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="comment">//对增补字符code point，生成高代理项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">highSurrogate</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<h3 id="4．按code-point处理char数组或序列"><a href="#4．按code-point处理char数组或序列" class="headerlink" title="4．按code point处理char数组或序列"></a>4．按code point处理char数组或序列</h3><p>Character包含若干方法，以方便按照code point处理char数组或序列。</p>
<p>返回char数组a中从offset开始count个char包含的code point个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointCount</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> offset, <span class="type">int</span> count)</span></span><br></pre></td></tr></table></figure>

<p>比如，如下代码输出为2, char个数为3，但code point为2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">chs[<span class="number">0</span>] = <span class="string">&#x27;马&#x27;</span>;</span><br><span class="line">Character.toChars(<span class="number">0x1FFFF</span>, chs, <span class="number">1</span>);</span><br><span class="line">System.out.println(Character.codePointCount(chs, <span class="number">0</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>除了接受char数组，还有一个重载的方法接受字符序列CharSequence：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointCount</span><span class="params">(CharSequence seq, <span class="type">int</span> beginIndex,<span class="type">int</span> endIndex)</span></span><br></pre></td></tr></table></figure>

<p>CharSequence是一个接口，它的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CharSequence</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">    CharSequence <span class="title function_">subSequence</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它与一个char数组是类似的，有length方法，有charAt方法根据索引获取字符，String类就实现了该接口。</p>
<p>返回char数组或序列中指定索引位置的code point：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointAt</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointAt</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index, <span class="type">int</span> limit)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointAt</span><span class="params">(CharSequence seq, <span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<p>如果指定索引位置为高代理项，下一个位置为低代理项，则返回两项组成的codepoint，检查下一个位置时，下一个位置要小于limit，没传limit时，默认为a.length。</p>
<p>返回char数组或序列中指定索引位置之前的code point：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointBefore</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointBefore</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> index, <span class="type">int</span> start)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">codePointBefore</span><span class="params">(CharSequence seq, <span class="type">int</span> index)</span></span><br></pre></td></tr></table></figure>

<p>codePointAt是往后找，codePointBefore是往前找，如果指定位置为低代理项，且前一个位置为高代理项，则返回两项组成的code point，检查前一个位置时，前一个位置要大于等于start，没传start时，默认为0。</p>
<p>根据code point偏移数计算char索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">offsetByCodePoints</span><span class="params">(<span class="type">char</span>[] a, <span class="type">int</span> start, <span class="type">int</span> count,<span class="type">int</span> index, <span class="type">int</span> codePointOffset)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">offsetByCodePoints</span><span class="params">(CharSequence seq, <span class="type">int</span> index,<span class="type">int</span> codePointOffset)</span></span><br></pre></td></tr></table></figure>

<p>如果字符数组或序列中没有增补字符，返回值为index+codePointOffset，如果有增补字符，则会将codePointOffset看作code point偏移，转换为字符偏移，start和count取字符数组的子数组。</p>
<p>比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chs = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">Character.toChars(<span class="number">0x1FFFF</span>, chs, <span class="number">1</span>);</span><br><span class="line">System.out.println(Character.offsetByCodePoints(chs, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>));<span class="comment">//输出结果为3, index和codePointOffset都为1，但第二个字符为增补字符，一个code point偏移是两个char偏移，所以结果为3。</span></span><br></pre></td></tr></table></figure>

<h3 id="5．字符属性"><a href="#5．字符属性" class="headerlink" title="5．字符属性"></a>5．字符属性</h3><p>Unicode在给每个字符分配一个编号之外，还分配了一些属性，Character类封装了对Unicode字符属性的检查和操作，下面介绍一些主要的属性。</p>
<p>获取字符类型（general category）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">(<span class="type">char</span> ch)</span></span><br></pre></td></tr></table></figure>

<p>Unicode给每个字符分配了一个类型，这个类型是非常重要的，很多其他检查和操作都是基于这个类型的。getType方法的参数可以是int类型的code point，也可以是char类型。char类型只能处理BMP字符，而int类型可以处理所有字符。Character类中很多方法都是既可以接受int类型，也可以接受char类型，后续只列出int类型的方法。返回值是int，表示类型，Character类中定义了很多静态常量表示这些类型，表7-3列出了一些字符、type值，以及Character类中常量的名称。</p>
<center>表7-3 常见字符类型值</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209094654.jpeg" alt="epub_923038_52"><br>检查字符是否在Unicode中被定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDefined</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>每个被定义的字符，其getType()返回值都不为0，如果返回值为0，表示无定义。注意与isValidCodePoint的区别，后者只要数字不大于0x10FFFF都返回true。</p>
<p>检查字符是否为数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isDigit</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>getType()返回值为DECIMAL_DIGIT_NUMBER的字符为数字。需要注意的是，不光字符’0’、’1’、……、’9’是数字，中文全角字符的0～9也是数字。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>; <span class="comment">//中文全角数字</span></span><br><span class="line">System.out.println((<span class="type">int</span>)ch+<span class="string">&quot;, &quot;</span>+Character.isDigit(ch));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65305, true</span><br></pre></td></tr></table></figure>

<p>全角字符的9, Unicode编号为65305，它也是数字。</p>
<p>检查是否为字母（Letter）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLetter</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>如果getType()的返回值为下列之一，则为Letter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPPERCASE_LETTER</span><br><span class="line">LOWERCASE_LETTER</span><br><span class="line">TITLECASE_LETTER</span><br><span class="line">MODIFIER_LETTER</span><br><span class="line">OTHER_LETTER</span><br></pre></td></tr></table></figure>

<p>除了TITLECASE_LETTER和MODIFIER_LETTER，其他在表7-3中有示例，而这两个平时碰到的也比较少，就不介绍了。</p>
<p>检查是否为字母或数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLetterOrDigit</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>只要其中之一返回true就返回true。</p>
<p>检查是否为字母（Alphabetic）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAlphabetic</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>这也是检查是否为字母，与isLetter的区别是：isLetter返回true时，isAlphabetic也必然返回true；此外，getType()值为LETTER_NUMBER时，isAlphabetic也返回true，而isLetter返回false。LETTER_NUMBER中常见的字符有罗马数字字符，如’I’、’Ⅱ’、’Ⅲ’、’Ⅳ’。</p>
<p>检查是否为空格字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSpaceChar</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p><code>getType()</code>值为<code>SPACE_SEPARATOR</code>,<code>LINE_SEPARATOR</code>和<code>PARAGRAPH_SEPARATOR</code>时，返回true。这个方法其实并不常用，因为它只能严格匹配空格字符本身，不能匹配实际产生空格效果的字符，如Tab控制键’<code>\t</code>‘。</p>
<p>更常用的检查空格的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isWhitespace</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>‘<code>\t</code>‘、’<code>\n</code>‘、全角空格’ ‘和半角空格’ ‘的返回值都为true。</p>
<p>检查是否为小写字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLowerCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>常见的小写字符主要是小写英文字母a～z。</p>
<p>检查是否为大写字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isUpperCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>常见的大写字符主要是大写英文字母A～Z。</p>
<p>检查是否为表意象形文字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isIdeographic</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>大部分中文都返回为true</p>
<p>检查是否为ISO 8859-1编码中的控制字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isISOControl</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>我们在第2章介绍过，0～31、127～159表示控制字符。</p>
<p>检查是否可作为Java标识符的第一个字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isJavaIdentifierStart</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>Java标识符是Java中的变量名、函数名、类名等，字母（Alphabetic）、美元符号（$）、下画线（_）可作为Java标识符的第一个字符，但数字字符不可以。</p>
<p>检查是否可作为Java标识符的中间字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isJavaIdentifierPart</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>相比isJavaIdentifierStart，主要多了数字字符，Java标识符的中间字符可以包含数字。</p>
<p>检查是否为镜像（mirrowed）字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMirrored</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>常见镜像字符有<code>( )</code>、<code>&#123; &#125;</code>、<code>&lt; &gt;</code>、<code>[ ]</code>，都有对应的镜像。</p>
<h3 id="6．字符转换"><a href="#6．字符转换" class="headerlink" title="6．字符转换"></a>6．字符转换</h3><p>Unicode除了规定字符属性外，对有大小写对应的字符，还规定了其对应的大小写，对有数值含义的字符，也规定了其数值。</p>
<p>我们先来看大小写，Character有两个静态方法，对字符进行大小写转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toLowerCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toUpperCase</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>这两个方法主要针对英文字符a～z和A～Z，例如：toLowerCase(‘A’)返回’a’,toUpper-Case(‘z’)返回’Z’。</p>
<p>返回一个字符表示的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getNumericValue</span><span class="params">(<span class="type">int</span> codePoint)</span></span><br></pre></td></tr></table></figure>

<p>字符’0’～’9’返回数值0～9，对于字符a～z，无论是小写字符还是大写字符，无论是普通英文还是中文全角，数值结果都是10～35。例如，如下代码的输出结果是一样的，都是10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//全角大写A</span></span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//全角小写a</span></span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>返回按给定进制表示的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digit</span><span class="params">(<span class="type">int</span> codePoint, <span class="type">int</span> radix)</span></span><br></pre></td></tr></table></figure>

<p>radix表示进制，常见的有二进制、八进制、十进制、十六进制，计算方式与get-NumericValue类似，只是会检查有效性，数值需要小于radix，如果无效，返回-1。例如：digit(‘F’,16)返回15，是有效的；但digit(‘G’,16)就无效，返回-1。</p>
<p>返回给定数值的字符形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">forDigit</span><span class="params">(<span class="type">int</span> digit, <span class="type">int</span> radix)</span></span><br></pre></td></tr></table></figure>

<p>与<code>digit(int codePoint, int radix)</code>相比，进行相反转换，如果数字无效，返回’<code>\0</code>‘。例如， <code>Character.forDigit(15, 16)</code>返回’<code>F</code>‘。</p>
<p>与Integer类似，Character也有按字节翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">reverseBytes</span><span class="params">(<span class="type">char</span> ch)</span></span><br></pre></td></tr></table></figure>

<p>例如，翻转字符0x1234：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toHexString(Character.reverseBytes((<span class="type">char</span>)<span class="number">0x1234</span>)));</span><br></pre></td></tr></table></figure>

<p>输出为3412。</p>
<p>至此，Characer类就介绍完了，它在Unicode字符级别（而非char级别）封装了字符的各种操作，通过将字符处理的细节交给Character类，其他类就可以在更高的层次上处理文本了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/36e750aa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/36e750aa/" class="post-title-link" itemprop="url">1.7 函数调用的基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 19:33:23" itemprop="dateCreated datePublished" datetime="2021-12-01T19:33:23+08:00">2021-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC1%E7%AB%A0-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第1章 编程基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/36e750aa/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/36e750aa/" data-xid="/JavaReadingNotes/36e750aa/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-7-函数调用的基本原理"><a href="#1-7-函数调用的基本原理" class="headerlink" title="1.7 函数调用的基本原理"></a>1.7 函数调用的基本原理</h1><p>在介绍递归函数的时候，我们看到了一个系统错误：java.lang.StackOverflowError，理解这个错误，需要理解函数调用的实现机制。下面，我们先来了解一个重要的概念：栈，然后再通过一些例子来仔细分析函数调用的过程。</p>
<h2 id="1-7-1-栈的概念"><a href="#1-7-1-栈的概念" class="headerlink" title="1.7.1 栈的概念"></a>1.7.1 栈的概念</h2><p>我们之前谈过程序执行的基本原理：CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。</p>
<p>基本上，这依然是成立的，程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。</p>
<p>但这里面有几个问题。<br>1）参数如何传递？<br>2）函数如何知道返回到什么地方？在if&#x2F;else、for中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。<br>3）函数结果如何传给调用方？</p>
<p>解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫<strong>栈</strong>。</p>
<p>栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据称为入栈，最下面的称为栈底，最上面的称为栈顶，从栈顶拿出数据通常称为出栈。栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最低的。</p>
<p>计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，以及函数内定义的局部变量。计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。返回值不太一样，它可能放在栈中，但它使用的栈和局部变量不完全一样，有的系统使用CPU内的一个存储器存储返回值，我们可以简单认为存在一个专门的返回值存储器。main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。</p>
<h2 id="1-7-2-函数执行的基本原理"><a href="#1-7-2-函数执行的基本原理" class="headerlink" title="1.7.2 函数执行的基本原理"></a>1.7.2 函数执行的基本原理</h2><p>以上描述可能有点抽象，我们通过一个例子来具体说明函数执行的过程，看个简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public class Sum &#123;</span><br><span class="line">2</span><br><span class="line">3      public static int sum(int a, int b) &#123;</span><br><span class="line">4           int c = a + b;</span><br><span class="line">5           return c;</span><br><span class="line">6      &#125;</span><br><span class="line">7</span><br><span class="line">8      public static void main(String[] args) &#123;</span><br><span class="line">9           int d = Sum.sum(1, 2);</span><br><span class="line">10          System.out.println(d);</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的例子，main函数调用了sum函数，计算1和2的和，然后输出计算结果，从概念上，这是容易理解的，让我们从栈的角度来讨论下。</p>
<p>当程序在main函数调用Sum.sum之前，栈的情况大概如图1-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221515.jpeg" alt="epub_923038_12"></p>
<center>图1-1 调用Sum.sum之前的栈示意图</center>

<p>栈中主要存放了两个变量args和d。在程序执行到Sum.sum的函数内部，准备返回之前，即第5行，栈的情况大概如图1-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221528.jpeg" alt="epub_923038_13"></p>
<center>图1-2 在Sum.sum内部，准备返回之前的栈示意图</center>

<p>我们解释下，在main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址（也就是调用函数结束后要执行的指令地址）入栈，接着跳转到sum函数，在sum函数内部，需要为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2，在返回之前，返回值保存到了专门的返回值存储器中。</p>
<p>在调用return后，程序会跳转到栈中保存的返回地址，即main的下一条指令地址，而sum函数相关的数据会出栈，从而又变回图1-1的样子。</p>
<p>main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。</p>
<p>函数执行的基本原理，简单来说就是这样。但有一些需要介绍的点，我们讨论一下。</p>
<p>我们在1.1节的时候说过，定义一个变量就会分配一块内存，但我们并没有具体谈什么时候分配内存，具体分配在哪里，什么时候释放内存。</p>
<p>从以上关于栈的描述我们可以看出，函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。但这个说法主要针对基本数据类型，接下来我们介绍数组和对象。</p>
<h2 id="1-7-3-数组和对象的内存分配"><a href="#1-7-3-数组和对象的内存分配" class="headerlink" title="1.7.3 数组和对象的内存分配"></a>1.7.3 数组和对象的内存分配</h2><p>对于数组和对象类型，我们介绍过，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续章节会进一步介绍）中，但存放地址的空间是分配在栈上的。我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayMax</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;max)&#123;</span><br><span class="line">                max = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> max(<span class="number">0</span>, arr);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序也很简单，main函数新建了一个数组，然后调用函数max计算0和数组中元素的最大值，在程序执行到max函数的return语句之前的时候，内存中栈和堆的情况如图1-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221610.jpeg" alt="epub_923038_14"></p>
<center>图1-3 参数有数组的内存栈和堆示意图</center>

<p>对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。</p>
<p>但说堆空间完全不受影响是不正确的，在这个例子中，当main函数执行结束，栈空间没有变量指向它的时候，Java系统会自动进行垃圾回收，从而释放这块空间。</p>
<h2 id="1-7-4-递归调用的原理"><a href="#1-7-4-递归调用的原理" class="headerlink" title="1.7.4 递归调用的原理"></a>1.7.4 递归调用的原理</h2><p>我们再通过栈的角度来理解一下递归函数的调用过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n＊factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> factorial(<span class="number">4</span>);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在factorial第一次被调用的时候，n是4，在执行到n<em>factorial(n-1)，即4</em>factorial(3)之前的时候，栈的情况大概如图1-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221645.jpeg" alt="epub_923038_15"></p>
<center>图1-4 递归调用栈示意图，n为4</center>

<p>注意，返回值存储器是没有值的，在调用factorial(3)后，栈的情况如图1-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221711.jpeg" alt="epub_923038_16"></p>
<center>图1-5 递归调用栈示意图，n为3</center>

<p>栈的深度增加了，返回值存储器依然为空，就这样，每递归调用一次，栈的深度就增加一层，每次调用都会分配对应的参数和局部变量，也都会保存调用的返回地址，在调用到n等于0的时候，栈的情况如图1-6所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221724.jpeg" alt="epub_923038_17"></p>
<center>图1-6 递归调用栈示意图，n为0</center>

<p>这个时候，终于有返回值了，我们将factorial简写为f。f(0)的返回值为1;f(0)返回到f(1), f(1)执行<code>1*f(0)</code>，结果也是1；然后返回到<code>f(2), f(2)</code>执行<code>2*f(1)</code>，结果是2；接着返回到<code>f(3), f(3)</code>执行<code>3*f(2)</code>，结果是6；然后返回到<code>f(4)</code>，执行<code>4*f(3)</code>，结果是24。</p>
<p>以上就是递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。</p>
<h2 id="1-7-5-小结"><a href="#1-7-5-小结" class="headerlink" title="1.7.5 小结"></a>1.7.5 小结</h2><p>本节介绍了函数调用的基本原理，<strong>函数调用主要是通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器存储的</strong>。</p>
<p>从函数调用的过程可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，如果程序可以比较容易地改为其他方式，应该考虑其他方式。另外，栈的空间不是无限的，一般正常调用都是没有问题的，但如果栈空间过深，系统就会抛出错误java.lang.StackOverflowError，即栈溢出。</p>
<p>至此，关于编程的基础知识，包括数据类型和变量、赋值、基本运算、流程控制中的条件执行和循环，以及函数的概念和基本原理，就介绍完了。我们谈到，在Java中，函数必须放在类中，目前我们简单认为类只是函数的容器，但类在Java中远不止有这个功能，它还承载了很多概念和思维方式，在探讨类的概念之前，在下一章，我们先来进一步理解下各种基本数据类型和文本背后的二进制表示。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/94ab78aa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/94ab78aa/" class="post-title-link" itemprop="url">1.6 函数的用法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 19:33:22" itemprop="dateCreated datePublished" datetime="2021-12-01T19:33:22+08:00">2021-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC1%E7%AB%A0-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第1章 编程基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/94ab78aa/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/94ab78aa/" data-xid="/JavaReadingNotes/94ab78aa/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-6-函数的用法"><a href="#1-6-函数的用法" class="headerlink" title="1.6 函数的用法"></a>1.6 函数的用法</h1><p>如果需要经常做某一种操作，则类似的代码需要重复写很多遍。比如在一个数组中查找某个数，第一次查找一个数，第二次可能查找另一个数，每查一个数，类似的代码都需要重写一遍，很罗唆。另外，有一些复杂的操作，可能分为很多个步骤，如果都放在一起，则代码难以理解和维护。</p>
<p>计算机程序使用<strong>函数</strong>这个概念来解决这个问题，即<strong>使用函数来减少重复代码和分解复杂操作</strong>。本节我们就来谈谈Java中的函数，包括函数的基本概念和一些细节，下节我们讨论函数的基本实现原理。</p>
<h2 id="1-6-1-基本概念"><a href="#1-6-1-基本概念" class="headerlink" title="1.6.1 基本概念"></a>1.6.1 基本概念</h2><p>函数这个概念，我们学数学的时候都接触过，其基本格式是y&#x3D;f(x)，表示的是x到y的对应关系，给定输入x，经过函数变换f，输出y。程序中的函数概念与其类似，也由输入、操作和输出组成，但它表示的是一段子程序，这个子程序有一个名字，表示它的目的（类比f），有零个或多个参数（类比x），有可能返回一个结果（类比y）。我们来看两个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print3Lines</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个函数的名字叫做sum，它的目的是对输入的两个数求和，有两个输入参数，分别是int整数a和b，它的操作是对两个数求和，求和结果放在变量sum中（这个sum和函数名字的sum没有任何关系），然后使用return语句将结果返回，最开始的public static是函数的修饰符，我们后续介绍。</p>
<p>第二个函数的名字叫做print3Lines，它的目的是在屏幕上输出三个空行，它没有输入参数，操作是使用一个循环输出三个空行，它没有返回值。</p>
<p>以上代码都比较简单，主要是演示函数的基本语法结构，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型  函数名字(参数类型 参数名字，…) &#123;</span><br><span class="line">    操作</span><br><span class="line">    <span class="keyword">return</span>返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的主要组成部分有以下几种。</p>
<p>1）函数名字：名字是不可或缺的，表示函数的功能。<br>2）参数：参数有0个到多个，每个参数由参数的数据类型和参数名字组成。<br>3）操作：函数的具体操作代码。<br>4）返回值：函数可以没有返回值，如果没有返回值则类型写成void，如果有则在函数代码中必须使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。<br>5）修饰符：Java中函数有很多修饰符，分别表示不同的目的，本节假定修饰符为public static，且暂不讨论这些修饰符的目的。</p>
<p>以上就是定义函数的语法。定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被<strong>调用</strong>。</p>
<p>Java中，任何函数都需要放在一个类中。类还没有介绍，我们暂时可以把类看作函数的一个容器，即函数放在类中，类中包括多个函数，Java中的函数一般叫做<strong>方法</strong>，我们不特别区分<strong>函数</strong>和<strong>方法</strong>，可能会交替使用。一个类里面可以定义多个函数，类里面可以定义一个叫做main的函数，形式如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数有特殊的含义，表示程序的入口，String[] args表示从控制台接收到的参数，我们暂时可以忽略它。Java中运行一个程序的时候，需要指定一个定义了main函数的类，Java会寻找main函数，并从main函数开始执行。</p>
<p>刚开始学编程的人可能会误以为程序从代码的第一行开始执行，这是错误的，不管main函数定义在哪里，Java函数都会先找到它，然后从它的第一行开始执行。</p>
<p>main函数中除了可以定义变量，操作数据，还可以<strong>调用</strong>其他函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(a, b);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    print3Lines();</span><br><span class="line">    System.out.println(sum(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用函数需要传递参数并处理返回值。main函数首先定义了两个变量a和b，接着调用了函数sum，并将a和b传递给了sum函数，然后将sum的结果赋值给了变量sum。</p>
<p>调用函数需要传递参数并处理返回值。main函数首先定义了两个变量a和b，接着调用了函数sum，并将a和b传递给了sum函数，然后将sum的结果赋值给了变量sum。</p>
<p>这里初学者需要注意的是，参数和返回值的名字是没有特别含义的。调用者main中的参数名字a和b，和函数定义sum中的参数名字a和b只是碰巧一样而已，它们完全可以不一样，而且名字之间没有关系，sum函数中不能使用main函数中的名字，反之也一样。调用者main中的sum变量和sum函数中的sum变量的名字也是碰巧一样而已，完全可以不一样。另外，变量和函数可以取一样的名字，但一样不代表有特别的含义。</p>
<p>调用函数如果没有参数要传递，也要加括号()，如print3Lines()。</p>
<p>传递的参数不一定是个变量，可以是常量，也可以是某个运算表达式，可以是某个函数的返回结果。比如：System.out.println(sum(3,4));，第一个函数调用sum(3,4)，传递的参数是常量3和4，第二个函数调用System.out.println传递的参数是sum(3,4)的返回结果。</p>
<p>关于参数传递，简单总结一下，定义函数时声明参数，实际上就是定义变量，只是这些变量的值是未知的，调用函数时传递参数，实际上就是给函数中的变量赋值。</p>
<p>函数可以调用同一个类中的其他函数，也可以调用其他类中的函数，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br></pre></td></tr></table></figure>

<p>调用Integer类中的toBinaryString函数，toBinaryString是Integer类中修饰符为public static的函数，表示输出一个整数的二进制表示。</p>
<p>对于需要重复执行的代码，可以定义函数，然后在需要的地方调用，这样可以减少重复代码。对于复杂的操作，可以将操作分为多个函数，会使得代码更加易读。</p>
<p>我们知道，程序执行基本上只有顺序执行、条件执行和循环执行，但更完整的描述应该包括函数的调用过程。程序从main函数开始执行，碰到函数调用的时候，会跳转进函数内部，函数调用了其他函数，会接着进入其他函数，函数返回后会继续执行调用后面的语句，返回到main函数并且main函数没有要执行的语句后程序结束。1.7节会更深入地介绍执行过程细节。在Java中，函数在程序代码中的位置和实际执行的顺序是没有关系的。</p>
<h2 id="1-6-2-进一步理解函数"><a href="#1-6-2-进一步理解函数" class="headerlink" title="1.6.2 进一步理解函数"></a>1.6.2 进一步理解函数</h2><p>函数的定义和基本调用应该是比较容易理解的，但有很多细节可能令初学者困惑，包括参数传递、返回、函数命名、调用过程等，我们逐个介绍。</p>
<h3 id="1．参数传递"><a href="#1．参数传递" class="headerlink" title="1．参数传递"></a>1．参数传递</h3><p>有两类特殊类型的参数：数组和可变长度的参数。</p>
<h4 id="（1）数组"><a href="#（1）数组" class="headerlink" title="（1）数组"></a>（1）数组</h4><p>数组作为参数与基本类型是不一样的，基本类型不会对调用者中的变量造成任何影响，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。我们看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;</span><br><span class="line">    reset(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。</p>
<p>这个其实也容易理解，我们在1.2节介绍过，一个数组变量有两块空间，一块用于存储数组内容本身，另一块用于存储内容的位置，给数组变量赋值不会影响原有的数组内容本身，而只会让数组变量指向一个不同的数组内容空间。</p>
<p>在上例中，函数参数中的数组变量arr和main函数中的数组变量arr存储的都是相同的位置，而数组内容本身只有一份数据，所以，在reset中修改数组元素内容和在main中修改是完全一样的。</p>
<h4 id="（2）可变长度的参数"><a href="#（2）可变长度的参数" class="headerlink" title="（2）可变长度的参数"></a>（2）可变长度的参数</h4><p>前面介绍的函数，参数个数都是固定的，但有时候可能希望参数个数不是固定的，比如求若干个数的最大值，可能是两个，也可能是多个。Java支持可变长度的参数，如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> ... a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> min;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&lt;a[i])&#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(max(<span class="number">0</span>));</span><br><span class="line">    System.out.println(max(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    System.out.println(max(<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>));</span><br><span class="line">    System.out.println(max(<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点“… ”，在函数内，可变长度参数可以看作是数组。可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度的参数。</p>
<p>可变长度参数实际上会转换为数组参数，也就是说，函数声明max(int min, int…a)实际上会转换为max(int min, int[] a)，在main函数调用max(0,2,4,5)的时候，实际上会转换为调用max(0, new int[]{2,4,5})，使用可变长度参数主要是简化了代码书写。</p>
<h3 id="2．理解返回"><a href="#2．理解返回" class="headerlink" title="2．理解返回"></a>2．理解返回</h3><p>对初学者，我们强调下return的含义。函数返回值类型为void时，return不是必需的，在没有return的情况下，会执行到函数结尾自动返回。return用于显式结束函数执行，返回调用方。</p>
<p>return可以用于函数内的任意地方，可以在函数结尾，也可以在中间，可以在if语句内，可以在for循环内，用于提前结束函数执行，返回调用方。</p>
<p>函数返回值类型为void也可以使用return，即“return; ”，不用带值，含义是返回调用方，只是没有返回值而已。</p>
<p>函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。</p>
<p>如果实际情况需要的返回值是一种复合结果呢？比如，查找一个字符数组中所有重复出现的字符以及重复出现的次数。这个可以用对象作为返回值，我们在第3章介绍类和对象。虽然返回值最多只能有一个，但其实一个也够了。</p>
<h3 id="3．重复的命名"><a href="#3．重复的命名" class="headerlink" title="3．重复的命名"></a>3．重复的命名</h3><p>每个函数都有一个名字，这个名字表示这个函数的意义，名字可以重复吗？在不同的类里，答案是肯定的，在同一个类里，要看情况。</p>
<p>同一个类里，函数可以重名，但是参数不能完全一样，即要么参数个数不同，要么参数个数相同但至少有一个参数类型不一样。</p>
<p>同一个类中函数名相同但参数不同的现象，一般称为函数重载。为什么需要函数重载呢？一般是因为函数想表达的意义是一样的，但参数个数或类型不一样。比如，求两个数的最大值，在Java的Math库中就定义了4个函数，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">max</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">float</span> <span class="title function_">max</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">max</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br></pre></td></tr></table></figure>

<h3 id="4．调用的匹配过程"><a href="#4．调用的匹配过程" class="headerlink" title="4．调用的匹配过程"></a>4．调用的匹配过程</h3><p>在之前介绍函数调用的时候，我们没有特别说明参数的类型。这里说明一下，参数传递实际上是给参数赋值，调用者传递的数据需要与函数声明的参数类型是匹配的，但不要求完全一样。什么意思呢？Java编译器会自动进行类型转换，并寻找最匹配的函数，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">System.out.println(Math.max(a, b));</span><br></pre></td></tr></table></figure>

<p>参数是字符类型的，但Math并没有定义针对字符类型的max函数，这是因为char其实是一个整数（我们在2.4节会说明）, Java会自动将char转换为int，然后调用Math. max(int a, int b)，屏幕会输出整数结果98。</p>
<p>如果Math中没有定义针对int类型的max函数呢？调用也会成功，会调用long类型的max函数。如果long也没有呢？会调用float型的max函数。如果float也没有，会调用double型的。Java编译器会自动寻找最匹配的。</p>
<p>在只有一个函数的情况下，即没有重载，只要可以进行类型转换，就会调用该函数，在有函数重载的情况下，会调用最匹配的函数。</p>
<h3 id="5．递归函数"><a href="#5．递归函数" class="headerlink" title="5．递归函数"></a>5．递归函数</h3><p>函数大部分情况下都是被别的函数调用的，但其实函数也可以调用它自己，调用自己的函数就叫<strong>递归函数</strong>。为什么需要自己调用自己呢？我们来看一个例子，求一个数的阶乘，数学中一个数n的阶乘，表示为n!，它的值定义是这样的：</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201215415.jpeg" alt="epub_923038_11"><br>0的阶乘是1, n的阶乘的值是n-1的阶乘的值乘以n，这个定义是一个递归的定义，为求n的值，需先求n-1的值，直到0，然后依次往回退。用递归表达的计算用递归函数容易实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n＊factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去应该是比较容易理解的，和数学定义类似。递归函数形式上往往比较简单，但递归其实是有开销的，而且使用不当，可能会出现意外的结果，比如说这个调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(factorial(<span class="number">100000</span>));</span><br></pre></td></tr></table></figure>

<p>系统并不会给出任何结果，而会抛出异常。异常我们在第6章介绍，此处理解为系统错误就可以了。异常类型为java.lang.StackOverflowError，这是什么意思呢？这表示栈溢出错误，要理解这个错误，我们需要理解函数调用的实现原理，我们1.7节介绍。</p>
<p>那递归不可行的情况下怎么办呢？递归函数经常可以转换为非递归的形式，通过循环实现。比如，求阶乘的例子，其非递归形式的定义是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n! =1× 2× 3× …× n</span><br></pre></td></tr></table></figure>

<p>这个可以用循环来实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        result=result＊i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-小结"><a href="#1-6-3-小结" class="headerlink" title="1.6.3 小结"></a>1.6.3 小结</h3><p>函数是计算机程序的一种重要结构，<strong>通过函数来减少重复代码、分解复杂操作是计算机程序的一种重要思维方式</strong>。本节我们介绍了函数的基础概念，以及关于参数传递、返回值、重载、递归方面的一些细节。</p>
<p>在Java中，函数还有大量的修饰符，如public、private、static、final、synchronized、abstract等，本节假定函数的修饰符都是public static，在后续章节中，我们再介绍这些修饰符。函数中还可以声明异常，我们也到第6章再介绍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/a874b478/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/a874b478/" class="post-title-link" itemprop="url">1.5 循环</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 19:33:21" itemprop="dateCreated datePublished" datetime="2021-12-01T19:33:21+08:00">2021-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC1%E7%AB%A0-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第1章 编程基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/a874b478/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/a874b478/" data-xid="/JavaReadingNotes/a874b478/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-5-循环"><a href="#1-5-循环" class="headerlink" title="1.5 循环"></a>1.5 循环</h1><p>所谓循环，就是多次重复执行某些类似的操作，这个操作一般不是完全一样的操作，而是类似的操作。都有哪些操作呢？这种例子太多了，比如：<br>1）展示照片，我们查看手机上的照片，背后的程序需要将照片一张张展示给我们。<br>2）播放音乐，我们听音乐，背后程序按照播放列表一首首给我们放。<br>3）查看消息，我们浏览朋友圈消息，背后程序将消息一条条展示给我们。</p>
<p>循环除了用于重复读取或展示某个列表中的内容，日常中的很多操作也要靠循环完成，比如：<br>1）在文件中，查找某个词，程序需要和文件中的词逐个比较（当然可能有更高效的方式，但也离不开循环）；<br>2）使用Excel对数据进行汇总，比如求和或平均值，需要循环处理每个单元的数据；<br>3）群发祝福消息给好友，程序需要循环给每个好友发。</p>
<p>当然，以上这些例子只是冰山一角。计算机程序运行时大致只能顺序执行、条件执行和循环执行。顺序和条件其实没什么特别的，而循环大概才是程序强大的地方。凭借循环，计算机能够非常高效地完成人很难或无法完成的事情。比如，在大量文件中查找包含某个搜索词的文档，对几十万条销售数据进行统计汇总等。下面，我们先来介绍循环的4种形式，然后介绍循环控制，最后讨论循环的实现原理并进行总结。</p>
<h2 id="1-5-1-循环的4种形式"><a href="#1-5-1-循环的4种形式" class="headerlink" title="1.5.1 循环的4种形式"></a>1.5.1 循环的4种形式</h2><p>在Java中，循环有4种形式，分别是while、do&#x2F;while、for和foreach，下面我们分别介绍。</p>
<h3 id="1-while"><a href="#1-while" class="headerlink" title="1. while"></a>1. while</h3><p>while的语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件语句)&#123;</span><br><span class="line">    代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件语句) 代码；</span><br></pre></td></tr></table></figure>

<p>while和if的语法很像，只是把if换成了while，它表达的含义也非常简单，只要条件语句为真，就一直执行后面的代码，为假就停止不做了。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;please input password&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> reader.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">password</span> <span class="operator">=</span> <span class="number">6789</span>;</span><br><span class="line"><span class="keyword">while</span>(num! =password)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;please input password&quot;</span>);</span><br><span class="line">      num = reader.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;correct&quot;</span>);</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们使用类型为Scanner的reader变量从屏幕控制台接收数字，reader. nextInt()从屏幕接收一个数字，如果数字不是6789，就一直提示输入，否则跳出循环。以上代码中的Scanner我们会在13.3节介绍，目前可以忽略其细节。</p>
<p>while循环中，代码块中会有影响循环中断或退出的条件，但经常不知道什么时候循环会中断或退出。比如，上例中在匹配的时候会退出，但什么时候能匹配取决于用户的输入。</p>
<h3 id="2-do-x2F-while"><a href="#2-do-x2F-while" class="headerlink" title="2. do&#x2F;while"></a>2. do&#x2F;while</h3><p>如果不管条件语句是什么，代码块都会至少执行一次，则可以使用do&#x2F;while循环，其语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    代码块；</span><br><span class="line">&#125;<span class="keyword">while</span>(条件语句)</span><br></pre></td></tr></table></figure>

<p>这个也很容易理解，先执行代码块，然后再判断条件语句，如果成立，则继续循环，否则退出循环。也就是说，不管条件语句是什么，代码块都会至少执行一次。上面的例子，改为do&#x2F;while循环，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">password</span> <span class="operator">=</span> <span class="number">6789</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;please input password&quot;</span>);</span><br><span class="line">    num = reader.nextInt();</span><br><span class="line">&#125;<span class="keyword">while</span>(num! =password);</span><br><span class="line">System.out.println(<span class="string">&quot;correct&quot;</span>);</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3. for"></a>3. for</h3><p>实际中应用最为广泛的循环语法可能是for了，尤其是在循环次数已知的情况。其语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句；循环条件；步进操作)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for后面的括号中有两个分号；，分隔了三条语句。除了循环条件必须返回一个boolean类型外，其他语句没有什么要求，但通常情况下第一条语句用于初始化，尤其是循环的索引变量，第三条语句修改循环变量，一般是步进，即递增或递减索引变量，循环体是在循环中执行的语句。</p>
<p>for循环简化了书写，但执行过程对初学者而言不是那么明显，实际上，它执行的流程如下：<br>1）执行初始化指令；<br>2）检查循环条件是否为true，如果为false，则跳转到第6步；<br>3）循环条件为真，执行循环体；<br>4）执行步进操作；<br>5）步进操作执行完后，跳转到第2步，即继续检查循环条件；<br>6）for循环后面的语句。</p>
<p>下面是一个简单的for循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序打印数组中的每个元素，初始化语句初始化索引i为0，循环条件为索引小于数组长度，步进操作为递增索引i，循环体打印数组元素。</p>
<p>在for中，每条语句都是可以为空的，也就是说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ; )&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>是有效的，这是个死循环，一直在空转，和while(true){}的效果是一样的。可以省略某些语句，但分号；不能省。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引变量在外面初始化了，所以初始化语句可以为空。</p>
<h3 id="4-foreach"><a href="#4-foreach" class="headerlink" title="4. foreach"></a>4. foreach</h3><p>foreach的语法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> element : arr)&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>foreach不是一个关键字，它使用冒号：，冒号前面是循环中的每个元素，包括数据类型和变量名称，冒号后面是要遍历的数组或集合（第9章介绍），每次循环element都会自动更新。对于不需要使用索引变量，只是简单遍历的情况，foreach语法上更为简洁。</p>
<h2 id="1-5-2-循环控制"><a href="#1-5-2-循环控制" class="headerlink" title="1.5.2 循环控制"></a>1.5.2 循环控制</h2><p>在循环的时候，会以循环条件作为是否结束的依据，但有时可能会需要根据别的条件提前结束循环或跳过一些代码，这时可以使用break或continue关键字对循环进行控制。</p>
<h3 id="1-break"><a href="#1-break" class="headerlink" title="1. break"></a>1. break</h3><p>break用于提前结束循环。比如，在一个数组中查找某个元素的时候，循环条件可能是到数组结束，但如果找到了元素，可能就会想提前结束循环，这时就可以使用break。</p>
<p>我们在介绍switch的时候提到过break，它用于跳转到switch外面。在循环的循环体中也可以使用break，它的含义和switch中的类似，用于跳出循环，开始执行循环后面的语句。以在数组中查找元素作为例子，代码可能是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = … ; <span class="comment">//在该数组中查找元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">toSearch</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">//要查找的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]==toSearch)&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i! =arr.length)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;found&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;not found&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果找到了，会调用break, break执行后会跳转到循环外面，不会再执行i++语句，所以即使是最后一个元素匹配，i也小于arr.length，而如果没有找到，i最后会变为arr. length，所以可根据i是否等于arr.length来判断是否找到了。以上代码中，也可以将判断是否找到的检查放到循环条件中，但通常情况下，使用break会使代码更清楚一些。</p>
<h3 id="2-continue"><a href="#2-continue" class="headerlink" title="2. continue"></a>2. continue</h3><p>在循环的过程中，有的代码可能不需要每次循环都执行，这时候，可以使用continue语句，continue语句会跳过循环体中剩下的代码，然后执行步进操作。我们看个例子，以下代码统计一个数组中某个元素的个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = …     <span class="comment">//在该数组中查找元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">toSearch</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">//要查找的元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]! =toSearch)&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;found count &quot;</span>+count);</span><br></pre></td></tr></table></figure>

<p>上面的代码统计数组中值等于toSearch的元素个数，如果值不等于toSearch，则跳过剩下的循环代码，执行i++。以上代码也可以不用continue，使用相反的if判断也可以得到相同的结果。这只是个人偏好的问题，如果类似要跳过的情况比较多，使用continue可能会更易读。</p>
<h2 id="1-5-3-实现原理"><a href="#1-5-3-实现原理" class="headerlink" title="1.5.3 实现原理"></a>1.5.3 实现原理</h2><p>和if一样，循环内部也是靠条件转移和无条件转移指令实现的，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其对应的跳转过程可能为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 int[] arr = &#123;1,2,3,4&#125;;</span><br><span class="line">2 int i=0;</span><br><span class="line">3 条件跳转：如果i&gt;=arr.length，跳转到第7行</span><br><span class="line">4 System.out.println(arr[i]);</span><br><span class="line">5 i++</span><br><span class="line">6 无条件跳转，跳转到第3行</span><br><span class="line">7 其他代码</span><br></pre></td></tr></table></figure>

<p>在if中，跳转只会往后面跳，而for会往前面跳，第6行就是无条件跳转指令，跳转到了前面的第3行。break&#x2F;continue语句也都会转换为跳转指令，具体就不赘述了。</p>
<h2 id="1-5-4-小结"><a href="#1-5-4-小结" class="headerlink" title="1.5.4 小结"></a>1.5.4 小结</h2><p>循环的语法总体上也是比较简单的，初学者需要注意的是for的执行过程，以及break和continue的含义。<strong>虽然循环看起来只是重复执行一些类似的操作而已，但它其实是计算机程序解决问题的一种基本思维方式</strong>，凭借循环（当然还有别的），计算机程序可以发挥出强大的威力，比如批量转换数据、查找过滤数据、统计汇总等。</p>
<p>使用基本数据类型、数组、基本运算，加上条件和循环，其实已经可以写很多程序了，但这样写出来的程序往往难以理解，尤其是程序逻辑比较复杂的时候。</p>
<p>解决复杂问题的基本策略是分而治之，将复杂问题分解为若干相对简单的子问题，然后子问题再分解为更小的子问题……程序由数据和指令组成，大程序可以分解为小程序，小程序接着分解为更小的程序。那如何表示子程序，以及子程序之间如何协调呢？我们下节介绍。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/2dfb27d3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/2dfb27d3/" class="post-title-link" itemprop="url">1Java编程的逻辑 版权信息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 19:33:20" itemprop="dateCreated datePublished" datetime="2021-12-01T19:33:20+08:00">2021-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/0%E7%AC%AC%E9%9B%B6%E9%83%A8%E5%88%86/" itemprop="url" rel="index"><span itemprop="name">0第零部分</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/2dfb27d3/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/2dfb27d3/" data-xid="/JavaReadingNotes/2dfb27d3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>108</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java编程的逻辑-版权信息"><a href="#Java编程的逻辑-版权信息" class="headerlink" title="Java编程的逻辑 版权信息"></a>Java编程的逻辑 版权信息</h1><ul>
<li>书名：Java编程的逻辑作者：</li>
<li>马俊昌出版社：机械工业出版社出版</li>
<li>时间：2018-01</li>
<li>ISBN：9787111587729</li>
<li>本书由北京华章图文信息有限公司授权上海阅文信息技术有限公司进行制作与发行</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/50a84633/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 蓝蓝站点">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/50a84633/" class="post-title-link" itemprop="url">2Java编程的逻辑 读者评论</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 19:33:20" itemprop="dateCreated datePublished" datetime="2021-12-01T19:33:20+08:00">2021-12-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/0%E7%AC%AC%E9%9B%B6%E9%83%A8%E5%88%86/" itemprop="url" rel="index"><span itemprop="name">0第零部分</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/50a84633/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/50a84633/" data-xid="/JavaReadingNotes/50a84633/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>784</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Java编程的逻辑-读者评论"><a href="#Java编程的逻辑-读者评论" class="headerlink" title="Java编程的逻辑 读者评论"></a>Java编程的逻辑 读者评论</h1><p>我觉得你的文章跟一般Java教程最大的不同在于，你把各个知识点的“为什么”都解释得很清楚，非常对味，非常感谢。很多网上教程，都是直接教如何做的，主要是动手能力。可是做完了还是云里雾里。结合你的文章，一下子就通透了。——Hannah</p>
<p>老马说编程，太好了。把神秘的编程，通俗地讲解，使编程者认识了本质。每个专题的介绍都是深入浅出，有分析，有总结，有详细例子，真是爱不释手的宝书。——张工荣成</p>
<p>其实老马写的东西网上都有大把的类似文章，但是老马总是能把复杂的东西讲得深入浅出，把看似简单的东西分析得细致深入！——VitaminChen</p>
<p>文章比其他文章的亮点：有情景带入，重点突出，让人耳目一新，读起来很方便。感谢辛苦付出。——hellojd</p>
<p>虽然我使用Java多年，可是阅读作者的文章仍然觉得受益匪浅。并发总结得很好，对前面讲的并发知识作了很好的总结和梳理。——彭越</p>
<p>我不是初学者，依然能从这里学到很多东西。对不了解原理的非初学者来说，像回头捡落下的宝贝似的。关于编码，之前一直云里雾里的，找了几篇文章都没读进去。你的讲解浅显易懂！——Keyirei</p>
<p>用平实的语言把计算机科学的思维方法由浅入深，娓娓道来，让人如沐春风，醍醐灌顶。这里面没有复制、粘贴的拼凑，更没有生硬古怪的翻译腔，文章中句句都能感觉到老马理解、实践、贯通后表达出来的逻辑严密周全和通透流畅。——杜鹏</p>
<p>最近从PHP转Java，从您的文章学到了很多知识，很系统地重构了对计算机以及程序语言的认知，很感谢。——房飞</p>
<p>多线程一直连概念也模糊，阅读后真的受益匪浅！异常处理，看着简单，刚开始学习时，自己也是胡乱try和throw，不过到开发时，才体会到正确处理的重要性。感谢这篇文章。比起学习使用庞大的框架，我觉得基础知识是更重要的，对于一个知识点的理解，细细琢磨，知道实现原理，也是一种收获。——Chain</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/JavaReadingNotes/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:07</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/11/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/11/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
