<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/11/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-mzjszagu6-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d83ba22a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d83ba22a/" class="post-title-link" itemprop="url">7.2 剖析String</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d83ba22a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d83ba22a/" data-xid="/JavaReadingNotes/d83ba22a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-2-剖析String"><a href="#7-2-剖析String" class="headerlink" title="7.2 剖析String"></a>7.2 剖析String</h1><p>字符串操作是计算机程序中最常见的操作之一。Java中处理字符串的主要类是String和StringBuilder，本节介绍String。先介绍基本用法，然后介绍实现原理，随后介绍编码转换，分析String的不可变性、常量字符串、hashCode和正则表达式。</p>
<h2 id="7-2-1-基本用法"><a href="#7-2-1-基本用法" class="headerlink" title="7.2.1 基本用法"></a>7.2.1 基本用法</h2><p>字符串的基本使用是比较简单直接的。可以通过常量定义String变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;老马说编程&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>也可以通过new创建String变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">new</span> String(<span class="string">&quot;老马说编程&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>String可以直接使用+和+=运算符，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;老马&quot;</span>;</span><br><span class="line">name+= <span class="string">&quot;说编程&quot;</span>;</span><br><span class="line">String descritpion = <span class="string">&quot;，探索编程本质&quot;</span>;</span><br><span class="line">System.out.println(name+descritpion);</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老马说编程，探索编程本质</span><br></pre></td></tr></table></figure>

<p>String类包括很多方法，以方便操作字符串，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">//判断字符串是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//获取字符串长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> <span class="comment">//取子字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> <span class="comment">//取子字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">//查找字符，返回第一个找到的索引位置，没找到返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span> <span class="comment">//查找子串，返回第一个找到的索引位置，没找到返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span> <span class="comment">//从后面查找字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span> <span class="comment">//从后面查找子字符串</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">//判断字符串中是否包含指定的字符序列</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> <span class="comment">//判断字符串是否以给定子字符串开头</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> <span class="comment">//判断字符串是否以给定子字符串结尾</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">//与其他字符串比较，看内容是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> <span class="comment">//忽略大小写比较是否相同</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> <span class="comment">//比较字符串大小</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> <span class="comment">//忽略大小写比较</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span> <span class="comment">//所有字符转换为大写字符，返回新字符串，原字符串不变</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span> <span class="comment">//所有字符转换为小写字符，返回新字符串，原字符串不变</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">//字符串连接，返回当前字符串和参数字符串合并结果</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">//字符串替换，替换单个字符</span></span></span><br><span class="line"><span class="function"><span class="comment">//字符串替换，替换字符序列，返回新字符串，原字符串不变</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> <span class="comment">//删掉开头和结尾的空格，返回新字符串，原字符串不变</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String regex)</span> <span class="comment">//分隔字符串，返回分隔后的子字符串数组</span></span></span><br></pre></td></tr></table></figure>

<p>看个String的简单例子，按逗号分隔”hello, world”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">String[] arr = str.split(<span class="string">&quot;, &quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>arr[0]</code>为”hello”, <code>arr[1]</code>为”world”。</p>
<p>String的操作大多简单直接，不再赘述。从调用者的角度了解了String的基本用法，下面我们进一步来理解String的内部（代码基于Java 7）。</p>
<h2 id="7-2-2-走进String内部"><a href="#7-2-2-走进String内部" class="headerlink" title="7.2.2 走进String内部"></a>7.2.2 走进String内部</h2><p>String类内部用一个字符数组表示字符串，实例变量定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>String有两个构造方法，可以根据char数组创建String变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure>

<p>需要说明的是，String会根据参数新创建一个数组，并复制内容，而不会直接用参数中的字符数组。String中的大部分方法内部也都是操作的这个字符数组。比如：<br>1）length()方法返回的是这个数组的长度。<br>2）substring()方法是根据参数，调用构造方法String(char value[], int offset, intcount)新建了一个字符串。<br>3）indexOf()方法查找字符或子字符串时是在这个数组中进行查找。</p>
<p>这些方法的实现大多比较直接，不再赘述。</p>
<p>String中还有一些方法，与这个char数组有关：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//返回指定索引位置的char</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回字符串对应的char数组， 注意，返回的是一个复制后的数组，而不是原数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//将char数组中指定范围的字符复制入目标数组指定位置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span></span></span><br></pre></td></tr></table></figure>

<p>与Character类似，String也提供了一些方法，按代码点对字符串进行处理，具体不再赘述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-3-编码转换"><a href="#7-2-3-编码转换" class="headerlink" title="7.2.3 编码转换"></a>7.2.3 编码转换</h2><p>String内部是按UTF-16BE处理字符的，对BMP字符，使用一个char，两个字节，对于增补字符，使用两个char，四个字节。我们在第2.3节介绍过各种编码，不同编码可能用于不同的字符集，使用不同的字节数目，以及不同的二进制表示。如何处理这些不同的编码呢？这些编码与Java内部表示之间如何相互转换呢？</p>
<p>Java使用Charset类表示各种编码，它有两个常用静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">defaultCharset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Charset <span class="title">forName</span><span class="params">(String charsetName)</span></span></span><br></pre></td></tr></table></figure>

<p>第一个方法返回系统的默认编码，比如，在笔者的计算机中，执行如下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Charset.defaultCharset().name());</span><br></pre></td></tr></table></figure>

<p>输出为UTF-8。</p>
<p>第二个方法返回给定编码名称的Charset对象，与我们在2.3节介绍的编码相对应，其charset名称可以是US-ASCII、ISO-8859-1、windows-1252、GB2312、GBK、GB18030、Big5、UTF-8等，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset charset = Charset.forName(<span class="string">&quot;GB18030&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>String类提供了如下方法，返回字符串按给定编码的字节表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset)</span><br></pre></td></tr></table></figure>

<p>第一个方法没有编码参数，使用系统默认编码；第二个方法参数为编码名称；第三个方法参数为Charset。</p>
<p>String类有如下构造方法，可以根据字节和编码创建字符串，也就是说，根据给定编码的字节表示，创建Java的内部表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span></span></span><br></pre></td></tr></table></figure>

<p>除了通过String中的方法进行编码转换，Charset类中也有一些方法进行编码/解码，本书就不介绍了。重要的是认识到，Java的内部表示与各种编码是不同的，但可以相互转换。</p>
<h2 id="7-2-4-不可变性"><a href="#7-2-4-不可变性" class="headerlink" title="7.2.4 不可变性"></a>7.2.4 不可变性</h2><p>与包装类类似，String类也是不可变类，即对象一旦创建，就没有办法修改了。String类也声明为了final，不能被继承，内部char数组value也是final的，初始化后就不能再变了。</p>
<p>String类中提供了很多看似修改的方法，其实是通过创建新的String对象来实现的，原来的String对象不会被修改。比如，concat()方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span>(otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Arrays.copyOf方法创建了一块新的字符数组，复制原内容，然后通过new创建了一个新的String，最后一行调用的是String的另一个构造方法，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">//assert share : &quot;unshared not supported&quot;;</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个非公开的构造方法，直接使用传递过来的数组作为内部数组。关于Arrays类，我们在7.4节介绍。</p>
<p>与包装类类似，定义为不可变类，程序可以更为简单、安全、容易理解。但如果频繁修改字符串，而每次修改都新建一个字符串，那么性能太低，这时，应该考虑Java中的另两个类StringBuilder和StringBuffer。</p>
<h2 id="7-2-5-常量字符串"><a href="#7-2-5-常量字符串" class="headerlink" title="7.2.5 常量字符串"></a>7.2.5 常量字符串</h2><p>Java中的字符串常量是非常特殊的，除了可以直接赋值给String变量外，它自己就像一个String类型的对象，可以直接调用String的各种方法。我们来看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;老马说编程&quot;</span>.length());</span><br><span class="line">System.out.println(<span class="string">&quot;老马说编程&quot;</span>.contains(<span class="string">&quot;老马&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;老马说编程&quot;</span>.indexOf(<span class="string">&quot;编程&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>实际上，这些常量就是String类型的对象，在内存中，它们被放在一个共享的地方，这个地方称为<strong>字符串常量池</strong>，它保存所有的常量字符串，每个常量只会保存一份，被所有使用者共享。<strong>当通过常量的形式使用一个字符串的时候，使用的就是常量池中的那个对应的String类型的对象</strong>。</p>
<p>比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name1 = <span class="string">&quot;老马说编程&quot;</span>;</span><br><span class="line">String name2 = <span class="string">&quot;老马说编程&quot;</span>;</span><br><span class="line">System.out.println(name1==name2);</span><br></pre></td></tr></table></figure>

<p>输出为true。为什么呢？可以认为，”老马说编程”在常量池中有一个对应的String类型的对象，我们假定名称为laoma，上面的代码实际上就类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String laoma = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;老&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;说&#x27;</span>, <span class="string">&#x27;编&#x27;</span>, <span class="string">&#x27;程&#x27;</span>&#125;);</span><br><span class="line">String name1 = laoma;</span><br><span class="line">String name2 = laoma;</span><br><span class="line">System.out.println(name1==name2);</span><br></pre></td></tr></table></figure>

<p>实际上只有一个String对象，三个变量都指向这个对象，name1==name2也就不言而喻了。</p>
<p>需要注意的是，<strong>如果不是通过常量直接赋值，而是通过new创建，==就不会返回true了</strong>，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name1 = <span class="keyword">new</span> String(<span class="string">&quot;老马说编程&quot;</span>);</span><br><span class="line">String name2 = <span class="keyword">new</span> String(<span class="string">&quot;老马说编程&quot;</span>);</span><br><span class="line">System.out.println(name1==name2);</span><br></pre></td></tr></table></figure>

<p>输出为false。为什么呢？上面代码类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String laoma = <span class="keyword">new</span> String(<span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;老&#x27;</span>, <span class="string">&#x27;马&#x27;</span>, <span class="string">&#x27;说&#x27;</span>, <span class="string">&#x27;编&#x27;</span>, <span class="string">&#x27;程&#x27;</span>&#125;);</span><br><span class="line">String name1 = <span class="keyword">new</span> String(laoma);</span><br><span class="line">String name2 = <span class="keyword">new</span> String(laoma);</span><br><span class="line">System.out.println(name1==name2);</span><br></pre></td></tr></table></figure>

<p>String类中以String为参数的构造方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hash是String类中另一个实例变量，表示缓存的hashCode值。</p>
<p>可以看出，name1和name2指向两个不同的String对象，只是这两个对象内部的value值指向相同的char数组。其内存布局如图7-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209100058.jpeg" alt="epub_923038_53"></p>
<center>图7-1 两个String对象的内存布局</center>

<p>所以，name1==name2不成立，但name1.equals(name2)是true。</p>
<h2 id="7-2-6-hashCode"><a href="#7-2-6-hashCode" class="headerlink" title="7.2.6 hashCode"></a>7.2.6 hashCode</h2><p>7.2.5节中提到hash这个实例变量，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">//Default to 0</span></span><br></pre></td></tr></table></figure>

<p>hash变量缓存了hashCode方法的值，也就是说，第一次调用hashCode方法的时候，会把结果保存在hash这个变量中，以后再调用就直接返回保存的值。</p>
<p>我们来看下String类的hashCode方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span>(h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> ＊ h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果缓存的hash不为0，就直接返回了，否则根据字符数组中的内容计算hash，计算方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[0]＊31^(n-1) + s[1]＊31^(n-2) + ... + s[n-1]</span><br></pre></td></tr></table></figure>

<p>s表示字符串，<code>s[0]</code>表示第一个字符，n表示字符串长度，<code>s[0]*31^(n-1)</code>表示31的(n-1)次方再乘以第一个字符的值。</p>
<p>为什么要用这个计算方法呢？使用这个式子，可以让hash值与每个字符的值有关，也与每个字符的位置有关，位置i（i&gt;=1）的因素通过31的（n-i）次方表示。使用31大致是因为两个原因：一方面可以产生更分散的散列，即不同字符串hash值也一般不同；另一方面计算效率比较高，31<em>h与32</em>h-h即（h&lt;&lt;5）-h等价，可以用更高效率的移位和减法操作代替乘法操作。</p>
<p>在Java中，普遍采用以上思路来实现hashCode。</p>
<h3 id="7-2-7-正则表达式"><a href="#7-2-7-正则表达式" class="headerlink" title="7.2.7 正则表达式"></a>7.2.7 正则表达式</h3><p>String类中，有一些方法接受的不是普通的字符串参数，而是正则表达式。什么是正则表达式呢？正则表达式可以理解为一个字符串，但表达的是一个规则，一般用于文本的匹配、查找、替换等。正则表达式具有丰富和强大的功能，是一个比较大的话题，我们在第25章单独介绍。</p>
<p>Java中有专门的类（如Pattern和Matcher）用于正则表达式，但对于简单的情况，String类提供了更为简洁的操作，String中接受正则表达式的方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)  <span class="comment">//分隔字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> <span class="comment">//检查是否匹配</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> <span class="comment">//字符串替换</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> <span class="comment">//字符串替换</span></span></span><br></pre></td></tr></table></figure>

<p>至此，关于String的用法、原理和特性等基本介绍完了。关于String的实现原理，值得了解的是，Java 9对String的实现进行了优化，它的内部不是char数组，而是byte数组，如果字符都是ASCII字符，它就可以使用一个字节表示一个字符，而不用UTF-16BE编码，节省内存。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8c48db9d/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8c48db9d/" class="post-title-link" itemprop="url">7.3 剖析StringBuilder</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8c48db9d/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8c48db9d/" data-xid="/JavaReadingNotes/8c48db9d/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-3-剖析StringBuilder"><a href="#7-3-剖析StringBuilder" class="headerlink" title="7.3 剖析StringBuilder"></a>7.3 剖析StringBuilder</h1><p>7.2.4节提到，如果字符串修改操作比较频繁，应该采用StringBuilder和StringBuffer类，这两个类的方法基本是完全一样的，它们的实现代码也几乎一样，唯一的不同就在于StringBuffer类是线程安全的，而StringBuilder类不是。</p>
<p>关于线程的概念，我们到第15章再介绍。这里需要知道的就是，线程安全是有成本的，影响性能，而字符串对象及操作大部分情况下不存在线程安全问题，适合使用String-Builder类。所以，本节就只讨论StringBuilder类，包括基本用法和基本原理。</p>
<h2 id="7-3-1-基本用法"><a href="#7-3-1-基本用法" class="headerlink" title="7.3.1 基本用法"></a>7.3.1 基本用法</h2><p>StringBuilder的基本用法很简单。创建StringBuilder对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br></pre></td></tr></table></figure>

<p>通过append方法添加字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sb.append(<span class="string">&quot;老马说编程&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;，探索编程本质&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>通过toString方法获取构建后的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老马说编程，探索编程本质</span><br></pre></td></tr></table></figure>

<p>大部分情况，使用就这么简单，通过new新建StringBuilder对象，通过append方法添加字符串，然后通过toString方法获取构建完成的字符串。</p>
<h2 id="7-3-2-基本实现原理"><a href="#7-3-2-基本实现原理" class="headerlink" title="7.3.2 基本实现原理"></a>7.3.2 基本实现原理</h2><p>StringBuilder类是怎么实现的呢？我们来看下它的内部组成，以及一些主要方法的实现，代码基于Java 7。与String类似，StringBuilder类也封装了一个字符数组，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>

<p>与String不同，它不是final的，可以修改。另外，与String不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>

<p>StringBuilder继承自AbstractStringBuilder，它的默认构造方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用父类的构造方法，父类对应的构造方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，new StringBuilder()代码内部会创建一个长度为16的字符数组，count的默认值为0。来看append方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span>) str = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>append会直接复制字符到内部的字符数组中，如果字符数组长度不够，会进行扩展，实际使用的长度用count体现。具体来说，ensureCapacityInternal(count+len)会确保数组的长度足以容纳新添加的字符，str.getChars会复制新添加的字符到字符数组中，count+=len会增加实际使用的长度。</p>
<p>ensureCapacityInternal的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span>(minimumCapacity - value.length &gt; <span class="number">0</span>)</span><br><span class="line">        expandCapacity(minimumCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果字符数组的长度小于需要的长度，则调用expandCapacity进行扩展，其代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = value.length ＊ <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity - minimumCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minimumCapacity;</span><br><span class="line">    <span class="keyword">if</span>(newCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minimumCapacity &lt; <span class="number">0</span>) <span class="comment">//overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        newCapacity = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    value = Arrays.copyOf(value, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展的逻辑是：分配一个足够长度的新数组，然后将原内容复制到这个新数组中，最后让内部的字符数组指向这个新数组，这个逻辑主要靠下面的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = Arrays.copyOf(value, newCapacity);</span><br></pre></td></tr></table></figure>

<p>关于类Arrays，我们下一节介绍，这里主要看下newCapacity是怎么算出来的。参数minimumCapacity表示需要的最小长度，需要多少分配多少不就行了吗？不行，因为那就跟String一样了，每append一次，都会进行一次内存分配，效率低下。这里的扩展策略是跟当前长度相关的，当前长度乘以2，再加上2，如果这个长度不够最小需要的长度，才用minimumCapacity。</p>
<p>比如，默认长度为16，长度不够时，会先扩展到<code>16*2+2</code>即34，然后扩展到<code>34*2+2</code>即70，然后是<code>70*2+2</code>即142，这是一种指数扩展策略。为什么要加2？这样，在原长度为0时也可以一样工作。</p>
<p>为什么要这么扩展呢？这是一种折中策略，一方面要减少内存分配的次数，另一方面要避免空间浪费。<strong>在不知道最终需要多长的情况下，指数扩展是一种常见的策略，广泛应用于各种内存分配相关的计算机程序中</strong>。不过，如果预先就知道需要多长，那么可以调用StringBuilder的另外一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br></pre></td></tr></table></figure>

<p>字符串构建完后，我们来看toString方法的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于内部数组新建了一个String。注意，这个String构造方法不会直接用value数组，而会新建一个，以保证String的不可变性。</p>
<p>除了append和toString方法， StringBuilder还有很多其他方法，包括更多构造方法、更多append方法、插入、删除、替换、翻转、长度有关的方法，限于篇幅，就不一一列举了。主要看下插入方法。在指定索引offset处插入字符串str：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span></span></span><br></pre></td></tr></table></figure>

<p>原来的字符后移，offset为0表示在开头插，为length()表示在结尾插，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">&quot;老马说编程&quot;</span>);</span><br><span class="line">sb.insert(<span class="number">0</span>, <span class="string">&quot;关注&quot;</span>);</span><br><span class="line">sb.insert(sb.length(), <span class="string">&quot;老马和你一起探索编程本质&quot;</span>);</span><br><span class="line">sb.insert(<span class="number">7</span>, <span class="string">&quot;, &quot;</span>);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关注老马说编程，老马和你一起探索编程本质</span><br></pre></td></tr></table></figure>

<p>了解了用法，下面来看insert的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((offset &lt; <span class="number">0</span>) || (offset &gt; length()))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">      <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">        str = <span class="string">&quot;null&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    System.arraycopy(value, offset, value, offset + len, count - offset);</span><br><span class="line">    str.getChars(value, offset);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这个实现思路是：在确保有足够长度后，首先将原数组中offset开始的内容向后挪动n个位置，n为待插入字符串的长度，然后将待插入字符串复制进offset位置</strong>。</p>
<p>挪动位置调用了System.arraycopy()方法，这是个比较常用的方法，它的声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将数组src中srcPos开始的length个元素复制到数组dest中destPos处。这个方法有个优点：即使src和dest是同一个数组，它也可以正确处理。比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.arraycopy(arr, <span class="number">1</span>, arr, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]+<span class="string">&quot;, &quot;</span>+arr[<span class="number">1</span>]+<span class="string">&quot;, &quot;</span>+arr[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>

<p>这里，src和dest都是arr, srcPos为1, destPos为0, length为3，表示将第二个元素开始的三个元素移到开头，所以输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2,3,4</span><br></pre></td></tr></table></figure>

<p>arraycopy的声明有个修饰符native，表示它的实现是通过Java本地接口实现的。Java本地接口是Java提供的一种技术，用于在Java中调用非Java实现的代码，实际上，array-copy是用C++语言实现的。为什么要用C++语言实现呢？因为这个功能非常常用，而C++的实现效率要远高于Java。</p>
<h2 id="7-3-3-String的-和-运算符"><a href="#7-3-3-String的-和-运算符" class="headerlink" title="7.3.3 String的+和+=运算符"></a>7.3.3 String的+和+=运算符</h2><p>Java中，String可以直接使用+和+=运算符，这是Java编译器提供的支持，背后，Java编译器一般会生成StringBuilder, +和+=操作会转换为append。比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">hello+=<span class="string">&quot;, world&quot;</span>;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>

<p>背后，Java编译器一般会转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder hello = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">hello.append(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">System.out.println(hello.toString());</span><br></pre></td></tr></table></figure>

<p>既然直接使用+和+=就相当于使用StringBuilder和append，那还有什么必要直接使用StringBuilder呢？在简单的情况下，确实没必要。不过，在稍微复杂的情况下，Java编译器可能没有那么智能，它可能会生成过多的StringBuilder，尤其是在有循环的情况下，比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    hello+=<span class="string">&quot;, world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>

<p>Java编译器转换后的代码大致如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(hello);</span><br><span class="line">    sb.append(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">    hello = sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(hello);</span><br></pre></td></tr></table></figure>

<p>在循环内部，每一次+=操作，都会生成一个StringBuilder。</p>
<p>所以，对于简单的情况，可以直接使用String的+和+=，对于复杂的情况，尤其是有循环的时候，应该直接使用StringBuilder。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/c31cface/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/c31cface/" class="post-title-link" itemprop="url">3.0 第3章 类的基础 3.1 类的基本概念</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC3%E7%AB%A0-%E7%B1%BB%E7%9A%84%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第3章 类的基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/c31cface/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/c31cface/" data-xid="/JavaReadingNotes/c31cface/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第3章-类的基础"><a href="#第3章-类的基础" class="headerlink" title="第3章 类的基础"></a>第3章 类的基础</h1><p>程序主要就是数据以及对数据的操作，为方便理解和操作，高级语言使用数据类型这个概念，不同的数据类型有不同的特征和操作，Java定义了8种基本数据类型：4种整型byte、short、int、long，两种浮点类型float、double，一种真假类型boolean，一种字符类型char。其他类型的数据都用类这个概念表达。</p>
<p>类比较复杂，本章主要介绍类的一些基础知识，具体分为3节：3.1节主要介绍类的基本概念；3.2节主要通过一些例子来演示如何将一些现实概念和问题通过类以及类的组合来表示和处理；3.3节介绍类代码的组织机制。</p>
<h1 id="3-1-类的基本概念"><a href="#3-1-类的基本概念" class="headerlink" title="3.1 类的基本概念"></a>3.1 类的基本概念</h1><p>在第1章，我们暂时将类看作函数的容器，在某些情况下，类也确实只是函数的容器，但<strong>类更多表示的是自定义数据类型</strong>。本节我们先从容器的角度，然后从自定义数据类型的角度介绍类。</p>
<h2 id="3-1-1-函数容器"><a href="#3-1-1-函数容器" class="headerlink" title="3.1.1 函数容器"></a>3.1.1 函数容器</h2><p>我们看个例子——Java API中的类Math，它里面主要包含了若干数学函数，表3-1列出了其中一些。</p>
<center>表3-1 Math类的常用函数</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208151217.jpeg" alt="epub_923038_34"><br>要使用这些函数，直接在前面加Math．即可，例如Math.abs(-1)返回1。这些函数都有相同的修饰符：public static。static表示类方法，也叫静态方法，与类方法相对的是<strong>实例方法</strong>。实例方法没有static修饰符，必须通过实例或者对象调用，而类方法可以直接通过类名进行调用，不需要创建实例。public表示这些函数是公开的，可以在任何地方被外部调用。</p>
<p>与public相对的是private。如果是private，则表示私有，这个函数只能在同一个类内被别的函数调用，而不能被外部的类调用。在Math类中，有一个函数Random initRNG()就是private的，这个函数被public的方法random()调用以生成随机数，但不能在Math类以外的地方被调用。</p>
<p>将函数声明为private可以避免该函数被外部类误用，调用者可以清楚地知道哪些函数是可以调用的，哪些是不可以调用的。类实现者通过private函数封装和隐藏内部实现细节，而调用者只需要关心public就可以了。可以说，<strong>通过private封装和隐藏内部实现细节，避免被误操作，是计算机程序的一种基本思维方式</strong>。</p>
<p>除了Math类，我们再来看一个例子Arrays。Arrays里面包含很多与数组操作相关的函数，表3-2列出了其中一些。</p>
<center>表3-2 Arrays类的一些函数</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208151246.jpeg" alt="epub_923038_35"><br>这里将类看作函数的容器，更多的是从语言实现的角度看，从概念的角度看，Math和Arrays也可以看作自定义数据类型，分别表示数学和数组类型，其中的public static函数可以看作类型能进行的操作。接下来更为详细地讨论自定义数据类型。</p>
<h2 id="3-1-2-自定义数据类型"><a href="#3-1-2-自定义数据类型" class="headerlink" title="3.1.2 自定义数据类型"></a>3.1.2 自定义数据类型</h2><p>我们将类看作自定义数据类型，所谓自定义数据类型就是除了8种基本类型以外的其他类型，用于表示和处理基本类型以外的其他数据。一个数据类型由其包含的属性以及该类型可以进行的操作组成，属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，同样，操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。</p>
<p>这样，一个数据类型就主要由4部分组成：</p>
<ul>
<li>类型本身具有的属性，通过类变量体现。</li>
<li>类型本身可以进行的操作，通过类方法体现。</li>
<li>类型实例具有的属性，通过实例变量体现。</li>
<li>类型实例可以进行的操作，通过实例方法体现。</li>
</ul>
<p>不过，对于一个具体类型，每一个部分不一定都有，Arrays类就只有类方法。</p>
<p>类变量和实例变量都叫<strong>成员变量</strong>，也就是类的成员，类变量也叫<strong>静态变量</strong>或<strong>静态成员变量</strong>。类方法和实例方法都叫<strong>成员方法</strong>，也都是类的成员，类方法也叫<strong>静态方法</strong>。</p>
<p>类方法我们上面已经看过了，Math和Arrays类中定义的方法就是类方法，这些方法的修饰符必须有static。下面解释类变量、实例变量和实例方法。</p>
<h3 id="1．类变量"><a href="#1．类变量" class="headerlink" title="1．类变量"></a>1．类变量</h3><p>类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。比如Math类，定义了两个数学中常用的常量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E = <span class="number">2.7182818284590452354</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>

<p>E表示数学中自然对数的底数，自然对数在很多学科中有重要的意义；PI表示数学中的圆周率π。与类方法一样，类变量可以直接通过类名访问，如Math.PI。</p>
<p>这两个变量的修饰符也都有public static, public表示外部可以访问，static表示是类变量。与public相对的也是private，表示变量只能在类内被访问。与static相对的是实例变量，没有static修饰符。</p>
<p>这里多了一个修饰符final, final在修饰变量的时候表示常量，即变量赋值后就不能再修改了。使用final可以避免误操作，比如，如果有人不小心将Math.PI的值改了，那么很多相关的计算就会出错。另外，Java编译器可以对final变量进行一些特别的优化。所以，如果数据赋值后就不应该再变了，就加final修饰符。</p>
<p>表示类变量的时候，static修饰符是必需的，但public和final都不是必需的。</p>
<h3 id="2．实例变量和实例方法"><a href="#2．实例变量和实例方法" class="headerlink" title="2．实例变量和实例方法"></a>2．实例变量和实例方法</h3><p>所谓实例，字面意思就是一个实际的例子。实例变量表示具体的实例所具有的属性，实例方法表示具体的实例可以进行的操作。如果将微信订阅号看作一个类型，那“老马说编程”订阅号就是一个实例，订阅号的头像、功能介绍、发布的文章可以看作实例变量，而修改头像、修改功能介绍、发布新文章可以看作实例方法。与基本类型对比，“int a; ”这个语句中，int就是类型，而a就是实例。</p>
<p>接下来，我们通过定义和使用类来进一步理解自定义数据类型。</p>
<h2 id="3-1-3-定义第一个类"><a href="#3-1-3-定义第一个类" class="headerlink" title="3.1.3 定义第一个类"></a>3.1.3 定义第一个类</h2><p>我们定义一个简单的类，表示在平面坐标轴中的一个点，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(x＊x+y＊y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来解释一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Point</span><br></pre></td></tr></table></figure>

<p>表示类型的名字是Point，是可以被外部公开访问的。这个public修饰似乎是多余的，不能被外部访问还能有什么用？在这里，确实不能用private修饰Point。但修饰符可以没有（即留空），表示一种包级别的可见性，关于包，3.3节再介绍。另外，类可以定义在一个类的内部，这时可以使用private 修饰符，关于内部类我们在第5章介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> y;</span><br></pre></td></tr></table></figure>

<p>定义了两个实例变量x和y，分别表示x坐标和y坐标，与类变量类似，修饰符也有public或private修饰符，表示含义类似，public表示可被外部访问，而private表示私有，不能直接被外部访问，实例变量不能有static修饰符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(x＊x+y＊y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义了实例方法distance，表示该点到坐标原点的距离。该方法可以直接访问实例变量x和y，这是实例方法和类方法的最大区别。实例方法直接访问实例变量，到底是什么意思呢？其实，在实例方法中，有一个隐含的参数，这个参数就是当前操作的实例自己，直接操作实例变量，实际也需要通过参数进行。实例方法和类方法的更多区别如下所示。</p>
<ul>
<li>类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。</li>
<li>实例方法既能访问实例变量，也能访问类变量，既可以调用实例方法，也可以调用类方法。</li>
</ul>
<p>如果这些让你感到困惑，没有关系，关于实例方法和类方法的更多细节，后续会进一步介绍。</p>
<h2 id="3-1-4-使用第一个类"><a href="#3-1-4-使用第一个类" class="headerlink" title="3.1.4 使用第一个类"></a>3.1.4 使用第一个类</h2><p>定义了类本身和定义了一个函数类似，本身不会做什么事情，不会分配内存，也不会执行代码。方法要执行需要被调用，而实例方法被调用，首先需要一个实例。实例也称为对象，我们可能会交替使用。下面的代码演示了如何使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point();</span><br><span class="line">    p.x = <span class="number">2</span>;</span><br><span class="line">    p.y = <span class="number">3</span>;</span><br><span class="line">    System.out.println(p.distance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们解释一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure>

<p>这个语句包含了Point类型的变量声明和赋值，它可以分为两部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 Point p;</span><br><span class="line">2 p = new Point()；</span><br></pre></td></tr></table></figure>

<p>Point p声明了一个变量，这个变量叫p，是Point类型的。这个变量和数组变量是类似的，都有两块内存：一块存放实际内容，一块存放实际内容的位置。<strong>声明变量本身只会分配存放位置的内存空间，这块空间还没有指向任何实际内容</strong>。因为这种变量和数组变量本身不存储数据，而只是存储实际内容的位置，它们也都称为<strong>引用类型</strong>的变量。</p>
<p>p = new Point()；创建了一个实例或对象，然后赋值给了Point类型的变量p，它至少做了两件事：</p>
<p>1）分配内存，以存储新对象的数据，对象数据包括这个对象的属性，具体包括其实例变量x和y。<br>2）给实例变量设置默认值，int类型默认值为0。</p>
<p>与方法内定义的局部变量不同，在创建对象的时候，所有的实例变量都会分配一个默认值，这与创建数组的时候是类似的，数值类型变量的默认值是0, boolean是false, char是“\u0000”，引用类型变量都是null。null是一个特殊的值，表示不指向任何对象。这些默认值可以修改，我们稍后介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.x = <span class="number">2</span>;</span><br><span class="line">p.y = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>给对象的变量赋值，语法形式是：&lt;对象变量名&gt;.&lt;成员名&gt;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(p.distance());</span><br></pre></td></tr></table></figure>

<p>调用实例方法distance，并输出结果，语法形式是：&lt;对象变量名&gt;.&lt;方法名&gt;。实例方法内对实例变量的操作，实际操作的就是p这个对象的数据。</p>
<p>我们在介绍基本类型的时候，先定义数据，然后赋值，最后是操作，自定义类型与此类似：</p>
<ul>
<li>Point p = new Point()；是定义数据并设置默认值。</li>
<li>p.x = 2; p.y = 3；是赋值。</li>
<li>p.distance()是数据的操作。</li>
</ul>
<p>可以看出，对实例变量和实例方法的访问都通过对象进行，<strong>通过对象来访问和操作其内部的数据是一种基本的面向对象思维</strong>。本例中，我们通过对象直接操作了其内部数据x和y，这是一个不好的习惯，<strong>一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作</strong>。这也是为了减少误操作，直接访问变量没有办法进行参数检查和控制，而通过方法修改，可以在方法中进行检查。</p>
<h2 id="3-1-5-变量默认值"><a href="#3-1-5-变量默认值" class="headerlink" title="3.1.5 变量默认值"></a>3.1.5 变量默认值</h2><p>之前我们说实例变量都有一个默认值，如果希望修改这个默认值，可以在定义变量的同时就赋值，或者将代码放入初始化代码块中，代码块用<code>&#123;&#125;</code>包围，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#123;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>x的默认值设为了1, y的默认值设为了2。在新建一个对象的时候，会先调用这个初始化，然后才会执行构造方法中的代码，关于构造方法，我们稍后介绍。</p>
<p>静态变量也可以这样初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> STATIC_ONE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> STATIC_TWO;</span><br><span class="line"><span class="keyword">static</span></span><br><span class="line">&#123;</span><br><span class="line">    STATIC_TWO = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>STATIC_TWO=2；语句外面包了一个static {}，这叫静态初始化代码块。静态初始化代码块在类加载的时候执行，这是在任何对象创建之前，且只执行一次。</p>
<h2 id="3-1-6-private变量"><a href="#3-1-6-private变量" class="headerlink" title="3.1.6 private变量"></a>3.1.6 private变量</h2><p>前面我们说一般不应该将实例变量声明为public，下面我们修改一下类的定义，将实例变量定义为private，通过实例方法来操作变量，如代码清单3-1所示。</p>
<center>代码清单3-1 Point类定义——实例变量定义为private</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.y = y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> x;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> y;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Math.sqrt(x ＊ x + y ＊ y);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个定义中，我们加了4个方法，setX/setY用于设置实例变量的值，getX/getY用于获取实例变量的值。</p>
<p>这里面需要介绍的是this这个关键字。this<strong>表示当前实例</strong>，在语句this.x=x；中，this.x表示实例变量x，而右边的x表示方法参数中的x。前面我们提到，在实例方法中，有一个隐含的参数，这个参数就是this，没有歧义的情况下，可以直接访问实例变量，在这个例子中，两个变量名都叫x，则需要通过加上this来消除歧义。</p>
<p>这4个方法看上去是非常多余的，直接访问变量不是更简洁吗？而且第1章我们也说过，函数调用是有成本的。在这个例子中，意义确实不太大，实际上，Java编译器一般也会将对这几个方法的调用转换为直接访问实例变量，而避免函数调用的开销。但在很多情况下，通过函数调用可以封装内部数据，避免误操作，我们一般还是不将成员变量定义为public。</p>
<p>使用这个类的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Point p = <span class="keyword">new</span> Point();</span><br><span class="line">    p.setX(<span class="number">2</span>);</span><br><span class="line">    p.setY(<span class="number">3</span>);</span><br><span class="line">    System.out.println(p.distance());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码将对实例变量的直接访问改为了方法调用。</p>
<h2 id="3-1-7-构造方法"><a href="#3-1-7-构造方法" class="headerlink" title="3.1.7 构造方法"></a>3.1.7 构造方法</h2><p>在初始化对象的时候，前面我们都是直接对每个变量赋值，有一个更简单的方式对实例变量赋初值，就是构造方法，我们先看下代码。在Point类定义中增加如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个就是构造方法，构造方法可以有多个。不同于一般方法，构造方法有一些特殊的地方：</p>
<p>1）名称是固定的，与类名相同。这也容易理解，靠这个用户和Java系统就都能容易地知道哪些是构造方法。<br>2）没有返回值，也不能有返回值。构造方法隐含的返回值就是实例本身。</p>
<p>与普通方法一样，构造方法也可以重载。第二个构造方法是比较容易理解的，使用this对实例变量赋值。</p>
<p>我们解释下第一个构造方法，this(0,0)的意思是调用第二个构造方法，并传递参数“0,0”，我们前面解释说this表示当前实例，可以通过this访问实例变量，这是this的第二个用法，用于在构造方法中调用其他构造方法。</p>
<p>这个this调用必须放在第一行，这个规定也是为了避免误操作。构造方法是用于初始化对象的，如果要调用别的构造方法，先调别的，然后根据情况自己再做调整，而如果自己先初始化了一部分，再调别的，自己的修改可能就被覆盖了。</p>
<p>这个例子中，不带参数的构造方法通过this(0,0)又调用了第二个构造方法，这个调用是多余的，因为x和y的默认值就是0，不需要再单独赋值，我们这里主要是演示其语法。</p>
<p>我们来看下如何使用构造方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这个调用就可以将实例变量x和y的值设为2和3。前面我们介绍new Point()的时候说，它至少做了两件事，一件是分配内存，另一件是给实例变量设置默认值，这里我们需要加上一件事，就是调用构造方法。调用构造方法是new操作的一部分。</p>
<p>通过构造方法，可以更为简洁地对实例变量进行赋值。关于构造方法，下面我们讨论两个细节概念：一个是默认构造方法；另一个是私有构造方法。</p>
<h3 id="1．默认构造方法"><a href="#1．默认构造方法" class="headerlink" title="1．默认构造方法"></a>1．默认构造方法</h3><p>每个类都至少要有一个构造方法，在通过new创建对象的过程中会被调用。但构造方法如果没什么操作要做，可以省略。Java编译器会自动生成一个默认构造方法，也没有具体操作。但一旦定义了构造方法，Java就不会再自动生成默认的，具体什么意思呢？在这个例子中，如果我们只定义了第二个构造方法（带参数的），则下面语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point();</span><br></pre></td></tr></table></figure>

<p>就会报错，因为找不到不带参数的构造方法。</p>
<p>为什么Java有时候自动生成，有时候不生成呢？在没有定义任何构造方法的时候，Java认为用户不需要，所以就生成一个空的以被new过程调用；定义了构造方法的时候，Java认为用户知道自己在干什么，认为用户是有意不想要不带参数的构造方法，所以不会自动生成。</p>
<h3 id="2．私有构造方法"><a href="#2．私有构造方法" class="headerlink" title="2．私有构造方法"></a>2．私有构造方法</h3><p>构造方法可以是私有方法，即修饰符可以为private，为什么需要私有构造方法呢？大致可能有这么几种场景：</p>
<p>1）不能创建类的实例，类只能被静态访问，如Math和Arrays类，它们的构造方法就是私有的。<br>2）能创建类的实例，但只能被类的静态方法调用。有一种常见的场景：类的对象有但是只能有一个，即单例（单个实例）。在这种场景中，对象是通过静态方法获取的，而静态方法调用私有构造方法创建一个对象，如果对象已经创建过了，就重用这个对象。<br>3）只是用来被其他多个构造方法调用，用于减少重复代码。</p>
<h2 id="3-1-8-类和对象的生命周期"><a href="#3-1-8-类和对象的生命周期" class="headerlink" title="3.1.8 类和对象的生命周期"></a>3.1.8 类和对象的生命周期</h2><p>了解了类和对象的定义与使用，下面我们再从程序运行的角度理解下类和对象的生命周期。</p>
<p>在程序运行的时候，当第一次通过new创建一个类的对象时，或者直接通过类名访问类变量和类方法时，Java会将类加载进内存，为这个类分配一块空间，这个空间会包括类的定义、它的变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。下一章会进一步介绍有关细节。</p>
<p>类加载进内存后，一般不会释放，直到程序结束。一般情况下，类只会加载一次，所以静态变量在内存中只有一份。</p>
<p>当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。</p>
<p>每个对象除了保存实例变量的值外，可以理解为还保存着对应类型即类的地址，这样，通过对象能知道它的类，访问到类的变量和方法代码。</p>
<p>实例方法可以理解为一个静态方法，只是多了一个参数this。通过对象调用方法，可以理解为就是调用这个静态方法，并将对象作为参数传给this。</p>
<p>对象的释放是被Java用垃圾回收机制管理的，大部分情况下，我们不用太操心，当对象不再被使用的时候会被自动释放。</p>
<p>具体来说，对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，而出栈就会释放。</p>
<p>堆中的内存是被垃圾回收机制管理的，当没有<strong>活跃变量</strong>指向对象的时候，对应的堆空间就可能被释放，具体释放时间是Java虚拟机自己决定的。活跃变量就是已加载的类的类变量，以及栈中所有的变量。</p>
<h2 id="3-1-9-小结"><a href="#3-1-9-小结" class="headerlink" title="3.1.9 小结"></a>3.1.9 小结</h2><p>本节我们主要从自定义数据类型的角度介绍了类，谈了如何定义和使用类。自定义类型由类变量、类方法、实例变量和实例方法组成，为方便对实例变量赋值，介绍了构造方法，最后介绍了类和对象的生命周期。</p>
<p>通过类实现自定义数据类型，封装该类型的数据所具有的属性和操作，隐藏实现细节，从而在更高的层次（类和对象的层次，而非基本数据类型和函数的层次）上考虑和操作数据，是计算机程序解决复杂问题的一种重要的思维方式。</p>
<p>本节提到了多个关键字，这里汇总一下。<br>1）public：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示可被外部访问。<br>2）private：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示不可以被外部访问，只能在类内部被使用。<br>3）static：修饰类变量和类方法，它也可以修饰内部类（5.3节介绍）。<br>4）this：表示当前实例，可以用于调用其他构造方法，访问实例变量，访问实例方法。<br>5）final：修饰类变量、实例变量，表示只能被赋值一次，也可以修饰实例方法和局部变量（下章会进一步介绍）。</p>
<p>本节介绍的Point类，其属性只有基本数据类型，下节介绍类的组合，以表达更为复杂的概念。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8ad72d35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8ad72d35/" class="post-title-link" itemprop="url">5.0 第5章 类的扩展 5.1 接口的本质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-08 12:34:05" itemprop="dateModified" datetime="2021-12-08T12:34:05+08:00">2021-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95/" itemprop="url" rel="index"><span itemprop="name">第5章 类的扩展</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8ad72d35/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8ad72d35/" data-xid="/JavaReadingNotes/8ad72d35/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第5章-类的扩展"><a href="#第5章-类的扩展" class="headerlink" title="第5章 类的扩展"></a>第5章 类的扩展</h1><p>之前我们一直在说，程序主要就是数据以及对数据的操作，而为了方便操作数据，高级语言引入了数据类型的概念。Java定义了8种基本数据类型，而类相当于是自定义数据类型，通过类的组合和继承可以表示和操作各种事物或者说对象。</p>
<p>除了基本的数据类型和类概念，还有一些扩展概念，包括接口、抽象类、内部类和枚举。上一章我们提到，继承有其两面性，替代继承的一种方式是使用接口，接口到底是什么呢？此外，介于接口和类之间，还有一个概念：抽象类，它又是什么呢？一个类可以定义在另一个类内部，称为内部类，为什么要有内部类，它到底是什么呢？枚举是一种特殊的数据类型，它有什么用呢？本章就来探讨这些概念，先来看接口。</p>
<h1 id="5-1-接口的本质"><a href="#5-1-接口的本质" class="headerlink" title="5.1 接口的本质"></a>5.1 接口的本质</h1><p>在之前的章节中，我们一直在强调数据类型的概念，但<strong>只是将对象看作属于某种数据类型，并按该类型进行操作，在一些情况下，并不能反映对象以及对对象操作的本质</strong>。</p>
<p>为什么这么说呢？很多时候，我们实际上关心的，并不是对象的类型，而是对象的<strong>能力</strong>，只要能提供这个能力，类型并不重要。我们来看一些生活中的例子。</p>
<p>比如要拍照，很多时候，只要能拍出符合需求的照片就行，至于是用手机拍，还是用Pad拍，或者是用单反相机拍，并不重要，即关心的<strong>是对象是否有拍出照片的能力</strong>，而并不关心对象到底是什么类型，手机、Pad或单反相机都可以。</p>
<p>又如要计算一组数字，只要能计算出正确结果即可，至于是由人心算，用算盘算，用计算器算，用计算机软件算，并不重要，即关心的是对象<strong>是否有计算的能力</strong>，而并不关心对象到底是算盘还是计算器。</p>
<p>再如要将冷水加热，只要能得到热水即可，至于是用电磁炉加热，用燃气灶加热，还是用电热水壶加热，并不重要，即重要的是对象<strong>是否有加热水的能力</strong>，而并不关心对象到底是什么类型。</p>
<p>在这些情况中，<strong>类型并不重要，重要的是能力</strong>。那如何表示能力呢？接口。下面就来详细介绍接口，包括其概念、用法、一些细节，以及如何用接口替代继承。</p>
<h2 id="5-1-1-接口的概念"><a href="#5-1-1-接口的概念" class="headerlink" title="5.1.1 接口的概念"></a>5.1.1 接口的概念</h2><p>接口这个概念在生活中并不陌生，电子世界中一个常见的接口就是USB接口。计算机往往有多个USB接口，可以插各种USB设备，如键盘、鼠标、U盘、摄像头、手机等。</p>
<p>接口声明了一组能力，但它自己并没有实现这个能力，它只是一个约定。接口涉及交互两方对象，一方需要实现这个接口，另一方使用这个接口，但<strong>双方对象并不直接互相依赖，它们只是通过接口间接交互</strong>，如图5-1所示。</p>
<p>拿上面的USB接口来说，USB协议约定了USB设备需要实现的能力，每个USB设备都需要实现这些能力，计算机使用USB协议与USB设备交互，计算机和USB设备互不依赖，但可以通过USB接口相互交互。下面我们来看Java中的接口。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208210342.jpeg" alt="epub_923038_45"></p>
<center>图5-1 接口的概念</center>

<h2 id="5-1-2-定义接口"><a href="#5-1-2-定义接口" class="headerlink" title="5.1.2 定义接口"></a>5.1.2 定义接口</h2><p>我们通过一个例子来说明Java中接口的概念。这个例子是“比较”，很多对象都可以比较，对于求最大值、求最小值、排序的程序而言，它们其实并不关心对象的类型是什么，只要对象可以比较就可以了，或者说，它们关心的是对象有没有可比较的能力。Java API中提供了Comparable接口，以表示可比较的能力，但它使用了泛型，而我们还没有介绍泛型，所以本节先自己定义一个Comparable接口，叫MyComparable。</p>
<p>首先来定义这个接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyComparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口的代码解释如下：<br>1）Java使用interface这个关键字来声明接口，修饰符一般都是public。<br>2）interface后面就是接口的名字MyComparable。<br>3）接口定义里面，声明了一个方法compareTo，但没有定义方法体，Java 8之前，接口内不能实现方法。接口方法不需要加修饰符，加与不加相当于都是publicabstract。</p>
<p>再来解释compareTo方法：<br>1）方法的参数是一个Object类型的变量other，表示另一个参与比较的对象。<br>2）第一个参与比较的对象是自己。<br>3）返回结果是int类型，-1表示自己小于参数对象，0表示相同，1表示大于参数对象。</p>
<p>接口与类不同，它的方法没有实现代码。定义一个接口本身并没有做什么，也没有太大的用处，它还需要至少两个参与者：一个需要实现接口，另一个使用接口。我们先来实现接口。</p>
<h2 id="5-1-3-实现接口"><a href="#5-1-3-实现接口" class="headerlink" title="5.1.3 实现接口"></a>5.1.3 实现接口</h2><p>类可以实现接口，表示类的对象具有接口所表示的能力。在此以上一章介绍过的Point类来说明。我们让Point具备可以比较的能力，Point之间怎么比较呢？我们假设按照与原点的距离进行比较，Point类代码如代码清单5-1所示。</p>
<center>代码清单5-1 Point类代码：实现了MyComparable</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">MyComparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(x＊x+y＊y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(! (other <span class="keyword">instanceof</span> Point))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        Point otherPoint = (Point)other;</span><br><span class="line">        <span class="keyword">double</span> delta = distance() - otherPoint.distance();</span><br><span class="line">        <span class="keyword">if</span>(delta&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(delta&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+x+<span class="string">&quot;, &quot;</span>+y+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释如下：<br>1）Java使用implements这个关键字表示实现接口，前面是类名，后面是接口名。<br>2）实现接口必须要实现接口中声明的方法，Point实现了compareTo方法。</p>
<p>再来解释Point的compareTo实现。<br>1）Point不能与其他类型的对象进行比较，它首先检查要比较的对象是否是Point类型，如果不是，使用throw抛出一个异常，异常将在下一章介绍，此处可以忽略。<br>2）如果是Point类型，则使用强制类型转换将Object类型的参数other转换为Point类型的参数otherPoint。<br>3）这种显式的类型检查和强制转换是可以使用泛型机制避免的，第8章我们再介绍泛型。</p>
<p>一个类可以实现多个接口，表明类的对象具备多种能力，各个接口之间以逗号分隔，语法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义和实现了接口，接下来我们来看怎么使用接口。</p>
<h2 id="5-1-4-使用接口"><a href="#5-1-4-使用接口" class="headerlink" title="5.1.4 使用接口"></a>5.1.4 使用接口</h2><p>与类不同，接口不能new，不能直接创建一个接口对象，对象只能通过类来创建。但可以声明接口类型的变量，引用实现了接口的类对象。比如，可以这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyComparable p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">MyComparable p2 = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(p1.compareTo(p2));</span><br></pre></td></tr></table></figure>

<p>p1和p2是MyComparable类型的变量，但引用了Point类型的对象，之所以能赋值是因为Point实现了MyComparable接口。如果一个类型实现了多个接口，那么这种类型的对象就可以被赋值给任一接口类型的变量。p1和p2可以调用MyComparable接口的方法，也只能调用MyComparable接口的方法，实际执行时，执行的是具体实现类的代码。</p>
<p>为什么Point类型的对象非要赋值给MyComparable类型的变量呢？在以上代码中，确实没必要。但在一些程序中，代码并不知道具体的类型，这才是接口发挥威力的地方。我们来看下面使用MyComparable接口的例子，如代码清单5-2所示。</p>
<center>代码清单5-2 使用MyComparable的示例：CompUtil</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">max</span><span class="params">(MyComparable[] objs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(objs==<span class="keyword">null</span>||objs.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MyComparable max = objs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;objs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max.compareTo(objs[i])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                max = objs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] objs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;objs.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;objs.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(objs[j].compareTo(objs[min])&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min!=i)&#123;</span><br><span class="line">                 Comparable temp = objs[i];</span><br><span class="line">                 objs[i] = objs[min];</span><br><span class="line">                 objs[min] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类CompUtil提供了两个方法，max获取传入数组中的最大值，sort对数组升序排序，参数都是MyComparable类型的数组，sort使用的是简单选择排序，具体算法我们就不介绍了。</p>
<p>可以看出，这个类是针对MyComparable接口编程，它并不知道具体的类型是什么，也并不关心，但却可以对任意实现了MyComparable接口的类型进行操作。我们来看如何对Point类型进行操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point[] points = <span class="keyword">new</span> Point[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">4</span>), <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;max: &quot;</span> + CompUtil.max(points));</span><br><span class="line">CompUtil.sort(points);</span><br><span class="line">System.out.println(<span class="string">&quot;sort: &quot;</span>+ Arrays.toString(points));</span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个Point类型的数组points，然后使用CompUtil的max方法获取最大值，使用sort排序，并输出结果，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max: (3,4)</span><br><span class="line">sort: [(1,2), (2,3), (3,4)]</span><br></pre></td></tr></table></figure>

<p>这里演示的是对Point数组操作，实际上可以针对任何实现了MyComparable接口的类型数组进行操作。这就是接口的威力，可以说，<strong>针对接口而非具体类型进行编程，是计算机程序的一种重要思维方式</strong>。接口很多时候反映了对象以及对对象操作的本质。它的优点有很多，首先是<strong>代码复用</strong>，同一套代码可以处理多种不同类型的对象，只要这些对象都有相同的能力，如CompUtil。</p>
<p><strong>接口更重要的是降低了耦合，提高了灵活性</strong>。使用接口的代码依赖的是接口本身，而非实现接口的具体类型，程序可以根据情况替换接口的实现，而不影响接口使用者。解决复杂问题的关键是分而治之，将复杂的大问题分解为小问题，但小问题之间不可能一点关系没有，分解的核心就是要降低耦合，提高灵活性，接口为恰当分解提供了有力的工具。</p>
<h2 id="5-1-5-接口的细节"><a href="#5-1-5-接口的细节" class="headerlink" title="5.1.5 接口的细节"></a>5.1.5 接口的细节</h2><p>前面介绍了接口的基本内容，接口还有一些细节，包括：</p>
<ul>
<li>接口中的变量。</li>
<li>接口的继承。</li>
<li>类的继承与接口。</li>
<li>instanceof。</li>
</ul>
<p>下面具体介绍。</p>
<h3 id="（1）接口中的变量"><a href="#（1）接口中的变量" class="headerlink" title="（1）接口中的变量"></a>（1）接口中的变量</h3><p>接口中可以定义变量，语法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个变量int a，修饰符是public static final，但这个修饰符是可选的，即使不写，也是public static final。这个变量可以通过“接口名．变量名”的方式使用，如Interface1.a。</p>
<h3 id="（2）接口的继承"><a href="#（2）接口的继承" class="headerlink" title="（2）接口的继承"></a>（2）接口的继承</h3><p>接口也可以继承，一个接口可以继承其他接口，继承的基本概念与类一样，但与类不同的是，接口可以有多个父接口，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBase1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBase2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IChild</span> <span class="keyword">extends</span> <span class="title">IBase1</span>, <span class="title">IBase2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IChild有IBase1和IBase2两个父类，接口的继承同样使用extends关键字，多个父接口之间以逗号分隔。</p>
<h3 id="（3）类的继承与接口"><a href="#（3）类的继承与接口" class="headerlink" title="（3）类的继承与接口"></a>（3）类的继承与接口</h3><p>类的继承与接口可以共存，换句话说，类可以在继承基类的情况下，同时实现一个或多个接口，语法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">IChild</span> </span>&#123;</span><br><span class="line">  <span class="comment">//主体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键字extends要放在implements之前。</p>
<h3 id="（4）instanceof"><a href="#（4）instanceof" class="headerlink" title="（4）instanceof"></a>（4）instanceof</h3><p>与类一样，接口也可以使用instanceof关键字，用来判断一个对象是否实现了某接口，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(p <span class="keyword">instanceof</span> MyComparable)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;comparable&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-6-使用接口替代继承"><a href="#5-1-6-使用接口替代继承" class="headerlink" title="5.1.6 使用接口替代继承"></a>5.1.6 使用接口替代继承</h2><p>上一章我们提到，可以使用组合和接口替代继承。怎么替代呢？</p>
<p>继承至少有两个好处：一个是复用代码；另一个是利用多态和动态绑定统一处理多种不同子类的对象。使用组合替代继承，可以复用代码，但不能统一处理。使用接口替代继承，针对接口编程，可以实现统一处理不同类型的对象，但接口没有代码实现，无法复用代码。将组合和接口结合起来替代继承，就既可以统一处理，又可以复用代码了。</p>
<p>我们还是以4.4节的例子来说明，先增加一个接口IAdd，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAdd</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span>[] numbers)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Base代码，让它实现IAdd接口，代码基本不变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> <span class="keyword">implements</span> <span class="title">IAdd</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主体代码，与代码清单4-10一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改Child代码，也是实现IAdd接口，代码基本不变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">IAdd</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主体代码，组合使用Base，与代码清单4-12一样</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Child复用了Base的代码，又都实现了IAdd接口，这样，既复用代码，又可以统一处理，还不用担心破坏封装。</p>
<h2 id="5-1-7-Java-8和Java-9对接口的增强"><a href="#5-1-7-Java-8和Java-9对接口的增强" class="headerlink" title="5.1.7 Java 8和Java 9对接口的增强"></a>5.1.7 Java 8和Java 9对接口的增强</h2><p>需要说明的是，前面介绍的都是Java 8之前的接口概念，Java 8和Java 9对接口做了一些增强。在Java 8之前，接口中的方法都是抽象方法，都没有实现体，Java 8允许在接口中定义两类新方法：<strong>静态方法和默认方法</strong>，它们有实现体，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test()就是一个静态方法，可以通过IDemo.test()调用。在接口不能定义静态方法之前，相关的静态方法往往定义在单独的类中，比如，Java API中，Collection接口有一个对应的单独的类Collections，在Java 8中，就可以直接写在接口中了，比如Comparator接口就定义了多个静态方法。</p>
<p>hi()是一个默认方法，用关键字default表示。默认方法与抽象方法都是接口的方法，不同在于，默认方法有默认的实现，实现类可以改变它的实现，也可以不改变。<strong>引入默认方法主要是函数式数据处理的需求，是为了便于给接口增加功能</strong>。关于函数式数据处理，会在第26章介绍。</p>
<p>在没有默认方法之前，Java是很难给接口增加功能的，比如List接口（第9章介绍），因为有太多非Java JDK控制的代码实现了该接口，如果给接口增加一个方法，则那些接口的实现就无法在新版Java上运行，必须改写代码，实现新的方法，这显然是无法接受的。函数式数据处理需要给一些接口增加一些新的方法，所以就有了默认方法的概念，接口增加了新方法，而接口现有的实现类也不需要必须实现。看一些例子，List接口增加了sort方法，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span>(Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collection接口增加了stream方法，其定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java 8中，静态方法和默认方法都必须是public的，Java 9去除了这个限制，它们都可以是private的，引入private方法主要是为了方便多个静态或默认方法复用代码，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDemoPrivate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">common</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;common&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">actionA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        common();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">actionB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        common();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，actionA和actionB两个默认方法共享了相同的common()方法的代码。</p>
<h2 id="5-1-8-小结"><a href="#5-1-8-小结" class="headerlink" title="5.1.8 小结"></a>5.1.8 小结</h2><p>本节我们谈了数据类型思维的局限，提到了很多时候关心的是能力，而非类型，所以引入了接口，介绍了Java中接口的概念和细节。<strong>针对接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，是分解复杂问题的一种重要工具</strong>。</p>
<p>接口不能创建对象，没有任何实现代码（Java 8之前），而之前介绍的类都有完整的实现，都可以创建对象。Java中还有一个介于接口和类之间的概念：抽象类，它有什么用呢？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/cb0345d2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/cb0345d2/" class="post-title-link" itemprop="url">5.3 内部类的本质</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC5%E7%AB%A0-%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95/" itemprop="url" rel="index"><span itemprop="name">第5章 类的扩展</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/cb0345d2/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/cb0345d2/" data-xid="/JavaReadingNotes/cb0345d2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="5-3-内部类的本质"><a href="#5-3-内部类的本质" class="headerlink" title="5.3 内部类的本质"></a>5.3 内部类的本质</h1><p>之前我们所说的类都对应于一个独立的Java源文件，但一个类还可以放在另一个类的内部，称之为内部类，相对而言，包含它的类称之为<strong>外部类</strong>。</p>
<p>一般而言，<strong>内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁</strong>。</p>
<p>不过，内部类只是Java编译器的概念，对于Java虚拟机而言，它是不知道内部类这回事的，<strong>每个内部类最后都会被编译为一个独立的类</strong>，生成一个独立的字节码文件。</p>
<p>也就是说，每个内部类其实都可以被替换为一个独立的类。当然，这是单纯就技术实现而言。<strong>内部类可以方便地访问外部类的私有变量，可以声明为private从而实现对外完全隐藏，相关代码写在一起，写法也更为简洁，这些都是内部类的好处</strong>。</p>
<p>在Java中，根据定义的位置和方式不同，主要有4种内部类。</p>
<ul>
<li>静态内部类。</li>
<li>成员内部类。</li>
<li>方法内部类。</li>
<li>匿名内部类。</li>
</ul>
<p>其中，方法内部类是在一个方法内定义和使用的；匿名内部类使用范围更小，它们都不能在外部使用；成员内部类和静态内部类可以被外部使用，不过它们都可以被声明为private，这样，外部就不能使用了。接下来，我们逐个介绍这些内部类的语法、实现原理以及使用场景。</p>
<h2 id="5-3-1-静态内部类"><a href="#5-3-1-静态内部类" class="headerlink" title="5.3.1 静态内部类"></a>5.3.1 静态内部类</h2><p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。</p>
<p>静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，下面我们介绍它的语法、实现原理和应用场景。我们看个静态内部类的例子，如代码清单5-3所示。</p>
<center>代码清单5-3 静态内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shared = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;inner &quot;</span> + shared);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StaticInner si = <span class="keyword">new</span> StaticInner();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部类为Outer，静态内部类为StaticInner，带有static修饰符。语法上，静态内部类除了位置放在其他类内部外，它与一个独立的类差别不大，可以有静态变量、静态方法、成员方法、成员变量、构造方法等。</p>
<p>静态内部类与外部类的联系也不大（与其他内部类相比）。它可以访问外部类的静态变量和方法，如innerMethod直接访问shared变量，但不可以访问实例变量和方法。在类内部，可以直接使用内部静态类，如test()方法所示。</p>
<p>public静态内部类可以被外部使用，只是需要通过“外部类．静态内部类”的方式使用，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.StaticInner si = <span class="keyword">new</span> Outer.StaticInner();</span><br><span class="line">si.innerMethod();</span><br></pre></td></tr></table></figure>

<p>静态内部类是怎么实现的呢？代码清单5-3所示的代码实际上会生成两个类：一个是Outer，另一个是Outer$StaticInner，代码大概如代码清单5-4所示。</p>
<center>代码清单5-4 静态内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> shared = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Outer$StaticInner si = <span class="keyword">new</span> Outer$StaticInner();</span><br><span class="line">        si.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> shared;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">StaticInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;inner &quot;</span> + Outer.access$<span class="number">0</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类访问了外部类的一个私有静态变量shared，而我们知道私有变量是不能被类外部访问的，Java的解决方法是：自动为Outer生成一个非私有访问方法access$0，它返回这个私有静态变量shared。</p>
<p>静态内部类的使用场景是很多的，如果它与外部类关系密切，且不依赖于外部类实例，则可以考虑定义为静态内部类。比如，一个类内部，如果既要计算最大值，又要计算最小值，可以在一次遍历中将最大值和最小值都计算出来，但怎么返回呢？可以定义一个类Pair，包括最大值和最小值，但Pair这个名字太普遍，而且它主要是类内部使用的，就可以定义为一个静态内部类。</p>
<p>我们也可以看一些在Java API中使用静态内部类的例子：</p>
<ul>
<li>Integer类内部有一个私有静态内部类IntegerCache，用于支持整数的自动装箱。</li>
<li>表示链表的LinkedList类内部有一个私有静态内部类Node，表示链表中的每个节点。</li>
<li>Character类内部有一个public静态内部类UnicodeBlock，用于表示一个Unicode block。</li>
</ul>
<p>以上一些类的细节我们在后续章节会再介绍。</p>
<h2 id="5-3-2-成员内部类"><a href="#5-3-2-成员内部类" class="headerlink" title="5.3.2 成员内部类"></a>5.3.2 成员内部类</h2><p>与静态内部类相比，成员内部类没有static修饰符，少了一个static修饰符，含义有很大不同，下面我们详细讨论。我们看个成员内部类的例子，如代码清单5-5所示。</p>
<center>代码清单5-5 成员内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;outer a &quot;</span> +a);</span><br><span class="line">            Outer.<span class="keyword">this</span>.action();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Inner就是成员内部类，与静态内部类不同，除了静态变量和方法，成员内部类还可以直接访问外部类的实例变量和方法，如innerMethod直接访问外部类私有实例变量a。成员内部类还可以通过“外部类．this.xxx”的方式引用外部类的实例变量和方法，如Outer.this. action()，这种写法一般在重名的情况下使用，如果没有重名，那么“外部类．this. ”是多余的。</p>
<p>在外部类内，使用成员内部类与静态内部类是一样的，直接使用即可，如test()方法所示。与静态内部类不同，<strong>成员内部类对象总是与一个外部类对象相连的</strong>，在外部使用时，它不能直接通过new Outer.Inner()的方式创建对象，而是要先将创建一个Outer类对象，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.n<span class="function">ew <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">inner.innerMethod();</span><br></pre></td></tr></table></figure>

<p>创建内部类对象的语法是“外部类对象<code>.new 内部类()</code>”，如outer.new Inner()。</p>
<p>与静态内部类不同，成员内部类中不可以定义静态变量和方法（final变量例外，它等同于常量），下面介绍的方法内部类和匿名内部类也都不可以。Java为什么要有这个规定呢？可以这么理解，这些内部类是与外部实例相连的，不应独立使用，而静态变量和方法作为类型的属性和方法，一般是独立使用的，在内部类中意义不大，而如果内部类确实需要静态变量和方法，那么也可以挪到外部类中。</p>
<p>成员内部类背后是怎么实现的呢？代码清单5-5也会生成两个类：一个是Outer，另一个是Outer$Inner，它们的代码大概如代码清单5-6所示。</p>
<center>代码清单5-6 成员内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Outer$Inner inner = <span class="keyword">new</span> Outer$Inner(<span class="keyword">this</span>);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>(Outer outer) &#123;</span><br><span class="line">        <span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> access$<span class="number">1</span>(Outer outer) &#123;</span><br><span class="line">        outer.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Outer outer;</span><br><span class="line">    <span class="keyword">public</span> Outer$Inner(Outer outer)&#123;</span><br><span class="line">        ths.outer = outer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span> + Outer.access$<span class="number">0</span>(outer));</span><br><span class="line">        Outer.access$<span class="number">1</span>(outer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Outer$Inner类有个实例变量outer指向外部类的对象，它在构造方法中被初始化，Outer在新建Outer$Inner对象时给它传递当前对象，由于内部类访问了外部类的私有变量和方法，外部类Outer生成了两个非私有静态方法：access$0用于访问变量a, access$1用于访问方法action。</p>
<p>成员内部类有哪些应用场景呢？如果内部类与外部类关系密切，需要访问外部类的实例变量或方法，则可以考虑定义为成员内部类。外部类的一些方法的返回值可能是某个接口，为了返回这个接口，外部类方法可能使用内部类实现这个接口，这个内部类可以被设为private，对外完全隐藏。</p>
<p>比如，在Java API的类LinkedList中，它的两个方法listIterator和descendingIterator的返回值都是接口Iterator，调用者可以通过Iterator接口对链表遍历，listIterator和descend-ingIterator内部分别使用了成员内部类ListItr和DescendingIterator，这两个内部类都实现了接口Iterator。关于LinkedList，第9章会详细介绍。</p>
<h2 id="5-3-3-方法内部类"><a href="#5-3-3-方法内部类" class="headerlink" title="5.3.3 方法内部类"></a>5.3.3 方法内部类</h2><p>内部类还可以定义在一个方法体中。我们看个例子，如代码清单5-7所示。</p>
<center>代码清单5-7 方法内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> param)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;outer a &quot;</span> +a);</span><br><span class="line">                System.out.println(<span class="string">&quot;param &quot;</span> +param);</span><br><span class="line">                System.out.println(<span class="string">&quot;local var &quot;</span> +str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类Inner定义在外部类方法test中，方法内部类只能在定义的方法内被使用。如果方法是实例方法，则除了静态变量和方法，内部类还可以直接访问外部类的实例变量和方法，如innerMethod直接访问了外部私有实例变量a。如果方法是静态方法，则方法内部类只能访问外部类的静态变量和方法。方法内部类还可以直接访问方法的参数和方法中的局部变量，不过，这些变量必须被声明为final，如innerMethod直接访问了方法参数param和局部变量str。</p>
<p>方法内部类是怎么实现的呢？对于代码清单5-7，系统生成的两个类代码大概如代码清单5-8所示。</p>
<center>代码清单5-8 方法内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        OuterInner inner = <span class="keyword">new</span> OuterInner(<span class="keyword">this</span>, param);</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> access$<span class="number">0</span>(Outer outer)&#123;</span><br><span class="line">        <span class="keyword">return</span> outer.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterInner</span> </span>&#123;</span><br><span class="line">    Outer outer;</span><br><span class="line">    <span class="keyword">int</span> param;</span><br><span class="line">    OuterInner(Outer outer, <span class="keyword">int</span> param)&#123;</span><br><span class="line">        <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        <span class="keyword">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;outer a &quot;</span> + Outer.access$<span class="number">0</span>(<span class="keyword">this</span>.outer));</span><br><span class="line">        System.out.println(<span class="string">&quot;param &quot;</span> + param);</span><br><span class="line">        System.out.println(<span class="string">&quot;local var &quot;</span> + <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与成员内部类类似，OuterInner类也有一个实例变量outer指向外部对象，在构造方法中被初始化，对外部私有实例变量的访问也是通过Outer添加的方法access$0来进行的。</p>
<p>方法内部类可以访问方法中的参数和局部变量，这是通过在构造方法中传递参数来实现的，如OuterInner构造方法中有参数int param，在新建OuterInner对象时，Outer类将方法中的参数传递给了内部类，如OuterInner inner = newOuterInner(this, param); 。在上面的代码中，String str并没有被作为参数传递，这是因为它被定义为了常量，在生成的代码中，可以直接使用它的值。</p>
<p>这也解释了为什么方法内部类访问外部方法中的参数和局部变量时，这些变量必须被声明为final，因为实际上，<strong>方法内部类操作的并不是外部的变量，而是它自己的实例变量</strong>，只是这些变量的值和外部一样，对这些变量赋值，并不会改变外部的值，为避免混淆，所以干脆强制规定必须声明为final。</p>
<p>如果的确需要修改外部的变量，那么可以将变量改为只含该变量的数组，修改数组中的值，如代码清单5-9所示。</p>
<center>代码清单5-9 方法内部类修改外部变量实例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String[] str = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">                str[<span class="number">0</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">        System.out.println(str[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str是一个只含一个元素的数组，方法内部类不能修改str本身，但可以修改它的数组元素。</p>
<p>通过前面介绍的语法和原理可以看出，方法内部类可以用成员内部类代替，至于方法参数，也可以作为参数传递给成员内部类。不过，如果类只在某个方法内被使用，使用方法内部类，可以实现更好的封装。</p>
<h2 id="5-3-4-匿名内部类"><a href="#5-3-4-匿名内部类" class="headerlink" title="5.3.4 匿名内部类"></a>5.3.4 匿名内部类</h2><p>与前面介绍的内部类不同，匿名内部类没有单独的类定义，它在创建对象的同时定义类，语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类(参数列表) &#123;</span><br><span class="line">    <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口() &#123;</span><br><span class="line">    <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类是与new关联的，在创建对象的时候定义类，new后面是父类或者父接口，然后是圆括号()，里面可以是传递给父类构造方法的参数，最后是大括号{}，里面是类的定义。</p>
<p>看个具体的例子，如代码清单5-10所示。</p>
<center>代码清单5-10 匿名内部类示例</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">            Point p = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> distance(<span class="keyword">new</span> Point(x, y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        System.out.println(p.distance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2和3，重写了distance()方法，在方法中访问了外部方法final参数x和y。</p>
<p>匿名内部类只能被使用一次，用来创建一个对象。它没有名字，没有构造方法，但可以根据参数列表，调用对应的父类构造方法。它可以定义实例变量和方法，可以有初始化代码块，初始化代码块可以起到构造方法的作用，只是构造方法可以有多个，而初始化代码块只能有一份。因为没有构造方法，它自己无法接受参数，如果必须要参数，则应该使用其他内部类。与方法内部类一样，匿名内部类也可以访问外部类的所有变量和方法，可以访问方法中的final参数和局部变量。</p>
<p>匿名内部类是怎么实现的呢？每个匿名内部类也都被生成为一个独立的类，只是类的名字以外部类加数字编号，没有有意义的名字。代码清单5-10会产生两个类Outer和Outer$1，代码大概如代码清单5-11所示。</p>
<center>代码清单5-11 匿名内部类示例的内部实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Outer$<span class="number">1</span>(<span class="keyword">this</span>,<span class="number">2</span>,<span class="number">3</span>, x, y);</span><br><span class="line">        System.out.println(p.distance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span>$1 <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">    <span class="keyword">int</span> y2;</span><br><span class="line">    Outer outer;</span><br><span class="line">    Outer$<span class="number">1</span>(Outer outer, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)&#123;</span><br><span class="line">        <span class="keyword">super</span>(x1, y1);</span><br><span class="line">        <span class="keyword">this</span>.outer = outer;</span><br><span class="line">        <span class="keyword">this</span>.x2 = x2;</span><br><span class="line">        <span class="keyword">this</span>.y2 = y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distance(<span class="keyword">new</span> Point(<span class="keyword">this</span>.x2, y2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与方法内部类类似，外部实例this、方法参数x和y都作为参数传递给了内部类构造方法。此外，new时的参数2和3也传递给了构造方法，内部类构造方法又将它们传递给了父类构造方法。</p>
<p>在调用方法时，很多方法需要一个接口参数，比如Arrays.sort方法，它可以接受一个数组，以及一个Comparator接口参数，Comparator有一个方法compare用于比较两个对象。比如，要对一个字符串数组不区分大小写排序，可以使用Arrays.sort方法，但需要传递一个实现了Comparator接口的对象，这时就可以使用匿名内部类，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortIgnoreCase</span><span class="params">(String[] strs)</span></span>&#123;</span><br><span class="line">    Arrays.sort(strs, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Comparator后面的<code>&lt;String&gt;</code>与泛型有关，表示比较的对象是字符串类型。匿名内部类还经常用于事件处理程序中，用于响应某个事件，比如一个Button，处理单击事件的代码可能类似如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Button bt = <span class="keyword">new</span> Button();</span><br><span class="line">bt.addActionListener(<span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//处理事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>调用addActionListener将事件处理程序注册到了Button对象bt中，当事件发生时，会调用actionPerformed方法，并传递事件详情ActionEvent作为参数。</p>
<p>以上Arrays.sort和Button都是针对接口编程的例子，另外，它们也都是一种回调的例子。所谓回调是相对于一般的正向调用而言的，平时一般都是正向调用，但Arrays.sort中传递的Comparator对象，它的compare方法并不是在写代码的时候被调用的，而是在Arrays. sort的内部某个地方回过头来调用的。Button的addActionListener中传递的ActionListener对象，它的actionPerformed方法也一样，是在事件发生的时候回过头来调用的。</p>
<p>将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行协作，是计算机程序的一种常用实践。匿名内部类是实现回调接口的一种简便方式。</p>
<p>至此，关于各种内部类就介绍完了。内部类本质上都会被转换为独立的类，但一般而言，它们可以实现更好的封装，代码实现上也更为简洁。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/f0edbeff/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/f0edbeff/" class="post-title-link" itemprop="url">7.4 剖析Arrays</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/f0edbeff/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/f0edbeff/" data-xid="/JavaReadingNotes/f0edbeff/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>8.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-4-剖析Arrays"><a href="#7-4-剖析Arrays" class="headerlink" title="7.4 剖析Arrays"></a>7.4 剖析Arrays</h1><p>数组是存储多个同类型元素的基本数据结构，数组中的元素在内存连续存放，可以通过数组下标直接定位任意元素，相比在后续章节介绍的其他容器而言效率非常高。</p>
<p>数组操作是计算机程序中的常见基本操作。Java中有一个类Arrays，包含一些对数组操作的静态方法，本节主要就来讨论这些方法。首先介绍怎么用，然后介绍它们的实现原理。学习Arrays的用法，就可以“避免重新发明轮子”，直接使用，学习它的实现原理，就可以在需要的时候自己实现它不具备的功能。</p>
<h2 id="7-4-1-用法"><a href="#7-4-1-用法" class="headerlink" title="7.4.1 用法"></a>7.4.1 用法</h2><p>Arrays类中有很多方法，我们主要介绍toString、排序、查找，对于一些其他方法，如复制、比较、批量设置值和计算哈希值等，我们也进行简单介绍。</p>
<h3 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString"></a>1. toString</h3><p>Arrays的toString()方法可以方便地输出一个数组的字符串形式，以便查看。它有9个重载的方法，包括8个基本类型数组和1个对象类型数组，下面列举两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(Object[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">String[] strArr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(strArr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[9, 8, 3, 4]</span><br><span class="line">[hello, world]</span><br></pre></td></tr></table></figure>

<p>如果不使用Arrays.toString方法，直接输出数组自身，即代码改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(Object[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>[] arr </span>= &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">String[] strArr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(strArr));</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(arr);</span><br><span class="line">String[] strArr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">System.out.println(strArr);</span><br></pre></td></tr></table></figure>

<p>则输出会变为如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[I@1224b90</span><br><span class="line">[Ljava.lang.String; @728edb84</span><br></pre></td></tr></table></figure>

<p>这个输出就难以阅读了，@后面的数字表示的是内存的地址。</p>
<h3 id="2．排序"><a href="#2．排序" class="headerlink" title="2．排序"></a>2．排序</h3><p>排序是一种非常常见的操作。同toString一样，对每种基本类型的数组，Arrays都有sort方法（boolean除外），例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">double</span>[] a)</span></span></span><br></pre></td></tr></table></figure>

<p>排序按照从小到大升序排列，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>数组已经排好序了。</p>
<p>除了基本类型，sort还可以直接接受对象类型，但对象需要实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>我们看个String数组的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Break, abc, hello, world]</span><br></pre></td></tr></table></figure>

<p>“Break”之所以排在最前面，是因为大写字母的ASCII码比小写字母都小。那如果排序的时候希望忽略大小写呢？sort还有另外两个重载方法，可以接受一个比较器作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>方法声明中的T表示泛型，泛型我们在第8章介绍，这里表示的是，这个方法可以支持所有对象类型，只要传递这个类型对应的比较器就可以了。Comparator就是比较器，它是一个接口，Java 7中的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最主要的是compare这个方法，它比较两个对象，返回一个表示比较结果的值，-1表示o1小于o2,0表示o1等于o2,1表示o1大于o2。排序是通过比较来实现的，sort方法在排序的过程中需要对对象进行比较的时候，就调用比较器的compare方法。Java 8中Comparator增加了多个静态和默认方法，具体可参看API文档。</p>
<p>String类有一个public静态成员，表示忽略大小写的比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br></pre></td></tr></table></figure>

<p>我们通过这个比较器再来对上面的String数组排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>这样，大小写就忽略了，输出变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[abc, Break, hello, world]</span><br></pre></td></tr></table></figure>

<p>为进一步理解Comparator，我们来看下String的这个比较器的主要实现代码，如代码清单7-2所示。</p>
<center>代码清单7-2 String的CaseInsensitiveComparator实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">          <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">          <span class="keyword">int</span> min = Math.min(n1, n2);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">              <span class="keyword">char</span> c1 = s1.charAt(i);</span><br><span class="line">              <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">              <span class="keyword">if</span>(c1 ! = c2) &#123;</span><br><span class="line">                  c1 = Character.toUpperCase(c1);</span><br><span class="line">                  c2 = Character.toUpperCase(c2);</span><br><span class="line">                  <span class="keyword">if</span>(c1 ! = c2) &#123;</span><br><span class="line">                      c1 = Character.toLowerCase(c1);</span><br><span class="line">                      c2 = Character.toLowerCase(c2);</span><br><span class="line">                      <span class="keyword">if</span>(c1 ! = c2) &#123;</span><br><span class="line">                        <span class="comment">//No overflow because of numeric promotion</span></span><br><span class="line">                        <span class="keyword">return</span> c1 - c2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单直接，就不解释了。</p>
<p>sort方法默认是从小到大排序，如果希望按照从大到小排序呢？对于对象类型，可以指定一个不同的Comparator，可以用匿名内部类来实现Comparator，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareToIgnoreCase(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>程序输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[world, hello, Break, abc]</span><br></pre></td></tr></table></figure>

<p>以上代码使用一个匿名内部类实现Comparator接口，返回o2与o1进行忽略大小写比较的结果，这样就能实现忽略大小写且按从大到小排序。</p>
<p>Collections类中有两个静态方法，可以返回逆序的Comparator，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">(Comparator&lt;T&gt; cmp)</span></span></span><br></pre></td></tr></table></figure>

<p>关于Collections类，我们在12.2节介绍。</p>
<p>这样，上面字符串忽略大小写逆序排序的代码可以改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;Break&quot;</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr, Collections.reverseOrder(String.CASE_INSENSITIVE_ORDER));</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p><strong>传递比较器Comparator给sort方法，体现了程序设计中一种重要的思维方式。将不变和变化相分离，排序的基本步骤和算法是不变的，但按什么排序是变化的，sort方法将不变的算法设计为主体逻辑，而将变化的排序方式设计为参数，允许调用者动态指定，这也是一种常见的设计模式，称为策略模式，不同的排序方式就是不同的策略</strong>。</p>
<h3 id="3．查找"><a href="#3．查找" class="headerlink" title="3．查找"></a>3．查找</h3><p>Arrays包含很多与sort对应的查找方法，可以在已排序的数组中进行二分查找。所谓二分查找就是从中间开始查找，如果小于中间元素，则在前半部分查找，否则在后半部分查找，每比较一次，要么找到，要么将查找范围缩小一半，所以查找效率非常高。</p>
<p>二分查找既可以针对基本类型数组，也可以针对对象数组，对对象数组，也可以传递Comparator，也可以指定查找范围。比如，针对int数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span></span></span><br></pre></td></tr></table></figure>

<p>针对对象数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span></span></span><br></pre></td></tr></table></figure>

<p>指定自定义比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T[] a, T key, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>

<p>如果能找到，binarySearch返回找到的元素索引，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">21</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">13</span>));</span><br></pre></td></tr></table></figure>

<p>输出为3。如果没找到，返回一个负数，这个负数等于-（插入点+<br>1）。插入点表示，如果在这个位置插入没找到的元素，可以保持原数组有序，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">21</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(arr, <span class="number">11</span>));</span><br></pre></td></tr></table></figure>

<p>输出为-4，表示插入点为3，如果在3这个索引位置处插入11，可以保持数组有序，即数组会变为{3,5,7,11,13,21}。</p>
<p>需要注意的是，binarySearch针对的必须是已排序数组，如果指定了Comparator，需要和排序时指定的Comparator保持一致。另外，如果数组中有多个匹配的元素，则返回哪一个是不确定的。</p>
<h3 id="4．更多方法"><a href="#4．更多方法" class="headerlink" title="4．更多方法"></a>4．更多方法</h3><p>除了常用的toString、排序和查找，Arrays中还有复制、比较、批量设置值和计算哈希值等方法。</p>
<p>基于原数组，复制一个新数组，与toString一样，也有多种重载形式，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[] copyOf(<span class="keyword">long</span>[] original, <span class="keyword">int</span> newLength)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength)</span><br></pre></td></tr></table></figure>

<p>判断两个数组是否相同，支持基本类型和对象类型，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">boolean</span>[] a, <span class="keyword">boolean</span>[] a2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object[] a, Object[] a2)</span></span></span><br></pre></td></tr></table></figure>

<p>只有数组长度相同，且每个元素都相同，才返回true，否则返回false。对于对象，相同是指equals返回true。</p>
<p>Arrays包含很多fill方法，可以给数组中的每个元素设置一个相同的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>也可以给数组中一个给定范围的每个元素设置一个相同的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> val)</span></span></span><br></pre></td></tr></table></figure>

<p>针对数组，计算一个数组的哈希值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">int</span> a[])</span></span></span><br></pre></td></tr></table></figure>

<p>计算hashCode的算法和String是类似的，我们看下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> element : a)</span><br><span class="line">        result = <span class="number">31</span> ＊ result + element;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下，String计算hashCode的算法也是类似的，数组中的每个元素都影响hash值，位置不同，影响也不同，使用31一方面产生的哈希值更分散，另一方面计算效率也比较高。</p>
<p>Java 8和9对Arrays类又增加了一些方法，比如将数组转换为流、并行排序、数组比较等，具体可参看API文档。</p>
<h2 id="7-4-2-多维数组"><a href="#7-4-2-多维数组" class="headerlink" title="7.4.2 多维数组"></a>7.4.2 多维数组</h2><p>之前介绍的数组都是一维的，数组还可以是多维的。先来看二维数组，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr[i].length; j++)&#123;</span><br><span class="line">        arr[i][j] = i+j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr就是一个二维数组，第一维长度为2，第二维长度为3，类似于一个矩阵，或者类似于一个表格，第一维表示行，第二维表示列。arr[i]表示第i行，它本身还是一个数组， arr[i][j]表示第i行中的第j个元素。</p>
<p>除了二维，数组还可以是三维、四维等，但一般而言，很少用到三维以上的数组，有几维，就有几个[]。比如，一个三维数组的声明为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>在创建数组时，除了第一维的长度需要指定外，其他维的长度不需要指定，甚至第一维中每个元素的第二维的长度可以不一样，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>arr是一个二维数组，第一维的长度为2，第一个元素的第二维长度为3，而第二个元素的第二维长度为5。</p>
<p>多维数组到底是什么呢？其实，可以认为，<strong>多维数组只是一个假象，只有一维数组，只是数组中的每个元素还可以是一个数组</strong>，这样就形成二维数组；如果其中每个元素还都是一个数组，那就是三维数组。</p>
<p>Arrays中的toString、equals、hashCode都有对应的针对多维数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">deepToString</span><span class="params">(Object[] a)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deepEquals</span><span class="params">(Object[] a1, Object[] a2)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deepHashCode</span><span class="params">(Object a[])</span></span></span><br></pre></td></tr></table></figure>

<p>这些deepXXX方法，都会判断参数中的元素是否也为数组，如果是，会递归进行操作。</p>
<p>看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(arr));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[0, 1], [2, 3, 4], [5, 6, 7, 8]]</span><br></pre></td></tr></table></figure>

<h2 id="7-4-3-实现原理"><a href="#7-4-3-实现原理" class="headerlink" title="7.4.3 实现原理"></a>7.4.3 实现原理</h2><p>下面介绍Arrays的方法的实现原理。hashCode()的实现我们已经介绍了；fill和equals等的实现都很简单，循环操作即可，不再赘述；下面主要介绍二分查找和排序的实现代码。</p>
<h3 id="1．二分查找"><a href="#1．二分查找" class="headerlink" title="1．二分查找"></a>1．二分查找</h3><p>二分查找（binarySearch）的代码比较直接，如代码清单7-3所示。</p>
<center>代码清单7-3 Arrays的二分查找实现</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(T[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      T key, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        T midVal = a[mid];</span><br><span class="line">        <span class="keyword">int</span> cmp = c.compare(midVal, key);</span><br><span class="line">        <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">//key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);   <span class="comment">//key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中有两个标志：low和high，表示查找范围，在while循环中，与中间值进行对比，大于则在后半部分查找（提高low），否则在前半部分查找（降低high）。</p>
<h3 id="2．排序-1"><a href="#2．排序-1" class="headerlink" title="2．排序"></a>2．排序</h3><p>与Arrays中的其他方法相比，sort要复杂得多。排序是计算机程序中一个非常重要的方面，几十年来，计算机科学家和工程师们对此进行了大量的研究，设计实现了各种各样的算法，进行了大量的优化。一般而言，没有一个最好的算法，不同算法往往有不同的适用场合。</p>
<p>那Arrays的sort是如何实现的呢？具体实现非常复杂，我们简单了解下。</p>
<p>对于基本类型的数组，Java采用的算法是<strong>双枢轴快速排序</strong>（Dual-PivotQuicksort）。这个算法是Java 7引入的，在此之前，Java采用的算法是普通的快速排序。双枢轴快速排序是对快速排序的优化，新算法的实现代码位于类java.util.DualPivotQuicksort中。</p>
<p>对于对象类型，Java采用的算法是TimSort。TimSort也是在Java 7引入的，在此之前， Java采用的是归并排序。TimSort实际上是对归并排序的一系列优化，TimSort的实现代码位于类java.util.TimSort中。</p>
<p>在这些排序算法中，如果数组长度比较小，它们还会采用效率更高的插入排序。</p>
<p>为什么基本类型和对象类型的算法不一样呢？排序算法有一个稳定性的概念，所谓稳定性就是对值相同的元素，如果排序前和排序后，算法可以保证它们的相对顺序不变，那算法就是稳定的，否则就是不稳定的。</p>
<p>快速排序更快，但不稳定，而归并排序是稳定的。对于基本类型，值相同就是完全相同，所以稳定不稳定没有关系。但对于对象类型，相同只是比较结果一样，它们还是不同的对象，其他实例变量也不见得一样，稳定不稳定可能就很有关系了，所以采用归并排序。</p>
<p>这些算法的实现是比较复杂的，所幸的是，Java提供了很好的封装，绝大多数情况下，我们会用就可以了。</p>
<h2 id="7-4-4-小结"><a href="#7-4-4-小结" class="headerlink" title="7.4.4 小结"></a>7.4.4 小结</h2><p>其实，Arrays中包含的数组方法是比较少的，很多常用的操作没有，比如，Arrays的binarySearch只能针对已排序数组进行查找，那没有排序的数组怎么方便查找呢？</p>
<p>Apache有一个开源包（<a target="_blank" rel="noopener" href="http://commons.apache.org/proper/commons-lang/%EF%BC%89%EF%BC%8C%E9%87%8C%E9%9D%A2%E6%9C%89%E4%B8%80%E4%B8%AA%E7%B1%BBArrayUtils%EF%BC%88%E4%BD%8D%E4%BA%8E%E5%8C%85org.apache.commons.lang3%EF%BC%89%EF%BC%8C%E5%8C%85%E5%90%AB%E4%BA%86%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E4%B8%8D%E5%88%97%E4%B8%BE%E4%BA%86%E3%80%82">http://commons.apache.org/proper/commons-lang/），里面有一个类ArrayUtils（位于包org.apache.commons.lang3），包含了更多的常用数组操作，这里就不列举了。</a></p>
<p>数组是计算机程序中的基本数据结构，Arrays类以及ArrayUtils类封装了关于数组的常见操作，使用这些方法，避免“重新发明轮子”吧。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/703d32a8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/703d32a8/" class="post-title-link" itemprop="url">7.5 剖析日期和时间</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/703d32a8/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/703d32a8/" data-xid="/JavaReadingNotes/703d32a8/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-5-剖析日期和时间"><a href="#7-5-剖析日期和时间" class="headerlink" title="7.5 剖析日期和时间"></a>7.5 剖析日期和时间</h1><p>本节，我们讨论Java 中日期和时间处理相关的API。日期和时间是一个比较复杂的概念，Java 8之前的设计有一些不足，业界有一个广泛使用的第三方类库Joda-Time, Java 8受Joda-Time影响，重新设计了日期和时间API，新增了一个包java.time。虽然Java 8之前的API有一些不足，但依然是被大量使用的，本节只介绍Java 8之前的API。关于Java 8的API，它使用了Lambda表达式，我们还没介绍，所以留待到第26章介绍。</p>
<p>下面，我们先来看一些基本概念，然后再介绍Java的日期和时间API。</p>
<h2 id="7-5-1-基本概念"><a href="#7-5-1-基本概念" class="headerlink" title="7.5.1 基本概念"></a>7.5.1 基本概念</h2><p>关于日期和时间，有一些基本概念，包括时区、时刻、纪元时、年历等。</p>
<h3 id="1．时区"><a href="#1．时区" class="headerlink" title="1．时区"></a>1．时区</h3><p>我们都知道，同一时刻，世界上各个地区的时间可能是不一样的，具体时间与时区有关。全球一共有24个时区，英国格林尼治是0时区，北京是东八区，也就是说格林尼治凌晨1点，北京是早上9点。0时区的时间也称为GMT+0时间，GMT是格林尼治标准时间，北京的时间就是GMT+8:00。</p>
<h3 id="2．时刻和纪元时"><a href="#2．时刻和纪元时" class="headerlink" title="2．时刻和纪元时"></a>2．时刻和纪元时</h3><p>所有计算机系统内部都用一个整数表示时刻，这个整数是距离格林尼治标准时间1970年1月1日0时0分0秒的毫秒数。为什么要用这个时间呢？更多的是历史原因，本书就不介绍了。</p>
<p>格林尼治标准时间1970年1月1日0时0分0秒也被称为Epoch Time（纪元时）。</p>
<p>这个整数表示的是一个时刻，与时区无关，世界上各个地方都是同一个时刻，但各个地区对这个时刻的解读（如年月日时分秒）可能是不一样的。</p>
<p>对于1970年以前的时间，使用负数表示。</p>
<h3 id="3．年历"><a href="#3．年历" class="headerlink" title="3．年历"></a>3．年历</h3><p>我们都知道，中国有公历和农历之分，公历和农历都是年历，不同的年历，一年有多少月，每月有多少天，甚至一天有多少小时，这些可能都是不一样的。</p>
<p>比如，公历有闰年，闰年2月是29天，而其他年份则是28天，其他月份，有的是30天，有的是31天。农历有闰月，比如闰7月，一年就会有两个7月，一共13个月。</p>
<p>公历是世界上广泛采用的年历，除了公历，还有其他一些年历，比如日本也有自己的年历。Java API的设计思想是支持国际化的，支持多种年历，但没有直接支持中国的农历，本书主要讨论公历。</p>
<p>简单总结下，时刻是一个绝对时间，对时刻的解读，则是相对的，与年历和时区相关。</p>
<h3 id="7-5-2-日期和时间API"><a href="#7-5-2-日期和时间API" class="headerlink" title="7.5.2 日期和时间API"></a>7.5.2 日期和时间API</h3><p>Java API中关于日期和时间，有三个主要的类。</p>
<ul>
<li>Date：表示时刻，即绝对时间，与年月日无关。</li>
<li>Calendar：表示年历，Calendar是一个抽象类，其中表示公历的子类是Gregorian-Calendar。</li>
<li>DateFormat：表示格式化，能够将日期和时间与字符串进行相互转换，DateFormat也是一个抽象类，其中最常用的子类是SimpleDateFormat。</li>
</ul>
<p>还有两个相关的类：</p>
<ul>
<li>TimeZone：表示时区。</li>
<li>Locale：表示国家（或地区）和语言。</li>
</ul>
<p>下面，我们来看这些类。</p>
<h3 id="1-Date"><a href="#1-Date" class="headerlink" title="1. Date"></a>1. Date</h3><p>Date是Java API中最早引入的关于日期的类，一开始，Date也承载了关于年历的角色，但由于不能支持国际化，其中的很多方法都已经过时了，被标记为了@Deprecated，不再建议使用。</p>
<p>Date表示时刻，内部主要是一个long类型的值，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> fastTime;</span><br></pre></td></tr></table></figure>

<p>fastTime表示距离纪元时的毫秒数，此处，关于transient关键字，我们暂时忽略。</p>
<p>Date有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span> </span>&#123;</span><br><span class="line">    fastTime = date;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个构造方法是根据传入的毫秒数进行初始化；第二个构造方法是默认构造方法，它根据System.currentTimeMillis()的返回值进行初始化。System.currentTimeMillis()是一个常用的方法，它返回当前时刻距离纪元时的毫秒数。</p>
<p>Date中的大部分方法都已经过时了，其中没有过时的主要方法有下面这些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> <span class="comment">//返回毫秒数</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> <span class="comment">//主要就是比较内部的毫秒数是否相同</span></span></span><br><span class="line"><span class="function"><span class="comment">//与其他Date进行比较，如果当前Date的毫秒数小于参数中的返回-1，相同返回0，否则返回1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date anotherDate)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Date when)</span> <span class="comment">//判断是否在给定日期之前</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">after</span><span class="params">(Date when)</span> <span class="comment">//判断是否在给定日期之后</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//哈希值算法与Long类似</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-TimeZone"><a href="#2-TimeZone" class="headerlink" title="2. TimeZone"></a>2. TimeZone</h3><p>TimeZone表示时区，它是一个抽象类，有静态方法用于获取其实例。获取当前的默认时区，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TimeZone tz = TimeZone.getDefault();</span><br><span class="line">System.out.println(tz.getID());</span><br></pre></td></tr></table></figure>

<p>获取默认时区，并输出其ID，在笔者的计算机中，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>默认时区是在哪里设置的呢？可以更改吗？Java中有一个系统属性user.timezone，保存的就是默认时区。系统属性可以通过System.getProperty获得，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.timezone&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>在笔者的计算机中，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>

<p>系统属性可以在Java启动的时候传入参数进行更改，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Duser.timezone=Asia/Shanghai xxxx</span><br></pre></td></tr></table></figure>

<p>TimeZone也有静态方法，可以获得任意给定时区的实例。比如，获取美国东部时区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeZone tz = TimeZone.getTimeZone(<span class="string">&quot;US/Eastern&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>ID除了可以是名称外，还可以是GMT形式表示的时区，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeZone tz = TimeZone.getTimeZone(<span class="string">&quot;GMT+08:00&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-Locale"><a href="#3-Locale" class="headerlink" title="3. Locale"></a>3. Locale</h3><p>Locale表示国家（或地区）和语言，它有两个主要参数：一个是国家（或地区）；另一个是语言，每个参数都有一个代码，不过国家（或地区）并不是必需的。比如，中国内地的代码是CN，中国台湾地区的代码是TW，美国的代码是US，中文语言的代码是zh，英文语言的代码是en。</p>
<p>Locale类中定义了一些静态变量，表示常见的Locale，比如：</p>
<ul>
<li>Locale.US：表示美国英语。</li>
<li>Locale.ENGLISH：表示所有英语。</li>
<li>Locale.TAIWAN：表示中国台湾地区所用的中文。</li>
<li>Locale.CHINESE：表示所有中文。</li>
<li>Locale.SIMPLIFIED_CHINESE：表示中国内地所用的中文。</li>
</ul>
<p>与TimeZone类似，Locale也有静态方法获取默认值，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Locale locale = Locale.getDefault();</span><br><span class="line">System.out.println(locale.toString());</span><br></pre></td></tr></table></figure>

<p>在笔者的计算机中，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zh_CN</span><br></pre></td></tr></table></figure>

<h3 id="4-Calendar"><a href="#4-Calendar" class="headerlink" title="4. Calendar"></a>4. Calendar</h3><p>Calendar类是日期和时间操作中的主要类，它表示与TimeZone和Locale相关的日历信息，可以进行各种相关的运算。我们先来看下它的内部组成，与Date类似，Calendar内部也有一个表示时刻的毫秒数，定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">long</span> time;</span><br></pre></td></tr></table></figure>

<p>除此之外，Calendar内部还有一个数组，表示日历中各个字段的值，定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> fields[];</span><br></pre></td></tr></table></figure>

<p>这个数组的长度为17，保存一个日期中各个字段的值，都有哪些字段呢？Calendar类中定义了一些静态变量，表示这些字段，主要有：</p>
<ul>
<li>Calendar.YEAR：表示年。</li>
<li>Calendar.MONTH：表示月，1月是0, Calendar同样定义了表示各个月份的静态变量，如Calendar.JULY表示7月。</li>
<li>Calendar.DAY_OF_MONTH：表示日，每月的第一天是1。</li>
<li>Calendar.HOUR_OF_DAY：表示小时，为0～23。</li>
<li>Calendar.MINUTE：表示分钟，为0～59。</li>
<li>Calendar.SECOND：表示秒，为0～59。</li>
<li>Calendar.MILLISECOND：表示毫秒，为0～999。</li>
<li>Calendar.DAY_OF_WEEK：表示星期几，周日是1，周一是2，周六是7,Calenar同样定义了表示各个星期的静态变量，如Calendar.SUNDAY表示周日。</li>
</ul>
<p>Calendar是抽象类，不能直接创建对象，它提供了多个静态方法，可以获取Calendar实例，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">(TimeZone zone, Locale aLocale)</span></span></span><br></pre></td></tr></table></figure>

<p>最终调用的方法都是需要TimeZone和Locale的，如果没有，则会使用上面介绍的默认值。getInstance方法会根据TimeZone和Locale创建对应的Calendar子类对象，在中文系统中，子类一般是表示公历的GregorianCalendar。</p>
<p>getInstance方法封装了Calendar对象创建的细节。TimeZone和Locale不同，具体的子类可能不同，但都是Calendar。这种隐藏对象创建细节的方式，是计算机程序中一种常见的设计模式，它有一个名字，叫工厂方法，getInstance就是一个工厂方法，它生产对象。</p>
<p>与new Date()类似，新创建的Calendar对象表示的也是当前时间，与Date不同的是， Calendar对象可以方便地获取年月日等日历信息。来看代码，输出当前时间的各种信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;year: &quot;</span>+calendar.get(Calendar.YEAR));</span><br><span class="line">System.out.println(<span class="string">&quot;month: &quot;</span>+calendar.get(Calendar.MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;day: &quot;</span>+calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;hour: &quot;</span>+calendar.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(<span class="string">&quot;minute: &quot;</span>+calendar.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;second: &quot;</span>+calendar.get(Calendar.SECOND));</span><br><span class="line">System.out.println(<span class="string">&quot;millisecond: &quot;</span> +calendar.get(Calendar.MILLISECOND));</span><br><span class="line">System.out.println(<span class="string">&quot;day_of_week: &quot;</span> + calendar.get(Calendar.DAY_OF_WEEK));</span><br></pre></td></tr></table></figure>

<p>具体输出与执行时的时间和默认的TimeZone以及Locale有关，比如，在笔者的计算机中的一次输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">year: 2016</span><br><span class="line">month: 7</span><br><span class="line">day: 14</span><br><span class="line">hour: 13</span><br><span class="line">minute: 55</span><br><span class="line">second: 51</span><br><span class="line">millisecond: 564</span><br><span class="line">day_of_week: 2</span><br></pre></td></tr></table></figure>

<p>内部，Calendar会将表示时刻的毫秒数，按照TimeZone和Locale对应的年历，计算各个日历字段的值，存放在fields数组中，Calendar.get方法获取的就是fields数组中对应字段的值。</p>
<p>Calendar支持根据Date或毫秒数设置时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeInMillis</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br></pre></td></tr></table></figure>

<p>也支持根据年月日等日历字段设置时间，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> date,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> hourOfDay, <span class="keyword">int</span> minute, <span class="keyword">int</span> second)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> value)</span></span></span><br></pre></td></tr></table></figure>

<p>除了直接设置，Calendar支持根据字段增加和减少时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> amount)</span></span></span><br></pre></td></tr></table></figure>

<p>amount为正数表示增加，负数表示减少。</p>
<p>比如，如果想设置Calendar为第二天的下午2点15，代码可以为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">calendar.set(Calendar.HOUR_OF_DAY, <span class="number">14</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">15</span>);</span><br><span class="line">calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>Calendar的这些方法中一个比较方便和强大的地方在于，它能够自动调整相关的字段。比如，我们知道2月最多有29天，如果当前时间为1月30号，对Calendar.MONTH字段加1，即增加一月，Calendar不是简单的只对月字段加1，那样日期是2月30号，是无效的，Calendar会自动调整为2月最后一天，即2月28日或29日。</p>
<p>再如，设置的值可以超出其字段最大范围，Calendar会自动更新其他字段，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.add(Calendar.HOUR_OF_DAY, <span class="number">48</span>);</span><br><span class="line">calendar.add(Calendar.MINUTE, -<span class="number">120</span>);</span><br></pre></td></tr></table></figure>

<p>相当于增加了46小时。</p>
<p>内部，根据字段设置或修改时间时，Calendar会更新fields数组对应字段的值，但一般不会立即更新其他相关字段或内部的毫秒数的值，不过在获取时间或字段值的时候， Calendar会重新计算并更新相关字段。</p>
<p>简单总结下，Calenar做了一项非常烦琐的工作，根据TimeZone和Locale，在绝对时间毫秒数和日历字段之间自动进行转换，且对不同日历字段的修改进行自动同步更新。</p>
<p>除了add方法，Calendar还有一个类似的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">roll</span><span class="params">(<span class="keyword">int</span> field, <span class="keyword">int</span> amount)</span></span></span><br></pre></td></tr></table></figure>

<p>与add方法的区别是，roll方法不影响时间范围更大的字段值。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">calendar.set(Calendar.HOUR_OF_DAY, <span class="number">13</span>);</span><br><span class="line">calendar.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">calendar.add(Calendar.MINUTE, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>calendar首先设置为13:59，然后分钟字段加3，执行后的calendar时间为14:02。如果add改为roll，即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.roll(Calendar.MINUTE, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>则执行后的calendar时间会变为13:02，在分钟字段上执行roll方法不会改变小时的值。</p>
<p>Calendar可以方便地转换为Date或毫秒数，方法是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Date <span class="title">getTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeInMillis</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>与Date类似，Calendar之间也可以进行比较，也实现了Comparable接口，相关方法有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Calendar anotherCalendar)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">after</span><span class="params">(Object when)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object when)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-DateFormat"><a href="#5-DateFormat" class="headerlink" title="5. DateFormat"></a>5. DateFormat</h3><p>DateFormat类主要在Date和字符串表示之间进行相互转换，它有两个主要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">format</span><span class="params">(Date date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String source)</span></span></span><br></pre></td></tr></table></figure>

<p>format将Date转换为字符串，parse将字符串转换为Date。</p>
<p>Date的字符串表示与TimeZone和Locale都是相关的，除此之外，还与两个格式化风格有关，一个是日期的格式化风格，另一个是时间的格式化风格。DateFormat定义了4个静态变量，表示4种风格：SHORT、MEDIUM、LONG和FULL；还定义了一个静态变量DEFAULT，表示默认风格，值为MEDIUM，不同风格输出的信息详细程度不同。</p>
<p>与Calendar类似，DateFormat也是抽象类，也用工厂方法创建对象，提供了多个静态方法创建DateFormat对象，有三类方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateTimeInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>public final static DateFormat getTimeInstance()</p>
<p>getDateTimeInstance方法既处理日期也处理时间，getDateInstance方法只处理日期，get-TimeInstance方法只处理时间。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">//2016-08-15 14:15:20</span></span><br><span class="line">calendar.set(<span class="number">2016</span>, <span class="number">07</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(DateFormat.getDateTimeInstance()</span><br><span class="line">        .format(calendar.getTime()));</span><br><span class="line">System.out.println(DateFormat.getDateInstance()</span><br><span class="line">        .format(calendar.getTime()));</span><br><span class="line">System.out.println(DateFormat.getTimeInstance()</span><br><span class="line">        .format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-8-15 14:15:20</span><br><span class="line">2016-8-15</span><br><span class="line">14:15:20</span><br></pre></td></tr></table></figure>

<p>每类工厂方法都有两个重载的方法，接受日期和时间风格以及Locale作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DateFormat <span class="title">getDateTimeInstance</span><span class="params">(<span class="keyword">int</span> dateStyle, <span class="keyword">int</span> timeStyle)</span></span></span><br><span class="line"><span class="function">DateFormat <span class="title">getDateTimeInstance</span><span class="params">(<span class="keyword">int</span> dateStyle, <span class="keyword">int</span> timeStyle, Locale aLocale)</span></span></span><br></pre></td></tr></table></figure>

<p>比如，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">//2016-08-15 14:15:20</span></span><br><span class="line">calendar.set(<span class="number">2016</span>, <span class="number">07</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">System.out.println(DateFormat.getDateTimeInstance(DateFormat.LONG,</span><br><span class="line">    DateFormat.SHORT, Locale.CHINESE).format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016年8月15日 下午2:15</span><br></pre></td></tr></table></figure>

<p>DateFormat的工厂方法里，我们没看到TimeZone参数，不过，DateFormat提供了一个setter方法，可以设置TimeZone：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeZone</span><span class="params">(TimeZone zone)</span></span></span><br></pre></td></tr></table></figure>

<p>DateFormat虽然比较方便，但如果我们要对字符串格式有更精确的控制，则应该使用SimpleDateFormat这个类。</p>
<h3 id="6-SimpleDateFormat"><a href="#6-SimpleDateFormat" class="headerlink" title="6. SimpleDateFormat"></a>6. SimpleDateFormat</h3><p>SimpleDateFormat是DateFormat的子类，相比DateFormat，它的一个主要不同是，它可以接受一个自定义的模式（pattern）作为参数，这个模式规定了Date的字符串形式。先看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">//2016-08-15 14:15:20</span></span><br><span class="line">calendar.set(<span class="number">2016</span>, <span class="number">07</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">20</span>);</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(</span><br><span class="line">    <span class="string">&quot;yyyy年MM月dd日 E HH时mm分ss秒&quot;</span>);</span><br><span class="line">System.out.println(sdf.format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016年08月15日 星期一 14时15分20秒</span><br></pre></td></tr></table></figure>
<p>SimpleDateFormat有个构造方法，可以接受一个pattern作为参数，这里pattern是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yyyy年MM月dd日 E HH时mm分ss秒</span><br></pre></td></tr></table></figure>

<p>pattern中的英文字符a～z和A～Z表示特殊含义，其他字符原样输出，这里：</p>
<ul>
<li>yyyy：表示4位的年。</li>
<li>MM：表示月，用两位数表示。</li>
<li>dd：表示日，用两位数表示。</li>
<li>HH：表示24小时制的小时数，用两位数表示。</li>
<li>mm：表示分钟，用两位数表示。</li>
<li>ss：表示秒，用两位数表示。</li>
<li>E：表示星期几。</li>
</ul>
<p>这里需要特意提醒一下，hh也表示小时数，但表示的是12小时制的小时数，而a表示的是上午还是下午，看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">//2016-08-15 14:15:20</span><br><span class="line">calendar.set(2016, 07, 15, 14, 15, 20);</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy/MM/dd hh:mm:ss a&quot;);</span><br><span class="line">System.out.println(sdf.format(calendar.getTime()));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016/08/15 02:15:20 下午</span><br></pre></td></tr></table></figure>

<p>更多的特殊含义可以参看SimpleDateFormat的API文档。如果想原样输出英文字符，可以将其用单引号括起来。</p>
<p>除了将Date转换为字符串，SimpleDateFormat也可以方便地将字符串转化为Date，看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;2016-08-15 14:15:20.456&quot;</span>;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Date date = sdf.parse(str);</span><br><span class="line">    SimpleDateFormat sdf2 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年M月d h:m:s.S a&quot;</span>);</span><br><span class="line">    System.out.println(sdf2.format(date));</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016年8月15 2:15:20.456 下午</span><br></pre></td></tr></table></figure>

<p>代码将字符串解析为了一个Date对象，然后使用另外一个格式进行了输出，这里SSS表示三位的毫秒数。需要注意的是，parse会抛出一个受检异常，异常类型为ParseException，调用者必须进行处理。</p>
<h2 id="7-5-3-局限性"><a href="#7-5-3-局限性" class="headerlink" title="7.5.3 局限性"></a>7.5.3 局限性</h2><p>至此，关于Java 8之前的日期和时间相关API的主要内容基本就介绍完了。Date表示时刻，与年月日无关，Calendar表示日历，与时区和Locale相关，可进行各种运算，是日期时间操作的主要类，DateFormat/SimpleDateFormat在Date和字符串之间进行相互转换。这些API存在着一些局限性，下面强调一下。</p>
<h3 id="1-Date中的过时方法"><a href="#1-Date中的过时方法" class="headerlink" title="1. Date中的过时方法"></a>1. Date中的过时方法</h3><p>Date中的方法参数与常识不符合，过时方法标记容易被人忽略，产生误用。比如，看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">2016</span>,<span class="number">8</span>,<span class="number">15</span>);</span><br><span class="line">System.out.println(DateFormat.getDateInstance().format(date));</span><br></pre></td></tr></table></figure>

<p>想当然的输出为2016-08-15，但其实输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3916-9-15</span><br></pre></td></tr></table></figure>

<p>之所以产生这个输出，是因为Date构造方法中的year表示的是与1900年的差，month是从0开始的。</p>
<h3 id="2-Calendar操作比较烦琐"><a href="#2-Calendar操作比较烦琐" class="headerlink" title="2. Calendar操作比较烦琐"></a>2. Calendar操作比较烦琐</h3><p>Calendar API的设计不是很成功，一些简单的操作都需要多次方法调用，写很多代码，比较臃肿。</p>
<p>另外，Calendar难以进行比较复杂的日期操作，比如，计算两个日期之间有多少个月，根据生日计算年龄，计算下个月的第一个周一等。</p>
<h3 id="3-DateFormat的线程安全性"><a href="#3-DateFormat的线程安全性" class="headerlink" title="3. DateFormat的线程安全性"></a>3. DateFormat的线程安全性</h3><p>DateFormat/SimpleDateFormat不是线程安全的。关于线程概念，第15章会详细介绍，这里简单说明一下。多个线程同时使用一个DateFormat实例的时候，会有问题，因为DateFormat内部使用了一个Calendar实例对象，多线程同时调用的时候，这个Calendar实例的状态可能就会紊乱。</p>
<p>解决这个问题大概有以下方案：</p>
<ul>
<li>每次使用DateFormat都新建一个对象。</li>
<li>使用线程同步（第15章介绍）。</li>
<li>使用ThreadLocal（第19章介绍）。</li>
<li>使用Joda-Time或Java 8的API，它们是线程安全的。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/eb612b60/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/eb612b60/" class="post-title-link" itemprop="url">7.6 随机</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:08" itemprop="dateModified" datetime="2021-12-07T12:07:08+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/eb612b60/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/eb612b60/" data-xid="/JavaReadingNotes/eb612b60/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="7-6-随机"><a href="#7-6-随机" class="headerlink" title="7.6 随机"></a>7.6 随机</h1><p>本节，我们来讨论随机，随机是计算机程序中一个非常常见的需求，比如：</p>
<ul>
<li>各种游戏中有大量的随机，比如扑克游戏中的洗牌。</li>
<li>微信抢红包，抢的红包金额是随机的。</li>
<li>北京购车摇号，谁能摇到是随机的。</li>
<li>给用户生成随机密码。</li>
</ul>
<p>我们首先来介绍Java对随机的支持，同时介绍其实现原理，然后针对一些实际场景，包括洗牌、抢红包、摇号、随机高强度密码、带权重的随机选择等，讨论如何应用随机。先来看如何使用最基本的随机。</p>
<h2 id="7-6-1-Math-random"><a href="#7-6-1-Math-random" class="headerlink" title="7.6.1 Math.random"></a>7.6.1 Math.random</h2><p>Java中，对随机最基本的支持是Math类中的静态方法random()，它生成一个0～1的随机数，类型为double，包括0但不包括1。比如，随机生成并输出3个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">    System.out.println(Math.random());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>笔者的计算机中的一次运行，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.4784896133823269</span><br><span class="line">0.03012515628333423</span><br><span class="line">0.7921024363953197</span><br></pre></td></tr></table></figure>

<p>每次运行，输出都不一样。Math.random()是如何实现的呢？我们来看相关代码（Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Random randomNumberGenerator;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Random <span class="title">initRNG</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rnd = randomNumberGenerator;</span><br><span class="line">    <span class="keyword">return</span> (rnd == <span class="keyword">null</span>) ? (randomNumberGenerator = <span class="keyword">new</span> Random()) : rnd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Random rnd = randomNumberGenerator;</span><br><span class="line">    <span class="keyword">if</span> (rnd == <span class="keyword">null</span>) rnd = initRNG();</span><br><span class="line">    <span class="keyword">return</span> rnd.nextDouble();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部它使用了一个Random类型的静态变量randomNumberGenerator，调用random()就是调用该变量的nextDouble()方法，这个Random变量只有在第一次使用的时候才创建。</p>
<p>下面我们来看这个Random类，它位于包java.util下。</p>
<h2 id="7-6-2-Random"><a href="#7-6-2-Random" class="headerlink" title="7.6.2 Random"></a>7.6.2 Random</h2><p>Random类提供了更为丰富的随机方法，它的方法不是静态方法，使用Random，先要创建一个Random实例，看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">System.out.println(rnd.nextInt());</span><br><span class="line">System.out.println(rnd.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>笔者计算机中的一次运行，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1516612608</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<p>nextInt()产生一个随机的int，可能为正数，也可能为负数，nextInt(100)产生一个随机int，范围是0～100，包括0不包括100。除了nextInt，还有一些别的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> <span class="comment">//随机生成一个long</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nextBoolean</span><span class="params">()</span> <span class="comment">//随机生成一个boolean</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextBytes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="comment">//产生随机字节， 字节个数就是bytes的长度</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">nextFloat</span><span class="params">()</span> <span class="comment">//随机浮点数，从0到1，包括0不包括1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">nextDouble</span><span class="params">()</span> <span class="comment">//随机浮点数，从0到1，包括0不包括1</span></span></span><br></pre></td></tr></table></figure>

<p>除了默认构造方法，Random类还有一个构造方法，可以接受一个long类型的种子参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>种子决定了随机产生的序列，种子相同，产生的随机数序列就是相同的</strong>。看个例子：</p>
<p>Random rnd = new Random(20160824);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">    System.out.print(rnd.nextInt(<span class="number">100</span>)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>种子为20160824，产生5个0～100的随机数，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">69 13 13 94 50</span><br></pre></td></tr></table></figure>

<p>这个程序无论执行多少遍，在哪执行，输出结果都是相同的。</p>
<p>除了在构造方法中指定种子，Random类还有一个setter实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeed</span><span class="params">(<span class="keyword">long</span> seed)</span></span></span><br></pre></td></tr></table></figure>

<p>其效果与在构造方法中指定种子是一样的。</p>
<p>为什么要指定种子呢？指定种子还是真正的随机吗？<strong>指定种子是为了实现可重复的随机</strong>。比如用于模拟测试程序中，模拟要求随机，但测试要求可重复。在北京购车摇号程序中，种子也是指定的，后面我们还会介绍。种子到底扮演了什么角色呢？随机到底是如何产生的呢？让我们看下随机的基本原理。</p>
<h2 id="7-6-3-随机的基本原理"><a href="#7-6-3-随机的基本原理" class="headerlink" title="7.6.3 随机的基本原理"></a>7.6.3 随机的基本原理</h2><p>Random产生的随机数不是真正的随机数，相反，它产生的随机数一般称为<strong>伪随机数</strong>。真正的随机数比较难以产生，计算机程序中的随机数一般都是伪随机数。</p>
<p>伪随机数都是基于一个种子数的，然后每需要一个随机数，都是对当前种子进行一些数学运算，得到一个数，基于这个数得到需要的随机数和新的种子。</p>
<p>数学运算是固定的，所以种子确定后，产生的随机数序列就是确定的，确定的数字序列当然不是真正的随机数，但种子不同，序列就不同，每个序列中数字的分布也都是比较随机和均匀的，所以称之为伪随机数。</p>
<p>Random的默认构造方法中没有传递种子，它会自动生成一个种子，这个种子数是一个真正的随机数，如下所示（Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong seedUniquifier</span><br><span class="line">    = <span class="keyword">new</span> AtomicLong(<span class="number">8682522807148012L</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">seedUniquifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; ; ) &#123;</span><br><span class="line">        <span class="keyword">long</span> current = seedUniquifier.get();</span><br><span class="line">    <span class="keyword">long</span> next = current ＊ <span class="number">181783497276652981L</span>;</span><br><span class="line">    <span class="keyword">if</span>(seedUniquifier.compareAndSet(current, next))</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>种子是seedUniquifier()与System.nanoTime()按位异或的结果，System.nanoTime()返回一个更高精度（纳秒）的当前时间，seedUniquifier()里面的代码涉及一些多线程相关的知识，我们后续章节再介绍，简单地说，就是返回当前seedUniquifier（current变量）与一个常数181783497276652981L相乘的结果（next变量），然后，设置seedUniquifier的值为next，使用循环和compareAndSet都是为了确保在多线程的环境下不会有两次调用返回相同的值，保证随机性。</p>
<p>有了种子数之后，其他数是怎么生成的呢？我们来看一些代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">nextLong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">long</span>)(next(<span class="number">32</span>)) &lt;&lt; <span class="number">32</span>) + next(<span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">nextFloat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">24</span>) / ((<span class="keyword">float</span>)(<span class="number">1</span> &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nextBoolean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next(<span class="number">1</span>) ! = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们都调用了next(int bits)，生成指定位数的随机数，我们来看下它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> multiplier = <span class="number">0x5DEECE66DL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> addend = <span class="number">0xBL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> mask = (<span class="number">1L</span> &lt;&lt; <span class="number">48</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed ＊ multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (! seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单地说，就是使用了如下公式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextseed = (oldseed ＊ multiplier + addend) &amp; mask;</span><br></pre></td></tr></table></figure>

<p>旧的种子（oldseed）乘以一个数（multiplier），加上一个数addend，然后取低48位作为结果（mask相与）。</p>
<p>为什么采用这个方法？这个方法为什么可以产生随机数？这个方法的名称叫线性同余随机数生成器（linear congruential pseudorandom number generator），描述在《计算机程序设计艺术》一书中。随机的理论是一个比较复杂的话题，超出了本书的范畴，我们就不讨论了。</p>
<p>我们需要知道的基本原理是：随机数基于一个种子，种子固定，随机数序列就固定，默认构造方法中，种子是一个真正的随机数。</p>
<p>理解了随机的基本概念和原理，我们来看一些应用场景，包括随机密码、洗牌、带权重的随机选择、微信抢红包算法，以及北京购车摇号算法。</p>
<h2 id="7-6-4-随机密码"><a href="#7-6-4-随机密码" class="headerlink" title="7.6.4 随机密码"></a>7.6.4 随机密码</h2><p>在给用户生成账号时，经常需要给用户生成一个默认随机密码，然后通过邮件或短信发给用户，作为初次登录使用。我们假定密码是6位数字，代码很简单，如代码清单7-4所示。</p>
<center>代码清单7-4 生成随机密码：6位数字</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomPassword</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</span><br><span class="line">    Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++)&#123;</span><br><span class="line">        chars[i] = (<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span>+rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，就不解释了。如果要求是8位密码，字符可能由大写字母、小写字母、数字和特殊符号组成，如代码清单7-5所示。</p>
<center>代码清单7-5 生成随机密码：简单8位</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPECIAL_CHARS = <span class="string">&quot;! @#$%^&amp;＊_=+-/&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">nextChar</span><span class="params">(Random rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(rnd.nextInt(<span class="number">4</span>))&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span>     (<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span>+rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomPassword</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">    Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        chars[i] = nextChar(rnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码，对每个字符，先随机选类型，然后在给定类型中随机选字符。在笔者的计算机中，一次的随机运行结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8Ctp2S4H</span><br></pre></td></tr></table></figure>

<p>这个结果不含特殊字符。很多环境对密码复杂度有要求，比如，至少要含一个大写字母、一个小写字母、一个特殊符号、一个数字。以上的代码满足不了这个要求，怎么满足呢？一种可能的代码如代码清单7-6所示。</p>
<center>代码清单7-6 生成随机密码：复杂8位</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">char</span>[] chars, Random rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = rnd.nextInt(chars.length);</span><br><span class="line">    <span class="keyword">while</span>(chars[index]! =<span class="number">0</span>)&#123;</span><br><span class="line">    index = rnd.nextInt(chars.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">nextSpecialChar</span><span class="params">(Random rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SPECIAL_CHARS.charAt(rnd.nextInt(SPECIAL_CHARS.length()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">nextUpperlLetter</span><span class="params">(Random rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">nextLowerLetter</span><span class="params">(Random rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span>+rnd.nextInt(<span class="number">26</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">nextNumLetter</span><span class="params">(Random rnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>)(<span class="string">&#x27;0&#x27;</span>+rnd.nextInt(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomPassword</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];</span><br><span class="line">    Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextSpecialChar(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextUpperlLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextLowerLetter(rnd);</span><br><span class="line">    chars[nextIndex(chars, rnd)] = nextNumLetter(rnd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chars[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            chars[i] = nextChar(rnd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nextIndex随机生成一个未赋值的位置，程序先随机生成4个不同类型的字符，放到随机位置上，然后给未赋值的其他位置随机生成字符。</p>
<h2 id="7-6-5-洗牌"><a href="#7-6-5-洗牌" class="headerlink" title="7.6.5 洗牌"></a>7.6.5 洗牌</h2><p>一种常见的随机场景是洗牌，就是将一个数组或序列随机重新排列。我们以一个整数数组为例来介绍如何随机重排，如代码清单7-7所示。</p>
<center>代码清单7-7 随机重排</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    Random rnd = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length; i&gt;<span class="number">1</span>; i--) &#123;</span><br><span class="line">        swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>shuffle方法能将参数数组arr随机重排，来看使用它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    arr[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">shuffle(arr);</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>调用shuffle方法前，arr是排好序的，调用后，一次调用的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[3, 8, 11, 10, 7, 9, 4, 1, 6, 12, 5, 0, 2]</span><br></pre></td></tr></table></figure>

<p>已经随机重新排序了。shuffle的基本思路是什么呢？从后往前，逐个给每个数组位置重新赋值，值是从剩下的元素中随机挑选的。在如下关键语句中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br></pre></td></tr></table></figure>

<p>i-1表示当前要赋值的位置，rnd.nextInt(i)表示从剩下的元素中随机挑选。</p>
<h2 id="7-6-6-带权重的随机选择"><a href="#7-6-6-带权重的随机选择" class="headerlink" title="7.6.6 带权重的随机选择"></a>7.6.6 带权重的随机选择</h2><p>实际场景中，经常要从多个选项中随机选择一个，不过，不同选项经常有不同的权重。比如，给用户随机奖励，三种面额：1元、5元和10元，权重分别为70、20和10。这个怎么实现呢？实现的基本思路是，使用概率中的累计概率分布。</p>
<p>以上面的例子来说，计算每个选项的累计概率值，首先计算总的权重，这里正好是100，每个选项的概率是70%、20%和10%，累计概率则分别是70%、90%和100%。</p>
<p>有了累计概率，则随机选择的过程是：使用nextDouble()生成一个0～1的随机数，然后使用二分查找，看其落入哪个区间，如果小于等于70%则选择第一个选项，70%和90%之间选第二个，90%以上选第三个，如图7-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209110957.jpeg" alt="epub_923038_54"></p>
<center>图7-2 选项的累计概率值</center>

<p>下面来看代码，我们使用一个类Pair表示选项和权重，如代码清单7-8所示。</p>
<center>代码清单7-8 表示选项和权重的类Pair</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    Object item;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(Object item, <span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.item = item;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用一个类WeightRandom表示带权重的选择，如代码清单7-9所示。</p>
<center>代码清单7-9 带权重的选择WeightRandom</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Pair[] options;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] cumulativeProbabilities;</span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeightRandom</span><span class="params">(Pair[] options)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.options = options;</span><br><span class="line">        <span class="keyword">this</span>.rnd = <span class="keyword">new</span> Random();</span><br><span class="line">        prepare();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weights = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Pair pair : options)&#123;</span><br><span class="line">            weights += pair.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">        cumulativeProbabilities = <span class="keyword">new</span> <span class="keyword">double</span>[options.length];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;options.length; i++) &#123;</span><br><span class="line">            sum += options[i].getWeight();</span><br><span class="line">            cumulativeProbabilities[i] = sum / (<span class="keyword">double</span>)weights;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">nextItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">double</span> randomValue = rnd.nextDouble();</span><br><span class="line">          <span class="keyword">int</span> index = Arrays.binarySearch(cumulativeProbabilities, randomValue);</span><br><span class="line">          <span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            index = -index-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> options[index].getItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，prepare()方法计算每个选项的累计概率，保存在数组cumulativeProbabilities中， nextItem()方法根据权重随机选择一个，具体就是，首先生成一个0～1的数，然后使用二分查找，如果没找到，返回结果是-（插入点）-1，所以-index-1就是插入点，插入点的位置就对应选项的索引。</p>
<p>回到上面的例子，随机选择10次，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pair[] options = <span class="keyword">new</span> Pair[]&#123;</span><br><span class="line">        <span class="keyword">new</span> Pair(<span class="string">&quot;1元&quot;</span>,<span class="number">7</span>), <span class="keyword">new</span> Pair(<span class="string">&quot;2元&quot;</span>, <span class="number">2</span>), <span class="keyword">new</span> Pair(<span class="string">&quot;10元&quot;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line">WeightRandom rnd = <span class="keyword">new</span> WeightRandom(options);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    System.out.print(rnd.nextItem()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一次运行中，输出正好符合预期，具体为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1元 1元 1元 2元 1元 10元 1元 2元 1元 1元</span><br></pre></td></tr></table></figure>

<p>不过，需要说明的是，由于随机，每次执行结果比例不一定正好相等。</p>
<h2 id="7-6-7-抢红包算法"><a href="#7-6-7-抢红包算法" class="headerlink" title="7.6.7 抢红包算法"></a>7.6.7 抢红包算法</h2><p>我们都知道，微信可以抢红包，红包有一个总金额和总数量，领的时候随机分配金额。金额是怎么随机分配的呢？微信具体是怎么做的，我们并不能确切地知道，但如下思路可以达到该效果。</p>
<p>维护一个剩余总金额和总数量，分配时，如果数量等于1，直接返回总金额，如果大于1，则计算平均值，并设定随机最大值为平均值的两倍，然后取一个随机值，如果随机值小于0.01，则为0.01，这个随机值就是下一个的红包金额。</p>
<p>我们来看代码，如代码清单7-10所示，为计算方便，金额用整数表示，以分为单位。</p>
<center>代码清单7-10 抢红包算法</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomRedPacket</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftMoney;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftNum;</span><br><span class="line">    <span class="keyword">private</span> Random rnd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomRedPacket</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftMoney = total;</span><br><span class="line">        <span class="keyword">this</span>.leftNum = num;</span><br><span class="line">        <span class="keyword">this</span>.rnd = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.leftNum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;抢光了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.leftNum==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.leftMoney;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> max = <span class="keyword">this</span>.leftMoney/<span class="keyword">this</span>.leftNum＊<span class="number">2d</span>;</span><br><span class="line">        <span class="keyword">int</span> money = (<span class="keyword">int</span>)(rnd.nextDouble()＊max);</span><br><span class="line">        money = Math.max(<span class="number">1</span>, money);</span><br><span class="line">        <span class="keyword">this</span>.leftMoney -= money;</span><br><span class="line">        <span class="keyword">this</span>.leftNum --;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单，就不解释了。关于synchronized修饰符，此处可以忽略，留待第15章介绍。看一个使用的例子，总金额为10元，10个红包，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RandomRedPacket redPacket = <span class="keyword">new</span> RandomRedPacket(<span class="number">1000</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    System.out.print(redPacket.nextMoney()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一次输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">136 48 90 151 36 178 92 18 122 129</span><br></pre></td></tr></table></figure>

<p>如果是这个算法，那先抢好，还是后抢好呢？先抢肯定抢不到特别大的，不过，后抢也不一定会，这要看前面抢的金额，剩下的多就有可能抢到大的，剩下的少就不可能有大的。</p>
<h2 id="7-6-8-北京购车摇号算法"><a href="#7-6-8-北京购车摇号算法" class="headerlink" title="7.6.8 北京购车摇号算法"></a>7.6.8 北京购车摇号算法</h2><p>我们来看下影响很多人的北京购车摇号，它的算法是怎样的呢？思路大概是这样的：<br>1）每期摇号前，将每个符合摇号资格的人，分配一个从0到总数的编号，这个编号是公开的，比如总人数为2 304 567，则编号为0～2 304 566。<br>2）摇号第一步是生成一个随机种子数，这个随机种子数在摇号当天通过一定流程生成，整个过程由公证员公证，就是生成一个真正的随机数。<br>3）种子数生成后，然后就是循环调用类似Random.nextInt(int n)方法，生成中签的编号。</p>
<p>编号是事先确定的，种子数是当场公证随机生成的，是公开的，随机算法是公开透明的，任何人都可以根据公开的种子数和编号验证中签的编号。</p>
<h2 id="7-6-9-小结"><a href="#7-6-9-小结" class="headerlink" title="7.6.9 小结"></a>7.6.9 小结</h2><p>本节介绍了随机，介绍了Java中对随机的支持Math.random()以及Random类，介绍了其使用和实现原理，同时，介绍了随机的一些应用场景，包括随机密码、洗牌、带权重的随机选择、微信抢红包和北京购车摇号，完整的代码在github上，地址为<a target="_blank" rel="noopener" href="https://github.com/swiftma/program-logic">https://github.com/swiftma/program-logic</a> ，位于包shuo.laoma.commoncls.c34下。</p>
<p>需要说明的是，Random类是线程安全的，也就是说，多个线程可以同时使用一个Random实例对象，不过，如果并发性很高，会产生竞争，这时，可以考虑使用多线程库中的ThreadLocalRandom类。另外，Java类库中还有一个随机类SecureRandom，可以产生安全性更高、随机性更强的随机数，用于安全加密等领域。</p>
<p>至此，关于常用基础类就介绍完了。我们深入分析了各种包装类、String、String-Builder、Arrays、日期和时间、以及随机，这些都是日常程序中经常用到的功能。还有一些基础类，限于篇幅，就不介绍了，比如UUID、Math和Objects,UUID用于随机生成需要确保唯一性的标识符，Math用于进行数学运算，Objects包含一些操作对象、检查条件的方法，具体可参看API文档。</p>
<p>之前章节中，我们经常提到泛型这一概念，它到底是什么呢？让我们下一章详细探讨。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/31a72ecb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/31a72ecb/" class="post-title-link" itemprop="url">7.0 第7章 常用基础类 7.1 包装类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-04 20:14:01" itemprop="dateCreated datePublished" datetime="2021-12-04T20:14:01+08:00">2021-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-08 22:05:54" itemprop="dateModified" datetime="2021-12-08T22:05:54+08:00">2021-12-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url" rel="index"><span itemprop="name">2第二部分 面向对象</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E7%AC%AC7%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%9F%BA%E7%A1%80%E7%B1%BB/" itemprop="url" rel="index"><span itemprop="name">第7章 常用基础类</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/31a72ecb/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/31a72ecb/" data-xid="/JavaReadingNotes/31a72ecb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第7章-常用基础类"><a href="#第7章-常用基础类" class="headerlink" title="第7章 常用基础类"></a>第7章 常用基础类</h1><p>本章介绍Java编程中一些常用的基础类，探讨它们的用法、应用和实现原理，这些类有：</p>
<ul>
<li>各种包装类；</li>
<li>文本处理的类String和StringBuilder；</li>
<li>数组操作的类Arrays；</li>
<li>日期和时间处理；</li>
<li>随机。</li>
</ul>
<h1 id="7-1-包装类"><a href="#7-1-包装类" class="headerlink" title="7.1 包装类"></a>7.1 包装类</h1><p>Java有8种基本类型，每种基本类型都有一个对应的包装类。包装类是什么呢？它是一个类，内部有一个实例变量，保存对应的基本类型的值，这个类一般还有一些静态方法、静态变量和实例方法，以方便对数据进行操作。Java中，基本类型和对应的包装类如表7-1所示。</p>
<center>表7-1 基本类型和对应的包装类</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213344.jpeg" alt="epub_923038_50"><br>包装类也都很好记，除了Integer和Character外，其他类名称与基本类型基本一样，只是首字母大写。包装类有什么用呢？Java中很多代码（比如后续章节介绍的容器类）只能操作对象，为了能操作基本类型，需要使用其对应的包装类。另外，包装类提供了很多有用的方法，可以方便对数据的操作。下面先介绍各个包装类的基本用法及其共同点，然后重点介绍Integer和Character。</p>
<h2 id="7-1-1-基本用法"><a href="#7-1-1-基本用法" class="headerlink" title="7.1.1 基本用法"></a>7.1.1 基本用法</h2><p>各个包装类都可以与其对应的基本类型相互转换，方法也是类似的，部分类型如表7-2所示。</p>
<center>表7-2 包装类与基本类型的转换</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211208213434.jpeg" alt="epub_923038_51"><br>包装类与基本类型的转换代码结构是类似的，每种包装类都有一个静态方法valueOf()，接受基本类型，返回引用类型，也都有一个实例方法xxxValue()返回对应的基本类型。</p>
<p>将基本类型转换为包装类的过程，一般称为“装箱”，而将包装类型转换为基本类型的过程，则称为“拆箱”。装箱/拆箱写起来比较烦琐，Java 5以后引入了自动装箱和拆箱技术，可以直接将基本类型赋值给引用类型，反之亦可，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br></pre></td></tr></table></figure>

<p>自动装箱/拆箱是Java编译器提供的能力，背后，它会替换为调用对应的valueOf/xxx-Value方法，比如，上面的代码会被Java编译器替换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">int</span> b = a.intValue();</span><br></pre></td></tr></table></figure>

<p>每种包装类也都有构造方法，可以通过new创建，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Boolean b = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line">Double d = <span class="keyword">new</span> Double(<span class="number">12.345</span>);</span><br><span class="line">Character c = <span class="keyword">new</span> Character(<span class="string">&#x27;马&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>那到底应该用静态的valueOf方法，还是使用new呢？一般建议使用valueOf方法。new每次都会创建一个新对象，而除了Float和Double外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，提升性能。实际上，从Java 9开始，这些构造方法已经被标记为过时了，推荐使用静态的valueOf方法。</p>
<h2 id="7-1-2-共同点"><a href="#7-1-2-共同点" class="headerlink" title="7.1.2 共同点"></a>7.1.2 共同点</h2><p>各个包装类有很多共同点，比如，都重写了Object中的一些方法，都实现了Comparable接口，都有一些与String有关的方法，大部分都定义了一些静态常量，都是不可变的。下面具体介绍。</p>
<h3 id="1．重写Object方法"><a href="#1．重写Object方法" class="headerlink" title="1．重写Object方法"></a>1．重写Object方法</h3><p>所有包装类都重写了Object类的如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>我们分别介绍。</p>
<h4 id="（1）equals"><a href="#（1）equals" class="headerlink" title="（1）equals"></a>（1）equals</h4><p>equals用于判断当前对象和参数传入的对象是否相同，Object类的默认实现是比较地址，对于两个变量，只有这两个变量指向同一个对象时，equals才返回true，它和比较运算符（==）的结果是一样的。</p>
<p>equals应该反映的是对象间的逻辑相等关系，所以这个默认实现一般是不合适的，子类需要重写该实现。所有包装类都重写了该实现，实际比较用的是其包装的基本类型值，比如，对于Long类，其equals方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Float，其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">        &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Float有一个静态方法floatToIntBits()，将float的二进制表示看作int。需要注意的是，只有两个float的二进制表示完全一样的时候，equals才会返回true。在2.2节的时候，我们提到小数计算是不精确的，数学概念上运算结果一样，但计算机运算结果可能不同，比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Float f1 = <span class="number">0.01f</span>;</span><br><span class="line">Float f2 = <span class="number">0.1f</span>＊<span class="number">0.1f</span>;</span><br><span class="line">System.out.println(f1.equals(f2));</span><br><span class="line">System.out.println(Float.floatToIntBits(f1));</span><br><span class="line">System.out.println(Float.floatToIntBits(f2));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="number">1008981770</span></span><br><span class="line"><span class="number">1008981771</span></span><br></pre></td></tr></table></figure>

<p>也就是，两个浮点数不一样，将二进制看作整数也不一样，相差为1。</p>
<p>Double的equals方法与Float类似，它有一个静态方法doubleToLongBits，将double的二进制表示看作long，然后再按long比较。</p>
<h4 id="（2）hashCode"><a href="#（2）hashCode" class="headerlink" title="（2）hashCode"></a>（2）hashCode</h4><p>hashCode返回一个对象的哈希值。哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。一个对象的哈希值不能改变，相同对象的哈希值必须一样。不同对象的哈希值一般应不同，但这不是必需的，可以有对象不同但哈希值相同的情况。</p>
<p>比如，对于一个班的学生对象，hashCode可以是学生的出生日期，出生日期是不变的，不同学生生日一般不同，分布比较均匀，个别生日相同的也没关系。</p>
<p>hashCode和equals方法联系密切，<strong>对两个对象，如果equals方法返回true，则hashCode也必须一样</strong>。反之不要求，equal方法返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。hashCode的默认实现一般是将对象的内存地址转换为整数，<strong>子类如果重写了equals方法，也必须重写hashCode</strong>。之所以有这个规定，是因为Java API中很多类依赖于这个行为，尤其是容器中的一些类。</p>
<p>包装类都重写了hashCode，根据包装的基本类型值计算hashCode，对于Byte、Short、Integer、Character, hashCode就是其内部值，代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Boolean, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ? <span class="number">1231</span> : <span class="number">1237</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据基类类型值返回了两个不同的数，为什么选这两个值呢？它们是质数（即只能被1和自己整除的数），质数用于哈希时比较好，不容易冲突。</p>
<p>对于Long, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是高32位与低32位进行位异或操作。</p>
<p>对于Double, hashCode代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> floatToIntBits(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与equals方法类似，将double的二进制表示看作long，然后再按long计算hashCode。</p>
<p>每个包装类也都重写了toString方法，返回对象的字符串表示，这个一般比较自然，不再赘述。</p>
<h3 id="2-Comparable"><a href="#2-Comparable" class="headerlink" title="2. Comparable"></a>2. Comparable</h3><p>每个包装类都实现了Java API中的Comparable接口。Comparable接口代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bits = doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span>(<span class="keyword">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;T&gt;</code>是泛型语法，我们在第8章介绍，T表示比较的类型，由实现接口的类传入。接口只有一个方法compareTo，当前对象与参数对象进行比较，在小于、等于、大于参数时，应分别返回-1、0、1。</p>
<p>各个包装类的实现基本都是根据基本类型值进行比较，不再赘述。对于Boolean,false小于true。对于Float和Double，存在和equals方法一样的问题，0.01和0.1*0.1相比的结果并不为0。</p>
<h3 id="3．包装类和String"><a href="#3．包装类和String" class="headerlink" title="3．包装类和String"></a>3．包装类和String</h3><p>除了toString方法外，包装类还有一些其他与String相关的方法。除了Character外，每个包装类都有一个静态的valueOf(String)方法，根据字符串表示返回包装类对象，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也都有一个静态的parseXXX(String)方法，根据字符串表示返回基本类型值，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean b = Boolean.valueOf(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">Float f = Float.valueOf(<span class="string">&quot;123.45f&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>都有一个静态的toString方法，根据基本类型值返回字符串表示，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="keyword">double</span> d = Double.parseDouble(<span class="string">&quot;123.45&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boolean.toString(<span class="keyword">true</span>));</span><br><span class="line">System.out.println(Double.toString(<span class="number">123.45</span>));</span><br></pre></td></tr></table></figure>

<p>对于整数类型，字符串表示除了默认的十进制外，还可以表示为其他进制，如二进制、八进制和十六进制，包装类有静态方法进行相互转换，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">123.45</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(<span class="number">12345</span>));       <span class="comment">//输出二进制</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">12345</span>));          <span class="comment">//输出十六进制</span></span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">&quot;3039&quot;</span>, <span class="number">16</span>));        <span class="comment">//按十六进制解析</span></span><br></pre></td></tr></table></figure>

<h3 id="4．常用常量"><a href="#4．常用常量" class="headerlink" title="4．常用常量"></a>4．常用常量</h3><p>包装类中除了定义静态方法和实例方法外，还定义了一些静态变量。对于Boolean类型，有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11000000111001</span><br><span class="line">3039</span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>所有数值类型都定义了MAX_VALUE和MIN_VALUE，表示能表示的最大/最小值，比如，对Integer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>Float和Double还定义了一些特殊数值，比如正无穷、负无穷、非数值，如Double类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> POSITIVE_INFINITY = <span class="number">1.0</span> / <span class="number">0.0</span>; <span class="comment">//正无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NEGATIVE_INFINITY = -<span class="number">1.0</span> / <span class="number">0.0</span>; <span class="comment">//负无穷</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> NaN = <span class="number">0.0d</span> / <span class="number">0.0</span>; <span class="comment">//非数值</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Number"><a href="#5-Number" class="headerlink" title="5. Number"></a>5. Number</h3><p>6种数值类型包装类有一个共同的父类Number。Number是一个抽象类，它定义了如下方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>通过这些方法，包装类实例可以返回任意的基本数值类型。</p>
<h3 id="6．不可变性"><a href="#6．不可变性" class="headerlink" title="6．不可变性"></a>6．不可变性</h3><p>包装类都是不可变类。所谓不可变是指实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：</p>
<ul>
<li>所有包装类都声明为了final，不能被继承。</li>
<li>内部基本类型值是私有的，且声明为了final。</li>
<li>没有定义setter方法。</li>
</ul>
<p>为什么要定义为不可变类呢？<strong>不可变使得程序更为简单安全</strong>，因为不用操心数据被意外改写的可能，可以安全地共享数据，尤其是在多线程的环境下。关于线程，我们在第15章介绍。</p>
<h2 id="7-1-3-剖析Integer与二进制算法"><a href="#7-1-3-剖析Integer与二进制算法" class="headerlink" title="7.1.3 剖析Integer与二进制算法"></a>7.1.3 剖析Integer与二进制算法</h2><p>本小节主要介绍Integer类， Long与Integer类似，就不再单独介绍了。一个简单的Integer还有什么要介绍的呢？它有一些二进制操作，包括位翻转和循环移位等，另外，我们也分析一下它的valueOf实现。为什么要关心实现代码呢？大部分情况下，确实不用关心，会用它就可以了，我们主要是学习其中的二进制操作。二进制是计算机的基础，但代码往往晦涩难懂，我们希望对其有一个更为清晰深刻的理解。</p>
<h3 id="1．位翻转"><a href="#1．位翻转" class="headerlink" title="1．位翻转"></a>1．位翻转</h3><p>Integer有两个静态方法，可以按位进行翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBytes</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br></pre></td></tr></table></figure>

<p>位翻转就是将int当作二进制，左边的位与右边的位进行互换，reverse是按位进行互换， reverseBytes是按byte进行互换，我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(a));</span><br><span class="line"><span class="keyword">int</span> r = Integer.reverse(a);</span><br><span class="line">System.out.println(Integer.toBinaryString(r));</span><br><span class="line"><span class="keyword">int</span> rb = Integer.reverseBytes(a);</span><br><span class="line">System.out.println(Integer.toHexString(rb));</span><br></pre></td></tr></table></figure>

<p>a是整数，用十六进制赋值，首先输出其二进制字符串，接着输出reverse后的二进制，最后输出reverseBytes后的十六进制，输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10010001101000101011001111000</span><br><span class="line">11110011010100010110001001000</span><br><span class="line">78563412</span><br></pre></td></tr></table></figure>

<p>reverseBytes是按字节翻转，78是十六进制表示的一个字节，12也是，所以结果78563412是比较容易理解的。二进制翻转初看是不对的，这是因为输出不是32位，输出时忽略了前面的0，我们补齐32位再看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00010010001101000101011001111000</span><br><span class="line">00011110011010100010110001001000</span><br></pre></td></tr></table></figure>

<p>这次结果就对了。这两个方法是怎么实现的呢？</p>
<p>先来看reverseBytes的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBytes</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i &gt;&gt;&gt; <span class="number">24</span>)              ) |</span><br><span class="line">            ((i &gt;&gt;    <span class="number">8</span>) &amp;    <span class="number">0xFF00</span>) |</span><br><span class="line">            ((i &lt;&lt;    <span class="number">8</span>) &amp; <span class="number">0xFF0000</span>) |</span><br><span class="line">            ((i &lt;&lt; <span class="number">24</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较晦涩，以参数i等于0x12345678为例，我们来分析执行过程：<br>1）<code>i&gt;&gt;&gt;24</code>无符号右移，最高字节挪到最低位，结果是0x00000012；<br>2）(<code>i&gt;&gt;8</code>) &amp; 0xFF00，左边第二个字节挪到右边第二个，i&gt;&gt;8结果是0x00123456，再进行&amp; 0xFF00，保留的是右边第二个字节，结果是0x00003400；<br>3）(<code>i &lt;&lt; 8</code>) &amp; 0xFF0000，右边第二个字节挪到左边第二个，i&lt;&lt;8结果是0x34567800，再进行&amp; 0xFF0000，保留的是右边第三个字节，结果是0x00560000；<br>4）<code>i&lt;&lt;24</code>，结果是0x78000000，最右字节挪到最左边。</p>
<p>这4个结果再进行或操作|，结果就是0x78563412，这样，通过左移、右移、与和或操作，就达到了字节翻转的目的。</p>
<p>我们再来看reverse的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//HD, Figure 7-1</span></span><br><span class="line">    i = (i &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span> | (i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span> | (i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>;</span><br><span class="line">    i = (i &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span> | (i &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">    i = (i &lt;&lt; <span class="number">24</span>) | ((i &amp; <span class="number">0xff00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">        ((i &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff00</span>) | (i &gt;&gt;&gt; <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码虽然很短，但非常晦涩，到底是什么意思呢？代码第一行是一个注释，HD表示的是一本书，书名为Hacker’s Delight，中文版为《算法心得：高效算法的奥秘》, HD是它的缩写，Figure 7-1是书中的图7-1, reverse的代码就是复制了这本书中图7-1的代码，书中也说明了代码的思路，我们简要说明。</p>
<p>高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着是4位一组交换、然后是8位、16位，16位之后就完成了。这个思路不仅适用于二进制，而且适用于十进制，为便于理解，我们看个十进制的例子。比如对数字12345678进行翻转。</p>
<p>第一轮，相邻单一数字进行互换，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21 43 65 87</span><br></pre></td></tr></table></figure>

<p>第二轮，以两个数字为一组交换相邻的，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">43 21 87 65</span><br></pre></td></tr></table></figure>

<p>第三轮，以4个数字为一组交换相邻的，结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8765 4321</span><br></pre></td></tr></table></figure>

<p>翻转完成。</p>
<p>对十进制而言，这个效率并不高，但对于二进制而言，却是高效的，因为二进制可以在一条指令中交换多个相邻位。下面代码就是对相邻单一位进行互换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (x &amp; 0x55555555) &lt;&lt;   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;&gt;   1;</span><br></pre></td></tr></table></figure>

<p>5的二进制表示是0101,0x55555555的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01010101010101010101010101010101</span><br></pre></td></tr></table></figure>

<p>x &amp; 0x55555555就是取x的奇数位。</p>
<p>A的二进制表示是1010,0xAAAAAAAA的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10101010101010101010101010101010</span><br></pre></td></tr></table></figure>

<p>x &amp; 0xAAAAAAAA就是取x的偶数位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &amp; 0x55555555) &lt;&lt;   1 | (x &amp; 0xAAAAAAAA) &gt;&gt;&gt;   1;</span><br></pre></td></tr></table></figure>

<p>表示的就是x的奇数位向左移，偶数位向右移，然后通过|合并，达到相邻位互换的目的。这段代码可以有个小的优化，只使用一个常量0x55555555，后半部分先移位再进行与操作，变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x55555555) &lt;&lt; 1 | (i &gt;&gt;&gt; 1) &amp; 0x55555555;</span><br></pre></td></tr></table></figure>

<p>同理，如下代码就是以两位为一组，对相邻位进行互换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x33333333) &lt;&lt; 2 | (i &amp; 0xCCCCCCCC)&gt;&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>3的二进制表示是0011,0x33333333的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00110011001100110011001100110011</span><br></pre></td></tr></table></figure>

<p>x &amp; 0x33333333就是取x以两位为一组的低半部分。</p>
<p>C的二进制表示是1100,0xCCCCCCCC的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11001100110011001100110011001100</span><br></pre></td></tr></table></figure>

<p>x &amp; 0xCCCCCCCC就是取x以两位为一组的高半部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x33333333) &lt;&lt; 2 | (i &amp; 0xCCCCCCCC)&gt;&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>表示的就是x以两位为一组，低半部分向高位移，高半部分向低位移，然后通过|合并，达到交换的目的。同样，可以去掉常量0xCCCCCCCC，代码可以优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i &amp; 0x33333333) &lt;&lt; 2 | (i &gt;&gt;&gt; 2) &amp; 0x33333333;</span><br></pre></td></tr></table></figure>

<p>同理，下面代码就是以4位为一组进行交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; 0x0f0f0f0f) &lt;&lt; 4 | (i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;</span><br></pre></td></tr></table></figure>

<p>到以8位为单位交换时，就是字节翻转了，可以写为如下更直接的形式，代码和reverse-Bytes基本完全一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &lt;&lt; 24) | ((i &amp; 0xff00) &lt;&lt; 8) |</span><br><span class="line">    ((i &gt;&gt;&gt; 8) &amp; 0xff00) | (i &gt;&gt;&gt; 24);</span><br></pre></td></tr></table></figure>

<p>reverse代码为什么要写得这么晦涩呢？或者说不能用更容易理解的方式写吗？比如，实现翻转，一种常见的思路是：第一个和最后一个交换，第二个和倒数第二个交换，直到中间两个交换完成。如果数据不是二进制位，这个思路是好的，但对于二进制位，这个思路的效率比较低。</p>
<p>CPU指令并不能高效地操作单个位，它操作的最小数据单位一般是32位（32位机器），另外，CPU可以高效地实现移位和逻辑运算，但实现加、减、乘、除运算则比较慢。</p>
<p>reverse<strong>是在充分利用CPU的这些特性，并行高效地进行相邻位的交换</strong>，也可以通过其他更容易理解的方式实现相同功能，但很难比这个代码更高效。</p>
<h3 id="2．循环移位"><a href="#2．循环移位" class="headerlink" title="2．循环移位"></a>2．循环移位</h3><p>Integer有两个静态方法可以进行循环移位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rotateLeft</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rotateRight</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance)</span></span></span><br></pre></td></tr></table></figure>

<p>rotateLeft方法是循环左移，rotateRight方法是循环右移，distance是移动的位数。所谓循环移位，是相对于普通的移位而言的，普通移位，比如左移2位，原来的最高两位就没有了，右边会补0，而如果是循环左移两位，则原来的最高两位会移到最右边，就像一个左右相接的环一样。看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="keyword">int</span> b = Integer.rotateLeft(a, <span class="number">8</span>);</span><br><span class="line">System.out.println(Integer.toHexString(b));</span><br><span class="line"><span class="keyword">int</span> c = Integer.rotateRight(a, <span class="number">8</span>);</span><br><span class="line">System.out.println(Integer.toHexString(c))</span><br></pre></td></tr></table></figure>

<p>b是a循环左移8位的结果，c是a循环右移8位的结果，所以输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">34567812</span><br><span class="line">78123456</span><br></pre></td></tr></table></figure>

<p>这两个函数的实现代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rotateLeft</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &lt;&lt; distance) | (i &gt;&gt;&gt; -distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rotateRight</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i &gt;&gt;&gt; distance) | (i &lt;&lt; -distance);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数中令人费解的是负数，如果distance是8，那i&gt;&gt;&gt;-8是什么意思呢？其实，实际的移位个数不是后面的直接数字，而是直接数字的最低5位的值，或者说是直接数字&amp;0x1f的结果。之所以这样，是因为5位最大表示31，移位超过31位对int整数是无效的。</p>
<p>理解了移动负数位的含义，就比较容易理解上面这段代码了，比如，-8的二进制表示是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11111111111111111111111111111000</span><br></pre></td></tr></table></figure>

<p>其最低5位是11000，十进制表示就是24，所以i&gt;&gt;&gt;-8就是i&gt;&gt;&gt;24, i&lt;&lt;8 |i&gt;&gt;&gt;24就是循环左移8位。上面代码中，i&gt;&gt;&gt;-distance就是i&gt;&gt;&gt;(32-distance),i&lt;&lt;-distance就是i&lt;&lt;(32-distance)。</p>
<p>Integer中还有一些其他的位操作，具体可参看API文档。关于其实现代码，都有注释指向Hacker’s Delight这本书的相关章节，不再赘述。</p>
<h3 id="3-valueOf的实现"><a href="#3-valueOf的实现" class="headerlink" title="3. valueOf的实现"></a>3. valueOf的实现</h3><p>在前面，我们提到，创建包装类对象时，可以使用静态的valueOf方法，也可以直接使用new，但建议使用valueOf方法，为什么呢？我们来看Integer的valueOf的代码（基于Java<br>7）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它使用了IntegerCache，这是一个私有静态内部类，如代码清单7-1所示。</p>
<center>代码清单7-1 IntegerCache</center>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(integerCacheHighPropValue ! = <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">//Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IntegerCache表示Integer缓存，其中的cache变量是一个静态Integer数组，在静态初始化代码块中被初始化，默认情况下，保存了-128～127共256个整数对应的Integer对象。</p>
<p>在valueOf代码中，如果数值位于被缓存的范围，即默认-128～127，则直接从Integer-Cache中获取已预先创建的Integer对象，只有不在缓存范围时，才通过new创建对象。</p>
<p>通过共享常用对象，可以节省内存空间，由于Integer是不可变的，所以缓存的对象可以安全地被共享。Boolean、Byte、Short、Long、Character都有类似的实现。这种共享常用对象的思路，是一种常见的设计思路，它有一个名字，叫<strong>享元模式</strong>，英文叫Flyweight，即共享的轻量级元素。</p>
<h2 id="7-1-4-剖析Character"><a href="#7-1-4-剖析Character" class="headerlink" title="7.1.4 剖析Character"></a>7.1.4 剖析Character</h2><p>本节探讨Character类。Character类除了封装了一个char外，还有什么可介绍的呢？它有很多静态方法，封装了Unicode字符级别的各种操作，是Java文本处理的基础，注意不是char级别，Unicode字符并不等同于char，本节详细介绍这些方法。在此之前，先来回顾一下Unicode知识。</p>
<h3 id="1-Unicode基础"><a href="#1-Unicode基础" class="headerlink" title="1. Unicode基础"></a>1. Unicode基础</h3><p>Unicode给世界上每个字符分配了一个编号，编号范围为0x000000～0x10FFFF。编号范围在0x0000～0xFFFF的字符为常用字符集，称BMP（Basic MultilingualPlane）字符。编号范围在0x10000～0x10FFFF的字符叫做增补字符（supplementary character）。</p>
<p>Unicode主要规定了编号，但没有规定如何把编号映射为二进制。UTF-16是一种编码方式，或者叫映射方式，它将编号映射为两个或4个字节，对BMP字符，它直接用两个字节表示，对于增补字符，使用4个字节表示，前两个字节叫高代理项（high surrogate），范围为0xD800～0xDBFF，后两个字节叫低代理项（lowsurrogate），范围为0xDC00～0xDFFF。UTF-16定义了一个公式，可以将编号与4字节表示进行相互转换。</p>
<p>Java内部采用UTF-16编码，char表示一个字符，但只能表示BMP中的字符，对于增补字符，需要使用两个char表示，一个表示高代理项，一个表示低代理项。</p>
<p>使用int可以表示任意一个Unicode字符，低21位表示Unicode编号，高11位设为0。整数编号在Unicode中一般称为<strong>代码点</strong>（code point），表示一个Unicode字符，与之相对，还有一个词<strong>代码单元</strong>（code unit）表示一个char。</p>
<p>Character类中有很多相关静态方法，下面分别介绍。</p>
<h3 id="2．检查code-point和char"><a href="#2．检查code-point和char" class="headerlink" title="2．检查code point和char"></a>2．检查code point和char</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个int是不是一个有效的代码点，小于等于0x10FFFF的为有效，大于的为无效</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValidCodePoint</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断一个int是不是BMP字符，小于等于0xFFFF的为BMP字符，大于的不是</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBmpCodePoint</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断一个int是不是增补字符，0x010000～0X10FFFF为增补字符</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSupplementaryCodePoint</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断char是否是高代理项，0xD800～0xDBFF为高代理项</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isHighSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断char是否为低代理项，0xDC00～0xDFFF为低代理项</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断char是否为代理项， char为低代理项或高代理项，则返回true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSurrogate</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断两个字符high和low是否分别为高代理项和低代理项</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSurrogatePair</span><span class="params">(<span class="keyword">char</span> high, <span class="keyword">char</span> low)</span></span></span><br><span class="line"><span class="function"><span class="comment">//判断一个代码点由几个char组成，增补字符返回2, BMP字符返回1</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">charCount</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-code-point与char的转换"><a href="#3-code-point与char的转换" class="headerlink" title="3. code point与char的转换"></a>3. code point与char的转换</h3><p>除了简单的检查外，Character类中还有很多方法，进行code point与char的相互转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据高代理项high和低代理项low生成代码点，这个转换有个公式，这个方法封装了这个公式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toCodePoint</span><span class="params">(<span class="keyword">char</span> high, <span class="keyword">char</span> low)</span></span></span><br><span class="line"><span class="function"><span class="comment">//根据代码点生成char数组，即UTF-16表示，如果code point为BMP字符，则返回的char</span></span></span><br><span class="line"><span class="function"><span class="comment">//数组长度为1，如果为增补字符，长度为2, char[0]为高代理项，char[1]为低代理项</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] <span class="title">toChars</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将代码点转换为char数组，与上面方法类似，只是结果存入指定数组dst的指定位置index</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toChars</span><span class="params">(<span class="keyword">int</span> codePoint, <span class="keyword">char</span>[] dst, <span class="keyword">int</span> dstIndex)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对增补字符code point，生成低代理项</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">lowSurrogate</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="comment">//对增补字符code point，生成高代理项</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">highSurrogate</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="4．按code-point处理char数组或序列"><a href="#4．按code-point处理char数组或序列" class="headerlink" title="4．按code point处理char数组或序列"></a>4．按code point处理char数组或序列</h3><p>Character包含若干方法，以方便按照code point处理char数组或序列。</p>
<p>返回char数组a中从offset开始count个char包含的code point个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure>

<p>比如，如下代码输出为2, char个数为3，但code point为2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">chs[<span class="number">0</span>] = <span class="string">&#x27;马&#x27;</span>;</span><br><span class="line">Character.toChars(<span class="number">0x1FFFF</span>, chs, <span class="number">1</span>);</span><br><span class="line">System.out.println(Character.codePointCount(chs, <span class="number">0</span>, <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>除了接受char数组，还有一个重载的方法接受字符序列CharSequence：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointCount</span><span class="params">(CharSequence seq, <span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex)</span></span></span><br></pre></td></tr></table></figure>

<p>CharSequence是一个接口，它的定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它与一个char数组是类似的，有length方法，有charAt方法根据索引获取字符，String类就实现了该接口。</p>
<p>返回char数组或序列中指定索引位置的code point：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> index, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointAt</span><span class="params">(CharSequence seq, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>如果指定索引位置为高代理项，下一个位置为低代理项，则返回两项组成的codepoint，检查下一个位置时，下一个位置要小于limit，没传limit时，默认为a.length。</p>
<p>返回char数组或序列中指定索引位置之前的code point：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> index, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">codePointBefore</span><span class="params">(CharSequence seq, <span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<p>codePointAt是往后找，codePointBefore是往前找，如果指定位置为低代理项，且前一个位置为高代理项，则返回两项组成的code point，检查前一个位置时，前一个位置要大于等于start，没传start时，默认为0。</p>
<p>根据code point偏移数计算char索引：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> count,<span class="keyword">int</span> index, <span class="keyword">int</span> codePointOffset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">offsetByCodePoints</span><span class="params">(CharSequence seq, <span class="keyword">int</span> index,<span class="keyword">int</span> codePointOffset)</span></span></span><br></pre></td></tr></table></figure>

<p>如果字符数组或序列中没有增补字符，返回值为index+codePointOffset，如果有增补字符，则会将codePointOffset看作code point偏移，转换为字符偏移，start和count取字符数组的子数组。</p>
<p>比如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">Character.toChars(<span class="number">0x1FFFF</span>, chs, <span class="number">1</span>);</span><br><span class="line">System.out.println(Character.offsetByCodePoints(chs, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>));<span class="comment">//输出结果为3, index和codePointOffset都为1，但第二个字符为增补字符，一个code point偏移是两个char偏移，所以结果为3。</span></span><br></pre></td></tr></table></figure>

<h3 id="5．字符属性"><a href="#5．字符属性" class="headerlink" title="5．字符属性"></a>5．字符属性</h3><p>Unicode在给每个字符分配一个编号之外，还分配了一些属性，Character类封装了对Unicode字符属性的检查和操作，下面介绍一些主要的属性。</p>
<p>获取字符类型（general category）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getType</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure>

<p>Unicode给每个字符分配了一个类型，这个类型是非常重要的，很多其他检查和操作都是基于这个类型的。getType方法的参数可以是int类型的code point，也可以是char类型。char类型只能处理BMP字符，而int类型可以处理所有字符。Character类中很多方法都是既可以接受int类型，也可以接受char类型，后续只列出int类型的方法。返回值是int，表示类型，Character类中定义了很多静态常量表示这些类型，表7-3列出了一些字符、type值，以及Character类中常量的名称。</p>
<center>表7-3 常见字符类型值</center>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211209094654.jpeg" alt="epub_923038_52"><br>检查字符是否在Unicode中被定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDefined</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>每个被定义的字符，其getType()返回值都不为0，如果返回值为0，表示无定义。注意与isValidCodePoint的区别，后者只要数字不大于0x10FFFF都返回true。</p>
<p>检查字符是否为数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>getType()返回值为DECIMAL_DIGIT_NUMBER的字符为数字。需要注意的是，不光字符’0’、’1’、……、’9’是数字，中文全角字符的0～9也是数字。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;9&#x27;</span>; <span class="comment">//中文全角数字</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)ch+<span class="string">&quot;, &quot;</span>+Character.isDigit(ch));</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">65305, true</span><br></pre></td></tr></table></figure>

<p>全角字符的9, Unicode编号为65305，它也是数字。</p>
<p>检查是否为字母（Letter）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetter</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>如果getType()的返回值为下列之一，则为Letter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPPERCASE_LETTER</span><br><span class="line">LOWERCASE_LETTER</span><br><span class="line">TITLECASE_LETTER</span><br><span class="line">MODIFIER_LETTER</span><br><span class="line">OTHER_LETTER</span><br></pre></td></tr></table></figure>

<p>除了TITLECASE_LETTER和MODIFIER_LETTER，其他在表7-3中有示例，而这两个平时碰到的也比较少，就不介绍了。</p>
<p>检查是否为字母或数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLetterOrDigit</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>只要其中之一返回true就返回true。</p>
<p>检查是否为字母（Alphabetic）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAlphabetic</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>这也是检查是否为字母，与isLetter的区别是：isLetter返回true时，isAlphabetic也必然返回true；此外，getType()值为LETTER_NUMBER时，isAlphabetic也返回true，而isLetter返回false。LETTER_NUMBER中常见的字符有罗马数字字符，如’I’、’Ⅱ’、’Ⅲ’、’Ⅳ’。</p>
<p>检查是否为空格字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSpaceChar</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p><code>getType()</code>值为<code>SPACE_SEPARATOR</code>,<code>LINE_SEPARATOR</code>和<code>PARAGRAPH_SEPARATOR</code>时，返回true。这个方法其实并不常用，因为它只能严格匹配空格字符本身，不能匹配实际产生空格效果的字符，如Tab控制键’<code>\t</code>‘。</p>
<p>更常用的检查空格的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isWhitespace</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>‘<code>\t</code>‘、’<code>\n</code>‘、全角空格’ ‘和半角空格’ ‘的返回值都为true。</p>
<p>检查是否为小写字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLowerCase</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>常见的小写字符主要是小写英文字母a～z。</p>
<p>检查是否为大写字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUpperCase</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>常见的大写字符主要是大写英文字母A～Z。</p>
<p>检查是否为表意象形文字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIdeographic</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>大部分中文都返回为true</p>
<p>检查是否为ISO 8859-1编码中的控制字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isISOControl</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>我们在第2章介绍过，0～31、127～159表示控制字符。</p>
<p>检查是否可作为Java标识符的第一个字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isJavaIdentifierStart</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>Java标识符是Java中的变量名、函数名、类名等，字母（Alphabetic）、美元符号（$）、下画线（_）可作为Java标识符的第一个字符，但数字字符不可以。</p>
<p>检查是否可作为Java标识符的中间字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isJavaIdentifierPart</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>相比isJavaIdentifierStart，主要多了数字字符，Java标识符的中间字符可以包含数字。</p>
<p>检查是否为镜像（mirrowed）字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMirrored</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>常见镜像字符有<code>( )</code>、<code>&#123; &#125;</code>、<code>&lt; &gt;</code>、<code>[ ]</code>，都有对应的镜像。</p>
<h3 id="6．字符转换"><a href="#6．字符转换" class="headerlink" title="6．字符转换"></a>6．字符转换</h3><p>Unicode除了规定字符属性外，对有大小写对应的字符，还规定了其对应的大小写，对有数值含义的字符，也规定了其数值。</p>
<p>我们先来看大小写，Character有两个静态方法，对字符进行大小写转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toLowerCase</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">toUpperCase</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>这两个方法主要针对英文字符a～z和A～Z，例如：toLowerCase(‘A’)返回’a’,toUpper-Case(‘z’)返回’Z’。</p>
<p>返回一个字符表示的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumericValue</span><span class="params">(<span class="keyword">int</span> codePoint)</span></span></span><br></pre></td></tr></table></figure>

<p>字符’0’～’9’返回数值0～9，对于字符a～z，无论是小写字符还是大写字符，无论是普通英文还是中文全角，数值结果都是10～35。例如，如下代码的输出结果是一样的，都是10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;A&#x27;</span>)); <span class="comment">//全角大写A</span></span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//全角小写a</span></span><br><span class="line">System.out.println(Character.getNumericValue(<span class="string">&#x27;a&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>返回按给定进制表示的数值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digit</span><span class="params">(<span class="keyword">int</span> codePoint, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>radix表示进制，常见的有二进制、八进制、十进制、十六进制，计算方式与get-NumericValue类似，只是会检查有效性，数值需要小于radix，如果无效，返回-1。例如：digit(‘F’,16)返回15，是有效的；但digit(‘G’,16)就无效，返回-1。</p>
<p>返回给定数值的字符形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">forDigit</span><span class="params">(<span class="keyword">int</span> digit, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure>

<p>与<code>digit(int codePoint, int radix)</code>相比，进行相反转换，如果数字无效，返回’<code>\0</code>‘。例如， <code>Character.forDigit(15, 16)</code>返回’<code>F</code>‘。</p>
<p>与Integer类似，Character也有按字节翻转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">reverseBytes</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure>

<p>例如，翻转字符0x1234：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toHexString(Character.reverseBytes((<span class="keyword">char</span>)<span class="number">0x1234</span>)));</span><br></pre></td></tr></table></figure>

<p>输出为3412。</p>
<p>至此，Characer类就介绍完了，它在Unicode字符级别（而非char级别）封装了字符的各种操作，通过将字符处理的细节交给Character类，其他类就可以在更高的层次上处理文本了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/36e750aa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/36e750aa/" class="post-title-link" itemprop="url">1.7 函数调用的基本原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-01 19:33:23" itemprop="dateCreated datePublished" datetime="2021-12-01T19:33:23+08:00">2021-12-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-12-07 12:07:07" itemprop="dateModified" datetime="2021-12-07T12:07:07+08:00">2021-12-07</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/" itemprop="url" rel="index"><span itemprop="name">9 Java编程的逻辑</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/" itemprop="url" rel="index"><span itemprop="name">1第一部分 编程基础与二进制</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/9-Java%E7%BC%96%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91/1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6/%E7%AC%AC1%E7%AB%A0-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">第1章 编程基础</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/36e750aa/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/36e750aa/" data-xid="/JavaReadingNotes/36e750aa/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-7-函数调用的基本原理"><a href="#1-7-函数调用的基本原理" class="headerlink" title="1.7 函数调用的基本原理"></a>1.7 函数调用的基本原理</h1><p>在介绍递归函数的时候，我们看到了一个系统错误：java.lang.StackOverflowError，理解这个错误，需要理解函数调用的实现机制。下面，我们先来了解一个重要的概念：栈，然后再通过一些例子来仔细分析函数调用的过程。</p>
<h2 id="1-7-1-栈的概念"><a href="#1-7-1-栈的概念" class="headerlink" title="1.7.1 栈的概念"></a>1.7.1 栈的概念</h2><p>我们之前谈过程序执行的基本原理：CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转（条件跳转或无条件跳转）。</p>
<p>基本上，这依然是成立的，程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。</p>
<p>但这里面有几个问题。<br>1）参数如何传递？<br>2）函数如何知道返回到什么地方？在if/else、for中，跳转的地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。<br>3）函数结果如何传给调用方？</p>
<p>解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫<strong>栈</strong>。</p>
<p>栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据称为入栈，最下面的称为栈底，最上面的称为栈顶，从栈顶拿出数据通常称为出栈。栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最低的。</p>
<p>计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，以及函数内定义的局部变量。计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。返回值不太一样，它可能放在栈中，但它使用的栈和局部变量不完全一样，有的系统使用CPU内的一个存储器存储返回值，我们可以简单认为存在一个专门的返回值存储器。main函数的相关数据放在栈的最下面，每调用一次函数，都会将相关函数的数据入栈，调用结束会出栈。</p>
<h2 id="1-7-2-函数执行的基本原理"><a href="#1-7-2-函数执行的基本原理" class="headerlink" title="1.7.2 函数执行的基本原理"></a>1.7.2 函数执行的基本原理</h2><p>以上描述可能有点抽象，我们通过一个例子来具体说明函数执行的过程，看个简单例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1 public class Sum &#123;</span><br><span class="line">2</span><br><span class="line">3      public static int sum(int a, int b) &#123;</span><br><span class="line">4           int c = a + b;</span><br><span class="line">5           return c;</span><br><span class="line">6      &#125;</span><br><span class="line">7</span><br><span class="line">8      public static void main(String[] args) &#123;</span><br><span class="line">9           int d = Sum.sum(1, 2);</span><br><span class="line">10          System.out.println(d);</span><br><span class="line">11     &#125;</span><br><span class="line">12 &#125;</span><br></pre></td></tr></table></figure>

<p>这是一个简单的例子，main函数调用了sum函数，计算1和2的和，然后输出计算结果，从概念上，这是容易理解的，让我们从栈的角度来讨论下。</p>
<p>当程序在main函数调用Sum.sum之前，栈的情况大概如图1-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221515.jpeg" alt="epub_923038_12"></p>
<center>图1-1 调用Sum.sum之前的栈示意图</center>

<p>栈中主要存放了两个变量args和d。在程序执行到Sum.sum的函数内部，准备返回之前，即第5行，栈的情况大概如图1-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221528.jpeg" alt="epub_923038_13"></p>
<center>图1-2 在Sum.sum内部，准备返回之前的栈示意图</center>

<p>我们解释下，在main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址（也就是调用函数结束后要执行的指令地址）入栈，接着跳转到sum函数，在sum函数内部，需要为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2，在返回之前，返回值保存到了专门的返回值存储器中。</p>
<p>在调用return后，程序会跳转到栈中保存的返回地址，即main的下一条指令地址，而sum函数相关的数据会出栈，从而又变回图1-1的样子。</p>
<p>main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。</p>
<p>函数执行的基本原理，简单来说就是这样。但有一些需要介绍的点，我们讨论一下。</p>
<p>我们在1.1节的时候说过，定义一个变量就会分配一块内存，但我们并没有具体谈什么时候分配内存，具体分配在哪里，什么时候释放内存。</p>
<p>从以上关于栈的描述我们可以看出，函数中的参数和函数内定义的变量，都分配在栈中，这些变量只有在函数被调用的时候才分配，而且在调用结束后就被释放了。但这个说法主要针对基本数据类型，接下来我们介绍数组和对象。</p>
<h2 id="1-7-3-数组和对象的内存分配"><a href="#1-7-3-数组和对象的内存分配" class="headerlink" title="1.7.3 数组和对象的内存分配"></a>1.7.3 数组和对象的内存分配</h2><p>对于数组和对象类型，我们介绍过，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆（也是内存的一部分，后续章节会进一步介绍）中，但存放地址的空间是分配在栈上的。我们来看个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayMax</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = min;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a&gt;max)&#123;</span><br><span class="line">                max = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> ret = max(<span class="number">0</span>, arr);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序也很简单，main函数新建了一个数组，然后调用函数max计算0和数组中元素的最大值，在程序执行到max函数的return语句之前的时候，内存中栈和堆的情况如图1-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221610.jpeg" alt="epub_923038_14"></p>
<center>图1-3 参数有数组的内存栈和堆示意图</center>

<p>对于数组arr，在栈中存放的是实际内容的地址0x1000，存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。</p>
<p>但说堆空间完全不受影响是不正确的，在这个例子中，当main函数执行结束，栈空间没有变量指向它的时候，Java系统会自动进行垃圾回收，从而释放这块空间。</p>
<h2 id="1-7-4-递归调用的原理"><a href="#1-7-4-递归调用的原理" class="headerlink" title="1.7.4 递归调用的原理"></a>1.7.4 递归调用的原理</h2><p>我们再通过栈的角度来理解一下递归函数的调用过程，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n＊factorial(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = factorial(<span class="number">4</span>);</span><br><span class="line">    System.out.println(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在factorial第一次被调用的时候，n是4，在执行到n<em>factorial(n-1)，即4</em>factorial(3)之前的时候，栈的情况大概如图1-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221645.jpeg" alt="epub_923038_15"></p>
<center>图1-4 递归调用栈示意图，n为4</center>

<p>注意，返回值存储器是没有值的，在调用factorial(3)后，栈的情况如图1-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221711.jpeg" alt="epub_923038_16"></p>
<center>图1-5 递归调用栈示意图，n为3</center>

<p>栈的深度增加了，返回值存储器依然为空，就这样，每递归调用一次，栈的深度就增加一层，每次调用都会分配对应的参数和局部变量，也都会保存调用的返回地址，在调用到n等于0的时候，栈的情况如图1-6所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/12/20211201221724.jpeg" alt="epub_923038_17"></p>
<center>图1-6 递归调用栈示意图，n为0</center>

<p>这个时候，终于有返回值了，我们将factorial简写为f。f(0)的返回值为1;f(0)返回到f(1), f(1)执行<code>1*f(0)</code>，结果也是1；然后返回到<code>f(2), f(2)</code>执行<code>2*f(1)</code>，结果是2；接着返回到<code>f(3), f(3)</code>执行<code>3*f(2)</code>，结果是6；然后返回到<code>f(4)</code>，执行<code>4*f(3)</code>，结果是24。</p>
<p>以上就是递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。</p>
<h2 id="1-7-5-小结"><a href="#1-7-5-小结" class="headerlink" title="1.7.5 小结"></a>1.7.5 小结</h2><p>本节介绍了函数调用的基本原理，<strong>函数调用主要是通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器存储的</strong>。</p>
<p>从函数调用的过程可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。在递归调用的情况下，如果递归的次数比较多，这个成本是比较可观的，所以，如果程序可以比较容易地改为其他方式，应该考虑其他方式。另外，栈的空间不是无限的，一般正常调用都是没有问题的，但如果栈空间过深，系统就会抛出错误java.lang.StackOverflowError，即栈溢出。</p>
<p>至此，关于编程的基础知识，包括数据类型和变量、赋值、基本运算、流程控制中的条件执行和循环，以及函数的概念和基本原理，就介绍完了。我们谈到，在Java中，函数必须放在类中，目前我们简单认为类只是函数的容器，但类在Java中远不止有这个功能，它还承载了很多概念和思维方式，在探讨类的概念之前，在下一章，我们先来进一步理解下各种基本数据类型和文本背后的二进制表示。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/JavaReadingNotes/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/11/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-mzjszagu6-lanlan2017.vercel.app","placeholder":"填写您的邮箱以便接收回复提醒,填写您个人网站地址以便为您增加访问量","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/11/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
