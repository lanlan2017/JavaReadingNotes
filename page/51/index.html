<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 5.4.0">

<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/JavaReadingNotes/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/JavaReadingNotes/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/JavaReadingNotes/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/JavaReadingNotes/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="_Sly-yzHYmALHXzjFpPWsodMrjBSphw7bfRbMUH80Qc">
  <meta name="msvalidate.01" content="B1CFD346B8DEBBFE0C983C2AF8955531">
  <meta name="baidu-site-verification" content="vkMTwK56xr">

<link rel="stylesheet" href="/JavaReadingNotes/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"lanlan2017.github.io","root":"/JavaReadingNotes/","images":"/JavaReadingNotes/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/JavaReadingNotes/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/JavaReadingNotes/js/config.js"></script>
<meta name="description" content="好好学习，天天向上">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝蓝站点">
<meta property="og:url" content="https://lanlan2017.github.io/JavaReadingNotes/page/51/index.html">
<meta property="og:site_name" content="蓝蓝站点">
<meta property="og:description" content="好好学习，天天向上">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝蓝">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://lanlan2017.github.io/JavaReadingNotes/page/51/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/51/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>蓝蓝站点</title>
  

  <script src="/JavaReadingNotes/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?dadeb188eb14ccde0b25a19230c429b5"></script>


<link rel="dns-prefetch" href="https://waline-test-lanlan2017.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/JavaReadingNotes/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/JavaReadingNotes/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">蓝蓝站点</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Java读书笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/JavaReadingNotes/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-dir"><a href="/JavaReadingNotes/dir/" rel="section"><i class="fa fa-sitemap fa-fw"></i>目录</a></li>
        <li class="menu-item menu-item-categories"><a href="/JavaReadingNotes/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/JavaReadingNotes/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/JavaReadingNotes/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="蓝蓝"
      src="/JavaReadingNotes/images/avatar.gif">
  <p class="site-author-name" itemprop="name">蓝蓝</p>
  <div class="site-description" itemprop="description">好好学习，天天向上</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/JavaReadingNotes/archives/">
          <span class="site-state-item-count">1871</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/JavaReadingNotes/categories/">
        <span class="site-state-item-count">626</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/todo/" title="todo → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;todo&#x2F;"><i class="fa fa-check-square fa-fw"></i>todo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://lanlan2017.github.io/links/" title="links → https:&#x2F;&#x2F;lanlan2017.github.io&#x2F;links&#x2F;"><i class="fa fa-link fa-fw"></i>links</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/722eb43c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/722eb43c/" class="post-title-link" itemprop="url">35.1 迷你版的交易系统</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 19:57:33" itemprop="dateCreated datePublished" datetime="2021-09-27T19:57:33+08:00">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 20:15:57" itemprop="dateModified" datetime="2021-10-01T20:15:57+08:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">8 设计模式之禅(第2版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/4-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C-%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B7%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">4 第四部分 完美世界 ——设计模式混编</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/4-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C-%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B7%E7%BC%96/%E7%AC%AC35%E7%AB%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第35章 工厂方法模式+策略模式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/722eb43c/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/722eb43c/" data-xid="/JavaReadingNotes/722eb43c/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="35-1-迷你版的交易系统"><a href="#35-1-迷你版的交易系统" class="headerlink" title="35.1 迷你版的交易系统"></a>35.1 迷你版的交易系统</h1><p>大家可能对银行的交易系统充满敬畏之情，一听说是银行的IT人员，立马想当然地认为这是个很厉害的人物，那我们今天就来对银行的交易系统做一个初步探讨。国内一家大型集团（全球500强之一）计划建立全国“一卡通”计划，每个员工配备一张IC卡，该卡基本上就是万能的，门禁系统用它，办公系统用它，你想打开自己的邮箱，没有它就甭想了，它还可以用来进行消费，比如到食堂吃饭，到园区内的商店消费，甚至洗澡、理发、借书、买书等都可以用它，只要这张卡内有余额，在集团内部就是一张借记卡（当然还有一些内部的补助通过该卡发放）。我们要讲解的就是“一卡通”项目联机交易子系统，类似于银行的交易系统，可以说它是交易系统的mini版吧。</p>
<p>该项目具有一定的挑战性，集团公司的架构分为三层：总部、省级分部、市级机构，业务要求是“一卡通”推广到全国，一名员工从北京出差到了上海，凭一卡通能在北京做的事情在上海同样能完成。对于联机交易子项目，异地分支机构与总部之间的通信采用了MQ（Message Queue，消息队列）传递消息，也就是我们观察者模式的BOSS版，与目前的通过POS机刷信用卡基本上是一个道理。</p>
<p>联机交易子系统有一个非常重要的子模块（Module）——扣款子模块。这个模块太重要了！从业务上来说，扣款失败就代表着所有的商业交易关闭，这是不允许发生的；从技术上来说，扣款的异常处理、事务处理、鲁棒性都是不容忽视的，特别是饭点时间，并发量是很恐怖的，这对架构师提出了很高的要求。</p>
<p>我们详细分析一下扣款子模块，每个员工都有一张IC卡，他的IC卡上有以下两种金额。</p>
<ul>
<li>固定金额</li>
</ul>
<p>固定金额是指员工不能提现的金额，这部分金额只能用来特定消费，即员工日常必需的消费，例如食堂内吃饭、理发、健身等活动。</p>
<ul>
<li>自由金额</li>
</ul>
<p>自由金额是可以提现的，当然也可以用于消费。每个月初，总部都会为每个员工的IC卡中打入固定数量的金额，然后提倡大家在集团内的商店消费。</p>
<p>在实际的系统开发中，架构设计采用的是一张IC卡绑定两个账户：固定账户和自由账号，本书为了简化描述，还是使用固定金额和自由金额的概念。既然有消费，系统肯定有扣款处理，系统内有两套扣款规则。</p>
<ul>
<li>扣款策略一</li>
</ul>
<p>该类型的扣款会对IC卡上的两个金额产生影响，计算公式如下： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IC卡固定余额=IC卡现有固定余额-交易金额/2 </span><br><span class="line">IC卡自由余额=IC卡现有自由金额-交易金额/2</span><br></pre></td></tr></table></figure>
<p>也就是说，该类型的消费分别在固定金额和自由金额上各扣除一半。它适用于固定消费场景例如吃饭、理发等情况下的扣款，这么做是为了防止乱请客，你请别人吃饭时自己也要出一半。</p>
<ul>
<li>扣款策略二</li>
</ul>
<p>全部从自由金额上扣除，由于集团内的各种消费、服务非常齐全，而且比市面价格稍低，员工还是很乐意到这里消费的，而且很多员工本身就住在集团附近，基本上就是“公司即家，家即公司”。</p>
<p>今天要讲的重点就是这两种消费的扣款策略该怎样设计？要知道这种联机交易，日后允许大规模变更的可能性基本上是零，所以系统设计的时候要做到可拆卸（Pluggable），避免日后维护的大量开支。</p>
<p>很明显，这是一个策略模式的实际应用，但是你还记得策略模式是有缺陷的吗？它的具体策略必须暴露出去，而且还要由上层模块初始化，这不合适，与迪米特法则有冲突，高层次模块对低层次的模块应该仅仅处在“接触”的层次上，而不应该是“耦合”的关系，否则，维护的工作量就会非常大。问题提出了，那我们就应该想办法来修改这个缺陷，正好工厂方法模式可以帮我们产生指定的对象，但是问题又来了，工厂方法模式要指定一个类，它才能产生对象，怎么办？引入一个配置文件进行映射，避免系统僵化情况的发生，我们以枚举类完成该任务。</p>
<p>还有一个问题，一个交易的扣款模式是固定的，根据其交易编号而定，那我们怎样把交易编号与扣款策略对应起来呢？采用状态模式或责任链模式都可以，如果采用状态则认为交易编号就是一个交易对象的状态，对于一笔确定的交易（一个已经生成了的对象），它的状态不会从一个状态过渡到另一个状态，也就是说它的状态只有一个，执行完毕后即结束，不存在多状态的问题；如果采用责任链模式，则可以用交易编码作为链中的判断依据，由每个执行节点进行判断，返回相应的扣款模式。但是在实际中，采用了关系型数据库存储扣款规则与交易编码的对应关系，为了简化该部分的讲义，我们在下面的设计中使用了条件判断语句来代替。</p>
<p>还有，这么复杂的扣款模块总要进行一个封装吧，不能让上层的业务模块直接深入到模块的内部，于是门面模式又摆在了眼前。</p>
<p>分析完毕，我们要先画出类图，做设计要遵循这样一个原则：先选最简单的业务，然后画出类图。那我们先定义交易中用到的两个类：IC卡类和交易类，如图35-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001195939.png" alt="image-20211001195939429"></p>
<p>图35-1 IC卡类和交易类</p>
<p>每个IC卡有三个属性，分别是IC卡号码、固定金额、自由金额，然后通过getter/setter方法来访问，如代码清单35-1所示。</p>
<p>代码清单35-1 IC卡类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Card</span> </span>&#123;</span><br><span class="line">    <span class="comment">//IC卡号码</span></span><br><span class="line">    <span class="keyword">private</span> String cardNo=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//卡内的固定交易金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> steadyMoney =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//卡内自由交易金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> freeMoney =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//getter/setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCardNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cardNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCardNo</span><span class="params">(String cardNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardNo = cardNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSteadyMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> steadyMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSteadyMoney</span><span class="params">(<span class="keyword">int</span> steadyMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.steadyMoney = steadyMoney;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFreeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> freeMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFreeMoney</span><span class="params">(<span class="keyword">int</span> freeMoney)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.freeMoney = freeMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的读者可能注意到，金额怎么都是整数类型呀，应该是double类型或者BigDecimal 类型呀。是，一般非银行的交易系统，比如超市的收银系统，系统内都是存放的int类型，在显示的时候才转换为货币类型。</p>
<p>交易信息Trade类，负责记录每一笔交易，它是由监听程序监听MQ队列而产生的，有两个属性：交易编号和交易金额，其中的交易编号对整个交易非常重要，18位字符（在银行的交易系统中，这里可不是字符串，一般是十进制数字或二进制数字，要考虑系统的性能，数字运算可比字符运算快得多），包括POS机编号、商户编号、校验码等，我们这里暂时用不到，就不多做介绍，我们只要知道它是一个非常有用的编码就成。交易金额为整数类型，实际金额放大100倍即可。如代码清单35-2所示。</p>
<p>代码清单35-2 交易类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trade</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交易编号</span></span><br><span class="line">    <span class="keyword">private</span> String tradeNo = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//交易金额</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//getter/setter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTradeNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tradeNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTradeNo</span><span class="params">(String postNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tradeNo = postNo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAmount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAmount</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个最简单也是在应用中最常使用的对象定义完毕，下面就需要来定义策略了，非常明显的策略模式，类图如图35-2所示。</p>
<p>典型的策略模式，扣款有两种策略：固定扣款和自由扣款。下面我们来看代码，先看抽象策略，也就是扣款接口，如代码清单35-3所示。</p>
<p>代码清单35-3 扣款策略接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDeduction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//扣款，提供交易和卡信息，进行扣款，并返回扣款是否成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">(Card card,Trade trade)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>固定扣款的规则是固定金额和自由金额各扣除交易金额的一半，如代码清单35-4所示。</p>
<p>代码清单35-4 扣款策略一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteadyDeduction</span> <span class="keyword">implements</span> <span class="title">IDeduction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//固定性交易扣款</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">(Card card, Trade trade)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//固定金额和自由金额各扣除50%</span></span><br><span class="line">        <span class="keyword">int</span> halfMoney = (<span class="keyword">int</span>)Math.rint(trade.getAmount() / <span class="number">2.0</span>);</span><br><span class="line">        card.setFreeMoney(card.getFreeMoney() - halfMoney);</span><br><span class="line">        card.setSteadyMoney(card.getSteadyMoney() - halfMoney);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001200222.png" alt="image-20211001200222415"></p>
<center>图35-2 扣款策略类图</center>
这个具体策略也非常简单，就是两个金额各自减去交易额的一半（注意除数是2.0，可不是2），然后再四舍五入，算法确实简单。该逻辑没有考虑账户余额不足的情况，也没有考虑异常情况，比如并发情况，读者可以想想看，一张卡有两笔消费同时发生时，是不是就发生错误了？一张卡同时有两笔消费会出现这种情况吗？会的，网络阻塞的情况，MQ多通道发送，在网络繁忙的情况下是有可能出现该问题，这里就不多介绍，有兴趣的读者可以看看MQ的资料。我们在这里的讲解实现的是一个快乐路径，认为所有的交易都是在安全可靠的环境中发生的，并且所有的系统环境都满足我们的要求。我们再来看另一个策略，这个策略更简单，如代码清单35-5所示。

<p>代码清单35-5 扣款策略二</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreeDeduction</span> <span class="keyword">implements</span> <span class="title">IDeduction</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自由扣款</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">(Card card, Trade trade)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接从自由余额中扣除</span></span><br><span class="line">        card.setFreeMoney(card.getFreeMoney() - trade.getAmount());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卡内的自由金额减去交易金额再修改卡内自由金额就完事了，异常情况不考虑。这两个具体的策略与我们的交易类型没有任何关系，也不应该有关系，策略模式就是提供两个可以相互替换的策略，至于在什么时候使用什么策略，则不是由策略模式来决定的。策略模式还有一个角色没出场，即封装角色，如代码清单35-6所示。</p>
<p>代码清单35-6 扣款策略的封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeductionContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">//扣款策略</span></span><br><span class="line">    <span class="keyword">private</span> IDeduction deduction = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造函数传递策略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeductionContext</span><span class="params">(IDeduction _deduction)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deduction = _deduction;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行扣款</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">(Card card,Trade trade)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.deduction.exec(card, trade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>典型的策略上下文角色。扣款模块的策略已经定义完毕了，然后需要想办法解决策略模式的缺陷：它把所有的策略类都暴露出去，暴露得越多以后的修改风险也就越大。怎么修改呢？增加一个映射配置文件，实现策略类的隐藏。我们使用枚举担当此任，对策略类进行映射处理，避免高层模块直接访问策略类，同时由工厂方法模式根据映射产生策略对象，类图如图35-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001200346.png" alt="image-20211001200346462"></p>
<center>图35-3 策略工厂类图</center>

<p>又是一个简单得不能再简单的模式——工厂方法模式，通过StrategyMan负责对具体策略的映射，如代码清单35-7所示。</p>
<p>代码清单35-7 策略枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">StrategyMan</span> </span>&#123;</span><br><span class="line">    SteadyDeduction(<span class="string">&quot;com.cbf4life.common.SteadyDeduction&quot;</span>), FreeDeduction(<span class="string">&quot;com.cbf4life.common.FreeDeduction&quot;</span>);</span><br><span class="line">    String value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StrategyMan</span><span class="params">(String _value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的代码解释过很多遍了，不再多说，它就是一个登记容器，所有的具体策略都在这里登记，然后提供给工厂方法模式。策略工厂如代码清单35-8所示。</p>
<p>代码清单35-8 策略工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//策略工厂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IDeduction <span class="title">getDeduction</span><span class="params">(StrategyMan strategy)</span></span>&#123;</span><br><span class="line">        IDeduction deduction = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deduction = (IDeduction)Class.forName(strategy.getValue()).newInstance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deduction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的工厂，根据策略管理类的枚举项创建一个策略对象，简单而实用，策略模式的缺陷也弥补成功。那这么复杂的系统怎么让高层模块访问？（你看不出复杂？那是因为我们写的都是快乐路径，太多情况都没有考虑，在实际项目中仅就并发处理和事务管理这两部分就够你头疼了。）既然系统很复杂，是不是需要封装一下。我们请出门面模式进行封装， 如代码清单35-9所示。</p>
<p>代码清单35-9 扣款模块封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeductionFacade</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对外公布的扣款信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Card <span class="title">deduct</span><span class="params">(Card card,Trade trade)</span></span>&#123;</span><br><span class="line">        <span class="comment">//获得消费策略</span></span><br><span class="line">        StrategyMan reg = getDeductionType(trade);</span><br><span class="line">        <span class="comment">//初始化一个消费策略对象</span></span><br><span class="line">        IDeduction deduction = StrategyFactory.getDeduction(reg);</span><br><span class="line">        <span class="comment">//产生一个策略上下文</span></span><br><span class="line">        DeductionContext context = <span class="keyword">new</span> DeductionContext(deduction);</span><br><span class="line">        <span class="comment">//进行扣款处理</span></span><br><span class="line">        context.exec(card, trade);</span><br><span class="line">        <span class="comment">//返回扣款处理完毕后的数据</span></span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得对应的商户消费策略</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StrategyMan <span class="title">getDeductionType</span><span class="params">(Trade trade)</span></span>&#123;</span><br><span class="line">        <span class="comment">//模拟操作</span></span><br><span class="line">        <span class="keyword">if</span>(trade.getTradeNo().contains(<span class="string">&quot;abc&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> StrategyMan.FreeDeduction;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> StrategyMan.SteadyDeduction;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次为什么要先展示代码而后写类图呢？那是因为这段代码比写类图更能让你理解。读者注意一下getDeductionType方法，这个方法在实际项目中是存在的，但是与上面的写法有天壤之别，因为在实际项目中，数据库中保存了策略代码与交易编码的对应关系，直接通过数据库的SQL语句就可以返回对应的扣款策略。这里我们采用大家最熟悉的条件转移来实现，也是比较清晰和容易理解的。</p>
<p>可能读者要问了，在门面模式中已经明确地说明，门面类中不允许有业务逻辑存在，但是你这里还是有了一个getDeductionType方法，它可代表的是一个判断逻辑呀，这是为什么呢？是的，该方法完全可以移到其他Hepler类中，由于我们是示例代码，暂没有明确的业务含义，故编写在此处，读者在实际应用中，请把该方法放置到其他类中。</p>
<p>好，所有用到的模式都介绍完毕了，我们把完整的类图整理一下，如图35-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001201110.png" alt="image-20211001201105393"></p>
<center>图35-4 扣款子模块完整类图</center>

<p>真实系统比这复杂得多，有了我们之前的分析，这个图还是比较容易看懂的。我们所有的开发都完成了，是不是应该写一个测试类来展示一下我们的成果，如代码清单35-10所示。</p>
<p>代码清单35-10 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟交易</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一张IC卡</span></span><br><span class="line">        Card card = initIC();</span><br><span class="line">        <span class="comment">//显示一下卡内信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;========初始卡信息：=========&quot;</span>);</span><br><span class="line">        showCard(card);</span><br><span class="line">        <span class="comment">//是否停止运行标志</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            Trade trade = createTrade();</span><br><span class="line">            DeductionFacade.deduct(card, trade);</span><br><span class="line">            <span class="comment">//交易成功，打印出成功处理消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n======交易凭证========&quot;</span>);</span><br><span class="line">            System.out.println(trade.getTradeNo()+<span class="string">&quot; 交易成功！&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本次发生的交易金额为：&quot;</span>+ trade.getAmount()/<span class="number">100.0</span>+<span class="string">&quot;元&quot;</span>);</span><br><span class="line">            <span class="comment">//展示一下卡内信息</span></span><br><span class="line">            showCard(card);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n是否需要退出？(Y/N)&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(getInput().equalsIgnoreCase(<span class="string">&quot;y&quot;</span>))&#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化一个IC卡</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Card <span class="title">initIC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Card card = <span class="keyword">new</span> Card();</span><br><span class="line">        card.setCardNo(<span class="string">&quot;1100010001000&quot;</span>);</span><br><span class="line">        card.setFreeMoney(<span class="number">100000</span>);</span><br><span class="line">        <span class="comment">//1000元</span></span><br><span class="line">        card.setSteadyMoney(<span class="number">80000</span>);</span><br><span class="line">        <span class="comment">//800元</span></span><br><span class="line">        <span class="keyword">return</span> card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产生一条交易</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Trade <span class="title">createTrade</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Trade trade = <span class="keyword">new</span> Trade();</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入交易编号：&quot;</span>);</span><br><span class="line">        trade.setTradeNo(getInput());</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入交易金额：&quot;</span>);</span><br><span class="line">        trade.setAmount(Integer.parseInt(getInput()));</span><br><span class="line">        <span class="comment">//返回交易</span></span><br><span class="line">        <span class="keyword">return</span> trade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印出当前卡内交易余额</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCard</span><span class="params">(Card card)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IC卡编号:&quot;</span> + card.getCardNo());</span><br><span class="line">        System.out.println(<span class="string">&quot;固定类型余额：&quot;</span>+ card.getSteadyMoney()/<span class="number">100.0</span> + <span class="string">&quot; 元&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;自由类型余额：&quot;</span>+ card.getFreeMoney()/<span class="number">100.0</span> + <span class="string">&quot; 元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得键盘输入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInput</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            str=(<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in))).readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//异常处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类比较长，耐心看还是非常简单的，对其中Client类的方法说明如下：</p>
<ul>
<li>initIC方法</li>
</ul>
<p>初始化一张IC卡，方便进行测试。</p>
<ul>
<li>createTrade方法</li>
</ul>
<p>创建一笔交易，完成测试任务。</p>
<ul>
<li>showCard方法</li>
</ul>
<p>显示IC卡内的信息。</p>
<ul>
<li>getInput方法</li>
</ul>
<p>获得从键盘输入的字符，以回车符作为终结标志。</p>
<p>方法介绍完毕了，我们运行一下看看，结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">========初始卡信息：========= </span><br><span class="line">IC卡编号:1100010001000 </span><br><span class="line">固定类型余额：800.0 元 </span><br><span class="line">自由类型余额：1000.0 元 </span><br><span class="line">请输入交易编号：abcdef </span><br><span class="line">请输入交易金额：10000 </span><br><span class="line">======交易凭证======== </span><br><span class="line">abcdef 交易成功！ </span><br><span class="line">本次发生的交易金额为：100.0 元 </span><br><span class="line">IC卡编号:1100010001000 </span><br><span class="line">固定类型余额：800.0 元</span><br><span class="line">自由类型余额：900.0 元 </span><br><span class="line">是否需要退出？(Y/N)</span><br></pre></td></tr></table></figure>
<p>我们模拟了一笔自由消费，直接从自由类型金额中扣除了。我们再模拟一笔固定类型的消费，运行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">========初始卡信息：========= </span><br><span class="line">IC卡编号:1100010001000 </span><br><span class="line">固定类型余额：800.0 元 </span><br><span class="line">自由类型余额：1000.0 元 </span><br><span class="line">请输入交易编号：abcdef </span><br><span class="line">请输入交易金额：10000 </span><br><span class="line">======交易凭证======== </span><br><span class="line">abcdef 交易成功！ </span><br><span class="line">本次发生的交易金额为：100.0 元 </span><br><span class="line">IC卡编号:1100010001000 </span><br><span class="line">固定类型余额：800.0 元 </span><br><span class="line">自由类型余额：900.0 元 </span><br><span class="line">是否需要退出？(Y/N)n </span><br><span class="line">请输入交易编号：1001 </span><br><span class="line">请输入交易金额：1234 </span><br><span class="line">======交易凭证======== </span><br><span class="line">1001 交易成功！ </span><br><span class="line">本次发生的交易金额为：12.34 元 </span><br><span class="line">IC卡编号:1100010001000 </span><br><span class="line">固定类型余额：793.83 元 </span><br><span class="line">自由类型余额：893.83 元 </span><br><span class="line">是否需要退出？(Y/N)</span><br></pre></td></tr></table></figure>
<p>交易成功！到这里为止，联机交易中的扣款子模块开发完毕了！是不是很简单，银行业的交易系统也就是这么回事！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d7d38d5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d7d38d5/" class="post-title-link" itemprop="url">36.1 事件触发器的开发</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 19:57:33" itemprop="dateCreated datePublished" datetime="2021-09-27T19:57:33+08:00">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 21:29:42" itemprop="dateModified" datetime="2021-10-01T21:29:42+08:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">8 设计模式之禅(第2版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/4-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C-%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B7%E7%BC%96/" itemprop="url" rel="index"><span itemprop="name">4 第四部分 完美世界 ——设计模式混编</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/4-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C-%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%B7%B7%E7%BC%96/%E7%AC%AC36%E7%AB%A0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第36章 观察者模式+中介者模式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d7d38d5/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d7d38d5/" data-xid="/JavaReadingNotes/d7d38d5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="36-1-事件触发器的开发"><a href="#36-1-事件触发器的开发" class="headerlink" title="36.1 事件触发器的开发"></a>36.1 事件触发器的开发</h1><p>大家都应该做过桌面程序的开发吧，比如编写一个EXE文件，或者使用Java Swing编写一个应用程序，或者是用Delphi、C编写C/S结构的应用系统，即使这些都没有做过，那也总编写过B/S结构的页面吧？回忆一下开发过程，大家是不是经常使用文本框和按钮这两个控件？比如设计一个按钮，那总要编写鼠标点击处理，你是不是这样开发：在按钮的onClick函数中编写自己的逻辑代码，然后鼠标点击测试，该代码就会运行。大家有没有想过为什么我们点击了按钮就会触发我们自己编写的代码呢？浏览器怎么知道操作者按了按钮要触发该事件呢？鼠标点击动作、按钮、自己编写的代码之间是如何关联起来呢？</p>
<p>我们今天的任务就是来模拟类似触发过程。我们这样分析：有一个产品（不管是Frame 还是Button或者是Radio），它有多个触发事件，它产生的时候触发一个创建事件，修改的时候触发修改事件，删除的时候触发删除事件，这就类似于我们的文本框，初始化（也就是创建）的时候要触发一个onLoad或onCreate事件，修改的时候触发onChange事件，双击(类似于删除)的时候又触发onDbClick事件，我们今天的目标就是来思考怎么实现这样一个架构。</p>
<p>设计都是先易后难，我们先从最简单的部分入手。首先需要一个产品，并且该产品要有创建、修改、销毁的动作，很明显这就是一个工厂方法模式。同时产品也可以通过克隆方式产生，这与我们在GUI设计中经常使用的复制粘贴操作相类似，要不界面上那么多的文本框，不使用复制粘贴，不累死人才怪呢，那这非常明显就是原型模式。好，分析到这里，我们先把这部分的类图建立起来，如图36-1所示。</p>
<p>很熟悉的类图，与工厂方法模式的通用类图非常相似，但不完全是。有什么差别呢？注意看产品类的私有属性canChanged和构造函数，它们有特殊的用途。在该类图中，我们使用了工厂方法模式创建产品，使用原型模式让对象可以被拷贝，仅仅这两个模式还不足以解决我们的问题，想想看，产品的产生是有一定的条件的，不是谁想产生就产生，否则怎么能够触发创建事件呢？因此需要限定产品的创建者，所以我们在类图中把产品和工厂的关系定位为组合关系，而不是简单的聚集或依赖关系。换句话说，产品只能由工厂类创建，而不能被其他对象通过new方式创建，因此我们在这里还用到一个单来源调用（Single Call）方法解决该问题。这是一个方法，不是一个设计模式，我马上给大家讲解它是如何工作的。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001202205.png" alt="image-20211001202204935"></p>
<center>图36-1 产品创建工厂</center>
我们先来看产品类的源代码，它比较简单，如代码清单36-1所示。

<p>代码清单36-1 产品类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="comment">//产品名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//是否可以属性变更</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//产生一个新的产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">(ProductManager manager,String _name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//允许建立产品</span></span><br><span class="line">        <span class="keyword">if</span>(manager.isCreateProduct())&#123;</span><br><span class="line">            canChanged =<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.name = _name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(canChanged)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//覆写clone方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Product p =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p =(Product)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在产品类中，我们只定义产品的一个属性：产品名称（name），并实现了getter/setter方法，然后我们实现了它的clone方法，确保对象是可以被拷贝的。还有一个特殊的地方是我们的构造函数，它怎么会要求传递进来一个工厂对象ProductManager呢？保留你的好奇心，马上为你揭晓答案。我们继续看代码，工厂类如代码清单36-2所示。</p>
<p>代码清单36-2 工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否可以创建一个产品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPermittedCreate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//建立一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先修改权限，允许创建</span></span><br><span class="line">        isPermittedCreate = <span class="keyword">true</span>;</span><br><span class="line">        Product p = <span class="keyword">new</span> Product(<span class="keyword">this</span>,name);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//废弃一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abandonProduct</span><span class="params">(Product p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//销毁一个产品，例如删除数据库记录</span></span><br><span class="line">        p = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editProduct</span><span class="params">(Product p,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改后的产品</span></span><br><span class="line">        p.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得是否可以创建一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPermittedCreate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">clone</span><span class="params">(Product p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//产生克隆事件</span></span><br><span class="line">        <span class="keyword">return</span> p.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看看工厂类，产品的创建、修改、遗弃、克隆方法都很简单，但有一个方法可不简单——isCreateProduct方法，它的作用是告诉产品类“我是能创建产品的”，注意看我们的程序，在工厂类ProductManager中定义了一个私有变量isCreateProduct，该变量只有在工厂类的createProduct函数中才能设置为true，在创建产品的时候，产品类Product的构造函数要求传递工厂对象，然后判断是否能够创建产品，即使你想使用类似这样的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Product p = new Product(new ProductManager(),&quot;abc&quot;);</span><br></pre></td></tr></table></figure>
<p>也是不可能创建出产品的，它在产品类中限制必须是当前有效工厂才能生产该产品，而且也只有有效的工厂才能修改产品，看看产品类的canChanged属性，只有它为true时，产品才可以修改，那怎么才能为true呢？在构造函数中判断是否可以为true。这就类似工厂要创建产品了，产品就问“你有权利创建我吗？”于是工厂类出示了两个证明材料证明自己可以创建产品：一是“我是你的工厂类”，二是“我的isCreateProduct返回true，我有权创建”，于是产品就被创建出来了。这种一个对象只能由固定的对象初始化的方法就叫做单来源调用（Single Call）——很简单，但非常有用的方法。</p>
<hr>
<p><strong>注意</strong> 采用单来源调用的两个对象一般是组合关系，两者有相同的生命期，它通常适用于有单例模式和工厂方法模式的场景中。</p>
<hr>
<p>我们继续往下分析，一个产品新建要触发事件，那事件是什么？当然也是一个对象了， 需要把它设计出来，仅仅有事件还不行，还要考虑有人去处理这个事件，产生了一个事件不可能没有对象去处理吧？如果是这样那事件还有什么意义呢？既然要去处理，那就需要一个通知渠道了，于是观察者模式准备好了。好，我们把这段分析的类图也画出来，如图36-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001211253.png" alt="image-20211001211253487"></p>
<center>图36-2 观察者模式处理事件</center>

<p>在该类图中，观察者为EventDispatch类，它使用了单例模式，避免对象膨胀，但同时也带来了性能及线程安全隐患，这点需要大家在实际应用中注意（想想Spring中的Bean注入， 默认也是单例，在通常的应用中一般不需要修改，除非是较大并发的应用）。我们来看代码，先来看事件类型定义，它是一个枚举类型，如代码清单36-3所示。</p>
<p>代码清单36-3 事件类型定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ProductEventType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个产品</span></span><br><span class="line">    NEW_PRODUCT(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">//删除一个产品</span></span><br><span class="line">    DEL_PRODUCT(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">//修改一个产品</span></span><br><span class="line">    EDIT_PRODUCT(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">//克隆一个产品</span></span><br><span class="line">    CLONE_PRODUCT(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProductEventType</span><span class="params">(<span class="keyword">int</span> _value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了4个事件类型，分别是新建、修改、删除以及克隆，比较简单。我们再来看产品的事件，如代码清单36-4所示。</p>
<p>代码清单36-4 产品事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductEvent</span> <span class="keyword">extends</span> <span class="title">Observable</span></span>&#123;</span><br><span class="line">    <span class="comment">//事件起源</span></span><br><span class="line">    <span class="keyword">private</span> Product source;</span><br><span class="line">    <span class="comment">//事件的类型</span></span><br><span class="line">    <span class="keyword">private</span> ProductEventType type;</span><br><span class="line">    <span class="comment">//传入事件的源头，默认为新建类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductEvent</span><span class="params">(Product p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(p,ProductEventType.NEW_PRODUCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件源头以及事件类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProductEvent</span><span class="params">(Product p,ProductEventType _type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = p;</span><br><span class="line">        <span class="keyword">this</span>.type = _type;</span><br><span class="line">        <span class="comment">//事件触发</span></span><br><span class="line">        notifyEventDispatch();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得事件的始作俑者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得事件的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProductEventType <span class="title">getEventType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通知事件处理中心</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEventDispatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addObserver(EventDispatch.getEventDispatch());</span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">        <span class="keyword">super</span>.notifyObservers(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在产品事件类中增加了一个私有方法notfiyEventDispatch，该方法的作用是明确事件的观察者，并同时在初始化时通知观察者，它在有参构造中被调用。我们再来看事件的观察者，如代码清单36-5所示。</p>
<p>代码清单36-5 事件的观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventDispatch</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> EventDispatch dispatch = <span class="keyword">new</span> EventDispatch();</span><br><span class="line">    <span class="comment">//不允许生成新的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventDispatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventDispatch <span class="title">getEventDispatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产品和事件都定义出来了，那我们想想怎么把这两者关联起来，产品和事件是两个独立的对象，两者都可以独立地扩展，用什么来适应它们的扩展呢？桥梁模式！两个不相关的类可以通过桥梁模式组合出稳定、健壮的结构，我们画出类图，如图36-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001211950.png" alt="image-20211001211950545"></p>
<center>图36-3 桥梁模式实现产品和事件的组合</center>
看着不像桥梁模式？看看桥梁模式的通用类图，然后把抽象化角色和实现化角色去掉看看，是不是就是一样了？各位可能要说了，把抽象化角色和实现化角色去掉，那桥梁模式在抽象层次耦合的优点还怎么体现呢？因为我们采用的是单个产品对象，没有必要进行抽象化处理，读者若要按照该框架做扩展开发，该部分是肯定需要抽象出接口或抽象类的，好在也非常简单，只要抽取一下就可以了。这样考虑后，我们的ProductManager类就增加一个功能：组合产品类和事件类，产生有意义的产品事件，如代码清单36-6所示。

<p>代码清单36-6 修正后的产品工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否可以创建一个产品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPermittedCreate = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//建立一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//首先修改权限，允许创建</span></span><br><span class="line">        isPermittedCreate = <span class="keyword">true</span>;</span><br><span class="line">        Product p = <span class="keyword">new</span> Product(<span class="keyword">this</span>,name);</span><br><span class="line">        <span class="comment">//产生一个创建事件</span></span><br><span class="line">        <span class="keyword">new</span> ProductEvent(p,ProductEventType.NEW_PRODUCT);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//废弃一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abandonProduct</span><span class="params">(Product p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//销毁一个产品，例如删除数据库记录</span></span><br><span class="line">        <span class="comment">//产生删除事件</span></span><br><span class="line">        <span class="keyword">new</span> ProductEvent(p,ProductEventType.DEL_PRODUCT);</span><br><span class="line">        p = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editProduct</span><span class="params">(Product p,String name)</span></span>&#123;</span><br><span class="line">        <span class="comment">//修改后的产品</span></span><br><span class="line">        p.setName(name);</span><br><span class="line">        <span class="comment">//产生修改事件</span></span><br><span class="line">        <span class="keyword">new</span> ProductEvent(p,ProductEventType.EDIT_PRODUCT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得是否可以创建一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCreateProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPermittedCreate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//克隆一个产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">clone</span><span class="params">(Product p)</span></span>&#123;</span><br><span class="line">        <span class="comment">//产生克隆事件</span></span><br><span class="line">        <span class="keyword">new</span> ProductEvent(p,ProductEventType.CLONE_PRODUCT);</span><br><span class="line">        <span class="keyword">return</span> p.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每个方法中增加了事件的产生机制，在createProduct方法中增加了创建产品事件，在editProduct方法中增加了修改产品事件，在delProduct方法中增加了遗弃产品事件，在clone方法中增加克隆产品事件，而且每个事件都是通过组合产生的，产品和事件的扩展性非常优秀。</p>
<p>刚刚我们说完了产品和事件的关系处理，现在回到我们事件的观察者，它承担着非常重要的职责。我们知道它要处理事件，但是现在还没有想好怎么实现它处理事件的update方法，暂时保持为空。</p>
<p>我们继续分析，这么多的事件（现在只有1个产品类，如果产品类很多呢？比如30多个）不可能每个产品事件都写一个处理者吧，对于产品事件来说，它最希望的结果就是我通知了事件处理者（也就是观察者模式的观察者），其他具体怎么处理由观察者来解决，那现在问题是观察者怎么来处理这么多的事件呢？事件的处理者必然有N多个，如何才能通知相应的处理者来处理事件呢？一个事件也可能通知多个处理者来处理，并且一个处理者处理完毕还可能通知其他的处理者，这不可能让每个处理者独自完成这样“不可能完成的任务”，我们把问题的示意图画出来，如图36-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001212114.png" alt="image-20211001212113884"></p>
<center>图36-4 事件处理示意图</center>

<p>看到该示意图，你立刻就会想到中介者模式。是的，需要中介者模式上场了，我们把EventDispatch类（嘿嘿，为什么要定义成Dispatch呢？就是分发的意思）作为事件分发的中介者，事件的处理者都是具体的同事类，它们有着相似的行为，都是处理产品事件，但是又有不相同的逻辑，每个同事类对事件都有不同的处理行为。我们来看类图，如图36-5所示。</p>
<p>在类图中，EventDispatch类有3个职责。</p>
<ul>
<li>事件的观察者</li>
</ul>
<p>作为观察者模式中的观察者角色，接收被观察期望完成的任务，在我们的框架中就是接收ProductEvent事件。</p>
<ul>
<li>事件分发者</li>
</ul>
<p>作为中介者模式的中介者角色，它担当着非常重要的任务——分发事件，并同时协调各个同事类（也就是事件的处理者）处理事件。</p>
<ul>
<li>事件处理者的管理员角色</li>
</ul>
<p>不是每一个事件的处理者都可以接收事件并进行处理，是需要获得分发者许可后才可以，也就是说只有事件分发者允许它处理，它才能处理。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001212239.png" alt="image-20211001212239626"></p>
<center>图36-5 采用中介者模式对事件进行分发</center>
事件分发者担当了这么多的职责，那是不是与单一职责原则相违背了？确实如此，我们在整个系统的设计中确实需要这样一个角色担任这么多的功能，如果强制细分也可以完成， 但是会加大代码量，同时导致系统的结构复杂，读者可以考虑拆分这3个职责，然后再组合相关的功能，看看代码量是如何翻倍的。

<hr>
<p>注意 设计原则只是一个理论，而不是一个带有刻度的标尺，因此在系统设计中不应该把它视为不可逾越的屏障，而是应该把它看成是一个方向标，尽量遵守，而不是必须恪守。</p>
<hr>
<p>既然事件分发者这么重要，我们就仔细研读一下它的代码，如代码清单36-7所示。</p>
<p>代码清单36-7 事件分发者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventDispatch</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> EventDispatch dispatch = <span class="keyword">new</span> EventDispatch();</span><br><span class="line">    <span class="comment">//事件消费者</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;EventCustomer&gt; customer = <span class="keyword">new</span> Vector&lt;EventCustomer&gt;();</span><br><span class="line">    <span class="comment">//不允许生成新的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventDispatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得单例对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventDispatch <span class="title">getEventDispatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dispatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//事件触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//事件的源头</span></span><br><span class="line">        Product product = (Product)arg;</span><br><span class="line">        <span class="comment">//事件</span></span><br><span class="line">        ProductEvent event = (ProductEvent)o;</span><br><span class="line">        <span class="comment">//处理者处理，这里是中介者模式的核心，可以是很复杂的业务逻辑</span></span><br><span class="line">        <span class="keyword">for</span>(EventCustomer e:customer)&#123;</span><br><span class="line">            <span class="comment">//处理能力是否匹配</span></span><br><span class="line">            <span class="keyword">for</span>(EventCustomType t:e.getCustomType())&#123;</span><br><span class="line">                <span class="keyword">if</span>(t.getValue()== event.getEventType().getValue())&#123;</span><br><span class="line">                    e.exec(event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册事件处理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomer</span><span class="params">(EventCustomer _customer)</span></span>&#123;</span><br><span class="line">        customer.add(_customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里使用Vector来存储所有的事件处理者，在update方法中使用了两个简单的for 循环来完成业务逻辑的判断，只要事件的处理者级别和事件的类型相匹配，就调用事件处理者的exec方法来处理事件，该逻辑是整个事件触发架构的关键点，但不是难点。请读者注意，在设计这样的框架前，一定要定义好消费者与生产者之间的搭配问题，一般的做法是通过xml文件类或者IoC容器配置规则，然后在框架启动时加载并驻留内存。</p>
<p>EventCustomer抽象类负责定义事件处理者必须具有的行为，首先是每一个事件的处理者 都必须定义自己能够处理的级别，也就是通过构造函数来定义自己的处理能力，当然处理能 力可以是多值的，也就是说一个处理者可以处理多个事件；然后各个事件的处理者只要实现 exec方法就可以了，完成自己对事件的消费处理即可。我们先来看抽象的事件处理者，如代 码清单36-8所示。</p>
<p>代码清单36-8 抽象的事件处理者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EventCustomer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//容纳每个消费者能够处理的级别</span></span><br><span class="line">    <span class="keyword">private</span> Vector&lt;EventCustomType&gt; customType = <span class="keyword">new</span> Vector&lt;EventCustomType&gt;();</span><br><span class="line">    <span class="comment">//每个消费者都要声明自己处理哪一类别的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventCustomer</span><span class="params">(EventCustomType _type)</span></span>&#123;</span><br><span class="line">        addCustomType(_type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每个消费者可以消费多个事件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCustomType</span><span class="params">(EventCustomType _type)</span></span>&#123;</span><br><span class="line">        customType.add(_type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到自己的处理能力</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector&lt;EventCustomType&gt; <span class="title">getCustomType</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> customType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每个事件都要对事件进行声明式消费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(ProductEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很简单，我们定义了一个Vector变量来存储处理者的处理能力，然后通过构造函数约束子类必须定义一个自己的处理能力。在代码中，我们用到了事件处理类型枚举，如代码清单36-9所示。</p>
<p>代码清单36-9 事件处理枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EventCustomType</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建立事件</span></span><br><span class="line">    NEW(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">//删除事件</span></span><br><span class="line">    DEL(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">//修改事件</span></span><br><span class="line">    EDIT(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">//克隆事件</span></span><br><span class="line">    CLONE(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EventCustomType</span><span class="params">(<span class="keyword">int</span> _value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = _value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在系统中定义了3个事件处理者，分别是乞丐、平民和贵族。乞丐只能获得别人遗弃的物品，平民消费自己生产的东西，自给自足，而贵族则可以获得精修的产品或者是绿色产品（也就是我们这里的克隆产品，不用自己劳动获得的产品）。我们先看乞丐的源代码， 如代码清单36-10所示。</p>
<p>代码清单36-10 乞丐</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beggar</span> <span class="keyword">extends</span> <span class="title">EventCustomer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只能处理被人遗弃的东西</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Beggar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(EventCustomType.DEL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(ProductEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//事件的源头</span></span><br><span class="line">        Product p = event.getSource();</span><br><span class="line">        <span class="comment">//事件类型</span></span><br><span class="line">        ProductEventType type = event.getEventType();</span><br><span class="line">        System.out.println(<span class="string">&quot;乞丐处理事件:&quot;</span>+p.getName() +<span class="string">&quot;销毁,事件类型=&quot;</span>+type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>乞丐在无参构造中定义了自己只能处理删除的事件，然后在exec方法中定义了事件的处理逻辑，每个处理者都是只要完成这两个方法即可，我们再来看平民级别的事件处理者，如代码清单36-11所示。</p>
<p>代码清单36-11 平民</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Commoner</span> <span class="keyword">extends</span> <span class="title">EventCustomer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义平民能够处理的事件的级别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Commoner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(EventCustomType.NEW);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(ProductEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//事件的源头</span></span><br><span class="line">        Product p = event.getSource();</span><br><span class="line">        <span class="comment">//事件类型</span></span><br><span class="line">        ProductEventType type = event.getEventType();</span><br><span class="line">        System.out.println(<span class="string">&quot;平民处理事件:&quot;</span>+p.getName() +<span class="string">&quot;诞生记,事件类型=&quot;</span>+type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平民只处理新建立的事件，其他事件不做处理，我们再来看贵族级别的事件处理者，如代码清单36-12所示。</p>
<p>代码清单36-12 贵族</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Nobleman</span> <span class="keyword">extends</span> <span class="title">EventCustomer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义贵族能够处理的事件的级别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Nobleman</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(EventCustomType.EDIT);</span><br><span class="line">        <span class="keyword">super</span>.addCustomType(EventCustomType.CLONE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">(ProductEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//事件的源头</span></span><br><span class="line">        Product p = event.getSource();</span><br><span class="line">        <span class="comment">//事件类型</span></span><br><span class="line">        ProductEventType type = event.getEventType();</span><br><span class="line">        <span class="keyword">if</span>(type.getValue() == EventCustomType.CLONE.getValue())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;贵族处理事件:&quot;</span>+p.getName() +<span class="string">&quot;克隆,事件类型=&quot;</span>+type);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;贵族处理事件:&quot;</span>+p.getName() +<span class="string">&quot;修改,事件类型=&quot;</span>+type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>贵族稍有不同，它有两个处理能力，能够处理修改事件和克隆事件，同时在exec方法中对这两类事件分别进行处理。此时，读者可能会想到另外一个处理模式：责任链模式。建立一个链，然后两类事件分别在链上进行处理并反馈结果。读者可以参考一下Servlet的过滤器（Filter）的设计，在框架平台的开发中可以采用该模式，它具有非常好的扩展性和稳定性。</p>
<p>所有的角色都已出场，我们建立一个场景类把它们串联起来，如代码清单36-13所示。</p>
<p>代码清单36-13 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得事件分发中心</span></span><br><span class="line">        EventDispatch dispatch = EventDispatch.getEventDispatch();</span><br><span class="line">        <span class="comment">//接受乞丐对事件的处理</span></span><br><span class="line">        dispatch.registerCustomer(<span class="keyword">new</span> Beggar());</span><br><span class="line">        <span class="comment">//接受平民对事件的处理</span></span><br><span class="line">        dispatch.registerCustomer(<span class="keyword">new</span> Commoner());</span><br><span class="line">        <span class="comment">//接受贵族对事件的处理</span></span><br><span class="line">        dispatch.registerCustomer(<span class="keyword">new</span> Nobleman());</span><br><span class="line">        <span class="comment">//建立一个原子弹生产工厂</span></span><br><span class="line">        ProductManager factory = <span class="keyword">new</span> ProductManager();</span><br><span class="line">        <span class="comment">//制造一个产品</span></span><br><span class="line">        System.out.println(<span class="string">&quot;=====模拟创建产品事件========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;创建一个叫做小男孩的原子弹&quot;</span>);</span><br><span class="line">        Product p = factory.createProduct(<span class="string">&quot;小男孩原子弹&quot;</span>);</span><br><span class="line">        <span class="comment">//修改一个产品</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n=====模拟修改产品事件========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;把小男孩原子弹修改为胖子号原子弹&quot;</span>);</span><br><span class="line">        factory.editProduct(p, <span class="string">&quot;胖子号原子弹&quot;</span>);</span><br><span class="line">        <span class="comment">//再克隆一个原子弹</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n=====模拟克隆产品事件========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆胖子号原子弹&quot;</span>);</span><br><span class="line">        factory.clone(p);</span><br><span class="line">        <span class="comment">//遗弃一个产品</span></span><br><span class="line">        System.out.println(<span class="string">&quot;\n=====模拟销毁产品事件========&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;遗弃胖子号原子弹&quot;</span>);</span><br><span class="line">        factory.abandonProduct(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=====模拟创建产品事件======== </span><br><span class="line">创建一个叫做小男孩的原子弹 </span><br><span class="line">平民处理事件:小男孩原子弹诞生记,事件类型=NEW_PRODUCT </span><br><span class="line">=====模拟修改产品事件======== </span><br><span class="line">把小男孩原子弹修改为胖子号原子弹</span><br><span class="line">贵族处理事件:胖子号原子弹修改,事件类型=EDIT_PRODUCT </span><br><span class="line">=====模拟克隆产品事件======== 克隆胖子号原子弹 </span><br><span class="line">贵族处理事件:胖子号原子弹克隆,事件类型=CLONE_PRODUCT </span><br><span class="line">=====模拟销毁产品事件======== </span><br><span class="line">遗弃胖子号原子弹 </span><br><span class="line">乞丐处理事件:胖子号原子弹销毁,事件类型=DEL_PRODUCT</span><br></pre></td></tr></table></figure>
<p>我们的事件处理框架已经生效了，有行为，就产生事件，并有处理事件的处理者，并且这三者都相互解耦，可以独立地扩展下去。比如，想增加处理者，没有问题，建立一个类继承EventCustomer，然后注册到EventDispatch上，就可以进行处理事件了；想扩展产品，没问题？需要稍稍修改一下，首先抽取出产品和事件的抽象类，然后再进行扩展即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/53db65b7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/53db65b7/" class="post-title-link" itemprop="url">38.1 规格模式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 19:57:33" itemprop="dateCreated datePublished" datetime="2021-09-27T19:57:33+08:00">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-02 00:22:46" itemprop="dateModified" datetime="2021-10-02T00:22:46+08:00">2021-10-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">8 设计模式之禅(第2版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/5-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%89%A9%E5%B1%95%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">5 第五部分 扩展篇</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/5-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%89%A9%E5%B1%95%E7%AF%87/%E7%AC%AC38%E7%AB%A0-%E6%96%B0%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">第38章 新模式</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/53db65b7/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/53db65b7/" data-xid="/JavaReadingNotes/53db65b7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="38-1-规格模式"><a href="#38-1-规格模式" class="headerlink" title="38.1 规格模式"></a>38.1 规格模式</h1><h2 id="38-1-1-规格模式的实现"><a href="#38-1-1-规格模式的实现" class="headerlink" title="38.1.1 规格模式的实现"></a>38.1.1 规格模式的实现</h2><p>不知道诸位有没有使用C#3.5做过开发，它有一个非常重要的新特性—— LINQ（Language INtegrated Query，语言集成查询），它提供了类似于SQL语法的遍历、筛选等功能，能完成对对象的查询，就像通过SQL语句查询数据库一样，例如这样的一个程序片段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dim DataList As String() = &#123;&quot;abc&quot;, &quot;def&quot;, &quot;ght&quot;&#125; </span><br><span class="line">Dim Result = From T As String In DataList Where T = &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p>这句话的意思就是从一个数组中查找出值为abc的元素，返回结果为IEnumerable，枚举器类型。注意看第二句话，它使用了类似SQL的Select语法结构，from、where关键字都有了，而且还支持类似的Orderby、Groupby功能，很强大，有兴趣的读者可以查阅有关资料。 那在Java世界中是否也存在这样的辅助框架呢？有，JoSQL、Quaere都可以提供类似的LINQ 语言，读者可以到网上研究一下JavaDoc，同样非常简单，功能强大。</p>
<p>我们今天要讲的主题与LINQ有很大关系，它是实现LINQ的核心。想想SQL语句中什么是最复杂的，是where后面的查询条件，看看自己写的SQL语句基本上都是一长串的条件判断，中间一堆的and、or、not逻辑符。我们今天的任务就是要实现条件语句的解析，该部分实现了，基本上LINQ语法已经实现了一大半。</p>
<p>我们以一个案例来讲解该技术，在内存中有10个User对象，根据不同的条件查找出用户，比如姓名包含某个字符、年龄小于多少岁等条件，类似这样的SQL：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">From</span> <span class="keyword">User</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%国庆%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>查找出姓名中包含“国庆”两个字的用户，这在关系型数据库中很容易实现，但是在对象群中怎么实现这样的查询呢？好，看似很简单，先设计一个用户类，然后提供一个用户查找工具类，类图非常容易，如图38-1所示。</p>
<p>很简单的类图，有一个用户类，同时提供了一个操作用户的辅助类，我们先来看User 类，如代码清单38-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001221545.png" alt="image-20211001221545481"></p>
<center>图38-1 简单用户查询类图</center>

<p>代码清单38-1 用户类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String _name,<span class="keyword">int</span> _age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = _name;</span><br><span class="line">        <span class="keyword">this</span>.age = _age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户信息打印</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名：&quot;</span> + name+<span class="string">&quot;\t年龄：&quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>User就是一个简单BO业务对象，再来看用户操作接口，它定义一个用户操作类必须具 有的方法，如代码清单38-2所示。</p>
<p>代码清单38-2 用户操作对象接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据用户名查找用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUserByNameEqual</span><span class="params">(String name)</span></span>;</span><br><span class="line">    <span class="comment">//年龄大于指定年龄的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUserByAgeThan</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里只定义了两个查询实现，分别是名字相同的用户和年龄大于指定年龄的用户，大家都知道，相似的查询条件还有很多，比如名字中包含指定字符、年龄小于指定年龄等，我们仅以实现这两个查询作为代表，如代码清单38-3所示。</p>
<p>代码清单38-3 用户操作类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> <span class="keyword">implements</span> <span class="title">IUserProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用户列表</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;User&gt; userList;</span><br><span class="line">    <span class="comment">//构造函数传递用户列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProvider</span><span class="params">(ArrayList&lt;User&gt; _userList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userList = _userList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//年龄大于指定年龄的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUserByAgeThan</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; result = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User u:userList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(u.getAge()&gt;age)&#123;</span><br><span class="line">                <span class="comment">//符合条件的用户</span></span><br><span class="line">                result.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//姓名等于指定姓名的用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUserByNameEqual</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; result = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User u:userList)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(u.getName().equals(name))&#123;</span><br><span class="line">                <span class="comment">//符合条件</span></span><br><span class="line">                result.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过for循环遍历一个动态数组，判断用户是否符合条件，将符合条件的用户放置到另外一个数组中，比较简单。我们编写场景类来模拟该情景，如代码清单38-4所示。</p>
<p>代码清单38-4 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先初始化一批用户</span></span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;苏大&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;牛二&quot;</span>,<span class="number">8</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;赵六&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;马七&quot;</span>,<span class="number">25</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;杨八&quot;</span>,<span class="number">30</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;侯九&quot;</span>,<span class="number">35</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;布十&quot;</span>,<span class="number">40</span>));</span><br><span class="line">        <span class="comment">//定义一个用户查询类</span></span><br><span class="line">        IUserProvider userProvider = <span class="keyword">new</span> UserProvider(userList);</span><br><span class="line">        <span class="comment">//打印出年龄大于20岁的用户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===年龄大于20岁的用户===&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(User u:userProvider.findUserByAgeThan(<span class="number">20</span>))&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">===年龄大于20岁的用户=== </span><br><span class="line">用户名：马七 年龄：25 </span><br><span class="line">用户名：杨八 年龄：30 </span><br><span class="line">用户名：侯九 年龄：35 </span><br><span class="line">用户名：布十 年龄：40</span><br></pre></td></tr></table></figure>
<p>结果非常正确，但是这样的一个框架基本上是不能适应业务变化的，为什么呢？业务变化虽然无规则，但是可以预测，比如我们这个查询，今天要查找年龄大于20岁的用户，明天要查找年龄小于30岁的用户，后天要查找姓名中包含“国庆”两个字的用户，想想看IUserProvider接口是不是要一直修改下去？接口是契约，而且我们一直提倡面向接口编程， 但是在这里接口竟然都可以修改，是不是发现设计有很大问题了！</p>
<p>问题发现了，就要想办法解决。再回顾一下编写的代码，注意看findUserByAgeThan和findUserByNameEqual两个方法，两者的代码有什么不同呢？除了if后面的判断条件不同外， 就没有不同的地方了，我们一直在说封装变化，这两段程序就仅仅有这一个变化点，我们是不是可以把它封装起来呢？完全可以，把它们两者的共同点抽取出来，先修改一下接口，如代码清单38-5所示。</p>
<p>代码清单38-5 修正后的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据条件查找用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUser</span><span class="params">(<span class="keyword">boolean</span> condition)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口的设计想法非常好，但是参数condition很难实现，看看findUserByAgeThan、 findUserByNameEqual这两个方法，怎么才能把两者的不同点设置成一个布尔型呢？如果需要在IUserProvider对象外判断后传递进来，那我们的封装就没有任何意义了——目前为止，这个方案有问题了。</p>
<p>继续考虑，既然不能在封装外运算，那就把整个条件都进行封装，由IUserProvider自己实现运算。好方法！那我们就设计一个这样的类，我们叫它规格类，什么意思呢？它是对一批对象的说明性描述，它依照基准判断候选对象是否满足条件。</p>
<p>思考后，我们设计出类图，如图38-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001222009.png" alt="image-20211001222008885"></p>
<center>图38-2 加入规格后的设计类图</center>
在该类图中建立了一个规格书接口，它的作用就是定制各种各样的规格，比如名字相等的规格UserByNameEqual、年龄大于基准年龄的规格UserByAgeThan等，然后在用户操作类中采用该规格进行判断。User类没有任何改变，如代码清单38-1所示，不再赘述。

<p>规格书接口是对全体规格书的声明定义，如代码清单38-6所示。</p>
<p>代码清单38-6 规格书接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//候选者是否满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规格书接口只定义一个方法，判断候选用户是否满足条件。再来看姓名相同的规格书， 它实现了规格书接口，如代码清单38-7所示。</p>
<p>代码清单38-7 姓名相同的规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserByNameEqual</span> <span class="keyword">implements</span> <span class="title">IUserSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基准姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数传递基准姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserByNameEqual</span><span class="params">(String _name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验用户是否满足条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getName().equals(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，通过构造函数传递进来基准用户名，然后判断候选用户是否匹配。大于基准年龄的规格书与此类似，如代码清单38-8所示。</p>
<p>代码清单38-8 大于基准年龄的规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserByAgeThan</span> <span class="keyword">implements</span> <span class="title">IUserSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基准年龄</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//构造函数传递基准年龄</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserByAgeThan</span><span class="params">(<span class="keyword">int</span> _age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = _age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验用户是否满足条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getAge() &gt; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规格书都已经定义完毕，我们再来看用户操作类，先看用户操作的接口，如代码清单38-9所示。</p>
<p>代码清单38-9 用户操作接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据条件查找用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUser</span><span class="params">(IUserSpecification userSpec)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个方法——根据指定的规格书查找用户。再来看其实现类，如代码清单38-10所示。</p>
<p>代码清单38-10 用户操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProvider</span> <span class="keyword">implements</span> <span class="title">IUserProvider</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用户列表</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;User&gt; userList;</span><br><span class="line">    <span class="comment">//传递用户列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProvider</span><span class="params">(ArrayList&lt;User&gt; _userList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userList = _userList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据指定的规格书查找用户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;User&gt; <span class="title">findUser</span><span class="params">(IUserSpecification userSpec)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;User&gt; result = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        <span class="keyword">for</span>(User u:userList)&#123;</span><br><span class="line">            <span class="keyword">if</span>(userSpec.isSatisfiedBy(u))&#123;</span><br><span class="line">                <span class="comment">//符合指定规格</span></span><br><span class="line">                result.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序改动很小，仅仅在if判断语句中根据规格书进行判断，我们持续地扩展规格书，有多少查询分类就可以扩展出多少个实现类，而IUserProvider则不需要任何改动，它的一个方法就覆盖了我们刚刚提出的N多查询路径。我们设计一个场景来看看效果如何，如代码清单38-11所示。</p>
<p>代码清单38-11 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先初始化一批用户</span></span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;苏大&quot;</span>,<span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;牛二&quot;</span>,<span class="number">8</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>,<span class="number">15</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;王五&quot;</span>,<span class="number">18</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;赵六&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;马七&quot;</span>,<span class="number">25</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;杨八&quot;</span>,<span class="number">30</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;侯九&quot;</span>,<span class="number">35</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;布十&quot;</span>,<span class="number">40</span>));</span><br><span class="line">        <span class="comment">//定义一个用户查询类</span></span><br><span class="line">        IUserProvider userProvider = <span class="keyword">new</span> UserProvider(userList);</span><br><span class="line">        <span class="comment">//打印出年龄大于20岁的用户</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===年龄大于20岁的用户===&quot;</span>);</span><br><span class="line">        <span class="comment">//定义一个规格书</span></span><br><span class="line">        IUserSpecification userSpec = <span class="keyword">new</span> UserByAgeThan(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span>(User u:userProvider.findUser(userSpec))&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在场景类中定义了一个规格书，然后把规格书提交给UserProvider就可以查找到自己需要的用户了，运行结果相同，不再赘述。</p>
<p>大家想想看，如果现在需求变更了，比如需要一个年龄小于基准年龄的用户，该怎么修改？增加一个小于基准年龄的规格书，实现IUserSpecification接口，然后在新的业务中调用即可，别的什么都不需要修改。再比如需要一个类似SQL中like语句的处理逻辑，这个也不难，如代码清单38-12所示。</p>
<p>代码清单38-12 Like规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserByNameLike</span> <span class="keyword">implements</span> <span class="title">IUserSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//like的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String LIKE_FLAG = <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="comment">//基准的like字符串</span></span><br><span class="line">    <span class="keyword">private</span> String likeStr;</span><br><span class="line">    <span class="comment">//构造函数传递基准姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserByNameLike</span><span class="params">(String _likeStr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.likeStr = _likeStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验用户是否满足条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        String name = user.getName();</span><br><span class="line">        <span class="comment">//替换掉%后的干净字符串</span></span><br><span class="line">        String str = likeStr.replace(<span class="string">&quot;%&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//是以名字开头，如&#x27;国庆%&#x27;</span></span><br><span class="line">        <span class="keyword">if</span>(likeStr.endsWith(LIKE_FLAG) &amp;&amp; !likeStr.startsWith(LIKE_FLAG))&#123;</span><br><span class="line">            result = name.startsWith(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(likeStr.startsWith(LIKE_FLAG) &amp;&amp; !likeStr.endsWith(LIKE_FLAG))&#123;</span><br><span class="line">            <span class="comment">//类似 &#x27;%国庆&#x27;</span></span><br><span class="line">            result = name.endsWith(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result = name.contains(str);</span><br><span class="line">            <span class="comment">//类似于&#x27;%国庆%&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，场景类也要适当地改动，毕竟业务已经发生了变化，高层模块要适应这种变化， 如代码清单38-13所示。</p>
<p>代码清单38-13 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先初始化一批用户</span></span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;苏国庆&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;国庆牛&quot;</span>,<span class="number">82</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;张国庆三&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//定义一个用户查询类</span></span><br><span class="line">        IUserProvider userProvider = <span class="keyword">new</span> UserProvider(userList);</span><br><span class="line">        <span class="comment">//打印出名字包含&quot;国庆&quot;的人员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===名字包含国庆的人员===&quot;</span>);</span><br><span class="line">        <span class="comment">//定义一个规格书</span></span><br><span class="line">        IUserSpecification userSpec = <span class="keyword">new</span> UserByNameLike(<span class="string">&quot;%国庆%&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(User u:userProvider.findUser(userSpec))&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">===名字包含国庆的人员=== </span><br><span class="line">用户名：苏国庆 年龄：23 </span><br><span class="line">用户名：国庆牛 年龄：82 </span><br><span class="line">用户名：张国庆三 年龄：10</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们已经设计了一个可扩展的对象查询平台，但是我们还有遗留问题未解决，看看SQL语句，为什么where后面会很长？是因为有AND、OR、NOT这些逻辑操作符的存在，它们可以串联起多个判断语句，然后整体反馈出一个结果来。想想看，我们上面的平台能支持这种逻辑操作符吗？不能，你要说能，那也说得通，需要两次过滤才能实现，比如要找名字包含“国庆”并且年龄大于25岁的用户，代码该怎么修改？如代码清单38-14所示。</p>
<p>代码清单38-14 复合查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个规格书</span></span><br><span class="line">        IUserSpecification userSpec1 = <span class="keyword">new</span> UserByNameLike(<span class="string">&quot;%国庆%&quot;</span>);</span><br><span class="line">        IUserSpecification userSpec2 = <span class="keyword">new</span> UserByAgeThan(<span class="number">20</span>);</span><br><span class="line">        userList = userProvider.findUser(userSpec1);</span><br><span class="line">        <span class="keyword">for</span>(User u:userProvider.findUser(userSpec2))&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够实现，但是思考一下程序逻辑，它采用了两次过滤，也就是两次循环，如果对象数量少还好说，如果对象数量巨大，这个效率就太低了，这是其一；其二，组合方式非常多， 比如“与”、“或”、“非”可以自由组合，姓名中包含“国庆”但年龄小于25的用户，姓名中不包含国庆但年龄大于25岁的用户等，我们还能如此设计吗？太多的组合方式，产生组合爆炸， 这种设计就不妥了，应该有更优秀的方案。</p>
<p>我们换个方式思考该问题，不管是AND或者OR或者NOT操作，它们的返回结果都还是一个规格书，只是逻辑更复杂了而已，这3个操作符只是提供了对原有规格书的复合作用， 换句话说，规格书对象之间可以进行与或非操作，操作的结果不变，分析到这里，我们就可以开始修改接口了，如代码清单38-15所示。</p>
<p>代码清单38-15 带与或非的规格书接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//候选者是否满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//and操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserSpecification <span class="title">and</span><span class="params">(IUserSpecification spec)</span></span>;</span><br><span class="line">    <span class="comment">//or操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserSpecification <span class="title">or</span><span class="params">(IUserSpecification spec)</span></span>;</span><br><span class="line">    <span class="comment">//not操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserSpecification <span class="title">not</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在规格书接口中增加了与或非的操作，接口修改了，实现类当然也要修改。先全面思考一下业务，与或非是不可扩展的操作，规格书（也就是规格对象）之间的操作只有这三种方法，是不需要扩展也不用预留扩展空间的。如此，我们就可以把与或非的实现放到基类中， 那现在的问题变成了怎么在基类中实现与或非。注意看它们的返回值都需要返回规格书类型，很明显，我们在这里要用到递归调用了。可以这样理解，基类需要子类提供业务逻辑支持，因为基类是一个抽象类，不能实例化后返回，我们把简单类图画出来，如图38-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001222734.png" alt="image-20211001222734100"></p>
<center>图38-3 与规格的示意</center>

<p>基类对子类产生了依赖，然后进行递归计算，大家一定会发出这样的疑问：父类怎么可能依赖子类，这还是面向接口编程吗？想想看，我们提出面向接口编程的目的是什么？是为了适应变化，拥抱变化，对于不可能发生变化的部分为什么不能固化呢？与或非操作符号还会增加修改吗？规格书对象之间的操作还有其他吗？思考清楚这些问题后，答案就迎刃而解了。</p>
<hr>
<p><strong>注意</strong> 父类依赖子类的情景只有在非常明确不会发生变化的场景中存在，它不具备扩展性，是一种固化而不可变化的结构。</p>
<hr>
<p>分析完毕，我们设计出详细的类图，如图38-4所示。</p>
<p>可能大家有很多的疑问，我们先来分析代码，代码分析完毕估计能解决你大部分的疑问。规格书接口如代码清单38-15所示，不再赘述。我们来看组合规格书 （CompositeSpecification），它是一个抽象类，实现了与或非的操作，如代码清单38-16所示。</p>
<p>代码清单38-16 组合规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeSpecification</span> <span class="keyword">implements</span> <span class="title">IUserSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否满足条件由实现类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//and操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserSpecification <span class="title">and</span><span class="params">(IUserSpecification spec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndSpecification(<span class="keyword">this</span>,spec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//not操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserSpecification <span class="title">not</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NotSpecification(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUserSpecification <span class="title">or</span><span class="params">(IUserSpecification spec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrSpecification(<span class="keyword">this</span>,spec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001222905.png" alt="image-20211001222904900"></p>
<center>图38-4 完整规格书类图</center>

<p>候选对象是否满足条件是由isSatisfiedBy方法决定的，它代表的是一个判断逻辑，由各个实现类实现。三个与或非操作在抽象类中实现，它是通过直接new了一个子类，如此设计非常符合单一职责原则，每个子类都有一个独立的职责，要么完成“与”操作，要么完成“或”操作，要么完成“非”操作。我们先来看“与”操作规格书，如代码清单38-17所示。</p>
<p>代码清单38-17 与规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传递两个规格书进行and操作</span></span><br><span class="line">    <span class="keyword">private</span> IUserSpecification left;</span><br><span class="line">    <span class="keyword">private</span> IUserSpecification right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndSpecification</span><span class="params">(IUserSpecification _left,IUserSpecification _right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = _left;</span><br><span class="line">        <span class="keyword">this</span>.right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行and运算</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.isSatisfiedBy(user) &amp;&amp; right.isSatisfiedBy(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过构造函数传递过来两个需要操作的规格书，然后通过isSatisfiedBy方法返回两者and 操作的结果。或规格书和非规格书与此类似，分别如代码清单38-18、代码清单38-19所示。</p>
<p>代码清单38-18 或规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左右两个规格书</span></span><br><span class="line">    <span class="keyword">private</span> IUserSpecification left;</span><br><span class="line">    <span class="keyword">private</span> IUserSpecification right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrSpecification</span><span class="params">(IUserSpecification _left,IUserSpecification _right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = _left;</span><br><span class="line">        <span class="keyword">this</span>.right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or运算</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.isSatisfiedBy(user) || right.isSatisfiedBy(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单38-19 非规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传递一个规格书</span></span><br><span class="line">    <span class="keyword">private</span> IUserSpecification spec;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotSpecification</span><span class="params">(IUserSpecification _spec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spec = _spec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//not操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !spec.isSatisfiedBy(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三个规格书都是不发生变化的，只要使用该框架，三个规格书都要实现的，而且代码基本上是雷同的，所以才有了父类依赖子类的设计，否则是严禁出现父类依赖子类的情况的。大家再仔细看看这三个规格书和组合规格书，代码很简单，但也很巧妙，它跳出了我们面向对象设计的思维，不变部分使用一种固化方式实现。</p>
<p>姓名相同、年龄大于基准年龄、Like格式等规格书都有少许改变，把实现接口变为继承 基类，我们以名字相等规格书为例，如代码清单38-20所示。</p>
<p>代码清单38-20 姓名相同规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserByNameEqual</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基准姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//构造函数传递基准姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserByNameEqual</span><span class="params">(String _name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = _name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验用户是否满足条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.getName().equals(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅修改了黑体部分，其他没有任何改变。另外两个规格书修改相同，不再赘述。其他的User及UserProvider没有任何改动，不再赘述。</p>
<p>我们修改一下场景类，如代码清单38-21所示。</p>
<p>代码清单38-21 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先初始化一批用户</span></span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;苏国庆&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;国庆牛&quot;</span>,<span class="number">82</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;张国庆三&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;李四&quot;</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="comment">//定义一个用户查询类</span></span><br><span class="line">        IUserProvider userProvider = <span class="keyword">new</span> UserProvider(userList);</span><br><span class="line">        <span class="comment">//打印出名字包含&quot;国庆&quot;的人员</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===名字包含国庆的人员===&quot;</span>);</span><br><span class="line">        <span class="comment">//定义一个规格书</span></span><br><span class="line">        IUserSpecification spec = <span class="keyword">new</span> UserByAgeThan(<span class="number">25</span>);</span><br><span class="line">        IUserSpecification spec2 = <span class="keyword">new</span> UserByNameLike(<span class="string">&quot;%国庆%&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(User u:userProvider.findUser(spec.and(spec2)))&#123;</span><br><span class="line">            System.out.println(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在场景类中我们建立了两个规格书，一个是年龄大于25的用户，另一个是名字中包含“国庆”两个字的用户，这两个规格书之间的关系是“与”关系，运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">===名字包含国庆的人员=== </span><br><span class="line">用户名：国庆牛 年龄：82</span><br></pre></td></tr></table></figure>
<p>到此为止我们的LINQ已经完成了很大一部分了，SQL语句中的where后面部分已经可以解析了，完全可以再增加年龄相等的规格书、姓名字数规格书等，你在SQL中使用过的条件在这里都能实现了。功臣还是依赖于三个与或非规格书，有了它们三个栋梁才能组合出一个精彩的条件查询世界。</p>
<h2 id="38-1-2-最佳实践"><a href="#38-1-2-最佳实践" class="headerlink" title="38.1.2 最佳实践"></a>38.1.2 最佳实践</h2><p>我们在例子中多次提到规格两个字，该实现模式就叫做规格模式（Specification Pattern），它不属于23个设计模式，它是其中一个模式的扩展，是哪个模式呢？</p>
<p>我们用全局的观点思考一下，基类代表的是所有的规格书，它的目的是描述一个完整的、可组合的规格书，它代表的是一个整体，其下的And规格书、Or规格书、Not规格书、年龄大于基准年龄规格书等都是一个真实的实现，也就是一个局部，现在我们又回到了整体和部分的关系了，那这是什么模式？对，组合模式，它是组合模式的一种特殊应用，我们来看它的通用类图，如图38-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001223346.png" alt="image-20211001223346451"></p>
<center>图38-5 规格模式通用类图</center>

<p>为什么在通用类图中把方法名称都定义出来呢？是因为只要使用规格模式，方法名称都是这四个，它是把组合模式更加具体化了，放在一个更狭小的应用空间中。我们再仔细看看，还能不能找到其他模式的身影？对，策略模式，每个规格书都是一个策略，它完成了一系列逻辑的封装，用年龄相等的规格书替换年龄大于指定年龄的规格书上层逻辑有什么改变吗？不需要任何改变！</p>
<p>规格模式非常重要，它巧妙地实现了对象筛选功能。我们来看其通用源码，首先看抽象规格书，如代码清单38-22所示。</p>
<p>代码清单38-22 抽象规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//候选者是否满足要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Object candidate)</span></span>;</span><br><span class="line">    <span class="comment">//and操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISpecification <span class="title">and</span><span class="params">(ISpecification spec)</span></span>;</span><br><span class="line">    <span class="comment">//or操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISpecification <span class="title">or</span><span class="params">(ISpecification spec)</span></span>;</span><br><span class="line">    <span class="comment">//not操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISpecification <span class="title">not</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组合规格书实现与或非的算法，如代码清单38-23所示。</p>
<p>代码清单38-23 组合规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeSpecification</span> <span class="keyword">implements</span> <span class="title">ISpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//是否满足条件由实现类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Object candidate)</span></span>;</span><br><span class="line">    <span class="comment">//and操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISpecification <span class="title">and</span><span class="params">(ISpecification spec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AndSpecification(<span class="keyword">this</span>,spec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//not操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISpecification <span class="title">not</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NotSpecification(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISpecification <span class="title">or</span><span class="params">(ISpecification spec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrSpecification(<span class="keyword">this</span>,spec);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与或非规格书代码分别如代码清单38-24至代码清单38-26所示。</p>
<p>代码清单38-24 与规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传递两个规格书进行and操作</span></span><br><span class="line">    <span class="keyword">private</span> ISpecification left;</span><br><span class="line">    <span class="keyword">private</span> ISpecification right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndSpecification</span><span class="params">(ISpecification _left,ISpecification _right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = _left;</span><br><span class="line">        <span class="keyword">this</span>.right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行and运算</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Object candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.isSatisfiedBy(candidate) &amp;&amp; right.isSatisfiedBy(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单38-25 或规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//左右两个规格书</span></span><br><span class="line">    <span class="keyword">private</span> ISpecification left;</span><br><span class="line">    <span class="keyword">private</span> ISpecification right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrSpecification</span><span class="params">(ISpecification _left,ISpecification _right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = _left;</span><br><span class="line">        <span class="keyword">this</span>.right = _right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//or运算</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Object candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left.isSatisfiedBy(candidate) || right.isSatisfiedBy(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单38-26 非规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传递一个规格书</span></span><br><span class="line">    <span class="keyword">private</span> ISpecification spec;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NotSpecification</span><span class="params">(ISpecification _spec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.spec = _spec;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//not操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Object candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !spec.isSatisfiedBy(candidate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上一个接口、一个抽象类、3个实现类只要在适用规格模式的地方都完全相同，不用做任何的修改，大家闭着眼照抄就成，要修改的是下面的规格书——业务规格书，如代码清单38-27所示。</p>
<p>代码清单38-27 业务规格书</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BizSpecification</span> <span class="keyword">extends</span> <span class="title">CompositeSpecification</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基准对象</span></span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BizSpecification</span><span class="params">(Object _obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = _obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSatisfiedBy</span><span class="params">(Object candidate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据基准对象和候选对象，进行业务判断，返回boolean</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是看怎么使用了，场景类如代码清单38-28所示。</p>
<p>代码清单38-28 场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//待分析的对象</span></span><br><span class="line">        ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">        <span class="comment">//定义两个业务规格书</span></span><br><span class="line">        ISpecification spec1 = <span class="keyword">new</span> BizSpecification(<span class="keyword">new</span> Object());</span><br><span class="line">        ISpecification spec2 = <span class="keyword">new</span> BizSpecification(<span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">//规则的调用</span></span><br><span class="line">        <span class="keyword">for</span>(Object obj:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(spec1.and(spec2).isSatisfiedBy(obj))&#123;</span><br><span class="line">                <span class="comment">//and操作</span></span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规格模式已经是一个非常具体的应用框架了（相对于23个设计模式），大家遇到类似多个对象中筛选查找，或者业务规则不适于放在任何已有实体或值对象中，而且规则的变化和组合会掩盖那些领域对象的基本含义，或者是想自己编写一个类似LINQ的语言工具的时候就可以照搬这部分代码，只要实现自己的逻辑规格书即可。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/c57845b6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/c57845b6/" class="post-title-link" itemprop="url">37.1 MVC框架的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-27 19:57:33" itemprop="dateCreated datePublished" datetime="2021-09-27T19:57:33+08:00">2021-09-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-02 00:22:46" itemprop="dateModified" datetime="2021-10-02T00:22:46+08:00">2021-10-02</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">8 设计模式之禅(第2版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/5-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%89%A9%E5%B1%95%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">5 第五部分 扩展篇</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/5-%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86-%E6%89%A9%E5%B1%95%E7%AF%87/%E7%AC%AC37%E7%AB%A0-MVC%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">第37章 MVC框架</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/c57845b6/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/c57845b6/" data-xid="/JavaReadingNotes/c57845b6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="37-1-MVC框架的实现"><a href="#37-1-MVC框架的实现" class="headerlink" title="37.1 MVC框架的实现"></a>37.1 MVC框架的实现</h1><p>相信这本书的读者对Struts的使用是得心应手了，也明白MVC框架有诸如视图与逻辑解耦、灵活稳定、业务逻辑可重用等优点，而且还对其他的MVC框架（例如JSF、Spring MVC、WebWork）也了解一点。SSH（Struts+Spring+Hibernate）框架是Java项目常用的框架，作为一个Java开发人员，应该对SSH框架很熟悉了！我们今天就学Struts怎么用！我们要讲的是MVC框架如何设计，你可以设计一个新的MVC框架与Struts抗衡。</p>
<p>在开始设计MVC框架前，首先要对MVC框架做一个简单的介绍。MVC（Model ViewController）的中文名称叫做模型视图控制器模型，就是因为它的英文名字太流行了， 中文名字反而被忽略了。它诞生于20世纪80年代，原本是为桌面应用程序建立起来的一个框架，现在反而在Web应用中大放异彩（其实也可以把B/S认为是C/S的瘦化结构），MVC框架的目的是通过控制器C将模型M（代表的是业务数据和业务逻辑）和视图V（人机交互的界面）实现代码分离，从而使同一个逻辑或行为或数据可以具有不同的表现形式，或者是同样的应用逻辑共享相同、不同视图。比如，可以用IE浏览器访问某应用网站（页面格式遵守HTML标准），也可以用手机通过WAP浏览器访问（页面格式遵守WML格式），对MVC框架来说，后台的程序（也就是模型）不用做任何修改，只是使用的视图不同而已。MVC框架如图37-1所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001213321.png" alt="image-20211001213320931"></p>
<center>图37-1 MVC框架示意图</center>
该框架是Model2的结构。MVC框架有两个版本，一个是Model1，也就是MVC的第一个版本，它的视图中存在着大量的流程控制和代码开发，也就是控制器和视图还具有部分的耦合。也有人不认为Model1属于MVC框架，那也说得通，因为在JSP页面中融合了控制器和视图的功能，这其实就是早期的开发模式，开发一堆的JSP页面，然后再开发一堆的JavaBean，JavaBean就是模型了，它只是把JSP和JavaBean拆分开了。Model2版本则提倡视图和模型的彻底分离，视图仅仅负责展示服务，不再参与业务的行为和数据处理。我们举例来说明MVC框架是如何图37-1 MVC框架示意图控制器（Controller）视图（View）模型 （Model）第37章运行的。

<p>在做Web开发时，例如开发一个数据展示界面，从一张表中把数据全部读出，然后展示到页面上，也是一个简单的表格，其中页面展示的格式就是视图V，怎么从数据库中取得数据则是模型M，那控制器C是做什么的呢？它负责把接收的浏览器的请求转发通知模型M处理，然后组合视图V，最终反馈一个带数据的视图到用户端，数据处理流程如图37-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001213507.png" alt="image-20211001213507728"></p>
<center>图37-2 MVC框架的逻辑流</center>
浏览器通过HTTP协议发出数据请求①，由控制器接收请求，通过路径②委托给数据模型处理，模型通过与逻辑层和持久层的交互（路径③④），把处理结果反馈给控制器（路径 ⑤），控制器根据结果组装视图（路径⑥⑦），并最终反馈给浏览器可以接受的HTML数据 （路径⑧）。整体MVC框架还是比较简单的，但它带来的优点非常多。

<ul>
<li>高重用性</li>
</ul>
<p>一个模型可以有多个视图，比如同样是一批数据，可以是柱状展示，也可以是条形展示，还可以是波形展示。同样，多个模型也可以共享一个视图，同样是一个登录界面，不同用户看到的菜单数量（模型中的数据）不同，或者不同业务权限级别的用户在同一个视图中展示。</p>
<ul>
<li>低耦合</li>
</ul>
<p>因为模型和视图分离，两者没有耦合关系，所以可以独立地扩展和修改而不会产生相互影响。</p>
<ul>
<li>快速开发和便捷部署</li>
</ul>
<p>模型和视图分离，可以使各个开发人员自由发挥，做视图的人员和开发模型的人员可以制订自己的计划，然后在控制器的协作下实现完整的应用逻辑。</p>
<p>MVC框架还有很多优点，本章主要不是讲解MVC技术，主要是通过讲解设计MVC框架 来说明设计模式该怎么应用，所以想了解更详细的MVC框架信息请自行查阅资料。</p>
<h2 id="37-1-1-MVC的系统架构"><a href="#37-1-1-MVC的系统架构" class="headerlink" title="37.1.1 MVC的系统架构"></a>37.1.1 MVC的系统架构</h2><p>我们设计的MVC框架包含以下模块：核心控制器（FilterDispatcher）、拦截器 （Interceptor）、过滤器（Filter）、模型管理器（Model Action）、视图管理器（View Provider）等，基本上一个MVC框架上常用的功能我们都具备了，系统架构如图37-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001213719.png" alt="image-20211001213719199"></p>
<center>图37-3 MVC系统架构</center>

<p>各个模块的职责如下：</p>
<ul>
<li>核心控制器</li>
</ul>
<p>MVC框架的入口，负责接收和反馈HTTP请求。</p>
<ul>
<li>过滤器</li>
</ul>
<p>Servlet容器内的过滤器，实现对数据的过滤处理。由于它是容器内的，因此必须依靠容 器才能运行，它是容器的一项功能，与容器息息相关，本章就不详细讲述了。</p>
<ul>
<li>拦截器</li>
</ul>
<p>对进出模型的数据进行过滤，它不依赖系统容器，只过滤MVC框架内的业务数据。</p>
<ul>
<li>模型管理器</li>
</ul>
<p>提供一个模型框架，该框架内的所有业务操作都应该是无状态的，不关心容器对象，例如Session、线程池等。</p>
<ul>
<li>视图管理器</li>
</ul>
<p>管理所有的视图，例如提供多语言的视图等。</p>
<ul>
<li>辅助工具</li>
</ul>
<p>它其实就是一大堆的辅助管理工具，比如文件管理、对象管理等。</p>
<p>在我们的MVC框架中，核心控制器是最重要的，我们就先从它着手。核心控制器使用了Servlet容器的过滤器技术，需要编写一个过滤器，所有进入MVC框架的请求都需要经过核心控制器的转发，类图如图37-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001213950.png" alt="image-20211001213950390"></p>
<p>图37-4 核心控制器类图</p>
<p>由于类图中的部分输入参数类型较长，省略了，请读者仔细看代码。首先阅读FilterDispatcher代码，如代码清单37-1所示。</p>
<p>代码清单37-1 核心控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterDispatcher</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个值栈辅助类</span></span><br><span class="line">    <span class="keyword">private</span> ValueStackHelper valueStackHelper = <span class="keyword">new</span> ValueStackHelper();</span><br><span class="line">    <span class="comment">//应用IActionDispatcher</span></span><br><span class="line">    IActionDispather actionDispatcher = <span class="keyword">new</span> ActionDispatcher();</span><br><span class="line">    <span class="comment">//servlet销毁时要做的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//过滤器必须实现的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//转换为HttpServletRequest</span></span><br><span class="line">        HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">        HttpServletResponse res = (HttpServletResponse)response;</span><br><span class="line">        <span class="comment">//传递到其他过滤器处理</span></span><br><span class="line">        chain.doFilter(req, res);</span><br><span class="line">        <span class="comment">//获得从HTTP请求的ACTION名称</span></span><br><span class="line">        String actionName = getActionNameFromURI(req);</span><br><span class="line">        <span class="comment">//对ViewManager的应用</span></span><br><span class="line">        ViewManager viewManager = <span class="keyword">new</span> ViewManager(actionName);</span><br><span class="line">        <span class="comment">//所有参数放入值栈</span></span><br><span class="line">        ValueStack valueStack = valueStackHelper.putIntoStack(req);</span><br><span class="line">        <span class="comment">//把所有的请求传递给ActionDispatcher处理</span></span><br><span class="line">        String result =actionDispatcher.actionInvoke(actionName);</span><br><span class="line">        String viewPath = viewManager.getViewPath(result);</span><br><span class="line">        <span class="comment">//直接转向</span></span><br><span class="line">        RequestDispatcher rd = req.getRequestDispatcher(viewPath);</span><br><span class="line">        rd.forward(req, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 1、检查XML配置文件是否正确 </span></span><br><span class="line"><span class="comment">        * 2、启动监控程序，观察配置文件是否正确 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过url获得actionName</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getActionNameFromURI</span><span class="params">(HttpServletRequest req)</span></span>&#123;</span><br><span class="line">        String path = (String) req.getRequestURI();</span><br><span class="line">        String actionName = path.substring(path.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>, path.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> actionName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们按照系统的执行顺序来讲解，首先在容器的配置文件中需要配置该过滤器，以tomcat为例，配置如代码清单37-2所示。</p>
<p>代码清单37-2 核心控制器的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>FilterDispatcher<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDispatcher<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>&#123;包名&#125;.FilterDispatcher<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterDispatcher<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里定义了对所有以.do结尾的请求进行拦截，拦截后由FilterDispatcher的doFilter方法处理。过滤器是在启动时自动初始化，初始化完毕后立刻调用inti方法，在init方法中我们做了两件事情。</p>
<ul>
<li>检查XML配置文件</li>
</ul>
<p>所有的Action与视图的对应关系是在配置文件中配置的，因此若配置文件出错，该应用应该停止响应，这就需要在启动时对XML文件进行完整性检查和语法分析。</p>
<ul>
<li>启动监视器</li>
</ul>
<p>配置文件随时都可以修改，但是它修改后不应该需要重新启动应用才能生效，否则对系统的正常运行有非常大的影响，因此这里要使用到Listener（监听）行为了。</p>
<p>init方法需要做的这两件事情是非常重要的，而且都还包含了几种不同的设计模式。首 先我们来看检查XML配置文件如何实现。先看我们定义的XML格式（框架中应该定义一个 DTD文件，XML文件的模板，读者可以自行实现），如代码清单37-3所示。</p>
<p>代码清单37-3 XML配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&#123;类名全路径&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;execute&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span>&gt;</span>/index2.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;fail&quot;</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>读者思考一下该怎么检查这个XML文件，有两个不同的检查策略：一是检查XML文件的语法是否正确；二是框架逻辑检查，这是什么意思呢？比如我们在XML文件中配置了一个类A，它只有一个方法methodA，在method中编写的配置文件为method=”methoda”，方法名写错了，那这样的配置是肯定不能运行的，需要框架逻辑检查把它揪出来。这两种不同的算法是完全可以替换的，而且很有必要替换，逻辑检查在应用启动的时候需要对所有的类进行过滤处理，牺牲的是效率，这在测试机上没有问题，在生产机上要花20分钟才能把一个应用启动起来，在分秒必争的业务系统中这是不允许的，因此就要求该算法可以退休，想用的时候 （测试机环境）就用，不想用的时候（生产环境）就不用，想到什么模式了吗？策略模式， 这两个算法都是对同样的源文件进行检查，只是算法不同，当然可以相互替换了。类图比较简单，就不再画了，我们直接看代码，抽象策略如代码清单37-4所示。</p>
<p>代码清单37-4 XML文件校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IXmlValidate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只有一个方法，检查XML是否符合条件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String xmlPath)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据一个指定的路径，对XML进行校验，返回校验结果。普通XML校验如代码清单37-5 所示。</p>
<p>代码清单37-5 普通XML校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonXmlValidate</span> <span class="keyword">implements</span> <span class="title">IXmlValidate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//XML语法检查，比如是否少写了一个结束标志</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String xmlPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于读写XML文件一般使用DOM4J或者JDOM，都提供对XML文件的语法校验功能，不符合XML语法（比如一个节点少写了结束标志<code>&lt;/node&gt;</code>）的文件是不能解析的，读者可以在自己编写框架时使用该类型工具。</p>
<p>框架的逻辑算法如代码清单37-6所示。</p>
<p>代码清单37-6 框架逻辑校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogicXmlValidate</span> <span class="keyword">implements</span> <span class="title">IXmlValidate</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查xmlPath是否符合逻辑，比如不会出现一个类中没有的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String xmlPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑校验相对比较复杂，它的逻辑流程如下：</p>
<ul>
<li>读取XML文件。</li>
<li>使用反射技术初始化一个对象（配置文件中的class属性值）。</li>
<li>检查是否存在配置文件中配置的方法。</li>
<li>检查方法的返回值是否是String，并且无输入参数，同时必须继承指定类或接口。</li>
</ul>
<p>逻辑校验需要把所有的对象都初始化一遍，在Action类较多的情况下，效率较低，但它可以提前发现出现访问异常的情况，把问题解决在萌芽状态。我们继续来看两个策略的场景类，如代码清单37-7所示。</p>
<p>代码清单37-7 策略的场景类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Checker</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用哪一个策略</span></span><br><span class="line">    <span class="keyword">private</span> IXmlValidate validate;</span><br><span class="line">    <span class="comment">//xml配置文件的路径</span></span><br><span class="line">    String xmlPath;</span><br><span class="line">    <span class="comment">//构造函数传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Checker</span><span class="params">(IXmlValidate _validate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.validate = _validate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXmlPath</span><span class="params">(String _xmlPath)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>.xmlPath = _xmlPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> validate.validate(xmlPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与通用策略模式稍有不同，每个模式在实际应用环境中都有其个性，很少出现完全照搬一个模式的情况，灵活应用设计模式才是关键。</p>
<p>在FilterDispatcher的init方法中，我们刚刚说它有两个职责：第一个职责是XML文件校验，这个我们完成了；第二个职责是启动监控程序。问题是要监控什么呢？监控XML有没有被修改，如果修改了就立刻通知校验程序对它进行校验。这就又用到了观察者模式：发现文件被修改，它立刻通知检查者处理，该片段的类图如图37-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001215149.png" alt="image-20211001215149343"></p>
<center>图37-5 XML文件监控类图</center>

<p>为什么要在这里定义一个Watchable接口呢？它表示所有可以监视的资源，比如数据库、日志文件、磁盘空间等。我们来看代码，监听接口如代码清单37-8所示。</p>
<p>代码清单37-8 监听接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Watchable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件监听者是观察者模式的被观察者，它一旦发现文件发生变化立刻通知观察者，如代码清单37-9所示。</p>
<p>代码清单37-9 文件监听者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWatcher</span> <span class="keyword">extends</span> <span class="title">Observable</span> <span class="keyword">implements</span> <span class="title">Watchable</span></span>&#123;</span><br><span class="line">    <span class="comment">//是否要重新加载XML文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isReload = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//启动监视</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//启动一个线程，每隔15秒扫描一下文件，发现文件日期被修改，立刻通知观察者</span></span><br><span class="line">        <span class="keyword">super</span>.addObserver(<span class="keyword">new</span> Checker());</span><br><span class="line">        <span class="keyword">super</span>.setChanged();</span><br><span class="line">        <span class="keyword">super</span>.notifyObservers(isReload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于框架是在操作系统之上运行的，文件变化时操作系统是不会通知应用系统的，因此我们能做的就是启动一个线程监视一批文件，发现文件改变了，立刻通知相关的处理者，它虽然有时间延迟，但对于一个应用框架来说是非常有必要的，避免了重启应用才能使配置生效的情况。</p>
<p>读者可能很疑惑，这种死循环的监控方式会不会对性能产生影响，答案是不会！为什么呢？</p>
<p>检查一个文件的时间一般是毫秒级的，相对于我们设置的运行周期（比如15秒执行一次）是一个非常微小的运行时间，对应用不会产生任何影响。大家都在使用Log4j进行日志处理，它有一个线程是每5秒检查一次日志是否满，大家觉得性能受影响了吗？基本上性能影响可以忽略不计。</p>
<p>由于Checker还要作为观察者，因此它要实现Observer接口，同时实现update方法，如代码清单37-10所示。</p>
<p>代码清单37-10 修正后的检查者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Checker</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable arg0, Object arg1)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查是否符合条件</span></span><br><span class="line">        arg1 = check();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，我们把init方法已经讲解完毕，它是在容器初始化时调用。有一个HTTP请求发送过来，容器调用我们编写的doFilter方法。仔细看一下我们的代码，其中有这样一句话：Chain.doFilter(req,res)，这句话是什么意思呢？是说让后续的过滤器先运行，等它们运行完毕后该过滤器再运行，应该想到这是一个责任链模式，它的类型是FilterChain。Servlet 容器把所有的过滤器组合在一起形成了一个过滤器链，它是怎么做到的呢？容器启动的时候，把所有的过滤器都初始化完毕，然后根据它们在web.xml中的配置顺序，从上向下组装一个过滤器链。注意所有的过滤器都必须实现Filter接口，这是建立过滤器链的首要前提。</p>
<p>我们再回过头来仔细看看类图，是不是有点熟悉？对，类似于中介者模式，我们并没有把中介者传递到各个同事类，只是我们采用中介者模式的思想，把中介者的职责分发出去由各个同事类来处理。</p>
<h2 id="37-1-2-模型管理器"><a href="#37-1-2-模型管理器" class="headerlink" title="37.1.2 模型管理器"></a>37.1.2 模型管理器</h2><p>模型管理器是整个MVC框架的难点，在这里我们会看到非常多的设计模式。我们在核心控制器的类图中看到有一个IActionDispatcher接口，它实现的模型行为分发是一个门面模式，如代码清单37-11所示。</p>
<p>代码清单37-11 模型行为分发接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActionDispather</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据Action的名字，返回处理结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">actionInvoke</span><span class="params">(String actionName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的职责非常简单，得到actionName就执行，熟悉Struts的读者可能很清楚这个方法是非常复杂的，它要从配置文件中找到执行对象，然后执行方法，还要考虑值栈、异常等，非常复杂。我们这里就有一个方法，它对外提供一个门面，所有的访问都是通过该门面来完成， 其实现类如代码清单37-12所示。</p>
<p>代码清单37-12 模型分发实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionDispather</span> <span class="keyword">implements</span> <span class="title">IActionDispather</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要执行的Action</span></span><br><span class="line">    <span class="keyword">private</span> ActionManager actionManager = <span class="keyword">new</span> ActionManager();</span><br><span class="line">    <span class="comment">//拦截器链</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Interceptors&gt; listInterceptors = InterceptorFactory.createInterceptors();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">actionInvoke</span><span class="params">(String actionName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前置拦截器</span></span><br><span class="line">        <span class="keyword">return</span> actionManager.execAction(actionName);</span><br><span class="line">        <span class="comment">//后置拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个非常简单的类，对外部提供统一封装好的行为。模型管理器的类图如图37-6所示。</p>
<p>首先说ActionManager类，它负责管理所有的行为类Action，那就必须定义一个行为类的接口或抽象类，如代码清单37-13所示。</p>
<p>代码清单37-13 抽象Action</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUCCESS = <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String FAIL = <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">    <span class="comment">//默认的执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001215608.png" alt="image-20211001215608539"></p>
<center>图37-6 模型管理器类图</center>
抽象的ActionSupport类看起来很简单，其实它可不简单，所有的模型行为都继承该类， 它之所以提供一个默认的execute方法，是因为在xml的配置文件中，可以省略掉method="XXX"这句话，默认就是调用该方法。它还有一个非常重要的行为：对象映射，把HTTP传递过来的字符串映射到一个业务对象上，我们会在值栈中详细讲解。

<p>读者可能很疑惑，Action的操作是需要获得环境数据的，比如HTTPServletRequest的数据，还有系统中的Session数据，单单一个ActionManager如何获得这些数据呢？通过值栈，在值栈中保存着该Action需要的所有数据。</p>
<p>我们再来看ActionManager类，如代码清单37-14所示。</p>
<p>代码清单37-14 Action管理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行Action的指定方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execAction</span><span class="params">(String actionName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这么简单吗？非也，其中的参数actionName指xml配置中的name属性值，它与从HTTP 传递过来的请求对象是一致的，根据HTTP传递过来的actionName在xml文件中查找对应的节点（Node）,然后就可以获取到该类的名称和方法，通过动态代理的方式执行该方法，在这里我们使用到了代理模式。</p>
<p>有读者可能听说过反射是影响性能的，它提供解释型操作。是这样的，但是实际应用还没有这么高的要求，把数据库设计得优秀一点，系统架构多考虑一点，提升的性能远比这个多。</p>
<p>然后我们再来看拦截器，拦截器和过滤器的区别就是：拦截器可以脱离容器（J2EE容器）运行，而过滤器不行。拦截器的目的是对数据和行为进行过滤，符合条件的才可以执行Action，或者是在Action执行完毕后，调用拦截器进行回收处理。我们定义一个抽象的拦截器，如代码清单37-15所示。</p>
<p>代码清单37-15 抽象拦截器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得当前的值栈</span></span><br><span class="line">    <span class="keyword">private</span> ValueStack valueStack = ValueStackHelper.getValueStack();</span><br><span class="line">    <span class="comment">//拦截器类型：前置、后置、环绕</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> type =<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前的值栈</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ValueStack <span class="title">getValueStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> valueStack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据type不同，处理方式也不同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截器类型</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(<span class="keyword">int</span> type)</span></span>;</span><br><span class="line">    <span class="comment">//子类实现的拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">intercept</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这怎么和Struts的拦截器不相同呀！是的，Struts的拦截器的拦截方法intercept是要接收一个ActionInvocation对象，这里却没有，我们主要是讲解模式，是为了技术实现，而类似Struts 的MVC框架属于工业级别的应用框架，考虑了太多的外界因素。拦截器分为三种。</p>
<ul>
<li>前置拦截器</li>
</ul>
<p>在Action调用前执行，对Action需要的场景数据进行过滤或重构。</p>
<ul>
<li>后置拦截器</li>
</ul>
<p>在Action调用后执行，负责回收场景，或对Action的后续事务进行处理。</p>
<ul>
<li>环绕拦截器</li>
</ul>
<p>在Action调用前后都执行。</p>
<p>我们的框架在这里使用了一个模板方法模式，开发者继承AbstractInterceptor后，只要完成两个职责即可：定义拦截类型（setType）和实现拦截器要拦截的方法（intercept），不用考虑它到底如何调用ActionInvocation，相对来说简单又实用。</p>
<p>有拦截器就肯定有拦截器链，多个拦截器组合在一起就成了拦截器链，如代码清单37- 16所示。</p>
<p>代码清单37-16 拦截器链</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptors</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">AbstractInterceptor</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//根据拦截器列表建立一个拦截器链</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interceptors</span><span class="params">(ArrayList&lt;AbstractInterceptor&gt; list)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//列出所有的拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;AbstractInterceptor&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截器链的执行方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">intercept</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//委托拦截器执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它实现了Iterable接口，提供了一个方便遍历拦截器的方法，这是迭代器模式。同时，由于是一个链结构，我们就想到了责任链，这里确实也是一个责任链模式，只是核心控制器上的过滤链是Servlet容器自己实现的，而拦截器链则需要我们自己编码实现。代码不复杂，读者可以参考责任链章节。</p>
<p>这里还有两个很有意思的方法。我们来看构造函数，它通过一个容纳有拦截器的动态数组生成一个拦截器链，它是一个自激行为，在XML文件中配置一个拦截器，其中包含多个拦截器，我们的构造函数就是这样的用途，自己建立一条链，而不是父类或者高层模块。再看intercept方法，链中每个节点都是一个拦截器，都有一个intercept方法，拦截器链中的intercept方法行为是委托第一个节点拦截器的intercept方法，然后所有的拦截器都会按照顺序执行一遍，这一点和我们的责任链模式是不同的，责任链模式是只要有节点处理就可以认为是结束，后续节点可以不再参与处理。</p>
<p>Struts还实现了方法拦截器，只要继承MethodFilterInterceptor即可，主要使用了反射技 术，有兴趣的话可以看看源代码。注意我们这里使用了拦截器链而不像Struts那样是拦截器 栈，一字之差，系统设计差别可就大了。</p>
<hr>
<p>注意 拦截器是会影响系统性能的，所有的Action在执行前后都会被拦截器过滤一遍，即使不符合拦截条件的也会被检查一遍，所以非必要情况不要使用拦截器。</p>
<hr>
<p>由于在XML配置文档中有太多的拦截器链，因此需要有一个工厂来创建它，否则太烦琐。如代码清单37-17所示。</p>
<p>代码清单37-17 拦截器链工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Interceptors&gt; <span class="title">createInterceptors</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据配置文件创建出所有的拦截器链</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用是根据配置文件一次性地创建出所有的拦截器，很简单的工厂方法模式。如果读者还记得我们刚刚讲的配置文件更新问题的话，应该想到这里也应该有一个观察者，配置文件修改了，拦截器链当然也要重建了，确实应该有这样一个观察者，读者可以自行思考如何实现。</p>
<h2 id="37-1-3-值栈"><a href="#37-1-3-值栈" class="headerlink" title="37.1.3 值栈"></a>37.1.3 值栈</h2><p>值栈按道理说应该很简单，就是把HTTP传递过来的String字符串压到堆栈中。听起来很简单，实现起来就比较有难度了，它要完成两个职责。</p>
<ul>
<li>管理堆栈</li>
</ul>
<p>不仅仅是出栈、入栈这么简单，它要管理栈中数据，同时还要允许前置拦截器对栈中数据进行修改，限制后置拦截器对栈的修改，还要把栈中数据与HTTPServletRequest中的数据建立关联。</p>
<ul>
<li>值映射</li>
</ul>
<p>从HTTP传递过来的数据都是字符串结构，那怎么才能转化成一个业务对象呢？比如在页面上有一个登录框，输入用户名（userName）和密码（password）。提交到MVC框架中怎么才能转为一个User对象呢？这也是值栈要完成的职责。</p>
<p>这里说一下值映射，怎么实现一个值的映射，这也是一个反射操作的结果。首先是HTTP传递过来的参数名称中要明确映射到哪一个对象，例如使用点号(.)区分，点号前是对象名称，点号后是属性名，如此规定后就可以轻松地处理了。由于使用的模式较少，这里就不再赘述。读者若有兴趣可以考虑使用一些开源工具，比如dozer等。</p>
<h2 id="37-1-4-视图管理器"><a href="#37-1-4-视图管理器" class="headerlink" title="37.1.4 视图管理器"></a>37.1.4 视图管理器</h2><p>视图管理器的功能很单一，按照模型指定的要求返回视图，在这里用到的主要模式就是桥梁模式，如果大家做过多语言的开发就非常清楚了，比如一个外部网站，提供中日英三种语言版本，我们不可能每个语言都写一套页面吧。一般是定义一个语言资源文件，然后视图根据不同的语言环境加载不同的语言。我们先来说视图，它包含三部分。</p>
<ul>
<li>静态页面</li>
</ul>
<p>比如图片放在什么地方，字体大小是什么样子，菜单应该放置在什么地方，这部分工作是由前台人员开发的，不涉及业务逻辑和业务数据。</p>
<ul>
<li>动态页面元素</li>
</ul>
<p>它指的是在一个固定场景下不发生变化但在异构场景中发生变化的元素，其中语言就属于动态页面元素，还有为使用不同浏览器而开发的代码。比如浏览器IE、Firefox、Chrome 等，虽然基本上都是符合HTML，但是还有一些细节差异，特别是在JavaScript的处理方面， 稍不注意就可能产生灾难。</p>
<ul>
<li>动态数据</li>
</ul>
<p>由模型产生的数据，它对视图来说是结构固定，并可反复加载。</p>
<p>在这三部分中，静态页面是完全静态的，动态页面元素是稍微有点动感，动态数据完全是多变的（数据结构不发生变化，否则页面无法展现）。把动态数据融入到静态页面中比较容易，已经在配置文件中指定要把模型中的数据放到哪个页面中，现在的问题是怎么把动态页面元素融入到静态页面中。静态页面有很多，语言类型也有很多，怎么融合在一起提供给浏览器访问呢？</p>
<p>桥梁模式可以解决用什么笔（圆珠笔、铅笔）和画什么图形（圆形、方形）的问题，我们遇到的问题与此场景类似。先看类图，如图37-7所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/10/20211001220257.png" alt="image-20211001220257520"></p>
<center>图37-7 视图与语言类图</center>
大家还记得Struts是怎么配置多语言的文件吗？我们采用类似的结构，如代码清单37-18 所示。

<p>代码清单37-18 资源配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title=标题 </span><br><span class="line">menu=菜单</span><br></pre></td></tr></table></figure>
<p>英文配置菜单与此类似，它的结构就是一个Map类型，我们把它读入到Map中，抽象类如代码清单37-19所示。</p>
<p>代码清单37-19 抽象语言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsLangData</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得所有的动态元素的配置项</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Map&lt;String,String&gt; <span class="title">getItems</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getItems方法是获得一种语言下的所有配置。我们来看中文语言包，如代码清单37-20所 示。</p>
<p>代码清单37-20 中文语言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GBLangData</span> <span class="keyword">extends</span> <span class="title">AbsLangData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Map 的结构为： </span></span><br><span class="line"><span class="comment">        * key=&#x27;title&#x27;, value=&#x27;标题&#x27; </span></span><br><span class="line"><span class="comment">        * key=&#x27;menu&#x27;, value=&#x27;菜单&#x27; </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>英文语言如代码清单37-21所示。</p>
<p>代码清单37-21 英文语言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ENLangData</span> <span class="keyword">extends</span> <span class="title">AbsLangData</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Map结构为： </span></span><br><span class="line"><span class="comment">        * key=&#x27;title&#x27;,value=&#x27;title&#x27;;</span></span><br><span class="line"><span class="comment">        * key=&#x27;menu&#x27;, value=&#x27;menu&#x27; </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视图分为两种类图，一种是需要直接替换资源文件的视图，比如JSP文件，框架直接把语言包中的资源项替换掉JSP中的条目即可，把{title}替换为“标题”，把{menu}替换为“菜单”，替换后存在框架的缓存目录中，提高系统的访问效率。另一种视图是不能替换的，比如SWF文件，它的资源可以通过类似HTTP传递参数的形式传递，重写一个URL即可。我们首先来看抽象视图，如代码清单37-22所示。</p>
<p>代码清单37-22 抽象视图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AbsLangData langData;</span><br><span class="line">    <span class="comment">//必须有一个语言文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbsView</span><span class="params">(AbsLangData _langData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.langData = _langData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得当前的语言</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbsLangData <span class="title">getLangData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> langData;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//页面的URL路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getURI</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组装一个页面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">assemble</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSP视图是需要替换资源项，如代码清单37-23所示。</p>
<p>代码清单37-23 JSP视图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspView</span> <span class="keyword">extends</span> <span class="title">AbsView</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传递语言配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JspView</span><span class="params">(AbsLangData _langData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(_langData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assemble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; langMap = getLangData().getItems();</span><br><span class="line">        <span class="keyword">for</span>(String key:langMap.keySet())&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 直接替换文件中的语言条目 </span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SWF文件是不能替换的，采用重写URL的方式，如代码清单37-24所示。</p>
<p>代码清单37-24 SWF视图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwfView</span> <span class="keyword">extends</span> <span class="title">AbsView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwfView</span><span class="params">(AbsLangData _langData)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(_langData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assemble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; langMap = getLangData().getItems();</span><br><span class="line">        <span class="keyword">for</span>(String key:langMap.keySet())&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 组装一个HTTP的请求格式： </span></span><br><span class="line"><span class="comment">            * http://abc.com/xxx.swf?key1=value&amp;key2=value</span></span><br><span class="line"><span class="comment">            */</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewManager是一个视图模块的入口，所有的访问都是通过它传递进来的，如代码清单 37-25所示。</p>
<p>代码清单37-25 视图管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Action的名称</span></span><br><span class="line">    <span class="keyword">private</span> String actionName;</span><br><span class="line">    <span class="comment">//当前的值栈</span></span><br><span class="line">    <span class="keyword">private</span> ValueStack valueStack = ValueStackHelper.getValueStack();</span><br><span class="line">    <span class="comment">//接收一个ActionName</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewManager</span><span class="params">(String _actionName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actionName = _actionName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据模型的返回结果提供视图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getViewPath</span><span class="params">(String result)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据值栈查找到需要提供的语言</span></span><br><span class="line">        AbsLangData langData = <span class="keyword">new</span> GBLangData();</span><br><span class="line">        <span class="comment">//根据action和result查找到指定的视图，并加载语言</span></span><br><span class="line">        AbsView view = <span class="keyword">new</span> JspView(langData);</span><br><span class="line">        <span class="comment">//返回视图的地址</span></span><br><span class="line">        <span class="keyword">return</span> view.getURI();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过桥梁模式我们把不同的语言和不同类型的视图结合起来，共同提供一个多语言的应用系统，即使以后增加语言也非常容易扩展。</p>
<h2 id="37-1-5-工具类"><a href="#37-1-5-工具类" class="headerlink" title="37.1.5 工具类"></a>37.1.5 工具类</h2><p>每个框架或项目都有大量的工具类，MVC框架也不例外。先来看操作XML文件的工具类，不可能自己读写XML文件，我们使用DOM4J来实现，它在大文件的处理上性能很有优势，而且比较简单，架构也非常优秀。</p>
<p>使用DOM4J从XML文件中读出的对象是节点（Node）、元素（Element）、属性（Attribute）等，这些对象还是比较容易理解的，但是不能保证一个开发组的人对这些都了解，因此需要把它转换成每个开发成员都理解的对象，比如我们处理这样一段XML代码，如代码清单37-26所示。</p>
<p>代码清单37-26 XML文件片段</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&#123;类名全路径&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;execute&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;success&quot;</span>&gt;</span>/index2.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">&quot;fail&quot;</span>&gt;</span>/index.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用DOM4J查找到该节点是一个Node对象，如果要取得属性，就需要转换为一个元素 (Element)对象，这不是每个开发成员都能理解的，于是给架构师提出的问题就是：如何把一个DOM4J对象转换成自己设计的对象。答案是适配器模式，我们首先定义一个Action节点类，如代码清单37-27所示。</p>
<p>代码清单37-27 Action节点类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Action的名称</span></span><br><span class="line">    <span class="keyword">private</span> String actionName;</span><br><span class="line">    <span class="comment">//Action的类名</span></span><br><span class="line">    <span class="keyword">private</span> String actionClass;</span><br><span class="line">    <span class="comment">//方法名，默认是execute</span></span><br><span class="line">    <span class="keyword">private</span> String methodName = <span class="string">&quot;excuete&quot;</span>;</span><br><span class="line">    <span class="comment">//视图路径</span></span><br><span class="line">    <span class="keyword">private</span> String view;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActionName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actionName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActionClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> actionClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> methodName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getView</span><span class="params">(String Result)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是一个抽象类，其中的getView是一个抽象方法，是根据执行结果查找到视图路径。 只要编写一个适配器就可以把Elemet对象转为Action节点，如代码清单37-28所示。</p>
<p>代码清单37-28 Action节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlActionNode</span> <span class="keyword">extends</span> <span class="title">ActionNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要转换的element</span></span><br><span class="line">    <span class="keyword">private</span> Element el;</span><br><span class="line">    <span class="comment">//通过构造函数传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlActionNode</span><span class="params">(Element _el)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.el = _el;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActionName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAttValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getActionClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAttValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAttValue(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getView</span><span class="params">(String result)</span></span>&#123;</span><br><span class="line">        ViewPathVisitor visitor = <span class="keyword">new</span> ViewPathVisitor(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">        el.accept(visitor);</span><br><span class="line">        <span class="keyword">return</span> visitor.getViewPath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得指定属性值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getAttValue</span><span class="params">(String attName)</span></span>&#123;</span><br><span class="line">        Attribute att = el.attribute(attName);</span><br><span class="line">        <span class="keyword">return</span> att.getText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个对象适配器，传递进来一个Element对象，把它转换为ActionNode对象，这样设计以后，系统开发人员就不用考虑开源工具对系统的影响，屏蔽了工具系统的影响，这是一个典型的适配器模式应用。</p>
<p>不知道读者是否注意到getView方法，它使用了一个访问者模式，这是DOM4J提供的一个非常优秀的API接口，传递进去一个访问者就可以遍历出我们需要的对象。我们来看自己定义的访问者，如代码清单37-29所示。</p>
<p>代码清单37-29 访问者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPathVisitor</span> <span class="keyword">extends</span> <span class="title">VisitorSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得指定的路径</span></span><br><span class="line">    <span class="keyword">private</span> String viewPath;</span><br><span class="line">    <span class="keyword">private</span> String result;</span><br><span class="line">    <span class="comment">//传递模型结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPathVisitor</span><span class="params">(String _result)</span></span>&#123;</span><br><span class="line">        result = _result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Element el)</span></span>&#123;</span><br><span class="line">        Attribute att = el.attribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(att != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(att.getName().equals(<span class="string">&quot;name&quot;</span>) &amp;&amp; att.getText().equals(result))&#123;</span><br><span class="line">                viewPath = el.getText();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getViewPath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> viewPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DOM4J提供了VisitorSupport抽象接口，可以接受元素、节点、属性等访问者。我们这里 接受了一个元素访问者，对所有的元素过滤一遍，然后找到自己需要的元素，非常强大！</p>
<p>我们继续分析，在IoC容器中都会区分对象是单例模式还是多例模式。想想我们的框架，每个HTTP请求都会产生一个线程，如果我们的Action初始化的时候是单例模式会出现什么情况？当并发足够多的时候就会产生阻塞，性能会严重下降，在特殊情况下还会产生线程不安全，这时就需要考虑多例情况。那多例是如何处理呢？使用Clone技术，首先在系统启动时初始化所有的Action，然后每过来一个请求就拷贝一个Action，减少了初始化对象的性能消耗。典型的原型模式，但问题也同时产生了，并发较多时，就可能会产生内存溢出的情况，内存不够用了!于是享元模式就可以上场了，建立一个对象池以容纳足够多的对象。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/6ad03aa1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/6ad03aa1/" class="post-title-link" itemprop="url">第三部分 谁的地盘谁做主 ——设计模式PK</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-26 10:49:00" itemprop="dateCreated datePublished" datetime="2021-09-26T10:49:00+08:00">2021-09-26</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-09-30 21:45:46" itemprop="dateModified" datetime="2021-09-30T21:45:46+08:00">2021-09-30</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">8 设计模式之禅(第2版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/8-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85-%E7%AC%AC2%E7%89%88/3-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E8%B0%81%E7%9A%84%E5%9C%B0%E7%9B%98%E8%B0%81%E5%81%9A%E4%B8%BB-%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FPK/" itemprop="url" rel="index"><span itemprop="name">3 第三部分 谁的地盘谁做主 ——设计模式PK</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/6ad03aa1/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/6ad03aa1/" data-xid="/JavaReadingNotes/6ad03aa1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>64</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第三部分-谁的地盘谁做主-——设计模式PK"><a href="#第三部分-谁的地盘谁做主-——设计模式PK" class="headerlink" title="第三部分 谁的地盘谁做主 ——设计模式PK"></a>第三部分 谁的地盘谁做主 ——设计模式PK</h1><ul>
<li>第30章 创建类模式大PK </li>
<li>第31章 结构类模式大PK </li>
<li>第32章 行为类模式大PK </li>
<li>第33章 跨战区PK</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/694ba95a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/694ba95a/" class="post-title-link" itemprop="url">5.3 实战：Eclipse运行速度调优</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-24 10:16:20" itemprop="dateCreated datePublished" datetime="2021-09-24T10:16:20+08:00">2021-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-18 10:55:11" itemprop="dateModified" datetime="2021-11-18T10:55:11+08:00">2021-11-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">7 深入理解Java虛拟机：JVM高级特性与最佳实践(第3版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">2第二部分 自动内存管理</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">第5章 调优案例分析与实战</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/5-3-%E5%AE%9E%E6%88%98%EF%BC%9AEclipse%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%B0%83%E4%BC%98/" itemprop="url" rel="index"><span itemprop="name">5.3 实战：Eclipse运行速度调优</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/694ba95a/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/694ba95a/" data-xid="/JavaReadingNotes/694ba95a/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>253</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="5-3-实战：Eclipse运行速度调优"><a href="#5-3-实战：Eclipse运行速度调优" class="headerlink" title="5.3 实战：Eclipse运行速度调优"></a>5.3 实战：Eclipse运行速度调优</h1><p>很多Java开发人员都有一种错觉，认为系统调优的工作都是针对服务端应用的，规模越大的系统，就需要越专业的调优运维团队参与。这个观点不能说不对，只是有点狭隘了。上一节中笔者所列举的案例确实大多是服务端运维、调优的例子，但不只服务端需要调优，其他应用类型也是需要的， 作为一个普通的Java开发人员，学习到的各种虚拟机的原理和最佳实践方法距离我们并不遥远，开发者身边就有很多场景可以使用上这些知识。下面就通过一个普通程序员日常工作中可以随时接触到的开发工具开始这次实战<a href="%E6%AD%A4%E5%AE%9E%E6%88%98%E6%98%AF%E6%9C%AC%E4%B9%A6%E7%AC%AC2%E7%89%88%E6%97%B6%E7%BC%96%E5%86%99%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E4%BB%8A%E5%A4%A9%E7%9C%8B%E6%9D%A5%E9%87%8C%E9%9D%A2%E7%9A%84Eclipse%E5%92%8CHotSpot%E7%89%88%E6%9C%AC%E5%B7%B2%E7%BB%8F%E8%BE%83%E6%97%A7%EF%BC%8C%E4%B8%8D%E8%BF%87%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E7%9A%84%E8%90%BD%E5%90%8E%E5%B9%B6%E6%9C%AA%E5%BD%B1%E5%93%8D%E7%AC%94%E8%80%85%E8%A6%81%E8%A1%A8%E8%BE%BE%E7%9A%84%E6%84%8F%E5%9B%BE%EF%BC%8C%E6%9C%AC%E6%A1%88%E4%BE%8B%E7%9B%AE%E5%89%8D%E4%B9%9F%E4%BB%8D%E7%84%B6%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AE%9E%E6%88%98%E4%BB%B7%E5%80%BC%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E7%AC%AC3%E7%89%88%E9%87%8C%E7%AC%94%E8%80%85%E5%B9%B6%E6%9C%AA%E5%88%BB%E6%84%8F%E5%B0%86Eclipse%E5%92%8CHotSpot%E5%8D%87%E7%BA%A7%E5%90%8E%E9%87%8D%E5%86%99%E4%B8%80%E6%AC%A1%E3%80%82">^1</a>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/15b18ae3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/15b18ae3/" class="post-title-link" itemprop="url">5.3.1 调优前的程序运行状态</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-24 10:16:20" itemprop="dateCreated datePublished" datetime="2021-09-24T10:16:20+08:00">2021-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-18 10:55:11" itemprop="dateModified" datetime="2021-11-18T10:55:11+08:00">2021-11-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">7 深入理解Java虛拟机：JVM高级特性与最佳实践(第3版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">2第二部分 自动内存管理</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">第5章 调优案例分析与实战</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/5-3-%E5%AE%9E%E6%88%98%EF%BC%9AEclipse%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%B0%83%E4%BC%98/" itemprop="url" rel="index"><span itemprop="name">5.3 实战：Eclipse运行速度调优</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/15b18ae3/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/15b18ae3/" data-xid="/JavaReadingNotes/15b18ae3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="5-3-1-调优前的程序运行状态"><a href="#5-3-1-调优前的程序运行状态" class="headerlink" title="5.3.1 调优前的程序运行状态"></a>5.3.1 调优前的程序运行状态</h2><p>笔者使用Eclipse作为日常工作中的主要IDE工具，由于安装的插件比较大（如Kloc-work、 ClearCase LT等）、代码也很多，启动Eclipse直到所有项目编译完成需要四五分钟。一直对开发环境的速度感觉到不满意，趁着编写这本书的机会，决定对Eclipse进行“动刀”调优。</p>
<p>笔者机器的Eclipse运行平台是32位Windows 7系统，虚拟机为HotSpot 1.5 b64。硬件为ThinkPad X201，Intel i5 CPU，4GB物理内存。在初始的配置文件eclipse.ini中，除了指定JDK的路径、设置最大堆为512MB以及开启了JMX管理（需要在VisualVM中收集原始数据）外，未作任何改动，原始配置内容如代码清单5-3所示。</p>
<p>代码清单5-3 Eclipse 3.5初始配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">D:/_DevSpace/jdk1.5.0/bin/javaw.exe </span><br><span class="line">-startup </span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line">--launcher.library </span><br><span class="line">plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.0.200.v20090519 </span><br><span class="line">-product </span><br><span class="line">org.eclipse.epp.package.jee.product </span><br><span class="line">--launcher.XXMaxPermSize </span><br><span class="line">256M </span><br><span class="line">-showsplash </span><br><span class="line">org.eclipse.platform </span><br><span class="line">-vmargs </span><br><span class="line">-Dosgi.requiredJavaVersion=1.5 </span><br><span class="line">-Xmx512m </span><br><span class="line">-Dcom.sun.management.jmxremote</span><br></pre></td></tr></table></figure>
<p>为了与调优后的结果进行量化对比，调优开始前笔者先做了一次初始数据测试。测试用例很简单，就是收集从Eclipse启动开始，直到所有插件加载完成为止的总耗时以及运行状态数据，虚拟机的运行数据通过VisualVM及其扩展插件VisualGC进行采集。测试过程中反复启动数次Eclipse直到测试结果稳定后，取最后一次运行的结果作为数据样本（为了避免操作系统未能及时进行磁盘缓存而产生的影响），数据样本如图5-2所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919112606.png" alt="image-20210919112606221"></p>
<p>图5-2 Eclipse原始运行数据 </p>
<p>Eclipse启动的总耗时没有办法从监控工具中直接获得，因为VisualVM不可能知道Eclipse运行到什么阶段算是启动完成。为了测试的准确性，笔者写了一个简单的Eclipse插件，用于统计Eclipse的启动耗时。由于代码十分简单，且本书并不是Eclipse RCP的开发教程，所以只列出代码清单5-4供读者参考，不再延伸。如果读者需要这个插件，可以使用下面的代码自己编译即可。</p>
<p>代码清单5-4 Eclipse启动耗时统计插件</p>
<p>ShowTime.java代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line"><span class="comment">/* ShowTime.java代码： */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.eclipse.jface.dialogs.MessageDialog;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.swt.widgets.Display;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.swt.widgets.Shell;</span><br><span class="line"><span class="keyword">import</span> org.eclipse.ui.IStartup;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 统计Eclipse启动耗时 * <span class="doctag">@author</span> zzm */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShowTime</span> <span class="keyword">implements</span> <span class="title">IStartup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">earlyStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Display.getDefault().syncExec(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> eclipseStartTime = Long.parseLong(System.getProperty(<span class="string">&quot;eclipse.startTime&quot;</span>));</span><br><span class="line">                <span class="keyword">long</span> costTime = System.currentTimeMillis() - eclipseStartTime;</span><br><span class="line">                Shell shell = Display.getDefault().getActiveShell();</span><br><span class="line">                String message = <span class="string">&quot;Eclipse启动耗时：&quot;</span> + costTime + <span class="string">&quot;ms&quot;</span>;</span><br><span class="line">                MessageDialog.openInformation(shell, <span class="string">&quot;Information&quot;</span>, message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>plugin.xml代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> &lt;?eclipse version=&quot;3.4&quot;?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extension</span> <span class="attr">point</span>=<span class="string">&quot;org.eclipse.ui.startup&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">startup</span> <span class="attr">class</span>=<span class="string">&quot;eclipsestarttime.actions.ShowTime&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述代码打包成JAR后放到Eclipse的plugins目录，反复启动几次后，插件显示的平均时间稳定在 15秒左右，如图5-3所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919113033.png" alt="image-20210919113033359"></p>
<p>图5-3 耗时统计插件运行效果<br>根据VisualGC和Eclipse插件收集到的信息，总结原始配置下的测试结果如下：</p>
<ul>
<li>整个启动过程平均耗时约15秒。</li>
<li>最后一次启动的数据样本中，垃圾收集总耗时4.149秒，其中：<ul>
<li>Full GC被触发了19次，共耗时3.166秒；</li>
<li>Minor GC被触发了378次，共耗时0.983秒。</li>
</ul>
</li>
<li>加载类9115个，耗时4.114秒。</li>
<li>即时编译时间1.999秒。</li>
<li>交给虚拟机的512MB堆内存被分配为40MB的新生代（31.5MB的Eden空间和2个4MB的Survivor 空间）以及472MB的老年代。</li>
</ul>
<p>客观地说，考虑到该机器硬件的条件，15秒的启动时间其实还在可接受范围以内，但是从VisualGC中反映的数据上看，存在的问题是非用户程序时间（图5-2中的Compile Time、Class Load Time、GC Time）占比非常之高，占了整个启动过程耗时的一半以上（这里存在少许夸张成分，因为如即时编译等动作是在后台线程完成的，用户程序在此期间也正常并发执行，最多就是速度变慢，所<br>以并没有占用一半以上的绝对时间）。虚拟机后台占用太多时间也直接导致Eclipse在启动后的使用过程中经常有卡顿的感觉，进行调优还是有较大价值的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/8de91e11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/8de91e11/" class="post-title-link" itemprop="url">5.3.2 升级JDK版本的性能变化及兼容问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-24 10:16:20" itemprop="dateCreated datePublished" datetime="2021-09-24T10:16:20+08:00">2021-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-18 10:55:11" itemprop="dateModified" datetime="2021-11-18T10:55:11+08:00">2021-11-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">7 深入理解Java虛拟机：JVM高级特性与最佳实践(第3版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">2第二部分 自动内存管理</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">第5章 调优案例分析与实战</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/5-3-%E5%AE%9E%E6%88%98%EF%BC%9AEclipse%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%B0%83%E4%BC%98/" itemprop="url" rel="index"><span itemprop="name">5.3 实战：Eclipse运行速度调优</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/8de91e11/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/8de91e11/" data-xid="/JavaReadingNotes/8de91e11/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="5-3-2-升级JDK版本的性能变化及兼容问题"><a href="#5-3-2-升级JDK版本的性能变化及兼容问题" class="headerlink" title="5.3.2 升级JDK版本的性能变化及兼容问题"></a>5.3.2 升级JDK版本的性能变化及兼容问题</h2><p>对Eclipse进行调优的第一步就是先对虚拟机的版本进行升级，希望能先从虚拟机版本身上得到一些“免费的”性能提升。</p>
<p>每次JDK的大版本发布时，发行商通常都会宣称虚拟机的运行速度比上一版本有了多少比例的提高，这虽然是个广告性质的宣言，常被使用者从更新列表或者技术白皮书中直接忽略，但技术进步确实会促使性能改进，从国内外的第三方评测数据来看，版本升级至少在某些方面确实带来了一定性能改善<a href="%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E4%B9%9F%E6%9C%89%E4%B8%8D%E5%B0%91%E6%80%A7%E8%83%BD%E5%80%92%E9%80%80%E7%9A%84%E6%A1%88%E4%BE%8B%EF%BC%8C%E5%8F%97%E7%A8%8B%E5%BA%8F%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85%E5%85%BC%E5%AE%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%99%90%E5%88%B6%EF%BC%8C%E5%9C%A8%E4%BC%81%E4%B8%9A%E5%BA%94%E7%94%A8%E4%B8%AD%E5%8D%87%E7%BA%A7JDK%E7%89%88%E6%9C%AC%E6%98%AF%E4%B8%80%E4%BB%B6%E9%9C%80%E8%A6%81%E6%85%8E%E9%87%8D%E8%80%83%E8%99%91%E7%9A%84%E4%BA%8B%E6%83%85%E3%80%82">^1</a>。以下是一个第三方网站对JDK 5、6、7三个版本做的性能评测，分别测试了以下4个用例[^2]。</p>
<p>1）生成500万个字符串。<br>2）500万次<code>ArrayList&lt;String&gt;</code>数据插入，使用第一点生成的数据。<br>3）生成500万个<code>HashMap&lt;String，Integer&gt;</code>，每个键-值对通过并发线程计算，测试并发能力。<br>4）打印500万个<code>ArrayList&lt;String&gt;</code>中的值到文件，并重读回内存。</p>
<p>三个版本的JDK分别运行这4个用例的测试程序，测试结果如图5-4所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919152917.png" alt="image-20210919152917030"></p>
<p>图5-4 JDK横向性能对比 </p>
<p>从这4个用例的测试结果来看，在每一个测试场景中新版的JDK性能都有改进，譬如JDK 6比JDK 5有大约15%的平均性能提升。尽管对JDK仅测试这四个用例并不能说明什么问题，甚至要通过测试数据来量化描述一个JDK比旧版提升了多少本身就是很难做到特别科学准确的（要做稍微靠谱一点的测试，可以使用SPECjvm 2015[^3]之类的软件来完成，或者把相应版本的TCK[^4]中数万个测试用例的性能数据对比一下可能稍有说服力），但笔者还是选择相信这次“软广告”性质的测试，把JDK版本升级到JDK 6 Update 21，升级没有选择JDK 7或者其他版本的最主要理由是：本书后续故事剧情发展需要。</p>
<p>与所有小说作者（嗯……知道，本书不是小说）设计的故事情节一样，获得最后的胜利之前总是要经历各种各样的挫折，这次升级到JDK 6之后，性能有什么变化先暂且不谈，在使用几分钟之后， 笔者的Eclipse就和前面几个服务端的案例一样非常“不负众望”地发生了内存溢出，如图5-5所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919153051.png" alt="image-20210919153051781"><br>图5-5 Eclipse OutOfMemoryError</p>
<p>这次内存溢出开始是完全出乎笔者意料的：决定对Eclipse做调优是因为速度慢，但笔者的开发环境一直都很稳定，至少没有出现过内存溢出的问题，而这次升级除了修改了eclipse.ini中的Java虚拟机路径之外，还未进行任何运行参数的调整，Eclipse居然进去主界面之后随便开了几个文件就抛出内存溢出异常了，难道JDK 6 Update21有哪个类库的API出现了严重的泄漏问题吗？</p>
<p>事实上并不是JDK 6出现了什么问题，否则以Java的影响力，它早就上新闻了。根据前面三章中介绍讲解的原理和工具，我们要查明这个异常的原因并且解决它一点也不困难。打开VisualVM，监视页签中的内存曲线部分如图5-6、图5-7所示。</p>
<p>在Java堆中监视曲线里，“堆大小”的曲线与“使用的堆”的曲线一直都有很大的间隔距离，每当两条曲线开始出现互相靠近的趋势时，“堆大小”的曲线就会快速向上转向，而“使用的堆”的曲线会向下转向。“堆大小”的曲线向上代表的是虚拟机内部在进行堆扩容，因为运行参数中并没有指定最小堆（-Xms）的值与最大堆（-Xmx）相等，所以堆容量一开始并没有扩展到最大值，而是根据使用情况进行伸缩扩展。“使用的堆”的曲线向下是因为虚拟机内部触发了一次垃圾收集，一些废弃对象的空间被回收后，内存用量相应减少。从图形上看，Java堆运作是完全正常的。但永久代的监视曲线就很明显有问题了，“PermGen大小”的曲线与“使用的PermGen”的曲线几乎完全重合在一起，这说明永久代中已经没有可回收的资源了，所以“使用的PermGen”的曲线不会向下发展，并且永久代中也没有空间可以扩展了，所以“PermGen大小”的曲线不能向上发展，说明这次内存溢出很明显是永久代导致的内存溢出。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919153527.png" alt="image-20210919153527309"></p>
<p>图5-6 Java堆监视曲线</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919153227.png" alt="image-20210919153227432"><br>图5-7 永久代监视曲线</p>
<p>再注意到图5-7中永久代的最大容量“67108864字节”，也就是64MB，这恰好是JDK在未使用- XX：MaxPermSize参数明确指定永久代最大容量时的默认值，无论JDK 5还是JDK 6，这个默认值都是64MB。对于Eclipse这种规模的Java程序来说，64MB的永久代内存空间显然是不够的，内存溢出是肯定的，但为何在JDK 5中没有发生过溢出呢？</p>
<p>在VisualVM的“概述&gt;JVM参数”页签中，分别检查使用JDK 5和JDK 6运行Eclipse时的Java虚拟机启动参数，发现使用JDK 6时，只有三个启动参数，如代码清单5-5所示。</p>
<p>代码清单5-5 JDK 1.6的Eclipse运行期参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote </span><br><span class="line">-Dosgi.requiredJavaVersion=1.5 </span><br><span class="line">-Xmx512m</span><br></pre></td></tr></table></figure>
<p>而使用JDK 5运行时，就有四个启动参数，其中多出来的一个正好就是设置永久代最大容量的- XX：MaxPermSize=256M，如代码清单5-6所示。<br>代码清单5-6 JDK 1.5的Eclipse运行期参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote </span><br><span class="line">-Dosgi.requiredJavaVersion=1.5</span><br><span class="line">-Xmx512m </span><br><span class="line">-XX:MaxPermSize=256M</span><br></pre></td></tr></table></figure>
<p>为什么会这样呢？笔者从Eclipse的Bug List网站[^5]上找到答案：使用JDK 5时之所以有永久代容量这个参数，是因为在eclipse.ini中存在“–launcher.XXMaxPermSize 256M”这项设置，当launcher——也就是Windows下的可执行程序eclipse.exe，检测到Eclipse是运行在Sun公司的虚拟机上的话，就会把参数值转化为-XX：MaxPermSize传递给虚拟机进程。因为世界三大商用虚拟机中只有Sun公司的虚拟机才有永久代的概念，也就是只有JDK 8以前的HotSpot虚拟机才需要设置这个参数，JRockit虚拟机和J9虚拟机都是不需要设置的，所以这个参数才会有检测虚拟机后进行设置的过程。</p>
<p>2010年4月10日，Oracle正式完成对Sun公司的收购，此后无论是网页还是具体程序产品，提供商都从Sun变为了Oracle，而eclipse.exe就是根据程序提供商来判断是否Sun公司的虚拟机的，当JDK 1.6 Update 21中java.exe、javaw.exe的“Company”属性从“Sun Microsystems Inc.”变为“Oracle Corporation”后，Eclipse就不再认识这个虚拟机了，因此没有把最大永久代的参数传递过去。</p>
<p>查明了原因，解决方案就简单了，launcher不认识就只好由人来告诉它，在eclipse.ini中明确指定- XX：MaxPermSize=256M这个参数，问题随即解决。</p>
<p>[^2]: 测试用例、数据及图片来源于<a target="_blank" rel="noopener" href="http://www.taranfx.com/java-7-whats-new-performance-benchmark-1-5-1-">http://www.taranfx.com/java-7-whats-new-performance-benchmark-1-5-1-</a> 6-1-7。<br>[^3]: 官方网站：<a target="_blank" rel="noopener" href="http://www.spec.org/jvm2008/docs/UserGuide.html%E3%80%82">http://www.spec.org/jvm2008/docs/UserGuide.html。</a><br>[^4]: TCK（Technology Compatibility Kit）是一套由一组测试用例和相应的测试工具组成的工具包，用于保证一个使用Java技术的实现能够完全遵守其适用的Java平台规范，并且符合相应的参考实现。<br>[^5]: <a target="_blank" rel="noopener" href="https://bugs.eclipse.org/bugs/show_bug.cgi?id=319514%E3%80%82">https://bugs.eclipse.org/bugs/show_bug.cgi?id=319514。</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/d83417c0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/d83417c0/" class="post-title-link" itemprop="url">5.3.4 调整内存设置控制垃圾收集频率</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-24 10:16:20" itemprop="dateCreated datePublished" datetime="2021-09-24T10:16:20+08:00">2021-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-18 10:55:11" itemprop="dateModified" datetime="2021-11-18T10:55:11+08:00">2021-11-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">7 深入理解Java虛拟机：JVM高级特性与最佳实践(第3版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">2第二部分 自动内存管理</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">第5章 调优案例分析与实战</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/5-3-%E5%AE%9E%E6%88%98%EF%BC%9AEclipse%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%B0%83%E4%BC%98/" itemprop="url" rel="index"><span itemprop="name">5.3 实战：Eclipse运行速度调优</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/d83417c0/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/d83417c0/" data-xid="/JavaReadingNotes/d83417c0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="5-3-4-调整内存设置控制垃圾收集频率"><a href="#5-3-4-调整内存设置控制垃圾收集频率" class="headerlink" title="5.3.4 调整内存设置控制垃圾收集频率"></a>5.3.4 调整内存设置控制垃圾收集频率</h1><p>三大块非用户程序时间中，还剩下“GC时间”没有调整，而“GC时间”却又是其中最重要的一块， 并不单单因为它是耗时最长的一块，更因为它是一个稳定持续的消耗。由于我们做的测试是在测程序的启动时间，类加载和编译时间的影响力在这项测试里被大幅放大了。在绝大多数的应用中，都不可能出现持续不断的类被加载和卸载。在程序运行一段时间后，随着热点方法被不断编译，新的热点方法数量也总会下降，这都会让类加载和即时编译的影响随运行时间增长而下降，但是垃圾收集则是随着程序运行而持续运作的，所以它对性能的影响才显得最为重要。</p>
<p>在Eclipse启动的原始数据样本中，短短15秒，类共发生了19次Full GC和378次Minor GC，一共397 次GC共造成了超过4秒的停顿，也就是超过1/4的时间都是在做垃圾收集，这样的运行数据看起来实在太糟糕了。</p>
<p>首先来解决新生代中的Minor GC，尽管垃圾收集的总时间只有不到1秒，但却发生了378次之多。 从VisualGC的线程监视中看到Eclipse启动期间一共发起了超过70条线程，同时在运行的线程数超过25 条，每当发生一次垃圾收集，所有用户线程<a href="%E4%B8%A5%E6%A0%BC%E6%9D%A5%E8%AF%B4%EF%BC%8C%E4%B8%8D%E5%8C%85%E6%8B%AC%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8Cnative%E4%BB%A3%E7%A0%81%E7%9A%84%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%9B%A0%E4%B8%BAnative%E4%BB%A3%E7%A0%81%E4%B8%80%E8%88%AC%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB%EF%BC%8C%E6%89%80%E4%BB%A5%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E6%8C%82%E8%B5%B7%E5%AE%83%E4%BB%AC%E6%9D%A5%E7%AD%89%E5%BE%85%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E3%80%82">^1</a>都必须跑到最近的一个安全点然后挂起线程来等待垃圾回收。这样过于频繁的垃圾收集就会导致很多没有必要的线程挂起及恢复动作。</p>
<p>新生代垃圾收集频繁发生，很明显是由于虚拟机分配给新生代的空间太小导致，Eden区加上一个Survivor区的总大小还不到35MB。所以完全有必要使用-Xmn参数手工调整新生代的大小。</p>
<p>再来看一看那19次Full GC，看起来19次相对于378次Minor GC来说并“不多”，但总耗时有3.166 秒，占了绝大部分的垃圾收集时间，降低垃圾收集停顿时间的主要目标就是要降低Full GC这部分时间。从VisualGC的曲线图上看得不够精确，这次直接从收集器日志<a href="%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%E5%8F%82%E6%95%B0%E8%A6%81%E6%B1%82%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%94%9F%E6%88%90GC%E6%97%A5%E5%BF%97%EF%BC%9A-XX%EF%BC%9A+PrintGCTimeStamps%EF%BC%88%E6%89%93%E5%8D%B0GC%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%EF%BC%89%E3%80%81-XX%EF%BC%9A+PrintGCDetails%EF%BC%88%E6%89%93%E5%8D%B0GC%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%EF%BC%89%E3%80%81-verbose%EF%BC%9Agc%EF%BC%88%E6%89%93%E5%8D%B0GC%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9%E5%B7%B2%E8%A2%AB%E5%89%8D%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%8C%85%E6%8B%AC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%EF%BC%89%E3%80%81-Xloggc%EF%BC%9Agc.log%E3%80%82">^2</a>中分析一下这些Full GC是如何产生的，代码清单5-9中是启动最开始的2.5秒内发生的10次Full GC记录。</p>
<p>代码清单5-9 Full GC记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0.278: [GC 0.278: [DefNew: 574K-&gt;33K(576K), 0.0012562 secs]0.279: [Tenured: 1467K-&gt;997K(1536K), 0.0181775 secs] 1920K-&gt;997K(2112K), 0.0195257 secs] </span><br><span class="line">0.312: [GC 0.312: [DefNew: 575K-&gt;64K(576K), 0.0004974 secs]0.312: [Tenured: 1544K-&gt;1608K(1664K), 0.0191592 secs] 1980K-&gt;1608K(2240K), 0.0197396 secs] </span><br><span class="line">0.590: [GC 0.590: [DefNew: 576K-&gt;64K(576K), 0.0006360 secs]0.590: [Tenured: 2675K-&gt;2219K(2684K), 0.0256020 secs] 3090K-&gt;2219K(3260K), 0.0263501 secs] </span><br><span class="line">0.958: [GC 0.958: [DefNew: 551K-&gt;64K(576K), 0.0011433 secs]0.959: [Tenured: 3979K-&gt;3470K(4084K), 0.0419335 secs] 4222K-&gt;3470K(4660K), 0.0431992 secs] </span><br><span class="line">1.575: [Full GC 1.575: [Tenured: 4800K-&gt;5046K(5784K), 0.0543136 secs] 5189K-&gt;5046K(6360K), [Perm : 12287K-&gt;12287K(12288K)], 0.0544163 secs] </span><br><span class="line">1.703: [GC 1.703: [DefNew: 703K-&gt;63K(704K), 0.0012609 secs]1.705: [Tenured: 8441K-&gt;8505K(8540K), 0.0607638 secs] 8691K-&gt;8505K(9244K), 0.0621470 secs] </span><br><span class="line">1.837: [GC 1.837: [DefNew: 1151K-&gt;64K(1152K), 0.0020698 secs]1.839: [Tenured: 14616K-&gt;14680K(14688K), 0.0708748 secs] 15035K-&gt;14680K(15840K), 0.0730947 secs] </span><br><span class="line">2.144: [GC 2.144: [DefNew: 1856K-&gt;191K(1856K), 0.0026810 secs]2.147: [Tenured: 25092K-&gt;24656K(25108K), 0.1112429 secs] 26172K-&gt;24656K(26964K), 0.1141099 secs] </span><br><span class="line">2.337: [GC 2.337: [DefNew: 1914K-&gt;0K(3136K), 0.0009697 secs]2.338: [Tenured: 41779K-&gt;27347K(42056K), 0.0954341 secs] 42733K-&gt;27347K(45192K), 0.0965513 secs] </span><br><span class="line">2.465: [GC 2.465: [DefNew: 2490K-&gt;0K(3456K), 0.0011044 secs]2.466: [Tenured: 46379K-&gt;27635K(46828K), 0.0956937 secs] 47621K-&gt;27635K(50284K), 0.0969918 secs] </span><br></pre></td></tr></table></figure>

<p>括号中加粗的数字代表着老年代的容量，这组GC日志显示，10次Full GC发生的原因全部都是老年代空间耗尽，每发生一次Full GC都伴随着一次老年代空间扩容：1536KB→1664KB→2684KB→… →42056KB→46828KB。10次GC以后老年代容量从起始的1536KB扩大到46828KB，当15秒后Eclipse启动完成时，老年代容量扩大到了103428KB，代码编译开始后，老年代容量到达顶峰473MB，整个Java 堆到达最大容量512MB。</p>
<p>日志还显示有些时候内存回收状况很不理想，空间扩容成为获取可用内存的最主要手段，譬如这一句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tenured: 25092K-&gt;24656K(25108K) , 0.1112429 secs</span><br></pre></td></tr></table></figure>
<p>代表老年代当前容量为25108KB，内存使用到25092KB的时候发生了Full GC，花费0.11秒把内存使用降低到24656KB，只回收了不到500KB的内存，这次垃圾收集基本没有什么回收效果，仅仅做了扩容，扩容过程相比起回收过程可以看作是基本不需要花费时间的，所以说这0.11秒几乎是平白浪费了。</p>
<p>由上述分析可以得出结论：Eclipse启动时Full GC大多数是由于老年代容量扩展而导致的，由永久代空间扩展而导致的也有一部分。为了避免这些扩展所带来的性能浪费，我们可以把-Xms和-XX： PermSize参数值设置为-Xmx和-XX：MaxPermSize参数值一样，这样就强制虚拟机在启动的时候就把老年代和永久代的容量固定下来，避免运行时自动扩展<a href="%E9%9C%80%E8%A6%81%E8%AF%B4%E6%98%8E%E4%B8%80%E7%82%B9%EF%BC%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%B0%B1%E4%BC%9A%E6%8A%8A%E5%8F%82%E6%95%B0%E4%B8%AD%E6%89%80%E8%AE%BE%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E5%85%A8%E9%83%A8%E5%88%92%E4%B8%BA%E7%A7%81%E6%9C%89%EF%BC%8C%E5%8D%B3%E4%BD%BF%E6%89%A9%E5%AE%B9%E5%89%8D%E6%9C%89%E4%B8%80%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%E4%B8%8D%E4%BC%9A%E8%A2%AB%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%94%A8%E5%88%B0%EF%BC%8C%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%E4%B9%9F%E4%B8%8D%E4%BC%9A%E4%BA%A4%E7%BB%99%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8%E3%80%82%E8%BF%99%E9%83%A8%E5%88%86%E5%86%85%E5%AD%98%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E8%A2%AB%E6%A0%87%E8%AF%86%E4%B8%BA%E2%80%9CVirtual%E2%80%9D%E5%86%85%E5%AD%98%E3%80%82">^3</a>。</p>
<p>根据以上分析，优化计划确定为：把新生代容量提升到128MB，避免新生代频繁发生Minor GC； 把Java堆、永久代的容量分别固定为512MB和96MB<a href="512MB%E5%92%8C96MB%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E5%AF%B9%E4%BA%8E%E7%AC%94%E8%80%85%E7%9A%84%E5%BA%94%E7%94%A8%E6%83%85%E5%86%B5%E6%9D%A5%E8%AF%B4%E4%BE%9D%E7%84%B6%E5%81%8F%E5%B0%91%EF%BC%8C%E4%BD%86%E7%94%B1%E4%BA%8E%E7%AC%94%E8%80%85%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E5%BC%80VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E4%BD%9C%EF%BC%8C%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E9%A2%84%E7%95%99%E8%BE%83%E5%A4%9A%E5%86%85%E5%AD%98%EF%BC%8C%E8%AF%BB%E8%80%85%E5%9C%A8%E5%AE%9E%E9%99%85%E8%B0%83%E4%BC%98%E6%97%B6%E4%B8%8D%E5%A6%A8%E5%86%8D%E8%AE%BE%E7%BD%AE%E5%A4%A7%E4%B8%80%E4%BA%9B%E3%80%82">^4</a>，避免内存扩展。这几个数值都是根据机器硬件和Eclipse插件、工程数量决定，读者实战的时候应依据VisualGC和日志里收集到的实际数据进行设置。改动后的eclipse.ini配置如代码清单5-10所示。</p>
<p>代码清单5-10 内存调整后的Eclipse配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-vm </span><br><span class="line">D:/_DevSpace/jdk1.6.0_21/bin/javaw.exe </span><br><span class="line">-startup </span><br><span class="line">plugins/org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line">--launcher.library plugins/org.eclipse.equinox.launcher.win32.win32.x86_1.0.200.v20090519 </span><br><span class="line">-product org.eclipse.epp.package.jee.product </span><br><span class="line">-showsplash org.eclipse.platform </span><br><span class="line">-vmargs </span><br><span class="line">-Dosgi.requiredJavaVersion=1.5 </span><br><span class="line">-Xverify:none </span><br><span class="line">-Xmx512m </span><br><span class="line">-Xms512m </span><br><span class="line">-Xmn128m </span><br><span class="line">-XX:PermSize=96m </span><br><span class="line">-XX:MaxPermSize=96m</span><br></pre></td></tr></table></figure>
<p>现在这个配置之下，垃圾收集的次数已经大幅度降低，图5-9是Eclipse启动后一分钟的监视曲线， 只发生了8次Minor GC和4次Full GC，总耗时为1.928秒。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919160201.png" alt="image-20210919160200884"></p>
<p>图5-9 GC调整后的运行数据 </p>
<p>这个结果已经算是基本正常，但是还存在一点瑕疵：从Old Gen的曲线上看，老年代直接固定在384MB，而内存使用量只有66MB，并且一直很平滑，完全不应该发生Full GC才对，那4次Full GC是怎么来的？使用jstat-gccause查询一下最近一次GC的原因，见代码清单5-11。</p>
<p>代码清单5-11 查询GC原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IcyFenix&gt;jps </span><br><span class="line">9772 Jps </span><br><span class="line">4068 org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line"></span><br><span class="line">C:\Users\IcyFenix&gt;jstat -gccause 4068 </span><br><span class="line">S0    S1    E     O      P      YGC  YGCT   FGC FGCT  GCT   LGCC        GCC </span><br><span class="line">0.00  0.00  1.00  14.81  39.29  6    0.422  20  5.992 6.414 System.gc() No GC</span><br></pre></td></tr></table></figure>
<p>从LGCC（Last GC Cause）中看到原来是代码调用System.gc()显式触发的垃圾收集，在内存设置调整后，这种显式垃圾收集不符合我们的期望，因此在eclipse.ini中加入参数-XX：+DisableExplicitGC屏蔽掉System.gc()。再次测试发现启动期间的Full GC已经完全没有了，只发生了6次Minor GC，总共耗时417毫秒，与调优前4.149秒的测试结果相比，正好是十分之一。进行GC调优后Eclipse的启动时间下降非常明显，比整个垃圾收集时间降低的绝对值还大，现在启动只需要7秒多，如图5-10所示。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919160511.png" alt="image-20210919160511532"></p>
<p>图5-10 Eclipse启动时间</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://lanlan2017.github.io/JavaReadingNotes/397b558c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/JavaReadingNotes/images/avatar.gif">
      <meta itemprop="name" content="蓝蓝">
      <meta itemprop="description" content="好好学习，天天向上">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蓝蓝站点">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/JavaReadingNotes/397b558c/" class="post-title-link" itemprop="url">5.3.3 编译时间和类加载时间的优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-24 10:16:20" itemprop="dateCreated datePublished" datetime="2021-09-24T10:16:20+08:00">2021-09-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-11-18 10:55:11" itemprop="dateModified" datetime="2021-11-18T10:55:11+08:00">2021-11-18</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/" itemprop="url" rel="index"><span itemprop="name">7 深入理解Java虛拟机：JVM高级特性与最佳实践(第3版)</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">2第二部分 自动内存管理</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" itemprop="url" rel="index"><span itemprop="name">第5章 调优案例分析与实战</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/JavaReadingNotes/categories/7-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9B%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E7%AC%AC3%E7%89%88/2%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/5-3-%E5%AE%9E%E6%88%98%EF%BC%9AEclipse%E8%BF%90%E8%A1%8C%E9%80%9F%E5%BA%A6%E8%B0%83%E4%BC%98/" itemprop="url" rel="index"><span itemprop="name">5.3 实战：Eclipse运行速度调优</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/JavaReadingNotes/397b558c/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/JavaReadingNotes/397b558c/" data-xid="/JavaReadingNotes/397b558c/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="5-3-3-编译时间和类加载时间的优化"><a href="#5-3-3-编译时间和类加载时间的优化" class="headerlink" title="5.3.3 编译时间和类加载时间的优化"></a>5.3.3 编译时间和类加载时间的优化</h2><p>从Eclipse启动时间来看，升级到JDK 6所带来的性能提升是……嗯？基本上没有提升。多次测试的平均值与JDK 5的差距完全在实验误差范围之内。</p>
<p>各位读者不必失望，Sun公司给的JDK 6性能白皮书<a href="%E7%99%BD%E7%9A%AE%E4%B9%A6%EF%BC%9Ahttp://java.sun.com/performance/reference/whitepapers/6_performance.html%E3%80%82">^1</a>描述的众多相对于JDK 5的提升并不至于全部是广告词，尽管总启动时间并没有减少，但在查看运行细节的时候，却发现了一件很令人玩味的事情：在JDK 6中启动完Eclipse所消耗的类加载时间比JDK 5长了接近一倍，读者注意不要看反了，这里写的是JDK 6的类加载比JDK 5慢一倍，测试结果见代码清单5-7，反复测试多次仍然是相似的结果。</p>
<p>代码清单5-7 JDK 5、JDK 6中的类加载时间对比</p>
<p>使用JDK 6的类加载时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IcyFenix&gt;jps </span><br><span class="line">3552 </span><br><span class="line">6372 org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line">6900 Jps </span><br><span class="line"></span><br><span class="line">C:\Users\IcyFenix&gt;jstat -class 6372 </span><br><span class="line">Loaded     Bytes    Unloaded   Bytes  Time </span><br><span class="line">  7917   10190.3           0     0.0  8.18</span><br></pre></td></tr></table></figure>
<p>使用JDK 5类加载时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IcyFenix&gt;jps </span><br><span class="line">3552 </span><br><span class="line">7272 Jps </span><br><span class="line">7216 org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line"></span><br><span class="line">C:\Users\IcyFenix&gt;jstat -class 7216 </span><br><span class="line">Loaded     Bytes   Unloaded   Bytes   Time </span><br><span class="line">  7902    9691.2          3     2.6   4.34</span><br></pre></td></tr></table></figure>
<p>在本例中类加载时间上的差距并不能作为一个具有普适性的测试结论去说明JDK 6的类加载必然比JDK 5慢，笔者测试了自己机器上的Tomcat和GlassFish启动过程，并没有出现类似的差距。在国内最大的Java社区中，笔者发起过关于此问题的讨论[^2]。从参与者反馈的测试结果来看，此问题只在一部分机器上存在，而且在JDK 6的各个更新包之间，测试结果也存在很大差异。</p>
<p>经多轮试验后，发现在笔者机器上两个JDK进行类加载时，字节码验证部分耗时差距尤其严重， 暂且认为是JDK 6中新加入类型检查验证器时，可能在某些机器上会影响到以前类型检查验证器的工作[^3]。考虑到实际情况，Eclipse使用者甚多，它的编译代码我们可以认为是安全可靠的，可以不需要在加载的时候再进行字节码验证，因此通过参数-Xverify：none禁止掉字节码验证过程也可作为一项优化措施。加入这个参数后，两个版本的JDK类加载速度都有所提高，此时JDK 6的类加载速度仍然比JDK 5要慢，但是两者的耗时已经接近了很多，测试结果如代码清单5-8所示。</p>
<p>代码清单5-8 JDK 1.5、1.6中取消字节码验证后的类加载时间对比<br>使用JDK 1.6的类加载时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IcyFenix&gt;jps </span><br><span class="line">5512 org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line">5596 Jps</span><br><span class="line"></span><br><span class="line">C:\Users\IcyFenix&gt;jstat -class 5512 </span><br><span class="line">Loaded   Bytes Unloaded Bytes Time </span><br><span class="line">  6749  8837.0        0   0.0 3.94</span><br></pre></td></tr></table></figure>
<p>使用JDK 1.5的类加载时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\IcyFenix&gt;jps </span><br><span class="line">4724 org.eclipse.equinox.launcher_1.0.201.R35x_v20090715.jar </span><br><span class="line">5412 Jps </span><br><span class="line"></span><br><span class="line">C:\Users\IcyFenix&gt;jstat -class 4724 </span><br><span class="line">Loaded   Bytes  Unloaded  Bytes  Time </span><br><span class="line">  6885  9109.7         3    2.6  3.10</span><br></pre></td></tr></table></figure>
<p>关于类与类加载的话题，譬如刚刚提到的字节码验证是怎么回事，本书专门规划了两个章节进行详细讲解，在此暂不再展开了。</p>
<p>在取消字节码验证之后，JDK 5的平均启动下降到了13秒，而在JDK 6的测试数据平均比JDK 5快了1秒左右，下降到平均12秒，如图5-8所示。在类加载时间仍然落后的情况下，依然可以看到JDK 6在性能上确实比JDK 5略有优势，说明至少在Eclipse启动这个测试用例上，升级JDK版本确实能带来一些“免费的”性能提升。</p>
<p><img data-src="https://raw.githubusercontent.com/lanlan2017/images/master/Blog/2021/09/20210919154912.png" alt="image-20210919154912188"></p>
<p>图5-8 运行在JDK 6下取消字节码验证的启动时间</p>
<p>前面提到过，除了类加载时间以外，在VisualGC中监视曲线中显示了两项很大的非用户程序耗时：编译时间（Compile Time）和垃圾收集时间（GC Time）。垃圾收集时间读者应该非常清楚了，而编译时间是什么东西？程序在运行之前不是已经编译了吗？</p>
<p>虚拟机的即时编译与垃圾收集一样，是本书的一个重点部分，后面有专门章节讲解，这里先简要介绍一下：编译时间是指虚拟机的即时编译器（Just In Time Compiler）编译热点代码（Hot Spot Code）的耗时。我们知道Java语言为了实现跨平台的特性，Java代码编译出来后形成Class文件中储存的是字节码（Byte Code），虚拟机通过解释方式执行字节码命令，比起C/C++编译成本地二进制代码来说，速度要慢不少。为了解决程序解释执行的速度问题，JDK 1.2以后，HotSpot虚拟机内置了两个即时编译器[^4]，如果一段Java方法被调用次数到达一定程度，就会被判定为热代码交给即时编译器即时编译为本地代码，提高运行速度（这就是HotSpot虚拟机名字的来由）。而且完全有可能在运行期动态编译比C/C++的编译期静态编译出来的结果要更加优秀，因为运行期的编译器可以收集很多静态编译器无法得知的信息，也可以采用一些激进的优化手段，针对“大多数情况”而忽略“极端情况”进行假<br>设优化，当优化条件不成立的时候再逆优化退回到解释状态或者重新编译执行。所以Java程序只要代码编写没有问题（典型的是各种泄漏问题，如内存泄漏、连接泄漏），随着运行时间增长，代码被编译得越来越彻底，运行速度应当是越运行越快的。不过，Java的运行期编译的一大缺点就是它进行编译需要消耗机器的计算资源，影响程序正常的运行时间，这也就是上面所说的“编译时间”。</p>
<p>HotSpot虚拟机提供了一个参数-Xint来禁止编译器运作，强制虚拟机对字节码采用纯解释方式执行。如果读者想使用这个参数省下Eclipse启动中那2秒的编译时间获得一个哪怕只是“更好看”的启动成绩的话，那恐怕要大失所望了，加上这个参数之后虽然编译时间确实下降到零，但Eclipse启动的总时间却剧增到27秒，就是因为没有即时编译的支持，执行速度大幅下降了。现在这个参数最大的作用， 除了某些场景调试上的需求外，似乎就剩下让用户缅怀一下JDK 1.2之前Java语言那令人心酸心碎的运行速度了。</p>
<p>与解释执行相对应的另一方面，HotSpot虚拟机还有另一个力度更强的即时编译器：当虚拟机运行在客户端模式的时候，使用的是一个代号为C1的轻量级编译器，另外还有一个代号为C2的相对重量级的服务端编译器能提供更多的优化措施。由于本次实战所采用的HotSpot版本还不支持多层编译，所以虚拟机只会单独使用其中一种即时编译器，如果使用客户端模式的虚拟机启动Eclipse将会使用到C2编译器，这时从VisualGC可以看到启动过程中虚拟机使用了超过15秒的时间去进行代码编译。如果读者的工作习惯是长时间不会关闭Eclipse的话，服务端编译器所消耗的额外编译时间最终是会在运行速度的提升上“赚”回来的，这样使用服务端模式是一个相当不错的选择。不过至少在本次实战中，我们还是继续选用客户端虚拟机来运行Eclipse。</p>
<p>[^2]: 笔者发起的关于JDK 6与JDK 5在Eclipse启动时类加载速度差异的讨论： <a target="_blank" rel="noopener" href="http://www.javaeye.com/topic/826542%E3%80%82">http://www.javaeye.com/topic/826542。</a><br>[^3]: 这部分内容可常见第7章关于类加载过程的介绍。<br>[^4]: JDK 1.2之前也可以使用外挂JIT编译器进行本地编译，但只能与解释器二选其一，不能同时工作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/JavaReadingNotes/page/50/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/JavaReadingNotes/">1</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/50/">50</a><span class="page-number current">51</span><a class="page-number" href="/JavaReadingNotes/page/52/">52</a><span class="space">&hellip;</span><a class="page-number" href="/JavaReadingNotes/page/188/">188</a><a class="extend next" rel="next" href="/JavaReadingNotes/page/52/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蓝蓝</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">5.8m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">88:01</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/comments.js"></script><script src="/JavaReadingNotes/js/utils.js"></script><script src="/JavaReadingNotes/js/motion.js"></script><script src="/JavaReadingNotes/js/next-boot.js"></script><script src="/JavaReadingNotes/js/bookmark.js"></script><script src="/JavaReadingNotes/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/JavaReadingNotes/js/third-party/search/local-search.js"></script>



  <script src="/JavaReadingNotes/js/third-party/fancybox.js"></script>

  <script src="/JavaReadingNotes/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/JavaReadingNotes/js/third-party/math/mathjax.js"></script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.2.0/dist/quicklink.umd.js" integrity="sha256-4kQf9z5ntdQrzsBC3YSHnEz02Z9C1UeW/E9OgnvlzSY=" crossorigin="anonymous"></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":true,"archive":true,"delay":true,"timeout":3000,"priority":true,"url":"https://lanlan2017.github.io/JavaReadingNotes/page/51/"}</script>
  <script src="/JavaReadingNotes/js/third-party/quicklink.js"></script>
<script class="next-config" data-name="waline" type="application/json">{"lang":null,"enable":true,"serverURL":"https://waline-test-lanlan2017.vercel.app","placeholder":"填写邮箱可接收回复通知 填写个人网址可为您引流","avatar":"mm","pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"meta":["nick","mail","link"],"libUrl":"https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js","el":"#waline-comments","path":"/JavaReadingNotes/page/51/"}</script>
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() => 
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => {
    new Waline(CONFIG.waline);
  });
});
</script>
</body>
</html>
